--
-- Create Schema Script 
--   Database Version   : 9.2.0.1.0 
--   TOAD Version       : 9.1.0.62 
--   DB Connect String  : 10.50.70.125:1521/ebankgua 
--   Schema             : EBANKING 
--   Script Created by  : EBANKING 
--   Script Created at  : 08/01/2015 07:24:48 p.m. 
--   Physical Location  :  
--   Notes              :  
--

-- Object Counts: 
--   Functions: 208     Lines of Code: 6405 
--   Indexes: 420       Columns: 554        Partitions: 25      
--   Object Privileges: 91 
--   Packages: 18       Lines of Code: 1619 
--   Package Bodies: 17 Lines of Code: 9880 
--   Procedures: 377    Lines of Code: 15016 
--   Sequences: 122 
--   Tables: 394        Columns: 3859       Partitions: 25      Constraints: 412    
--   Triggers: 58 
--   Types: 27 
--   Views: 39          


CREATE OR REPLACE TYPE          ACTIVATIONBEAN AS OBJECT (  
    ACTIVACION         DATE,
 	ALIAS    		   VARCHAR2(50),
 	ANSWER    		   VARCHAR2(50),
 	CEL_PHONE    	   VARCHAR2(30),
 	CLIENTE    		   VARCHAR2(20),
 	CODE     		   VARCHAR2(50),
 	COMPANY    		   NUMBER,
 	CUENTA    		   VARCHAR2(30),
 	CUENTAOTARJ   	   VARCHAR2(20),
 	EMAIL    		   VARCHAR2(50),
 	FIRSTINTENTO  	   DATE,
 	INTENTOS_LOCALIZAR NUMBER,
 	IP     			   VARCHAR2(30),
 	LASTINTENTO   	   DATE,
 	NAME    		   VARCHAR2(250),
 	OFFICE_PHONE   	   VARCHAR2(30),
 	QUESTION   		   VARCHAR2(50),
 	STATUS     		   NUMBER,
 	TARJETA    		   VARCHAR2(30),
 	TIPOPROD   		   VARCHAR2(50),
  	CONSTRUCTOR FUNCTION ACTIVATIONBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          ALNOVABEAN AS OBJECT (  
  ID                 INTEGER,
  CODE               VARCHAR2(20), 
  BUSY               INTEGER(3),
  SERVER             VARCHAR2(32),
  TERMINAL2CHANNEL   INTEGER,
  APP                VARCHAR2(60),
  USUARIO_MODIFICO   VARCHAR2(30),
  FECHA_OPERACION    DATE,
  FECHA_MODIFICACION DATE,
  CONSTRUCTOR FUNCTION ALNOVABEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          BLOQUEO 
AS
OBJECT
(

IDBLOQUEO NUMBER, IDALNOVA VARCHAR2(8)

);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          FRECUENTSBEAN AS OBJECT (  
  USER_ID              NUMBER(8),
  REFERENCIA           VARCHAR2(20), 
  CANAL                VARCHAR2(3),
  TELEFONO             VARCHAR2(20),
  CUENTA               VARCHAR2(20),
  STATUS               NUMBER(2),
  ULTIMA_ACTUALIZACION DATE,
  CONSTRUCTOR FUNCTION FRECUENTSBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          IDCORREOS AS TABLE OF VARCHAR2(8 BYTE);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_FILTER IS OBJECT (
  FILTER_TYPE INTEGER, -- Filter Types are 0-> ALL, 1->NAMELIST, 2->WHERE CLAUSE, 3->OBJECTID LIST
  OBJTYPE VARCHAR2(40),
  OBJECTIDS OBJECTIDLIST,
  NAMES NAMELIST,
  WHERECLAUSE VARCHAR2(1000));
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_FILTER_SET IS TABLE OF MIGR_FILTER;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_REPORT_DETAIL_ROW AS OBJECT
 (CAPTURED_ID            NUMBER(38),
  CAPTURED_NAME          VARCHAR2(4000),
  CONVERTED_NAME          VARCHAR2(4000),
  CAPTURED_TYPE          VARCHAR2(4000),
  CONVERTED_TYPE          VARCHAR2(4000),
  CAPTURE_STATUS         VARCHAR2(20),
  CONVERT_STATUS         VARCHAR2(20),
  GENERATE_STATUS        VARCHAR2(20),
  LOGTEXT               VARCHAR2(4000)
 );
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_REPORT_DETAIL_TABLE AS TABLE OF MIGR_REPORT_DETAIL_ROW;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_REPORT_SUM_ROW AS OBJECT
       (LABEL           VARCHAR2(50),
	    SCHEMA_SUM      NUMBER,
        TABLE_SUM       NUMBER,
		INDEX_SUM       NUMBER,
		CONSTRAINT_SUM  NUMBER,
		VIEW_SUM        NUMBER,
		TRIGGER_SUM     NUMBER,
		SP_SUM          NUMBER		
        );
/

SHOW ERRORS;


CREATE OR REPLACE TYPE MIGR_REPORT_SUM_TABLE AS TABLE OF MIGR_REPORT_SUM_ROW;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE NAMELIST IS TABLE OF VARCHAR2(40);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE name_and_count_array IS VARRAY(30) OF name_and_count_t;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE name_and_count_t IS OBJECT (
  OBJECT_NAME varchar2(30),
  UPDATE_COUNT INTEGER);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE OBJECTIDLIST IS TABLE OF INTEGER;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          ONOMBRES 
AS
OBJECT
(
IDALNOVA VARCHAR(8), NOMBRES VARCHAR2(50)
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          OTRANOMBRES AS TABLE OF TYPENOMBRES;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE records AS TABLE OF number;
/

SHOW ERRORS;


CREATE OR REPLACE type split_tbl as table of number;
/

SHOW ERRORS;


CREATE OR REPLACE type tabtype as table of number;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE TDCFRECUENTBEAN AS OBJECT (  
  CLIENT             NUMBER(8),
  DESTINO         	 VARCHAR2(18),
  BANCO         	 VARCHAR2(30),
  NOMBRE             VARCHAR2(100),
  STATUS         	 NUMBER,
  FECHA_MODIFICACION DATE,
  IP_ORIGEN        	 VARCHAR2(30),
  ALIAS         	 VARCHAR2(30),
  CANAL          	 VARCHAR2(10),
  CONSTRUCTOR FUNCTION TDCFRECUENTBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE TIPO AS TABLE OF NUMBER;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          TNOMBRES AS TABLE OF ONOMBRES;
/

SHOW ERRORS;


CREATE OR REPLACE TYPE          TYPENOMBRES AS TABLE OF VARCHAR2(60);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE USERBEAN AS OBJECT (  
    ACTIVATION          	DATE,
 	ACTIVE 					NUMBER(1),
 	ADVANCEDSERVICE   		NUMBER,
 	ANSWER      			VARCHAR2(48 BYTE),
 	CELLULAR     			VARCHAR2(16 BYTE),
 	EMAIL      				VARCHAR2(40 BYTE),
 	ID       				NUMBER(10),
 	QUESTION     			VARCHAR2(48 BYTE),
 	MAIL_RECEIVE    		NUMBER(1),
 	OLD_ADVANCEDSERVICE  	NUMBER,
 	PWD_BANCA_TEL    		VARCHAR2(30 BYTE),
 	PWD_CHANGE_DATE   		DATE,
 	PWD_CONFIRM    			VARCHAR2(30 BYTE),
 	PWD_CONFIRM_CHANGE_DATE DATE,
 	PWD_STATUS     			NUMBER(1),
 	SECUREDATA    			VARCHAR2(48 BYTE),
 	SECURITY_LEVEL    		INTEGER,
 	TELEFONO_OFICINA   		VARCHAR2(25 BYTE),
 	TRACKING     	   	    NUMBER(1),
 	TOKEN      				NUMBER,
 	USER2CELLCOMPANY   		NUMBER,
 	CONSTRUCTOR FUNCTION USERBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE USEROLDBEAN AS OBJECT (  
  USER_ID              NUMBER,
  CELLULAR_OLD         VARCHAR2(16),
  CELLULAR_CHANGE_DATE DATE,
  TELEFONO_ALTERNO_OLD VARCHAR2(16),
  ALTERNO_CHANGE_DATE  DATE,
  EMAIL_OLD        	   VARCHAR2(50),
  EMAIL_CHANGE_DATE    DATE,
  QUESTION_CHANGE_DATE DATE,
  ANSWER_CHANGE_DATE   DATE,
  CONSTRUCTOR FUNCTION USEROLDBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE OR REPLACE TYPE USERSESSIONBEAN AS OBJECT (  
  ID              NUMBER(20) ,
  SESSION_ACTIVA  VARCHAR2(50),
  SESSION_START   DATE,
  IP              VARCHAR2(15),
  CONSTRUCTOR FUNCTION USERSESSIONBEAN RETURN SELF AS RESULT
);
/

SHOW ERRORS;


CREATE SEQUENCE ALBUM_SEQ
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE ALLFREC_SEQ
  START WITH 1
  MAXVALUE 2000000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE ALLFREC_SEQUENCE
  START WITH 1851
  MAXVALUE 2000000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE CAT_SEQ
  START WITH 12
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE DBOBJECTID_SEQUENCE
  START WITH 1
  INCREMENT BY 50
  MAXVALUE 999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 50
  NOORDER;


CREATE SEQUENCE EBANKING_RMASMS_SEQUENCE
  START WITH 21
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE FIAR_LLENAR_TEMPORALES
  START WITH 1461
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE FIAR_SORTEO_SEQ
  START WITH 21
  MAXVALUE 9999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE ID_CONTRATO_EMISORES
  START WITH 120
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE ID_LOGIN_HISTORY_SEQ
  START WITH 45610
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE ID_TOKEN_HISTORY_SEQ
  START WITH 1467
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE ID_TOKEN_STATUS_SEQ
  START WITH 1900
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE INCPRE
  START WITH 21
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE INCREMENTO_ID_CLIENT
  START WITH 101
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE INCREMENTO_ID_CLIENTE
  START WITH 101
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE INCREMENTO_ID_RECORDATORIO
  START WITH 142
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE INTERESADOS_SEQ
  START WITH 3
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE PHOTOS_SEQ
  START WITH 6
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE POSTIT_SEQ
  START WITH 3
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE PRUEBA_ID
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE REPORTOS_MONTOS_SEQ
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE REPORTOS_TASA_PLAZO_SEQ
  START WITH 1
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE RMASMS_SEQUENCE
  START WITH 221
  MAXVALUE 2000000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SECUENCIAIUSACELL
  START WITH 18581
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEC_TAOP_PROGRA
  START WITH 61
  MAXVALUE 999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEC_TASPEICELULAR
  START WITH 4443
  MAXVALUE 9999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQCTAMEDPAGO
  START WITH 1
  MAXVALUE 9999999999999999999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQCTAOCULTA
  START WITH 979
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQENCUESTA
  START WITH 101
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQUENCE_IUPIFRECUENT
  START WITH 401
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_M_TRACKING
  START WITH 47095
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_M_TRACKING_DETALLE
  START WITH 13700
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_M_USUARIOS
  START WITH 309
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_M_USUARIOS_OPERA
  START WITH 46698
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_OPER_FREC
  START WITH 13376
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_TOKEN_TARJETA
  START WITH 39
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_WU_CONFIRMACION
  START WITH 123
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQUENCE_WU_ID_BENEF
  START WITH 14
  MAXVALUE 9999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_ACTIVACION_SMS_ID
  START WITH 221
  MAXVALUE 1000000000000000000000000000
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_ACTIVATION_FAILURE_H
  START WITH 1204
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_ACT_PAGMOV
  START WITH 109
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_ALERTAS_BAZ
  START WITH 1210
  MAXVALUE 9999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_ARCHIVO_PMASIVOS
  START WITH 22
  MAXVALUE 9999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SEQ_BITACORA_CORE
  START WITH 1
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_BITACORA_DESTINOS_FREC_ID
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_BITACORA_ID
  START WITH 20119
  MAXVALUE 9999999999999999999999999
  MINVALUE 0
  CYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_BITA_CORE
  START WITH 1
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_BIT_CAN_FA
  START WITH 12241
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_BLOQ_INAC
  START WITH 6944
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_CLIP
  START WITH 433
  MAXVALUE 99999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_CU_FREC
  START WITH 688
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_CU_PROG
  START WITH 61
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_DESTINOS_TEF_SPEI_TER_ID
  START WITH 176384
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_DE_DESCUENTO
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_DE_IMPUESTO
  START WITH 102
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_DE_TRANSFERENCIAS
  START WITH 14
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_CAMBIO_PWD
  START WITH 5611
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_LOGIN_TA
  START WITH 255
  MAXVALUE 99999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_MAIL
  START WITH 7158
  MAXVALUE 99999999999999999
  MINVALUE 1
  CYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_MONTOSUSER
  START WITH 120
  MAXVALUE 999999999999999999
  MINVALUE 100
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_PAGO_TAZ
  START WITH 1445
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_RFC
  START WITH 13
  MAXVALUE 99999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EBANKING_SESSION
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_EMISORES
  START WITH 1208
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_FAKE_DISP
  START WITH 180013
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_FAKE_DISP2
  START WITH 90000
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_FIAR_BENEFICIARIOS
  START WITH 7164
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_FIAR_TRACE
  START WITH 1
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_FRECUENTES_SPEI_ID
  START WITH 812
  MAXVALUE 1000000000000000000000000000
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_HISTORIAL_PROCESO
  START WITH 2032
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_HISTORICO_TEF_SPEI_TER_ID
  START WITH 924
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_HIST_CUENTA_SMS_ID
  START WITH 861
  MAXVALUE 1000000000000000000000000000
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_HIST_LOGIN
  START WITH 41
  MAXVALUE 1000000000000000000000000000
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_HIST_LOGIN_ID
  START WITH 1341
  MAXVALUE 1000000000000000000000000000
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_ID
  START WITH 1
  MAXVALUE 999
  MINVALUE 1
  CYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_ID_ENV_SMS
  START WITH 81
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SEQ_ID_MEX_BIT
  START WITH 9859
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 5
  ORDER;


CREATE SEQUENCE SEQ_ID_REGISTRO
  START WITH 192
  MAXVALUE 99999999999999999999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_MENSAJE_ID
  START WITH 33121
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_MICNEG_PAG
  START WITH 60
  MAXVALUE 99999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_MICROBUSINESS_PAYMENT
  START WITH 20
  MAXVALUE 99999999999
  MINVALUE 0
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_MONTOSUSER
  START WITH 343
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_MONTOS_PERMITIDOS
  START WITH 1
  MAXVALUE 99999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_OPE_PROG
  START WITH 101
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_OTROS_SERVICIOS
  START WITH 2
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_PNUMBER_CONTAC
  START WITH 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_PREACT_USER
  START WITH 81
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_REC_AGENDA
  START WITH 510
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_SCHEDULED_EMAIL_ID
  START WITH 536
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_SCHEDULED_PAYMENT_ID
  START WITH 2080
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_SEGURIDAD_ACCESO
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SEQ_SPEI_FREQ30
  START WITH 32
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TARJV_BITACORA_ID
  START WITH 21
  MAXVALUE 9999999999999999999999999
  MINVALUE 0
  CYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TELEFONO_ID
  START WITH 1344
  MAXVALUE 999999999999999999999999999
  MINVALUE 0
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TOKEN_ACT
  START WITH 1
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TOKEN_DISP
  START WITH 876
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TOKEN_PC
  START WITH 7
  MAXVALUE 9999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TOKEN_PREVENCION_ID
  START WITH 627
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TOKEN_SOLICITUD_ID
  START WITH 5643
  MAXVALUE 999999999999999999999999999
  MINVALUE 5000
  NOCYCLE
  NOCACHE
  NOORDER;


CREATE SEQUENCE SEQ_TRANSF_ADICIONALES
  START WITH 221
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  CYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SEQ_TRANSF_BITACORA
  START WITH 150
  MAXVALUE 999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_TRANSF_PROGRAMADAS
  START WITH 301
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SEQ_WU_IDBENEF
  START WITH 61
  MAXVALUE 9999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SE_FOLIONUEVO
  START WITH 101
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDBENEF
  START WITH 81
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDBENEFAF
  START WITH 121
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDCLIENTE
  START WITH 121
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDCONTENIDO
  START WITH 1
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDDIRBENEF
  START WITH 81
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDDIRECAFI
  START WITH 121
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDDIRECCION
  START WITH 81
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDDOCUMENTO
  START WITH 1
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDFISCAL
  START WITH 121
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDINFOEYF
  START WITH 81
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDNEGOCIO
  START WITH 141
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDPERSONAPE
  START WITH 81
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SE_IDUSOCUENTA
  START WITH 101
  MAXVALUE 10000000
  MINVALUE 1
  NOCYCLE
  CACHE 20
  ORDER;


CREATE SEQUENCE SQ_FOLIOMOVIL
  START WITH 284
  MAXVALUE 99999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE SQ_ID
  START WITH 61
  MAXVALUE 999
  MINVALUE 1
  CYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE WUNUMREFERENCE_SEQ
  START WITH 591
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE WUNUMREFER_SEQ
  START WITH 1754
  MAXVALUE 9999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE WUNUMREF_SEQ
  START WITH 971
  MAXVALUE 9999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE TABLE ACCIONES
(
  OPERACION   VARCHAR2(100 BYTE)                NOT NULL,
  MOVIMIENTO  NUMBER(20)                        NOT NULL,
  FECHA       DATE                              DEFAULT sysdate               NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ACERTUM_USER
(
  ID                     NUMBER(10)             NOT NULL,
  NUMCUENTA              VARCHAR2(30 BYTE),
  NUMTARJETA             VARCHAR2(30 BYTE),
  TOKEN                  NUMBER,
  FECHAACTIVACIONPORTAL  DATE,
  FECHAACTIVACIONASESOR  DATE,
  RFC                    VARCHAR2(15 BYTE),
  EMAIL                  VARCHAR2(40 BYTE),
  BIOMETRICO             VARCHAR2(15 BYTE),
  ULTIMOACCESO           DATE,
  ACTIVO                 NUMBER(1),
  CELULAR                VARCHAR2(16 BYTE),
  TELEFONO               VARCHAR2(25 BYTE),
  SECUREDATA             VARCHAR2(48 BYTE),
  ACTIVACIONTYPE         NUMBER(4),
  SECURITY_LEVEL         INTEGER,
  TRACKING               NUMBER(1)              DEFAULT 0,
  ULTIMA_IP              VARCHAR2(20 BYTE),
  FECHA_MODIFICACION     DATE,
  USUARIO_MODIFICA       VARCHAR2(10 BYTE),
  FECHA_CREACION         DATE,
  ULTIMO_ACCESO          DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ACTIVACION_DEX
(
  CTEALNOVA            NUMBER(8)                NOT NULL,
  CTEDEX               NUMBER(8),
  U_ID                 VARCHAR2(15 BYTE),
  FECHAACTIVACION      DATE,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ACTIVACION_SMS
(
  ID                  NUMBER(10)                NOT NULL,
  ID_CLIENTE          VARCHAR2(10 BYTE)         NOT NULL,
  FECHA_ACTIVACION    DATE                      NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ACTIVACION_WU
(
  CU                   VARCHAR2(50 BYTE)        NOT NULL,
  U_ID                 VARCHAR2(40 BYTE)        NOT NULL,
  FECHA_ACTIVACION     DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ACTIVAR_ACRTUM
(
  TELEFONO            VARCHAR2(10 BYTE)         NOT NULL,
  NUMERO_CLIENTE      VARCHAR2(10 BYTE)         NOT NULL,
  EMAIL               VARCHAR2(100 BYTE)        NOT NULL,
  PRIMER_LOGEO        NUMBER                    NOT NULL,
  FECHA_ACTIVACION    DATE                      NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE AGENDA_RECORDATORIOS
(
  OPERACION  VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALERTAS_BAZ
(
  ID_ALERTA                  INTEGER            NOT NULL,
  ID_ALNOVA                  VARCHAR2(10 BYTE)  NOT NULL,
  TIPO_MENSAJE               VARCHAR2(50 BYTE)  NOT NULL,
  MENSAJE                    VARCHAR2(2000 BYTE),
  ESTATUS                    INTEGER            NOT NULL,
  FECHA_ALERTA               DATE               NOT NULL,
  FECHA_ULTIMA_MODIFICACION  DATE               DEFAULT SYSDATE,
  USUARIO_MODIFICO           VARCHAR2(100 BYTE),
  SISTEMA_ORIGEN             VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALERTAS_TEST
(
  ID    INTEGER                                 NOT NULL,
  DATA  VARCHAR2(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALL_FRECUENTES
(
  ID_FRECUENTES         NUMBER(10)              NOT NULL,
  USER_ID               NUMBER(8)               NOT NULL,
  FRECUENTE             VARCHAR2(50 BYTE)       NOT NULL,
  STATUS                VARCHAR2(2 BYTE)        NOT NULL,
  CANAL                 VARCHAR2(3 BYTE),
  ID_SERVICIO           VARCHAR2(8 BYTE),
  ULTIMA_ACTUALIZACION  DATE                    NOT NULL,
  USUARIO_MODIFICO      VARCHAR2(30 BYTE)       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_BRANCH
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(10 BYTE)                NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE)
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_CHANNEL
(
  ID              INTEGER                       NOT NULL,
  CODE            VARCHAR2(10 BYTE)             NOT NULL,
  DESCRIPTION     VARCHAR2(50 BYTE),
  CHANNEL2BRANCH  INTEGER                       NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_STATUS
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(10 BYTE)                NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE),
  ERROR        INTEGER                          NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TERMINAL
(
  ID                  INTEGER                   NOT NULL,
  CODE                VARCHAR2(10 BYTE)         NOT NULL,
  BUSY                INTEGER                   NOT NULL,
  SERVER              VARCHAR2(32 BYTE),
  TERMINAL2CHANNEL    INTEGER                   NOT NULL,
  FECHA_MODIFICACION  DATE                      DEFAULT SYSDATE
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TERMINAL_ACERTUM
(
  ID                  INTEGER                   NOT NULL,
  CODE                VARCHAR2(10 BYTE)         NOT NULL,
  BUSY                INTEGER                   NOT NULL,
  SERVER              VARCHAR2(32 BYTE),
  TERMINAL2CHANNEL    INTEGER                   NOT NULL,
  FECHA_MODIFICACION  DATE                      DEFAULT SYSDATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TERM_ES
(
  ID                INTEGER                     NOT NULL,
  CODE              VARCHAR2(20 BYTE)           NOT NULL,
  BUSY              INTEGER                     NOT NULL,
  SERVER            VARCHAR2(32 BYTE),
  TERMINAL2CHANNEL  INTEGER                     NOT NULL,
  APP               VARCHAR2(60 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_OPERACION   DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TERM_SEL
(
  ID                INTEGER                     NOT NULL,
  CODE              VARCHAR2(20 BYTE)           NOT NULL,
  BUSY              INTEGER                     NOT NULL,
  APP               VARCHAR2(60 BYTE)           NOT NULL,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_OPERACION   DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TERM_SEL_RESPALD
(
  ID                INTEGER                     NOT NULL,
  CODE              VARCHAR2(20 BYTE)           NOT NULL,
  BUSY              INTEGER                     NOT NULL,
  APP               VARCHAR2(60 BYTE)           NOT NULL,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_OPERACION   DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_TRANSACTION
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(10 BYTE)                NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE)                NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ALNOVA_USER
(
  ID            INTEGER                         NOT NULL,
  CODE          VARCHAR2(10 BYTE)               NOT NULL,
  DESCRIPTION   VARCHAR2(50 BYTE),
  USER2CHANNEL  INTEGER                         NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ATA_WU_CONFIRMACION
(
  FCUID                VARCHAR2(25 BYTE)        NOT NULL,
  FCID                 VARCHAR2(20 BYTE)        NOT NULL,
  FCIDOPERACION        VARCHAR2(10 BYTE)        NOT NULL,
  FCSUCURSAL           VARCHAR2(5 BYTE)         NOT NULL,
  FCCAJA               VARCHAR2(2 BYTE)         NOT NULL,
  FCPAIS               VARCHAR2(3 BYTE)         NOT NULL,
  FCCANAL              VARCHAR2(10 BYTE)        NOT NULL,
  FCNOMBREREMIT        VARCHAR2(12 BYTE)        NOT NULL,
  FCAPELLIDOREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCDIRECCIONREMIT     VARCHAR2(100 BYTE)       NOT NULL,
  FCCPREMIT            VARCHAR2(5 BYTE)         NOT NULL,
  FCPOBLACIONREMIT     VARCHAR2(24 BYTE)        NOT NULL,
  FCESTADOREMIT        VARCHAR2(24 BYTE)        NOT NULL,
  FCTELREMIT           VARCHAR2(15 BYTE)        NOT NULL,
  FDFECHNACREMIT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPOIDREMIT        VARCHAR2(3 BYTE)         NOT NULL,
  FCFOLIOREMIT         VARCHAR2(15 BYTE)        NOT NULL,
  FCFECHVENCREMIT      VARCHAR2(8 BYTE)         NOT NULL,
  FCIDEMISORREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONALREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCPAISREMIT          VARCHAR2(2 BYTE)         NOT NULL,
  FCLUGARNACREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONAL           VARCHAR2(10 BYTE)        NOT NULL,
  FCOCUPACION          VARCHAR2(20 BYTE)        NOT NULL,
  FCACUSERECIBO        VARCHAR2(3 BYTE)         NOT NULL,
  FCBENEFNOMBRE        VARCHAR2(25 BYTE)        NOT NULL,
  FCBENEFAPELLIDOS     VARCHAR2(45 BYTE)        NOT NULL,
  FCPRINCIPAL          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGO              VARCHAR2(11 BYTE)        NOT NULL,
  FCIMPUESTO           VARCHAR2(11 BYTE)        NOT NULL,
  FCDESCUENTO          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGOMENSAJE       VARCHAR2(11 BYTE)        NOT NULL,
  FCTOTALPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCMONTOPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCPAISORIGEN         VARCHAR2(2 BYTE)         NOT NULL,
  FCMONEDAORIGEN       VARCHAR2(3 BYTE)         NOT NULL,
  FCPAISDESTINO        VARCHAR2(2 BYTE)         NOT NULL,
  FCPAISDESTINOPOBLAC  VARCHAR2(50 BYTE)        NOT NULL,
  FCPAISDESTINOESTADO  VARCHAR2(50 BYTE)        NOT NULL,
  FCMONEDADESTINO      VARCHAR2(3 BYTE)         NOT NULL,
  FCPAGARSINID         VARCHAR2(1 BYTE)         NOT NULL,
  FCPREGUNTA           VARCHAR2(35 BYTE)        NOT NULL,
  FCRESPUESTA          VARCHAR2(35 BYTE)        NOT NULL,
  FCMENSAJE            VARCHAR2(200 BYTE)       NOT NULL,
  FCMTCN               VARCHAR2(10 BYTE)        NOT NULL,
  FCREFERENCIANO       VARCHAR2(16 BYTE)        NOT NULL,
  FCOPERADOR           VARCHAR2(12 BYTE)        NOT NULL,
  FCOPERADORNOMBRE     VARCHAR2(25 BYTE)        NOT NULL,
  FCOPERADORAPPATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCOPERADORAPMATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCIDSISTEMAEXT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPONOMBREREMIT    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPONOMBREBENEF    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPOTRANFDINERO    VARCHAR2(3 BYTE)         NOT NULL,
  FCIDTARJETALEALTAD   VARCHAR2(3 BYTE)         NOT NULL,
  FCENVIOTERCEROS      VARCHAR2(1 BYTE)         NOT NULL,
  FCEXPIRADO           VARCHAR2(1 BYTE)         NOT NULL,
  FCUSUARIO            VARCHAR2(15 BYTE)        NOT NULL,
  FCPASSWORD           VARCHAR2(15 BYTE)        NOT NULL,
  FDFECHATRANSACCION   TIMESTAMP(6)             DEFAULT SYSDATE               NOT NULL,
  FCXML                VARCHAR2(3000 BYTE)      NOT NULL,
  FCNORETENCION        VARCHAR2(15 BYTE)        NOT NULL,
  FCTCORIGEN           VARCHAR2(20 BYTE)        NOT NULL,
  FCTCDESTINO          VARCHAR2(20 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE A_FAM
(
  ALNOVA  VARCHAR2(8 BYTE)                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE A_RSA
(
  ALNOVA  VARCHAR2(8 BYTE)                      NOT NULL,
  ESTADO  NUMBER(1)                             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE A_TAR
(
  ALNOVA  VARCHAR2(8 BYTE)                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BENEFICIARIOS_WU
(
  CU                   VARCHAR2(20 BYTE)        NOT NULL,
  ALIAS                VARCHAR2(50 BYTE),
  ID_BENEFICIARIO_WU   VARCHAR2(20 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(50 BYTE)        NOT NULL,
  CIUDAD               VARCHAR2(30 BYTE),
  ESTADO               VARCHAR2(20 BYTE),
  NOMBRE               VARCHAR2(100 BYTE)       NOT NULL,
  AP_PATERNO           VARCHAR2(100 BYTE)       NOT NULL,
  AP_MATERNO           VARCHAR2(100 BYTE)       NOT NULL,
  ESTATUS              NUMBER(1)                DEFAULT 0                     NOT NULL,
  FECHA_ACTIVACION     DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BENEFICIARIOWU
(
  CU                   VARCHAR2(20 BYTE)        NOT NULL,
  ALIAS                VARCHAR2(50 BYTE),
  ID_BENEFICIARIO_WU   VARCHAR2(20 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(50 BYTE)        NOT NULL,
  CIUDAD               VARCHAR2(30 BYTE),
  ESTADO               VARCHAR2(20 BYTE),
  NOMBRE               VARCHAR2(100 BYTE)       NOT NULL,
  AP_PATERNO           VARCHAR2(100 BYTE)       NOT NULL,
  AP_MATERNO           VARCHAR2(100 BYTE)       NOT NULL,
  ESTATUS              NUMBER(1)                DEFAULT 0                     NOT NULL,
  FECHA_ACTIVACION     DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BENEFI_DEX
(
  ID_BENEFICIARIO_DEX  NUMBER(20)               NOT NULL,
  ALIAS_BENEFICIARIO   VARCHAR2(50 BYTE)        NOT NULL,
  CTEDEX               NUMBER(20)               NOT NULL,
  FECHAACTIVACION      DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  NOMBRE_COMPLETO      VARCHAR2(250 BYTE),
  NUM_CELULAR          VARCHAR2(15 BYTE),
  CEL_COMPANY          NUMBER(1),
  TIP_BENEFI           NUMBER(1)                DEFAULT 1                     NOT NULL,
  ESTATUS              NUMBER(1)                DEFAULT 1                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BENEFI_WU
(
  CU                   VARCHAR2(30 BYTE)        NOT NULL,
  ALIAS                VARCHAR2(50 BYTE),
  ID_BENEFICIARIO_WU   VARCHAR2(20 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(50 BYTE)        NOT NULL,
  CIUDAD               VARCHAR2(30 BYTE),
  ESTADO               VARCHAR2(20 BYTE),
  NOMBRE_COMPLETO      VARCHAR2(250 BYTE)       NOT NULL,
  ESTATUS              NUMBER(1)                DEFAULT 0                     NOT NULL,
  FECHA_ACTIVACION     DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BITAAPERTURAS
(
  CUENTA          VARCHAR2(20 BYTE)             NOT NULL,
  TARJETAVIRTUAL  VARCHAR2(20 BYTE),
  IDALNOVA        VARCHAR2(20 BYTE)             NOT NULL,
  CLIENTEUNICO    VARCHAR2(20 BYTE),
  NOMBREAPLIC     VARCHAR2(20 BYTE)             NOT NULL,
  TIPOCUENTA      VARCHAR2(10 BYTE),
  FECHAULTMODIF   DATE                          DEFAULT SYSDATE,
  USRMODIF        VARCHAR2(20 BYTE)             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BITACORA_CORE
(
  ID_OPERACION         INTEGER                  NOT NULL,
  USUARIO              VARCHAR2(12 BYTE)        NOT NULL,
  OPERACION            VARCHAR2(50 BYTE)        NOT NULL,
  MONTO                VARCHAR2(11 BYTE),
  SISTEMA              VARCHAR2(30 BYTE)        NOT NULL,
  REQUEST              VARCHAR2(3500 BYTE)      NOT NULL,
  FECHAOPER            DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL
)
PARTITION BY RANGE (FECHAOPER) 
(  
  PARTITION OPER2013 VALUES LESS THAN (TO_DATE(' 2014-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2014 VALUES LESS THAN (TO_DATE(' 2015-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2015 VALUES LESS THAN (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2016 VALUES LESS THAN (TO_DATE(' 2017-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2017 VALUES LESS THAN (TO_DATE(' 2018-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2018 VALUES LESS THAN (TO_DATE(' 2019-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2019 VALUES LESS THAN (TO_DATE(' 2020-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2020 VALUES LESS THAN (TO_DATE(' 2021-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPER2021 VALUES LESS THAN (TO_DATE(' 2022-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION OPERDEFAULT VALUES LESS THAN (MAXVALUE)
    LOGGING
    NOCOMPRESS
)
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BIT_CAN_FA
(
  ID_FA                NUMBER(7)                NOT NULL,
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  NOMBRE               VARCHAR2(50 BYTE)        NOT NULL,
  APELLIDOS            VARCHAR2(50 BYTE)        NOT NULL,
  SERIE_TOKEN          VARCHAR2(12 BYTE)        NOT NULL,
  FECHA_CADUCIDAD      DATE                     NOT NULL,
  CORREO_ELECTRONICO   VARCHAR2(40 BYTE),
  HABILITADO           NUMBER(1)                NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT Sysdate               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BIT_CAN_FA_EBK
(
  ID_FA                NUMBER(7)                NOT NULL,
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  NOMBRE               VARCHAR2(50 BYTE)        NOT NULL,
  APELLIDOS            VARCHAR2(50 BYTE)        NOT NULL,
  SERIE_TOKEN          VARCHAR2(12 BYTE)        NOT NULL,
  FECHA_CADUCIDAD      DATE                     NOT NULL,
  STATUS               NUMBER(2)                NOT NULL,
  CORREO_ELECTRONICO   VARCHAR2(40 BYTE),
  HABILITADO           NUMBER(1)                NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT Sysdate               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BIT_MEX_TRANS
(
  ID_TRANSACCION       NUMBER(7)                NOT NULL,
  NUM_CLIENTE          VARCHAR2(10 BYTE)        NOT NULL,
  DISPOSITIVO          VARCHAR2(3 BYTE)         NOT NULL,
  RESULTADO_AUTH       VARCHAR2(3 BYTE)         NOT NULL,
  OPERACION            VARCHAR2(4 BYTE)         NOT NULL,
  TIEMPO_TARJETAS      NUMBER(6)                NOT NULL,
  TIEMPO_BD            NUMBER(6)                NOT NULL,
  TIEMPO_RSA           NUMBER(6)                NOT NULL,
  TIEMPO_TOTAL         NUMBER(6)                NOT NULL,
  IP_CLIENTE           VARCHAR2(15 BYTE)        NOT NULL,
  IP_INSTANCIA         VARCHAR2(15 BYTE)        NOT NULL,
  SISTEMA              VARCHAR2(8 BYTE),
  FECHA_AUTH           DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BIT_REF_FAM
(
  ID_DISPOSITIVO       NUMBER(7)                NOT NULL,
  ALNOVA               VARCHAR2(8 BYTE)         NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT Sysdate               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BIT_REF_TOKEN
(
  ID_DIS               NUMBER                   NOT NULL,
  NUM_CLIENTE          VARCHAR2(15 BYTE)        NOT NULL,
  NUM_SERIE_TOKEN      VARCHAR2(12 BYTE)        NOT NULL,
  STATUS               NUMBER                   NOT NULL,
  FECHA_MODIFICACION   DATE                     DEFAULT Sysdate               NOT NULL,
  FECHA_ACTIVACION     DATE                     DEFAULT Sysdate               NOT NULL,
  SISTEMA              VARCHAR2(6 BYTE)         NOT NULL,
  IDPAIS               VARCHAR2(3 BYTE)         NOT NULL,
  NUM_CLI_NUE          VARCHAR2(15 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT Sysdate               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BLOQUEOINAC_H
(
  ID_BLOQUEO           NUMBER                   NOT NULL,
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  FECHA_MODIFICACION   DATE                     DEFAULT SYSDATE               NOT NULL,
  ESTATUS              VARCHAR2(25 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIOS_MODIFICO    VARCHAR2(30 BYTE)        NOT NULL,
  SISTEMA              VARCHAR2(25 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE BTA_WU_CONFIRMACION
(
  FCUID                VARCHAR2(25 BYTE)        NOT NULL,
  ID                   NUMBER                   NOT NULL,
  FCID                 VARCHAR2(20 BYTE)        NOT NULL,
  FCIDOPERACION        VARCHAR2(10 BYTE)        NOT NULL,
  FCSUCURSAL           VARCHAR2(5 BYTE)         NOT NULL,
  FCCAJA               VARCHAR2(2 BYTE)         NOT NULL,
  FCPAIS               VARCHAR2(3 BYTE)         NOT NULL,
  FCCANAL              VARCHAR2(10 BYTE)        NOT NULL,
  FCNOMBREREMIT        VARCHAR2(12 BYTE)        NOT NULL,
  FCAPELLIDOREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCDIRECCIONREMIT     VARCHAR2(100 BYTE)       NOT NULL,
  FCCPREMIT            VARCHAR2(5 BYTE)         NOT NULL,
  FCPOBLACIONREMIT     VARCHAR2(24 BYTE)        NOT NULL,
  FCESTADOREMIT        VARCHAR2(24 BYTE)        NOT NULL,
  FCTELREMIT           VARCHAR2(15 BYTE)        NOT NULL,
  FDFECHNACREMIT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPOIDREMIT        VARCHAR2(3 BYTE)         NOT NULL,
  FCFOLIOREMIT         VARCHAR2(15 BYTE)        NOT NULL,
  FCFECHVENCREMIT      VARCHAR2(8 BYTE)         NOT NULL,
  FCIDEMISORREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONALREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCPAISREMIT          VARCHAR2(2 BYTE)         NOT NULL,
  FCLUGARNACREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONAL           VARCHAR2(10 BYTE)        NOT NULL,
  FCOCUPACION          VARCHAR2(20 BYTE)        NOT NULL,
  FCACUSERECIBO        VARCHAR2(3 BYTE)         NOT NULL,
  FCBENEFNOMBRE        VARCHAR2(25 BYTE)        NOT NULL,
  FCBENEFAPELLIDOS     VARCHAR2(45 BYTE)        NOT NULL,
  FCPRINCIPAL          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGO              VARCHAR2(11 BYTE)        NOT NULL,
  FCIMPUESTO           VARCHAR2(11 BYTE)        NOT NULL,
  FCDESCUENTO          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGOMENSAJE       VARCHAR2(11 BYTE)        NOT NULL,
  FCTOTALPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCMONTOPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCPAISORIGEN         VARCHAR2(2 BYTE)         NOT NULL,
  FCMONEDAORIGEN       VARCHAR2(3 BYTE)         NOT NULL,
  FCPAISDESTINO        VARCHAR2(2 BYTE)         NOT NULL,
  FCPAISDESTINOPOBLAC  VARCHAR2(50 BYTE)        NOT NULL,
  FCPAISDESTINOESTADO  VARCHAR2(50 BYTE)        NOT NULL,
  FCMONEDADESTINO      VARCHAR2(3 BYTE)         NOT NULL,
  FCPAGARSINID         VARCHAR2(1 BYTE)         NOT NULL,
  FCPREGUNTA           VARCHAR2(35 BYTE)        NOT NULL,
  FCRESPUESTA          VARCHAR2(35 BYTE)        NOT NULL,
  FCMENSAJE            VARCHAR2(200 BYTE)       NOT NULL,
  FCMTCN               VARCHAR2(10 BYTE)        NOT NULL,
  FCREFERENCIANO       VARCHAR2(16 BYTE)        NOT NULL,
  FCOPERADOR           VARCHAR2(12 BYTE)        NOT NULL,
  FCOPERADORNOMBRE     VARCHAR2(25 BYTE)        NOT NULL,
  FCOPERADORAPPATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCOPERADORAPMATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCIDSISTEMAEXT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPONOMBREREMIT    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPONOMBREBENEF    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPOTRANFDINERO    VARCHAR2(3 BYTE)         NOT NULL,
  FCIDTARJETALEALTAD   VARCHAR2(3 BYTE)         NOT NULL,
  FCENVIOTERCEROS      VARCHAR2(1 BYTE)         NOT NULL,
  FCEXPIRADO           VARCHAR2(1 BYTE)         NOT NULL,
  FCUSUARIO            VARCHAR2(15 BYTE)        NOT NULL,
  FCPASSWORD           VARCHAR2(15 BYTE)        NOT NULL,
  FDFECHATRANSACCION   TIMESTAMP(6)             DEFAULT SYSDATE               NOT NULL,
  FCXML                VARCHAR2(3000 BYTE)      NOT NULL,
  FCNORETENCION        VARCHAR2(15 BYTE)        NOT NULL,
  FCTCORIGEN           VARCHAR2(20 BYTE)        NOT NULL,
  FCTCDESTINO          VARCHAR2(20 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CALLCENTERLOG
(
  TARJETA        VARCHAR2(30 BYTE),
  CUENTA         VARCHAR2(30 BYTE),
  USUARIO        VARCHAR2(250 BYTE)             NOT NULL,
  NOMBRECLIENTE  VARCHAR2(250 BYTE)             NOT NULL,
  ACCION         VARCHAR2(100 BYTE)             NOT NULL,
  CONSECUTIVO    VARCHAR2(30 BYTE)              NOT NULL,
  FECHA          DATE                           DEFAULT sysdate               NOT NULL,
  DETALLE        VARCHAR2(500 BYTE),
  VALIDACION     NUMBER(1)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CARRIER
(
  CARRIER_ID   NUMBER(2)                        NOT NULL,
  DESCRIPCION  VARCHAR2(20 BYTE)                NOT NULL,
  STATUS       NUMBER(1)                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CARROS
(
  CARRO   VARCHAR2(4 BYTE)                      NOT NULL,
  MODELO  VARCHAR2(15 BYTE)                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CATALOGO
(
  FC_NOMBRE              VARCHAR2(20 BYTE)      NOT NULL,
  FC_IP_ADDRESS          VARCHAR2(15 BYTE)      DEFAULT '172.0.0.1'           NOT NULL,
  FD_CREATED_DATE        DATE                   DEFAULT sysdate               NOT NULL,
  FD_MODIFICATION_DATE   DATE                   DEFAULT sysdate               NOT NULL,
  FD_OPERATION_TIME      TIMESTAMP(6)           DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FC_TRANSACTION_NUMBER  VARCHAR2(6 BYTE)       DEFAULT ''                    NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CLIENTESSELECTOSC
(
  ALNOVA  VARCHAR2(10 BYTE)                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CLIENTESSELECTOSD
(
  ALNOVA  VARCHAR2(10 BYTE)                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CLIENTE_PLO
(
  ID         NUMBER                             NOT NULL,
  NOMBRE     VARCHAR2(50 BYTE)                  NOT NULL,
  DIRECCION  VARCHAR2(40 BYTE)                  NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE COMPRAMAX_ESTATUS
(
  IDESTATUS    NUMBER(2)                        NOT NULL,
  DESCESTATUS  VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE COMPRATA_TELEFONOSFRECUENTES
(
  CLIENT                NUMBER(8)               NOT NULL,
  CARRIER               NUMBER(2)               NOT NULL,
  TELEPHONE             VARCHAR2(10 BYTE)       NOT NULL,
  REFERENCE             VARCHAR2(40 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                VARCHAR2(2 BYTE),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CONFIR
(
  ID                    NUMBER(10)              NOT NULL,
  ID_CLIENTE            NUMBER(10)              NOT NULL,
  ID_TIPOTRANSFERENCIA  NUMBER(2)               NOT NULL,
  COD_BANCO             NUMBER(7),
  CUENTA_DESTINO        VARCHAR2(50 BYTE)       NOT NULL,
  NOMBRE_DESTINO        VARCHAR2(40 BYTE),
  EMAIL_DESTINO         VARCHAR2(59 BYTE),
  NUM_CELULAR_DESTINO   VARCHAR2(15 BYTE),
  NUM_TEL_CASA          VARCHAR2(15 BYTE),
  NUM_TEL_OFFNA         VARCHAR2(15 BYTE),
  IP_ORIGEN             VARCHAR2(30 BYTE),
  FECHA_MODIFICACION    DATE,
  PLAZA                 NUMBER(2),
  TIPO_CUENTA_DESTINO   VARCHAR2(10 BYTE),
  CARRIER_NAME          VARCHAR2(18 BYTE),
  DESCRIPCION_CUENTA    VARCHAR2(100 BYTE),
  APODO                 VARCHAR2(100 BYTE),
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                VARCHAR2(2 BYTE),
  CANAL                 VARCHAR2(3 BYTE),
  TARJETA               VARCHAR2(16 BYTE),
  NOTIFICACION          NUMBER(2)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CORE_EJBS
(
  IDEJB                NUMBER(20)               NOT NULL,
  NOMBRE_EJB           VARCHAR2(80 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CORE_MACS
(
  MAC                  VARCHAR2(20 BYTE)        NOT NULL,
  IDROL                NUMBER(20)               NOT NULL,
  NOMBRE_APLICACION    VARCHAR2(50 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CORE_METODS
(
  IDMETODO             NUMBER(20)               NOT NULL,
  IDEJB                NUMBER(20)               NOT NULL,
  NOMBRE_METODO        VARCHAR2(80 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  DESCRIPCION_FUNCION  VARCHAR2(400 BYTE),
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CORE_ROL
(
  IDROL                NUMBER(20)               NOT NULL,
  NOMBRE_ROL           VARCHAR2(50 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CORE_ROL_METODS
(
  IDROL_METODO         NUMBER(30)               NOT NULL,
  IDMETODO             NUMBER(20)               NOT NULL,
  IDROL                NUMBER(20)               NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CREDITOSOTROSBANCOSFRECUENT
(
  CLIENTE             NUMBER(8)                 NOT NULL,
  BANCO               NUMBER(3)                 NOT NULL,
  TIPOCREDITO         NUMBER(3)                 NOT NULL,
  CUENTACREDITO       VARCHAR2(25 BYTE)         NOT NULL,
  BENEFICIARIO        VARCHAR2(40 BYTE)         NOT NULL,
  STATUS              NUMBER,
  FECHA_MODIFICACION  DATE,
  IP_ORIGEN           VARCHAR2(30 BYTE),
  CANAL               VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CTAS_OCULTAS
(
  ID_CONSECUTIVO       INTEGER                  NOT NULL,
  ID_CLI_ALNOVA        VARCHAR2(50 BYTE)        NOT NULL,
  TIPO_CUENTA          VARCHAR2(100 BYTE)       NOT NULL,
  CUENTA               VARCHAR2(50 BYTE)        NOT NULL,
  ESTATUS              INTEGER                  NOT NULL,
  FECHA_ALTA           DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  SISTEMA              VARCHAR2(25 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CT_COUNTRY
(
  FI_COUNTRY_ID          INTEGER                NOT NULL,
  FC_COUNTRY             VARCHAR2(50 BYTE),
  FI_STATUS              INTEGER                NOT NULL,
  FC_USER                VARCHAR2(30 BYTE)      DEFAULT 'DEFAULT'             NOT NULL,
  FI_EMPLOYEE_ID         INTEGER                DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS          VARCHAR2(15 BYTE)      DEFAULT '127.0.0.1'           NOT NULL,
  FD_CREATED_DATE        DATE                   DEFAULT SYSDATE               NOT NULL,
  FD_MODIFICATION_DATE   DATE                   DEFAULT SYSDATE               NOT NULL,
  FD_OPERATION_TIME      TIMESTAMP(6)           DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FI_CENTER_OPERATION    INTEGER                DEFAULT 0                     NOT NULL,
  FC_TRANSACTION_NUMBER  VARCHAR2(50 BYTE)      DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CT_HOV_LETTER
(
  FI_PRODUCT_LETTER_ID     INTEGER              NOT NULL,
  FI_STATE_ID              INTEGER              NOT NULL,
  FI_NOTIFICATION_TYPE_ID  INTEGER              NOT NULL,
  FC_LETTER_NAME           VARCHAR2(20 BYTE)    NOT NULL,
  FC_LETTER_CODE           VARCHAR2(100 BYTE)   NOT NULL,
  FI_STATUS                INTEGER              NOT NULL,
  FC_USER                  VARCHAR2(30 BYTE)    DEFAULT 'Default'             NOT NULL,
  FI_EMPLOYEE_ID           INTEGER              DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS            VARCHAR2(15 BYTE)    DEFAULT '172.0.0.1'           NOT NULL,
  FI_CENTER_OPERATION      INTEGER              DEFAULT 0                     NOT NULL,
  FD_CREATED_DATE          DATE                 DEFAULT sysdate               NOT NULL,
  FD_MODIFICATION_DATE     DATE                 DEFAULT sysdate               NOT NULL,
  FD_OPERATION_TIME        TIMESTAMP(6)         DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FC_TRANSACTION_NUMBER    VARCHAR2(50 BYTE)    DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CT_NOTIFICATION_TYPE
(
  FI_NOTIFICATION_TYPE_ID    INTEGER            NOT NULL,
  FC_NOTIFICATION_TYPE       VARCHAR2(255 BYTE) NOT NULL,
  FC_NOTIFICATION_TYPE_DESC  VARCHAR2(500 BYTE) NOT NULL,
  FI_STATUS                  INTEGER            DEFAULT 0                     NOT NULL,
  FC_USER                    VARCHAR2(30 BYTE)  DEFAULT USER                  NOT NULL,
  FI_EMPLOYEE_ID             INTEGER            DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS              VARCHAR2(15 BYTE)  DEFAULT '127.0.0.1'           NOT NULL,
  FI_CENTER_OPERATION        INTEGER            DEFAULT 0                     NOT NULL,
  FD_CREATED_DATE            DATE               DEFAULT SYSDATE               NOT NULL,
  FD_MODIFICATION_DATE       DATE               DEFAULT SYSDATE               NOT NULL,
  FD_OPERATION_TIME          TIMESTAMP(6)       DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FC_TRANSACTION_NUMBER      VARCHAR2(50 BYTE)  DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CT_STATE
(
  FI_STATE_ID            INTEGER                NOT NULL,
  FC_STATE_INITIAL       VARCHAR2(4 BYTE),
  FC_STATE               VARCHAR2(50 BYTE),
  FI_COUNTRY_ID          INTEGER,
  FI_STATUS              INTEGER                NOT NULL,
  FC_USER                VARCHAR2(30 BYTE)      DEFAULT 'DEFAULT'             NOT NULL,
  FI_EMPLOYEE_ID         INTEGER                DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS          VARCHAR2(15 BYTE)      DEFAULT '127.0.0.1'           NOT NULL,
  FD_CREATED_DATE        DATE                   DEFAULT SYSDATE               NOT NULL,
  FD_MODIFICATION_DATE   DATE                   DEFAULT SYSDATE               NOT NULL,
  FD_OPERATION_TIME      TIMESTAMP(6)           DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FI_CENTER_OPERATION    INTEGER                DEFAULT 0                     NOT NULL,
  FC_TRANSACTION_NUMBER  VARCHAR2(50 BYTE)      DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE CU_FRECUENTES
(
  ID                   NUMBER(22)               NOT NULL,
  ID_ALNOVA            VARCHAR2(10 BYTE)        NOT NULL,
  CLIENTE_UNICO        VARCHAR2(22 BYTE)        NOT NULL,
  ALIAS                VARCHAR2(30 BYTE)        NOT NULL,
  NOMBRE               VARCHAR2(80 BYTE)        NOT NULL,
  FECHA_MODIFICACION   DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE,
  STATUS               NUMBER(1),
  SISTEMA              VARCHAR2(8 BYTE)         NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DATOS_GOBIERNOS_PDF
(
  ID_CLIENTE        VARCHAR2(256 BYTE)          NOT NULL,
  TITULO_PAGO       VARCHAR2(256 BYTE),
  NOMBRE_CLIENTE    VARCHAR2(256 BYTE),
  DIRECCION         VARCHAR2(256 BYTE),
  CODIGO_POSTAL     VARCHAR2(256 BYTE),
  MUNICIPIO         VARCHAR2(256 BYTE),
  ESTADO            VARCHAR2(256 BYTE),
  CONCEPTO          VARCHAR2(256 BYTE),
  CONCEPTO1         VARCHAR2(256 BYTE),
  CONCEPTO2         VARCHAR2(256 BYTE),
  CONCEPTO3         VARCHAR2(256 BYTE),
  BANCO             VARCHAR2(256 BYTE),
  NUM_AUTORIZACION  INTEGER,
  FECHA_PAGO        DATE                        DEFAULT SYSDATE,
  LINEA_CAPTURA     VARCHAR2(256 BYTE)          NOT NULL,
  CERT_DIGITAL      VARCHAR2(256 BYTE),
  TOTAL             NUMBER,
  ID_SERVICIO       VARCHAR2(10 BYTE)           NOT NULL,
  COLONIA           VARCHAR2(256 BYTE),
  CONCEPTO4         VARCHAR2(256 BYTE),
  CONCEPTO5         VARCHAR2(256 BYTE),
  CONCEPTO6         VARCHAR2(256 BYTE),
  CONCEPTO7         VARCHAR2(256 BYTE),
  REFERENCIA        VARCHAR2(4 BYTE)            DEFAULT 1,
  RFC               VARCHAR2(15 BYTE),
  CUENTACARGO       INTEGER,
  IVA               NUMBER(12,2),
  IMPORTE           NUMBER(12,2),
  IVACOMISION       NUMBER(12,2)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DATOS_IMSS_PDF
(
  LINEA_CAPTURA                  VARCHAR2(53 BYTE) NOT NULL,
  NUM_AUTORIZACION               INTEGER        NOT NULL,
  ID_CLIENTE                     VARCHAR2(256 BYTE) NOT NULL,
  CUENTACARGO                    VARCHAR2(30 BYTE) NOT NULL,
  SELLO_DIGITAL                  VARCHAR2(256 BYTE) NOT NULL,
  OPCION                         NUMBER(1)      NOT NULL,
  FOLIOSUA                       VARCHAR2(6 BYTE) NOT NULL,
  PERIODOPAGO                    VARCHAR2(6 BYTE) NOT NULL,
  COMISION                       NUMBER(12,2)   NOT NULL,
  IMPORTETOTAL                   NUMBER(12,2)   NOT NULL,
  IMPORTERCV                     NUMBER(12,2)   NOT NULL,
  IMPORTEIMSS                    NUMBER(12,2)   NOT NULL,
  IMPORTEACV                     NUMBER(12,2),
  IMPORTEVIVIENDA                NUMBER(12,2),
  IMPORTEINFONAVIT               NUMBER(12,2),
  IMPORTESEGUROSIMSS             NUMBER(12,2),
  IMPORTEACTUALIZACIONIMSS       NUMBER(12,2),
  IMPORTERECARGOSIMSS            NUMBER(12,2),
  IMPORTERETIROCESAFORE          NUMBER(12,2),
  IMPORTEACTUALIZACIONAFORE      NUMBER(12,2),
  IMPORTERECARGOSAFORE           NUMBER(12,2),
  IMPORTEAPORTACIONVOLAFORE      NUMBER(12,2),
  IMPORTEAPORTACIONCOMAFORE      NUMBER(12,2),
  IMPORTECUENTAINDINFONAVIT      NUMBER(12,2),
  IMPORTEAPORPATRONALINFONAVIT   NUMBER(12,2),
  IMPORTEAMORTIZACIONINFONAVIT   NUMBER(12,2),
  IMPORTEACTUALIZACIONINFONAVIT  NUMBER(12,2),
  IMPORTERECARGOSINFONAVIT       NUMBER(12,2),
  IMPORTEMULTASINFONAVIT         NUMBER(12,2),
  IMPORTEFUNDEMEXINFONAVIT       NUMBER(12,2),
  ORIGENARCHIVO                  NUMBER(1),
  REGPATRONAL                    VARCHAR2(11 BYTE),
  VERSIONSUA                     VARCHAR2(4 BYTE),
  FECHA_VENCIMIENTO              DATE,
  FECHA_CARGO                    DATE           DEFAULT SYSDATE,
  FECHA_PAGO                     DATE           DEFAULT SYSDATE,
  NUM_TRABAJADORES               NUMBER(10),
  RAZONSOCIAL                    VARCHAR2(50 BYTE),
  DOMICILIO                      VARCHAR2(85 BYTE),
  RFCPATRONAL                    VARCHAR2(13 BYTE),
  ULTIMA_MODIFICACION            DATE           DEFAULT SYSDATE,
  USUARIO_MODIFICO               VARCHAR2(15 BYTE),
  SISTEMA                        VARCHAR2(15 BYTE),
  PAIS                           VARCHAR2(2 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DATOS_SERVICIO_PDF
(
  REFERENCIA        VARCHAR2(40 BYTE)           NOT NULL,
  NUMERO_OPERACION  INTEGER                     NOT NULL,
  FECHA_APLICACION  DATE,
  FECHA_PAGO        DATE,
  ID_SERVICIO       VARCHAR2(10 BYTE),
  CUENTA_CARGO      INTEGER,
  IMPORTE           NUMBER(12,2),
  COMISION          NUMBER(12,2),
  IVA               NUMBER(12,2),
  TOTAL             NUMBER(12,2),
  SELLO_DIGITAL     VARCHAR2(100 BYTE),
  NOMBRE_COMPLETO   VARCHAR2(100 BYTE),
  ACTIVIDAD         VARCHAR2(50 BYTE),
  NUMERO_CLIENTE    VARCHAR2(10 BYTE),
  ADICIONAL         VARCHAR2(100 BYTE)          DEFAULT null
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DBEXPERT_PLAN1
(
  STATEMENT_ID       VARCHAR2(30 BYTE),
  TIMESTAMP          DATE,
  REMARKS            VARCHAR2(80 BYTE),
  OPERATION          VARCHAR2(30 BYTE),
  OPTIONS            VARCHAR2(255 BYTE),
  OBJECT_NODE        VARCHAR2(128 BYTE),
  OBJECT_OWNER       VARCHAR2(30 BYTE),
  OBJECT_NAME        VARCHAR2(30 BYTE),
  OBJECT_INSTANCE    NUMBER,
  OBJECT_TYPE        VARCHAR2(30 BYTE),
  OPTIMIZER          VARCHAR2(255 BYTE),
  SEARCH_COLUMNS     NUMBER,
  ID                 NUMBER,
  PARENT_ID          NUMBER,
  POSITION           NUMBER,
  COST               NUMBER,
  CARDINALITY        NUMBER,
  BYTES              NUMBER,
  OTHER_TAG          VARCHAR2(255 BYTE),
  PARTITION_START    VARCHAR2(255 BYTE),
  PARTITION_STOP     VARCHAR2(255 BYTE),
  PARTITION_ID       NUMBER,
  OTHER              LONG,
  DISTRIBUTION       VARCHAR2(30 BYTE),
  CPU_COST           NUMBER(38),
  IO_COST            NUMBER(38),
  TEMP_SPACE         NUMBER(38),
  ACCESS_PREDICATES  VARCHAR2(4000 BYTE),
  FILTER_PREDICATES  VARCHAR2(4000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DESBLOQUEO
(
  ID                  NUMBER(10)                NOT NULL,
  VALIDACION          VARCHAR2(20 BYTE)         NOT NULL,
  INGRESADO           VARCHAR2(100 BYTE)        NOT NULL,
  REGISTRADO          VARCHAR2(100 BYTE)        NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  IP_USUARIO          VARCHAR2(20 BYTE)         NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(20 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DESTINOS_TEF_SPEI_TERCEROS
(
  ID                    NUMBER(10)              NOT NULL,
  ID_CLIENTE            NUMBER(10)              NOT NULL,
  ID_TIPOTRANSFERENCIA  NUMBER(2)               NOT NULL,
  COD_BANCO             NUMBER(3),
  CUENTA_DESTINO        VARCHAR2(18 BYTE)       NOT NULL,
  NOMBRE_DESTINO        VARCHAR2(40 BYTE),
  EMAIL_DESTINO         VARCHAR2(59 BYTE),
  NUM_CELULAR_DESTINO   VARCHAR2(15 BYTE),
  NUM_TEL_CASA          VARCHAR2(15 BYTE),
  NUM_TEL_OFFNA         VARCHAR2(15 BYTE),
  IP_ORIGEN             VARCHAR2(30 BYTE),
  FECHA_MODIFICACION    DATE,
  PLAZA                 NUMBER(2),
  TIPO_CUENTA_DESTINO   VARCHAR2(10 BYTE),
  CARRIER_NAME          VARCHAR2(18 BYTE),
  DESCRIPCION_CUENTA    VARCHAR2(50 BYTE),
  APODO                 VARCHAR2(30 BYTE),
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                VARCHAR2(1 BYTE),
  CANAL                 VARCHAR2(3 BYTE),
  NOTIFICACION          NUMBER(2)               DEFAULT 1
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DEXCLIENTE
(
  CLIENTE_ALNOVA        VARCHAR2(50 BYTE)       NOT NULL,
  CLIENTE_ID            NUMBER                  NOT NULL,
  NOMBRE                VARCHAR2(100 BYTE),
  APELLIDO_PATERNO      VARCHAR2(150 BYTE),
  APELLIDO_MATERNO      VARCHAR2(150 BYTE),
  FECHA_NACIMIENTO      DATE,
  PAIS_IDENTIFICACION   NUMBER,
  TIPO_IDENTIFICACION   NUMBER,
  FOLIO_IDENTIFICACION  VARCHAR2(256 BYTE),
  ULTIMA_MODIFICACION   DATE,
  USUARIO_MODIFICO      VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DEXIMPUESTO
(
  ID                     NUMBER,
  MTCN                   VARCHAR2(80 BYTE)      NOT NULL,
  NOMBRE_IMPUESTO        VARCHAR2(150 BYTE),
  MONTO                  NUMBER(15,2)           NOT NULL,
  ID_IMPUESTO            NUMBER,
  ID_IMPORTE             NUMBER,
  NOMBRE_CORTO_IMPUESTO  VARCHAR2(50 BYTE),
  ULTIMA_MODIFICACION    DATE,
  USUARIO_MODIFICO       VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE DEXTRANSFERENCIA
(
  CLIENTE_ID           NUMBER                   NOT NULL,
  MTCN                 VARCHAR2(80 BYTE)        NOT NULL,
  MONTO_ENVIADO        NUMBER(12,2)             NOT NULL,
  BENEFICIARIO_ID      NUMBER                   NOT NULL,
  TARIFA               NUMBER(12,2)             NOT NULL,
  NUM_CUENTA           VARCHAR2(50 BYTE)        NOT NULL,
  FECHA_ENVIO          DATE                     DEFAULT NULL                  NOT NULL,
  FOLIO_RETENCION      VARCHAR2(50 BYTE)        DEFAULT NULL                  NOT NULL,
  PAIS_ID_DESTINO      NUMBER,
  ESTADO_ID_DESTINO    NUMBER,
  CIUDAD_ID_DESTINO    NUMBER,
  ID_MONEDA_ENVIO      NUMBER,
  ID_MONEDA_DESTINO    NUMBER,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKINGPAN_USER
(
  NSS            CHAR(11 BYTE)                  NOT NULL,
  RFC            VARCHAR2(13 BYTE),
  FECH_NAC       DATE                           NOT NULL,
  NOMBRE         VARCHAR2(50 BYTE)              NOT NULL,
  PATERNO        VARCHAR2(50 BYTE)              NOT NULL,
  MATERNO        VARCHAR2(50 BYTE)              NOT NULL,
  CURP           CHAR(18 BYTE),
  EMAIL          VARCHAR2(30 BYTE)              NOT NULL,
  CELULAR        VARCHAR2(10 BYTE),
  COMPANIA_CEL   INTEGER,
  TEL_ADICIONAL  VARCHAR2(10 BYTE),
  PREGUNTA       VARCHAR2(50 BYTE)              NOT NULL,
  RESPUESTA      VARCHAR2(50 BYTE)              NOT NULL,
  RECIBE_MAIL    CHAR(1 BYTE)                   DEFAULT 0,
  RECIBE_SMS     CHAR(1 BYTE)                   DEFAULT 0,
  ACTIVO         CHAR(1 BYTE)                   DEFAULT 1
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTECONOMICA
(
  ID_PROFESION  INTEGER,
  ID            INTEGER,
  DESCRIPCION   VARCHAR2(150 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTGIRO
(
  ID           INTEGER,
  DESCRIPCION  VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTIVATION
(
  ALIAS               VARCHAR2(50 BYTE)         NOT NULL,
  CLIENTE             VARCHAR2(20 BYTE),
  EMAIL               VARCHAR2(50 BYTE),
  CUENTAOTARJ         VARCHAR2(20 BYTE),
  QUESTION            VARCHAR2(50 BYTE),
  ANSWER              VARCHAR2(50 BYTE),
  CEL_PHONE           VARCHAR2(30 BYTE),
  COMPANY             NUMBER,
  OFFICE_PHONE        VARCHAR2(30 BYTE),
  STATUS              NUMBER                    NOT NULL,
  ACTIVACION          DATE                      DEFAULT SYSDATE,
  CODE                VARCHAR2(50 BYTE)         NOT NULL,
  CUENTA              VARCHAR2(30 BYTE)         NOT NULL,
  IP                  VARCHAR2(30 BYTE),
  TARJETA             VARCHAR2(30 BYTE),
  TIPO                VARCHAR2(20 BYTE),
  MONITOR             VARCHAR2(20 BYTE),
  COMENTARIO          VARCHAR2(250 BYTE),
  INTENTOS_LOCALIZAR  NUMBER                    DEFAULT 0,
  NAME                VARCHAR2(250 BYTE),
  TIPOPROD            VARCHAR2(50 BYTE),
  FIRSTINTENTO        DATE                      DEFAULT NULL,
  LASTINTENTO         DATE                      DEFAULT NULL,
  CONFIRMACION        DATE                      DEFAULT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTIVATION_FAILURE
(
  USER_ID       NUMBER(10)                      NOT NULL,
  ATTEMPTS      NUMBER(3)                       NOT NULL,
  ATTEMPT_DATE  DATE                            NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTIVATION_FAILURE_H
(
  ID            NUMBER                          NOT NULL,
  USER_ID       NUMBER(10)                      NOT NULL,
  ATTEMPT_DATE  DATE                            NOT NULL,
  ATTEMPT       NUMBER(3)                       NOT NULL,
  IP            VARCHAR2(15 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ACTIVATION_H
(
  FOLIO          VARCHAR2(30 BYTE),
  CUENTA         VARCHAR2(30 BYTE),
  TITULAR        VARCHAR2(80 BYTE),
  EMAIL          VARCHAR2(30 BYTE),
  IPHONE         VARCHAR2(20 BYTE),
  APHONE         VARCHAR2(20 BYTE),
  FACTIVACION    DATE,
  FFINTENTO      DATE,
  FLINTENTO      DATE,
  INTENTOS       NUMBER,
  FCONFIRMACION  DATE,
  RESULTADO      VARCHAR2(20 BYTE),
  TACTIVACION    DATE,
  STATUS         NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ADYACENCIA
(
  ADYACENCIA  VARCHAR2(20 BYTE)                 NOT NULL,
  LONGITUD    NUMBER(2)                         NOT NULL,
  ES_LETRA    NUMBER(1)                         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ALERTAS_DEPOSITO
(
  CLIENTE_ID          NUMBER,
  CUENTA_HASH         CHAR(28 BYTE),
  SECUENCIA_TELEFONO  NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ALERTAS_RETIRO
(
  CLIENTE_ID          NUMBER,
  CUENTA_HASH         CHAR(28 BYTE),
  SECUENCIA_TELEFONO  NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ALERTAS_TEFDEV
(
  CLIENTE_ID          NUMBER,
  CUENTA_HASH         CHAR(28 BYTE),
  SECUENCIA_TELEFONO  NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_BAJASLDAP
(
  ID                   VARCHAR2(10 BYTE),
  STATUS               NUMBER                   NOT NULL,
  FECHA_CAMBIO_STATUS  DATE                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_BANKS
(
  ID                 INTEGER                    NOT NULL,
  CODE               VARCHAR2(8 BYTE)           NOT NULL,
  DESCRIPTION        VARCHAR2(64 BYTE)          NOT NULL,
  SHORT_DESCRIPTION  VARCHAR2(64 BYTE),
  TEF                NUMBER(1),
  SPEUAS             NUMBER(1)
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_BINES
(
  PREFIJO     VARCHAR2(8 BYTE)                  NOT NULL,
  BANCO       VARCHAR2(30 BYTE)                 NOT NULL,
  NOMBRE      VARCHAR2(100 BYTE)                NOT NULL,
  AFILIACION  CHAR(1 BYTE),
  COBERTURA   CHAR(1 BYTE),
  CLASE       VARCHAR2(15 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_BITACORA_TRAN
(
  ID                INTEGER                     NOT NULL,
  NUM_CLIENTE       INTEGER                     NOT NULL,
  ID_CAT_OPERACION  INTEGER                     NOT NULL,
  IP                VARCHAR2(30 BYTE)           NOT NULL,
  CTA_ORIGEN        VARCHAR2(30 BYTE),
  CTA_DESTINO       VARCHAR2(33 BYTE),
  FECHA_OPER        DATE                        DEFAULT SYSDATE               NOT NULL,
  MONTO             NUMBER(30,2)                NOT NULL,
  FOLIO             VARCHAR2(70 BYTE)           NOT NULL,
  METODO_CONFIR     INTEGER,
  DETALLE           VARCHAR2(4000 BYTE)         NOT NULL,
  NOMBRE_CLIENTE    VARCHAR2(90 BYTE)           NOT NULL,
  DETALLE2          VARCHAR2(4000 BYTE),
  APLICACION        VARCHAR2(20 BYTE)           DEFAULT 'NETNET'
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CAMBIO_PWD
(
  ID            NUMBER                          NOT NULL,
  USER_ID       NUMBER(10)                      NOT NULL,
  IP            VARCHAR2(30 BYTE)               NOT NULL,
  FECHA         DATE                            NOT NULL,
  ID_SESSION    VARCHAR2(100 BYTE)              NOT NULL,
  PASO          NUMBER(1)                       NOT NULL,
  STATUS        NUMBER(1)                       NOT NULL,
  CALIFICACION  NUMBER(2)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CATALOG_SERVICES
(
  ID_SERVICE      INTEGER                       NOT NULL,
  NAME_SERVICE    VARCHAR2(50 BYTE)             NOT NULL,
  PERIOD_OF_TIME  INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CAT_OPERACION
(
  ID             INTEGER                        NOT NULL,
  DETALLE_OPERA  CHAR(70 BYTE)                  NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CELLCOMPANY
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(8 BYTE)                 NOT NULL,
  DESCRIPTION  VARCHAR2(64 BYTE)                NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CLIP
(
  ID                INTEGER                     NOT NULL,
  FOLIOCLIP         VARCHAR2(20 BYTE)           NOT NULL,
  FOLIOBAZ          VARCHAR2(16 BYTE)           NOT NULL,
  NOMBRE            VARCHAR2(40 BYTE)           NOT NULL,
  AP_PATERNO        VARCHAR2(40 BYTE)           NOT NULL,
  AP_MATERNO        VARCHAR2(40 BYTE)           NOT NULL,
  RFC               VARCHAR2(13 BYTE)           NOT NULL,
  CURP              VARCHAR2(18 BYTE)           NOT NULL,
  NSS               VARCHAR2(11 BYTE),
  FECHA_APLICACION  DATE                        DEFAULT SYSDATE               NOT NULL,
  OPERADOR          VARCHAR2(10 BYTE)           NOT NULL,
  IP                VARCHAR2(15 BYTE)           NOT NULL,
  CALLE             VARCHAR2(40 BYTE),
  NUMERO_EXT        VARCHAR2(20 BYTE),
  NUMERO_INT        VARCHAR2(20 BYTE),
  COLONIA           VARCHAR2(40 BYTE),
  DEL_MUNI          VARCHAR2(50 BYTE),
  CP                INTEGER,
  FOLIO_SOLICITUD   VARCHAR2(16 BYTE),
  FECHA_TRASPASO    DATE,
  NUM_CLIENTE       VARCHAR2(10 BYTE)           NOT NULL,
  EMAIL             VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CLIP_EEC_OTRONOMBRE
(
  ID                NUMBER                      NOT NULL,
  FOLIOBAZ          VARCHAR2(16 BYTE)           NOT NULL,
  FOLIOCLIP         VARCHAR2(20 BYTE)           NOT NULL,
  NOMBRE            VARCHAR2(40 BYTE)           NOT NULL,
  AP_PATERNO        VARCHAR2(40 BYTE)           NOT NULL,
  AP_MATERNO        VARCHAR2(40 BYTE),
  RFC               VARCHAR2(13 BYTE),
  CURP              VARCHAR2(18 BYTE),
  NSS               VARCHAR2(11 BYTE),
  FECHA_APLICACION  DATE                        DEFAULT SYSDATE               NOT NULL,
  OPERADOR          VARCHAR2(10 BYTE),
  IP                VARCHAR2(15 BYTE),
  CALLE             VARCHAR2(40 BYTE),
  NUMERO_EXT        VARCHAR2(20 BYTE),
  NUMERO_INT        VARCHAR2(20 BYTE),
  COLONIA           VARCHAR2(40 BYTE),
  DEL_MUNI          VARCHAR2(50 BYTE),
  CP                NUMBER,
  FOLIO_SOLICITUD   VARCHAR2(16 BYTE),
  FECHA_TRASPASO    DATE,
  NUM_CLIENTE       VARCHAR2(10 BYTE)           NOT NULL,
  EMAIL             VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_CONTROL_HILOS
(
  NOMBRE     VARCHAR2(20 BYTE)                  NOT NULL,
  LASTDATE   DATE,
  INSTANCIA  VARCHAR2(5 BYTE),
  BANDERA    NUMBER                             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_DICCIONARIO
(
  PALABRA  VARCHAR2(20 BYTE)                    NOT NULL,
  IDIOMA   VARCHAR2(10 BYTE)                    NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_EDOCIVIL
(
  ID           INTEGER,
  DESCRIPCION  VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_EMPRESAS
(
  EMPRESA_ID  INTEGER                           NOT NULL,
  NOMBRE      VARCHAR2(60 BYTE)                 NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ERRORS_REPORT
(
  FECHA   DATE                                  NOT NULL,
  MODULO  VARCHAR2(100 BYTE)                    NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ESTADOS
(
  ESTADO_ID  INTEGER                            NOT NULL,
  NOMBRE     VARCHAR2(60 BYTE)                  NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_FIRMA
(
  FOLIO_ALNOVA  VARCHAR2(100 BYTE),
  CUENTA        VARCHAR2(100 BYTE),
  CONTRATO      VARCHAR2(10 BYTE),
  FIRMA         VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_HISTORICO_PAGOPEDIDOS
(
  IDPEDIDO     VARCHAR2(20 BYTE)                NOT NULL,
  IDRETENCION  VARCHAR2(20 BYTE)                NOT NULL,
  IDSECPAGO    VARCHAR2(20 BYTE)                NOT NULL,
  PETICION     VARCHAR2(300 BYTE),
  RESPUESTA    VARCHAR2(300 BYTE),
  EXITO        VARCHAR2(5 BYTE),
  ERROR        VARCHAR2(400 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ICEL
(
  FOLIO                     VARCHAR2(30 BYTE)   NOT NULL,
  FECHA                     DATE                DEFAULT sysdate               NOT NULL,
  ALNOVA_RESPONSE           VARCHAR2(800 BYTE)  NOT NULL,
  STORED_PROCEDURE_REQUEST  VARCHAR2(800 BYTE)  NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_IDENTIFICACION
(
  ID           INTEGER,
  DESCRIPCION  VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_IMPUESTOS_GDF
(
  LINEA_PAGO   VARCHAR2(50 BYTE),
  FECHA        DATE,
  ESTADO       VARCHAR2(3 BYTE),
  REQUEST_WS   VARCHAR2(200 BYTE),
  RESPONSE_WS  VARCHAR2(200 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_INDICES_TAN
(
  ID  INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN
(
  USER_ID     NUMBER(10)                        NOT NULL,
  ATTEMPTS    NUMBER(3)                         NOT NULL,
  LOGIN_DATE  DATE                              NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN_HIST
(
  ID          NUMBER                            NOT NULL,
  USER_ID     NUMBER(10)                        NOT NULL,
  LOGIN_DATE  DATE                              NOT NULL,
  ALIAS       VARCHAR2(20 BYTE)                 NOT NULL,
  ATTEMPT     NUMBER(3)                         NOT NULL,
  IP          VARCHAR2(15 BYTE),
  VALIDACION  NUMBER(1)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN_HISTORY
(
  USER_ID     NUMBER(10)                        NOT NULL,
  LOGIN_DATE  DATE                              NOT NULL,
  ALIAS       VARCHAR2(20 BYTE)                 NOT NULL,
  ATTEMPT     NUMBER(3)                         NOT NULL,
  IP          VARCHAR2(15 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN_TA
(
  NUM_TARJETA  VARCHAR2(16 BYTE)                NOT NULL,
  ATTEMPTS     NUMBER(3)                        NOT NULL,
  LOGIN_DATE   DATE                             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN_TA_HIS
(
  ID           INTEGER                          NOT NULL,
  NUM_TARJETA  NUMBER                           NOT NULL,
  LOGIN_DATE   DATE                             DEFAULT SYSDATE               NOT NULL,
  ATTEMPTS     NUMBER                           NOT NULL,
  IP           VARCHAR2(15 BYTE)                NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_LOGIN_TIMES
(
  CTE_ALNOVA           VARCHAR2(20 BYTE),
  FECHA                DATE,
  STATUS               VARCHAR2(5 BYTE),
  INSTANCIA            VARCHAR2(20 BYTE),
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_MAIL
(
  FECHA_CREACION       DATE                     DEFAULT sysdate               NOT NULL,
  SUBJECT              VARCHAR2(100 BYTE)       NOT NULL,
  MAIL_TO              VARCHAR2(100 BYTE)       NOT NULL,
  MAIL_CC              VARCHAR2(100 BYTE),
  MAIL_BCC             VARCHAR2(100 BYTE),
  FECHA_ENVIADO        DATE,
  STATUS               NUMBER                   DEFAULT 0,
  CONTENIDO            BLOB,
  ID_EBANKING_MAIL     NUMBER,
  ENCABEZADO           VARCHAR2(100 BYTE),
  FOLIO                VARCHAR2(100 BYTE),
  ES_MULTIPARTE        NUMBER                   DEFAULT 0,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_MAILING
(
  ID_CLIENTE   NUMBER                           NOT NULL,
  PROD_TDC     NUMBER                           DEFAULT 0,
  STATUS_MAIL  NUMBER                           DEFAULT 0
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_MONITOR_SERVICES
(
  ID      INTEGER,
  FECHA   DATE,
  STATUS  CHAR(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_MUNICIPIOS
(
  CITY_CODE    VARCHAR2(6 BYTE)                 NOT NULL,
  DESCRIPCION  VARCHAR2(60 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_NACIONALIDAD
(
  ID           INTEGER,
  DESCRIPCION  VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_NIVELESSEGURIDAD
(
  IDUSER               NUMBER,
  NIVELMOVIMIENTOS     NUMBER                   NOT NULL,
  NIVELTRANSFERENCIAS  NUMBER                   NOT NULL,
  NIVELFRECUENTES      NUMBER                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_NIVELESSEGURIDADHIST
(
  ID                 NUMBER                     NOT NULL,
  FECHADEOPERACION   DATE                       DEFAULT sysdate               NOT NULL,
  MOVIMIENTOSOLD     NUMBER                     NOT NULL,
  TRANSFERENCIASOLD  NUMBER                     NOT NULL,
  FRECUENTESOLD      NUMBER                     NOT NULL,
  MOVIMIENTOS        NUMBER                     NOT NULL,
  TRANSFERENCIAS     NUMBER                     NOT NULL,
  FRECUENTES         NUMBER                     NOT NULL,
  IP                 VARCHAR2(30 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_OPERACIONES
(
  CLIENTE         INTEGER                       NOT NULL,
  OPER_PLANEADAS  INTEGER                       DEFAULT 0                     NOT NULL,
  OPERACION       VARCHAR2(100 BYTE)            NOT NULL,
  SEMANA          INTEGER                       NOT NULL,
  ANIO            INTEGER                       NOT NULL,
  IMPOR_PLANEADO  INTEGER                       DEFAULT 0                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_PAGO_TAZ
(
  NUM_CLIENTE     INTEGER                       NOT NULL,
  NOM_ORIGEN      VARCHAR2(50 BYTE)             NOT NULL,
  NUM_TAZ         VARCHAR2(20 BYTE)             NOT NULL,
  NOM_DESTINO     VARCHAR2(50 BYTE),
  TIPO_PAGO       INTEGER                       NOT NULL,
  REFERENCIA      VARCHAR2(80 BYTE),
  PAIS            INTEGER,
  CANAL           INTEGER,
  SUCURSAL        INTEGER,
  FOLIO           INTEGER,
  MONTO           NUMBER(12,2),
  FECHA_PAGO      DATE                          DEFAULT SYSDATE               NOT NULL,
  TIENDA_DES      INTEGER,
  CANAL_DES       INTEGER,
  TIENDA_ORI      INTEGER,
  CANAL_ORI       INTEGER,
  FOLIO_OPE_ORI   INTEGER,
  NUM_RETEN       INTEGER                       NOT NULL,
  CUENTA_CARGO    VARCHAR2(20 BYTE)             NOT NULL,
  FOLIO_ABONO     VARCHAR2(20 BYTE),
  FOLIO_SERVICIO  VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_PARAMETROS
(
  ID           VARCHAR2(20 BYTE)                NOT NULL,
  VALOR        VARCHAR2(255 BYTE)               NOT NULL,
  DESCRIPCION  VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_RECORDATORIOS
(
  ID                NUMBER,
  CLIENTE           VARCHAR2(10 BYTE),
  TITULO            VARCHAR2(100 BYTE)          NOT NULL,
  FECHA             DATE                        DEFAULT sysdate               NOT NULL,
  FECHAFIN          DATE                        NOT NULL,
  TIPORECORDATORIO  VARCHAR2(6 BYTE)            NOT NULL,
  ACTIVO            NUMBER                      NOT NULL,
  TIPOREPETICION    NUMBER                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_REF_TEF
(
  CLIENTE_ID      NUMBER,
  NOREFERENCIA    VARCHAR2(18 BYTE),
  FECHAOPERACION  DATE,
  STATUS          INTEGER,
  CUENTA_HASH     CHAR(28 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_RFC
(
  ID_EBANKING_RFC  NUMBER                       NOT NULL,
  USER_ID          VARCHAR2(256 BYTE)           NOT NULL,
  RFC              VARCHAR2(256 BYTE)           NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_RMASMS
(
  SMSKEY               NUMBER(10)               NOT NULL,
  ALNOVA_CLIENT        VARCHAR2(8 BYTE),
  ACCOUNT_NUMBER       VARCHAR2(20 BYTE),
  PHONE                VARCHAR2(10 BYTE),
  CARRIER_ID           NUMBER(2)                NOT NULL,
  ACTIVATION_DATE      DATE,
  CANCEL_DATE          DATE,
  STATUS               VARCHAR2(1 BYTE),
  SISTEMA              VARCHAR2(25 BYTE),
  PAIS                 VARCHAR2(3 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_CONFIRM
(
  IDUSER                      NUMBER(10)        DEFAULT null                  NOT NULL,
  MAX_TERCEROS                NUMBER            DEFAULT null,
  MAX_INTERBANCARIO           NUMBER            DEFAULT null,
  MAX_PAGOS                   NUMBER            DEFAULT null,
  MAX_TIEMPOAIRE              NUMBER            DEFAULT null,
  MAX_DIARIO                  NUMBER            DEFAULT null,
  PWD_TRASPASOS               VARCHAR2(40 BYTE) DEFAULT null,
  PWD_SERVICIOS               VARCHAR2(40 BYTE) DEFAULT null,
  PWD_TIEMPOAIRE              VARCHAR2(40 BYTE) DEFAULT null,
  PWD_CAMBIONIVEL             VARCHAR2(40 BYTE) DEFAULT null,
  PWD_CUENTASOCULTAS          VARCHAR2(40 BYTE) DEFAULT null,
  PWD_TEF                     VARCHAR2(40 BYTE) DEFAULT null,
  PWD_SPEUA                   VARCHAR2(40 BYTE) DEFAULT null,
  SECURITY_LEVEL              NUMBER            DEFAULT 1                     NOT NULL,
  ESTATUS_PWD_TRASPASOS       NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_SERVICIOS       NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_TIEMPOAIRE      NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_CAMBIONIVEL     NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_CUENTASOCULTAS  NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_TEF             NUMBER(1)         DEFAULT 0,
  ESTATUS_PWD_SPEUA           NUMBER(1)         DEFAULT 0,
  ADVANCEDSERVICE             NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_CUENTAS
(
  IDUSER        NUMBER(10)                      DEFAULT 0,
  CUENTA        VARCHAR2(20 BYTE)               DEFAULT 0                     NOT NULL,
  VISIBILIDAD   NUMBER                          DEFAULT 0                     NOT NULL,
  PORCONFIRMAR  NUMBER                          DEFAULT -1                    NOT NULL,
  TIPO          NUMBER                          NOT NULL,
  DESCRIPCION   VARCHAR2(40 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_CUENTAS_AUX
(
  IDUSER        NUMBER(10)                      DEFAULT 0,
  VISIBILIDAD   NUMBER                          DEFAULT 0                     NOT NULL,
  PORCONFIRMAR  NUMBER                          DEFAULT -1                    NOT NULL,
  TIPO          NUMBER                          NOT NULL,
  CUENTA        VARCHAR2(50 BYTE)               DEFAULT 0                     NOT NULL,
  DESCRIPCION   VARCHAR2(40 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_MAX_AMOUNT
(
  IDUSER               NUMBER(10)               DEFAULT null                  NOT NULL,
  TERCEROS             NUMBER                   DEFAULT null,
  INTERBANCARIO        NUMBER                   DEFAULT null,
  PAGOS                NUMBER                   DEFAULT null,
  TIEMPOAIRE           NUMBER                   DEFAULT null,
  DIARIO               NUMBER                   DEFAULT null,
  MOV_TERCEROS         NUMBER                   DEFAULT null,
  MOV_INTER            NUMBER                   DEFAULT null,
  MOV_PAGOS            NUMBER                   DEFAULT null,
  MOV_TIEMPOAIRE       NUMBER                   DEFAULT null,
  MOV_DIARIO           NUMBER                   DEFAULT null,
  ULTIMO_MOVIMIENTO    DATE,
  INTERNACIONALES      NUMBER                   DEFAULT null,
  MOV_INTERNACIONALES  NUMBER                   DEFAULT null
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_MAX_AMOUNT_H
(
  IDUSER           NUMBER(10)                   DEFAULT null                  NOT NULL,
  TERCEROS         NUMBER                       DEFAULT null,
  INTERBANCARIO    NUMBER                       DEFAULT null,
  PAGOS            NUMBER                       DEFAULT null,
  INTERNACIONALES  NUMBER                       DEFAULT null
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SECURITY_PWD
(
  IDUSER                  NUMBER(10)            DEFAULT 0                     NOT NULL,
  TRASPASOS               VARCHAR2(40 BYTE)     DEFAULT null,
  SERVICIOS               VARCHAR2(40 BYTE)     DEFAULT null,
  TIEMPOAIRE              VARCHAR2(40 BYTE)     DEFAULT null,
  CAMBIONIVEL             VARCHAR2(40 BYTE)     DEFAULT null,
  CUENTASOCULTAS          VARCHAR2(40 BYTE)     DEFAULT null,
  TEF                     VARCHAR2(40 BYTE)     DEFAULT null,
  SPEUA                   VARCHAR2(40 BYTE)     DEFAULT null,
  ESTATUS_TRASPASOS       NUMBER(1)             DEFAULT 0,
  ESTATUS_SERVICIOS       NUMBER(1)             DEFAULT 0,
  ESTATUS_CAMBIONIVEL     NUMBER(1)             DEFAULT 0,
  ESTATUS_CUENTASOCULTAS  NUMBER(1)             DEFAULT 0,
  ESTATUS_TEF             NUMBER(1)             DEFAULT 0,
  ESTATUS_SPEUA           NUMBER(1)             DEFAULT 0,
  ESTATUS_TIEMPOAIRE      NUMBER(1)             DEFAULT 0
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SERVICE
(
  ID           NUMBER                           NOT NULL,
  DESCRIPTION  VARCHAR2(50 BYTE)                NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SESSION
(
  ID             NUMBER(20)                     NOT NULL,
  ALIAS          VARCHAR2(32 BYTE)              NOT NULL,
  SESSION_START  DATE                           NOT NULL,
  SESSION_END    DATE,
  ACTIVE         NUMBER(1)                      NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SOLKITHUELLA
(
  NUM_CTE          VARCHAR2(20 BYTE)            NOT NULL,
  NOMBRE           VARCHAR2(50 BYTE),
  NUM_CTA_CARGO    VARCHAR2(20 BYTE),
  CALLE            VARCHAR2(30 BYTE),
  NUMEXT           VARCHAR2(6 BYTE),
  NUMINT           VARCHAR2(6 BYTE),
  COL              VARCHAR2(30 BYTE),
  CP               VARCHAR2(6 BYTE),
  DEL_MUNI         VARCHAR2(30 BYTE),
  EDO              VARCHAR2(30 BYTE),
  CALLE_DER        VARCHAR2(30 BYTE),
  CALLE_IZQ        VARCHAR2(30 BYTE),
  CALLE_FRE        VARCHAR2(30 BYTE),
  CALLE_ATR        VARCHAR2(30 BYTE),
  COMISION         NUMBER,
  IVA              NUMBER,
  REFERENCIA       VARCHAR2(20 BYTE)            NOT NULL,
  NUM_OPERACION    VARCHAR2(20 BYTE)            NOT NULL,
  FECHA_OPERACION  DATE                         DEFAULT SYSDATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SPEI_ALNOVA
(
  CODBANC  VARCHAR2(6 BYTE)                     NOT NULL,
  NOMBANC  VARCHAR2(100 BYTE)                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SPEI_BANKS
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(8 BYTE)                 NOT NULL,
  DESCRIPTION  VARCHAR2(64 BYTE)                NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_SUCURSALES
(
  SUCURSAL   VARCHAR2(6 BYTE)                   NOT NULL,
  NOMBRE     VARCHAR2(60 BYTE),
  DIRECCION  VARCHAR2(60 BYTE)                  NOT NULL,
  CP         VARCHAR2(6 BYTE)                   NOT NULL,
  CITY_CODE  VARCHAR2(6 BYTE)                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TARJETASNIP
(
  CLIENTE       VARCHAR2(10 BYTE),
  CUENTA        VARCHAR2(20 BYTE),
  PRODUCTO      VARCHAR2(5 BYTE)                NOT NULL,
  SUBPRODUCTO   VARCHAR2(5 BYTE)                NOT NULL,
  STATUS        NUMBER,
  FECHA_CAMBIO  DATE,
  NIP           NUMBER,
  TARJETA       NUMBER,
  NUMTARJETA    VARCHAR2(25 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TARJV_BITACORA
(
  ID             INTEGER                        NOT NULL,
  NUM_CLIENTE    INTEGER                        NOT NULL,
  TARJETA        VARCHAR2(20 BYTE)              NOT NULL,
  OPERACION      VARCHAR2(20 BYTE)              NOT NULL,
  FECHA_OPER     DATE                           DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIF  VARCHAR2(20 BYTE)              NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TASAS_IA
(
  SUBPRODUCTO  VARCHAR2(4 BYTE)                 NOT NULL,
  PRODUCTO     VARCHAR2(2 BYTE)                 NOT NULL,
  PLAZO        NUMBER(4)                        NOT NULL,
  TASA         FLOAT(4)                         NOT NULL,
  FECHA        DATE                             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TEF_ALNOVA
(
  ID      INTEGER                               NOT NULL,
  CODIGO  VARCHAR2(6 BYTE)                      NOT NULL,
  NOMBRE  VARCHAR2(50 BYTE)                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_COBRO
(
  NO_CTE            VARCHAR2(15 BYTE)           NOT NULL,
  NO_SERIE_TOKEN    VARCHAR2(20 BYTE)           NOT NULL,
  FECHA_ACTIVACION  DATE                        NOT NULL,
  FECHA_NEGACION    DATE,
  FECHA_ACEPTACION  DATE,
  STATUS            NUMBER                      NOT NULL,
  DESC_NEGACION     CLOB,
  CTA_DESTINO       VARCHAR2(20 BYTE)           NOT NULL,
  CTA_CARGO         VARCHAR2(20 BYTE)           NOT NULL,
  MONTO             NUMBER                      NOT NULL,
  MONTO_ALNOVA      VARCHAR2(6 BYTE)            NOT NULL,
  LAYOUT            VARCHAR2(88 BYTE),
  RESP              VARCHAR2(12 BYTE),
  FECHA_COBRO       DATE,
  SISTEMA           VARCHAR2(6 BYTE),
  IDPAIS            VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_HIST
(
  ID                    NUMBER,
  NUM_CLIENTE           NUMBER                  NOT NULL,
  NUM_SERIE_TOKEN       VARCHAR2(12 BYTE)       NOT NULL,
  ALIAS                 VARCHAR2(32 BYTE),
  FECHA_APLICACION      DATE                    NOT NULL,
  IP_SUCURSAL_TERMINAL  VARCHAR2(15 BYTE)       NOT NULL,
  OPERADOR              VARCHAR2(32 BYTE)       NOT NULL,
  SUCURSAL              VARCHAR2(32 BYTE)       NOT NULL,
  ACCION                NUMBER                  NOT NULL,
  SISTEMA               VARCHAR2(6 BYTE),
  IDPAIS                VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_PREVENCION
(
  ID                  NUMBER                    NOT NULL,
  TITULAR             VARCHAR2(100 BYTE)        NOT NULL,
  EMAIL               VARCHAR2(100 BYTE)        NOT NULL,
  IP                  VARCHAR2(15 BYTE)         NOT NULL,
  NUM_SERIE_TOKEN     VARCHAR2(10 BYTE)         NOT NULL,
  TEL_PARTICULAR      VARCHAR2(15 BYTE),
  TEL_CELULAR         VARCHAR2(15 BYTE),
  CARRIER_CEL         INTEGER                   DEFAULT 0                     NOT NULL,
  FEC_HORA_OPERACION  DATE                      DEFAULT SYSDATE               NOT NULL,
  NUM_CLIENTE         VARCHAR2(15 BYTE)         NOT NULL,
  ESTATUS             NUMBER                    NOT NULL,
  MOTIVO_PREV_FRAUDE  NUMBER,
  ALIAS               VARCHAR2(32 BYTE),
  FEC_PREV_FRAU       DATE,
  ID_USER_PREV_FRAU   VARCHAR2(32 BYTE),
  NUM_INTENTOS        NUMBER                    DEFAULT 0                     NOT NULL,
  OBSERVACION         VARCHAR2(200 BYTE),
  FEC_PRI_INTENTO     DATE,
  FEC_ULT_INTENTO     DATE,
  TIPO_OPERACION      NUMBER,
  SISTEMA             VARCHAR2(6 BYTE),
  IDPAIS              VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_SOLICITUD
(
  FOLIO_SOLICITUD          NUMBER(22),
  NUM_CTE                  VARCHAR2(20 BYTE),
  NOM_CTE                  VARCHAR2(50 BYTE),
  APE_PAT_CTE              VARCHAR2(50 BYTE),
  APE_MAT_CTE              VARCHAR2(50 BYTE),
  RFC_CTE                  VARCHAR2(13 BYTE),
  DIR_ENT                  VARCHAR2(60 BYTE),
  COL_ENT                  VARCHAR2(60 BYTE),
  CP_ENT                   VARCHAR2(5 BYTE),
  CIUDAD_ENT               VARCHAR2(100 BYTE),
  EDO_ENT                  VARCHAR2(100 BYTE),
  TEL_ENT                  VARCHAR2(15 BYTE),
  TEL_ADI_ENT              VARCHAR2(15 BYTE),
  PER_AUT1                 VARCHAR2(200 BYTE),
  PER_AUT2                 VARCHAR2(200 BYTE),
  PER_AUT3                 VARCHAR2(200 BYTE),
  FECHA_SOL_INTERNET       DATE,
  ESTATUS_SOL              NUMBER(22),
  NUM_PEDIDO_EKT           NUMBER(22),
  DIR_IP                   VARCHAR2(15 BYTE),
  FECHA_SOL_PREVFRA        DATE,
  ID_USUARIO_PREV_FRAUDES  VARCHAR2(20 BYTE),
  EMAIL                    VARCHAR2(50 BYTE),
  ALIAS                    VARCHAR2(30 BYTE),
  CTA_CARGO                VARCHAR2(20 BYTE),
  TIPO_CTA_CARGO           VARCHAR2(50 BYTE),
  SKU1                     VARCHAR2(10 BYTE),
  SKU2                     VARCHAR2(10 BYTE),
  CANT_SKU1                NUMBER(22),
  CANT_SKU2                NUMBER(22),
  COSTO_ENVIO              NUMBER(22),
  ID_MENSAJERIA            VARCHAR2(10 BYTE),
  DES_MENSAJERIA           VARCHAR2(30 BYTE),
  NO_INTENTOS              NUMBER(22),
  OBS                      VARCHAR2(200 BYTE),
  PRIMER_INTENTO           DATE,
  ULTIMO_INTENTO           DATE,
  IMPORTE                  FLOAT(126),
  RETENCION_SOLICITUD      VARCHAR2(20 BYTE),
  SISTEMA                  VARCHAR2(6 BYTE),
  IDPAIS                   VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_SOL_PAGO
(
  FOLIO_SOLICITUD     NUMBER(22),
  NUM_CTE             VARCHAR2(15 BYTE),
  CTA_CARGO           VARCHAR2(30 BYTE),
  REF_CTA_CARGO       VARCHAR2(50 BYTE),
  TIT_CTA_CARGO       VARCHAR2(100 BYTE),
  CUENTA_DESTINO      VARCHAR2(30 BYTE),
  REF_CUENTA_DESTINO  VARCHAR2(50 BYTE),
  TIT_CTA_DESTINO     VARCHAR2(100 BYTE),
  REQUES              VARCHAR2(2000 BYTE),
  FECHA_SOLICITUD     DATE,
  ESTATUS_PAGO        NUMBER(30),
  FECHA_PAGO          DATE,
  RETENCION_PAGOS     VARCHAR2(20 BYTE),
  IMPORTE             FLOAT(126),
  SISTEMA             VARCHAR2(6 BYTE),
  IDPAIS              VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_STATUS
(
  ID                  NUMBER                    NOT NULL,
  NUM_CLIENTE         VARCHAR2(15 BYTE)         NOT NULL,
  NUM_SERIE_TOKEN     VARCHAR2(12 BYTE)         NOT NULL,
  STATUS              NUMBER                    NOT NULL,
  FECHA_MODIFICACION  DATE                      DEFAULT Sysdate               NOT NULL,
  FECHA_ACTIVACION    DATE                      DEFAULT Sysdate               NOT NULL,
  SISTEMA             VARCHAR2(6 BYTE),
  IDPAIS              VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TOKEN_TARJETA_AG12
(
  ID_TARJETA           NUMBER(5)                NOT NULL,
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  STATUS               CHAR(1 BYTE)             NOT NULL,
  DESFASE              NUMBER                   NOT NULL,
  SINCRONIZACIONES     NUMBER                   NOT NULL,
  FECHA_ACTIVACION     DATE                     NOT NULL,
  FECHA_MODIF          DATE,
  SISTEMA              VARCHAR2(25 BYTE),
  PAIS                 VARCHAR2(3 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TX_PLACES
(
  ID           INTEGER                          NOT NULL,
  CODE         VARCHAR2(8 BYTE)                 NOT NULL,
  DESCRIPTION  VARCHAR2(32 BYTE)                NOT NULL,
  PLACE2STATE  INTEGER                          NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_TX_STATES
(
  ID           INTEGER                          NOT NULL,
  DESCRIPTION  VARCHAR2(64 BYTE)                NOT NULL
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER
(
  ID                        NUMBER(10)          NOT NULL,
  ACTIVATION                DATE,
  ACTIVE                    NUMBER(1),
  ANSWER                    VARCHAR2(48 BYTE),
  CELLULAR                  VARCHAR2(16 BYTE),
  EMAIL                     VARCHAR2(40 BYTE),
  QUESTION                  VARCHAR2(48 BYTE),
  USER2CELLCOMPANY          NUMBER,
  ADVANCEDSERVICE           NUMBER,
  SECUREDATA                VARCHAR2(48 BYTE),
  ACTIVATIONTYPE            NUMBER(4),
  SECURITY_LEVEL            INTEGER             DEFAULT 1,
  STATUSNS                  NUMBER,
  CODIGONS                  VARCHAR2(48 BYTE),
  CONFIRMNS                 DATE,
  STATUS_CONT_TRAN          NUMBER(1)           DEFAULT 0,
  MAIL_RECEIVE              NUMBER(1)           DEFAULT 1,
  TRACKING                  NUMBER(1)           DEFAULT 0,
  PWD_CONFIRM               VARCHAR2(30 BYTE),
  PWD_BANCA_TEL             VARCHAR2(30 BYTE),
  PWD_CHANGE_DATE           DATE,
  PWD_STATUS                NUMBER(1),
  PWD_CONFIRM_CHANGE_DATE   DATE,
  BIOMETRICO                VARCHAR2(15 BYTE),
  TELEFONO_OFICINA          VARCHAR2(25 BYTE),
  OLD_ADVANCEDSERVICE       NUMBER,
  ULT_ACCESO                DATE,
  ULT_IP                    VARCHAR2(20 BYTE),
  BAN_MAIL                  INTEGER,
  TOKEN                     NUMBER,
  FECHA_CAMBIO_STATUS_BAJA  DATE,
  STATUS_BAJA               NUMBER,
  USER_STATUS               NUMBER(3)           DEFAULT -1,
  FECHA_CAMBIO_STATUS       DATE                DEFAULT SYSDATE,
  RFC_CLIENTE               VARCHAR2(15 BYTE),
  NIP_RED_MOVIL             VARCHAR2(50 BYTE),
  FECHA_MODIFICACION        DATE,
  USUARIO_MODIFICA          VARCHAR2(30 BYTE),
  OBSERVACIONES             VARCHAR2(500 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USERX
(
  ID                        NUMBER(10),
  ACTIVATION                DATE,
  ACTIVE                    NUMBER(1),
  ANSWER                    VARCHAR2(48 BYTE),
  CELLULAR                  VARCHAR2(16 BYTE),
  EMAIL                     VARCHAR2(50 BYTE),
  QUESTION                  VARCHAR2(48 BYTE),
  USER2CELLCOMPANY          NUMBER,
  ADVANCEDSERVICE           NUMBER,
  SECUREDATA                VARCHAR2(48 BYTE),
  ACTIVATIONTYPE            NUMBER(4),
  SECURITY_LEVEL            NUMBER(38)          DEFAULT 1,
  STATUSNS                  NUMBER,
  CODIGONS                  VARCHAR2(48 BYTE),
  CONFIRMNS                 DATE,
  STATUS_CONT_TRAN          NUMBER(1)           DEFAULT 0,
  MAIL_RECEIVE              NUMBER(1)           DEFAULT 1,
  TRACKING                  NUMBER(1)           DEFAULT 0,
  PWD_CONFIRM               VARCHAR2(30 BYTE),
  PWD_BANCA_TEL             VARCHAR2(30 BYTE),
  PWD_CHANGE_DATE           DATE,
  PWD_STATUS                NUMBER(1),
  PWD_CONFIRM_CHANGE_DATE   DATE,
  BIOMETRICO                VARCHAR2(15 BYTE),
  TELEFONO_OFICINA          VARCHAR2(25 BYTE),
  OLD_ADVANCEDSERVICE       NUMBER,
  ULT_ACCESO                DATE,
  FECHA_CAMBIO_STATUS_BAJA  DATE,
  STATUS_BAJA               NUMBER,
  TOKEN                     NUMBER(38)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_ACTIVATION
(
  ID            NUMBER,
  SUC_IP        VARCHAR2(40 BYTE),
  SUC_OPERADOR  VARCHAR2(20 BYTE),
  SUC_NOMBRE    VARCHAR2(15 BYTE),
  FECHA         DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_BACK
(
  ID                        NUMBER(10)          NOT NULL,
  ACTIVATION                DATE                NOT NULL,
  ACTIVE                    NUMBER(1)           NOT NULL,
  ANSWER                    VARCHAR2(48 BYTE)   NOT NULL,
  CELLULAR                  VARCHAR2(16 BYTE),
  EMAIL                     VARCHAR2(100 BYTE),
  QUESTION                  VARCHAR2(48 BYTE)   NOT NULL,
  USER2CELLCOMPANY          NUMBER              NOT NULL,
  ADVANCEDSERVICE           NUMBER,
  SECUREDATA                VARCHAR2(48 BYTE),
  ACTIVATIONTYPE            NUMBER(4),
  SECURITY_LEVEL            INTEGER             DEFAULT 1,
  STATUSNS                  NUMBER,
  CODIGONS                  VARCHAR2(48 BYTE),
  CONFIRMNS                 DATE,
  STATUS_CONT_TRAN          NUMBER(1)           DEFAULT 0,
  MAIL_RECEIVE              NUMBER(1)           DEFAULT 1,
  TRACKING                  NUMBER(1)           DEFAULT 0,
  PWD_CONFIRM               VARCHAR2(30 BYTE),
  PWD_BANCA_TEL             VARCHAR2(30 BYTE),
  PWD_CHANGE_DATE           DATE,
  PWD_STATUS                NUMBER(1),
  PWD_CONFIRM_CHANGE_DATE   DATE,
  BIOMETRICO                VARCHAR2(15 BYTE),
  TELEFONO_OFICINA          VARCHAR2(25 BYTE),
  OLD_ADVANCEDSERVICE       NUMBER,
  ULT_ACCESO                DATE,
  ULT_IP                    VARCHAR2(20 BYTE),
  BAN_MAIL                  INTEGER,
  TOKEN                     NUMBER,
  FECHA_CAMBIO_STATUS_BAJA  DATE,
  STATUS_BAJA               NUMBER,
  USER_STATUS               NUMBER(3)           DEFAULT -1,
  FECHA_CAMBIO_STATUS       DATE                DEFAULT SYSDATE,
  RFC_CLIENTE               VARCHAR2(15 BYTE),
  NIP_RED_MOVIL             VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_CERT_VIP
(
  ID                   NUMBER(10)               NOT NULL,
  MONTO_MAX            NUMBER(20)               NOT NULL,
  FECHA_INICIO         DATE                     NOT NULL,
  FECHA_FIN            DATE                     NOT NULL,
  FECHA_CAMBIO_STATUS  DATE                     DEFAULT SYSDATE,
  USER_CAMBIO          VARCHAR2(100 BYTE),
  SISTEMA              VARCHAR2(20 BYTE),
  VIP                  VARCHAR2(1 BYTE),
  CUENTA               VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_OLD
(
  USER_ID               NUMBER,
  CELLULAR_OLD          VARCHAR2(16 BYTE),
  CELLULAR_CHANGE_DATE  DATE,
  TELEFONO_ALTERNO_OLD  VARCHAR2(16 BYTE),
  ALTERNO_CHANGE_DATE   DATE,
  EMAIL_OLD             VARCHAR2(50 BYTE),
  EMAIL_CHANGE_DATE     DATE,
  QUESTION_CHANGE_DATE  DATE,
  ANSWER_CHANGE_DATE    DATE,
  IP                    VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_SESSION
(
  ID              NUMBER(20)                    NOT NULL,
  SESSION_ACTIVA  VARCHAR2(50 BYTE)             NOT NULL,
  SESSION_START   DATE,
  IP              VARCHAR2(15 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_STATUS
(
  ID           NUMBER(3)                        NOT NULL,
  DESCRIPCION  VARCHAR2(255 BYTE)               NOT NULL,
  MONTO_MAX    NUMBER(20)                       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_STATUS_H
(
  ID                NUMBER(10)                  NOT NULL,
  STATUS_ACTUAL     NUMBER(3)                   NOT NULL,
  STATUS_NUEVO      NUMBER(3)                   NOT NULL,
  MONTO_MAX_ACTUAL  NUMBER(20)                  NOT NULL,
  MONTO_MAX_NUEVO   NUMBER(20)                  NOT NULL,
  FECHA_CAMBIO      DATE                        DEFAULT SYSDATE,
  IP                VARCHAR2(20 BYTE)           NOT NULL,
  SISTEMA           VARCHAR2(10 BYTE)           NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_USER_TRACKING
(
  NUMERO_CLIENTE  NUMBER                        NOT NULL,
  FECHA           DATE                          DEFAULT SYSDATE               NOT NULL,
  DESCRIPCION     VARCHAR2(100 BYTE),
  SISTEMA         VARCHAR2(10 BYTE),
  ALIAS           VARCHAR2(100 BYTE),
  ESTATUS         INTEGER,
  USR_PREV        VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANKING_ZIP_CODE
(
  COD_POS  VARCHAR2(20 BYTE)                    NOT NULL,
  LOWZIP   INTEGER                              NOT NULL,
  UPZIP    INTEGER                              NOT NULL,
  CIUDAD   VARCHAR2(80 BYTE)                    NOT NULL,
  IATA     VARCHAR2(3 BYTE),
  SERV     VARCHAR2(20 BYTE),
  CARGO    VARCHAR2(20 BYTE),
  FREC     VARCHAR2(20 BYTE),
  ROTULO   VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EBANK_ENCUESTAS
(
  ID_CONSECUTIVO       INTEGER                  NOT NULL,
  ID_ENCUESTA          VARCHAR2(150 BYTE)       NOT NULL,
  ID_CLI_ALNOVA        VARCHAR2(50 BYTE)        NOT NULL,
  NUM_PREGUNTA         NUMBER(4,2)              NOT NULL,
  RESPUESTA            VARCHAR2(200 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(50 BYTE)        DEFAULT 'EBANKING'            NOT NULL,
  SISTEMA              VARCHAR2(50 BYTE)        DEFAULT 'EBANKING'            NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         DEFAULT 'MX'
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EDCULTURALES
(
  USER_ID               NUMBER(8)               NOT NULL,
  REFERENCIA            VARCHAR2(20 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EDITORIALES
(
  CODIGO  NUMBER(3),
  NOMBRE  VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE EJB_CORE
(
  EJB                  VARCHAR2(60 BYTE)        NOT NULL,
  DESCRIPCION          VARCHAR2(80 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ENCUESTA_DESPACHO
(
  ID_ENCUESTA         INTEGER                   NOT NULL,
  NOMBRE_DESPACHO     VARCHAR2(50 BYTE)         NOT NULL,
  FECHA_INI_ENCUESTA  DATE                      NOT NULL,
  FECHA_FIN_ENCUESTA  DATE                      NOT NULL,
  DESCRIPCION         VARCHAR2(200 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ENCUESTA_EMPLEADO
(
  ID_ENCUESTA       INTEGER                     NOT NULL,
  NUM_EMPLEADO      VARCHAR2(20 BYTE)           NOT NULL,
  NOMBRE_EMPLEADO   VARCHAR2(60 BYTE)           NOT NULL,
  FECHA_EVALUACION  DATE                        DEFAULT SYSDATE               NOT NULL,
  PREGUNTA1         INTEGER,
  PREGUNTA2         INTEGER,
  PREGUNTA3         INTEGER,
  PREGUNTA4         INTEGER,
  P5_TIPO_ATENCION  INTEGER,
  P5_TIEMPO_RESP    INTEGER,
  P5_ENTREGA_SERV   INTEGER,
  P5_ACTITUD_SERV   INTEGER,
  P5_SEGUIMIENTO    INTEGER,
  P5_COMUNICACION   INTEGER,
  PREGUNTA6         VARCHAR2(6 BYTE),
  PREGUNTA7         VARCHAR2(500 BYTE),
  DESC_PREG1        VARCHAR2(500 BYTE),
  DESC_PREG6        VARCHAR2(500 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ENCUESTA_PBAZ
(
  ID_ENCUESTA     INTEGER                       NOT NULL,
  ID_CLI_ALNOVA   VARCHAR2(50 BYTE)             NOT NULL,
  RESP_1          INTEGER                       NOT NULL,
  RESP_2          INTEGER                       NOT NULL,
  RESP_3          INTEGER                       NOT NULL,
  RESP_4          INTEGER                       NOT NULL,
  RESP_5          INTEGER                       NOT NULL,
  COMENTARIOS     VARCHAR2(1000 BYTE),
  FECHA           DATE                          NOT NULL,
  RESP_4CUAL      VARCHAR2(150 BYTE),
  RESP_4_1        INTEGER,
  RESP_4_1PORQUE  VARCHAR2(150 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ERROR_APERTURA
(
  USER_ID          NUMBER(10)                   NOT NULL,
  NUM_CUENTA       VARCHAR2(30 BYTE)            NOT NULL,
  TIPO_APERTURA    CHAR(1 BYTE)                 NOT NULL,
  TARJETA_VIRTUAL  VARCHAR2(30 BYTE),
  FECHA            DATE                         NOT NULL,
  EXCEPCION        CLOB
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ESTADISTICAS
(
  PAGINA       VARCHAR2(100 BYTE)               NOT NULL,
  CONTEO       NUMBER(20)                       NOT NULL,
  FECHA        DATE                             DEFAULT SYSDATE               NOT NULL,
  AUTENTICADO  NUMBER(1)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ESTADISTICAS_AFORE
(
  PAGINA       VARCHAR2(40 BYTE)                NOT NULL,
  CONTEO       NUMBER(20)                       NOT NULL,
  FECHA        DATE                             DEFAULT SYSDATE               NOT NULL,
  AUTENTICADO  NUMBER(1)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FAKE_TOKEN_DISP
(
  ID_ACT_DISPOSITIVO     NUMBER(7)              NOT NULL,
  ID_ALNOVA              VARCHAR2(8 BYTE)       NOT NULL,
  SEMILLA                VARCHAR2(50 BYTE),
  ESTADO                 CHAR(1 BYTE)           NOT NULL,
  DESFASE                NUMBER,
  SINCRONIZACIONES       NUMBER                 NOT NULL,
  FECHA_SOLICITUD        DATE                   NOT NULL,
  FECHA_ACTIVACION       DATE,
  SISTEMA                VARCHAR2(25 BYTE),
  PAIS                   VARCHAR2(3 BYTE),
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  USUARIO_MODIFICO       VARCHAR2(30 BYTE)      NOT NULL,
  CONTRATO_FIRMADO       CHAR(1 BYTE)           DEFAULT 0,
  ULTIMA_SINCRONIZACION  DATE                   NOT NULL,
  CORREO_ELECTONICO      VARCHAR2(40 BYTE),
  NUM_MODELO             VARCHAR2(20 BYTE)      DEFAULT '100'                 NOT NULL,
  NUM_TELEFONO           VARCHAR2(15 BYTE),
  SOPERATIVO             VARCHAR2(25 BYTE)      DEFAULT 'iOS, Android, Bberry' NOT NULL,
  VERSION                VARCHAR2(8 BYTE)       DEFAULT '1.0'                 NOT NULL,
  TIPO                   NUMBER                 DEFAULT 1                     NOT NULL,
  SEM_ENCRIPTADA         VARCHAR2(132 BYTE)     DEFAULT '0'
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FBLIKE
(
  ID_ALNOVA           NUMBER(15)                NOT NULL,
  NUM_CTA             VARCHAR2(30 BYTE),
  EMPRESA             VARCHAR2(30 BYTE)         NOT NULL,
  PAIS                VARCHAR2(30 BYTE)         NOT NULL,
  SISTEMA             VARCHAR2(30 BYTE)         NOT NULL,
  FECHA_ACTIVACION    DATE                      NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_BENEFICIARIOS
(
  ID                   NUMBER                   NOT NULL,
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  PRIMER_NOMBRE        VARCHAR2(35 BYTE)        NOT NULL,
  SEGUNDO_NOMBRE       VARCHAR2(35 BYTE),
  AP_PATERNO           VARCHAR2(35 BYTE)        NOT NULL,
  AP_MATERNO           VARCHAR2(35 BYTE),
  PARENTESCO           VARCHAR2(30 BYTE),
  EDAD                 NUMBER,
  PORCENTAJE           NUMBER,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_BOLETOS
(
  ID_SORTEO            NUMBER                   NOT NULL,
  ID_PARTICIPANTE      VARCHAR2(8 BYTE)         NOT NULL,
  FECHA                DATE                     NOT NULL,
  BOLETO_INI           NUMBER                   NOT NULL,
  BOLETO_FIN           NUMBER                   NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_CANDIDATOS
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  NO_EMPLEADO          NUMBER                   NOT NULL,
  CTA_NOMINA           VARCHAR2(20 BYTE)        NOT NULL,
  NOMBRE               VARCHAR2(35 BYTE)        NOT NULL,
  AP_PATERNO           VARCHAR2(35 BYTE),
  AP_MATERNO           VARCHAR2(35 BYTE),
  FECHA_INGRESO        DATE                     NOT NULL,
  UNIDAD_NEGOCIO       VARCHAR2(8 BYTE),
  MONTO_CREDITO        NUMBER,
  PERIODO_NOMINA       VARCHAR2(1 BYTE)         NOT NULL,
  CUENTA_FIAR          VARCHAR2(20 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  CUENTA_FIARPLUS      VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_CLIENTES
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  NO_EMPLEADO          NUMBER                   NOT NULL,
  CTA_NOMINA           VARCHAR2(20 BYTE)        NOT NULL,
  NOMBRE               VARCHAR2(35 BYTE)        NOT NULL,
  AP_PATERNO           VARCHAR2(35 BYTE),
  AP_MATERNO           VARCHAR2(35 BYTE),
  FECHA_INGRESO        DATE                     NOT NULL,
  UNIDAD_NEGOCIO       VARCHAR2(8 BYTE),
  MONTO_CREDITO        NUMBER,
  PERIODO_NOMINA       VARCHAR2(1 BYTE)         NOT NULL,
  CUENTA_FIAR          VARCHAR2(20 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  CUENTA_FIARPLUS      VARCHAR2(20 BYTE),
  MODULO_FIAR          INTEGER                  DEFAULT 0,
  MONTO_INSOLUTO       NUMBER                   DEFAULT 0
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_CLIENTES_RESP
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  NO_EMPLEADO          NUMBER                   NOT NULL,
  CTA_NOMINA           VARCHAR2(20 BYTE)        NOT NULL,
  NOMBRE               VARCHAR2(35 BYTE)        NOT NULL,
  AP_PATERNO           VARCHAR2(35 BYTE),
  AP_MATERNO           VARCHAR2(35 BYTE),
  FECHA_INGRESO        DATE                     NOT NULL,
  UNIDAD_NEGOCIO       VARCHAR2(8 BYTE),
  MONTO_CREDITO        NUMBER,
  PERIODO_NOMINA       VARCHAR2(1 BYTE)         NOT NULL,
  CUENTA_FIAR          VARCHAR2(20 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  CUENTA_FIARPLUS      VARCHAR2(20 BYTE),
  MODULO_FIAR          INTEGER                  DEFAULT 0
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_CONTRATOS
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  IDCONTRATO           NUMBER                   NOT NULL,
  CONTRATO             BLOB,
  FECHA_FIRMA          DATE,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  FIRMA1               VARCHAR2(4000 BYTE),
  FIRMA2               VARCHAR2(4000 BYTE),
  FIRMA3               VARCHAR2(4000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_DATOS_SOLICITUD
(
  CTE_ALNOVA                 VARCHAR2(8 BYTE)   NOT NULL,
  RFC                        VARCHAR2(8 BYTE),
  DOMICILIO                  VARCHAR2(100 BYTE),
  CURP                       VARCHAR2(20 BYTE),
  ID_SOLICITUD_MESA_CONTROL  VARCHAR2(20 BYTE),
  ULTIMA_MODIFICACION        DATE               NOT NULL,
  USUARIO_MODIFICO           VARCHAR2(30 BYTE)  NOT NULL,
  ESTADO                     VARCHAR2(2 BYTE),
  MUNICIPIO                  VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_PARTICIPANTES_TEMP
(
  ID_TEMP          INTEGER,
  ID_PARTICIPANTE  VARCHAR2(8 BYTE),
  MONTO_CREDITO    NUMBER,
  RANGO_INICIAL    NUMBER,
  RANGO_FINAL      NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_PARTICIPE
(
  ID_SORTEO            NUMBER                   NOT NULL,
  ID_PARTICIPANTE      VARCHAR2(8 BYTE)         NOT NULL,
  ID_PREMIO            NUMBER                   NOT NULL,
  FECHA_SELECCION      DATE                     NOT NULL,
  BOLETO_PREMIADO      NUMBER                   NOT NULL,
  STATUS               VARCHAR2(2 BYTE)         NOT NULL,
  FECHA_INICIO         DATE                     NOT NULL,
  FECHA_FIN            DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  ID_RESPUESTA_1       NUMBER,
  ID_RESPUESTA_2       NUMBER,
  ID_RESPUESTA_3       NUMBER,
  ID_PREGUNTA_1        NUMBER,
  ID_PREGUNTA_2        NUMBER,
  ID_PREGUNTA_3        NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_PREGUNTAS
(
  ID_PREGUNTA          NUMBER                   NOT NULL,
  PREGUNTA             VARCHAR2(700 BYTE)       NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_PREMIO
(
  ID_SORTEO            NUMBER                   NOT NULL,
  ID_PREMIO            NUMBER                   NOT NULL,
  MONTO                NUMBER                   NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_REGISTRO
(
  ID_REGISTRO          INTEGER                  NOT NULL,
  NUM_EMPLEADO         NVARCHAR2(8)             NOT NULL,
  CTA_NOMINA           NVARCHAR2(15)            NOT NULL,
  HUELLA_EMPLEADO      CLOB,
  ESTATUS_REGISTRO     VARCHAR2(5 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_RESPUESTAS
(
  ID_RESPUESTA         NUMBER                   NOT NULL,
  ID_PREGUNTA          NUMBER                   NOT NULL,
  RESPUESTA            VARCHAR2(500 BYTE)       NOT NULL,
  CORRECTA             VARCHAR2(2 BYTE)         NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_SORTEO
(
  ID_SORTEO            NUMBER                   NOT NULL,
  NUMERO_DIAS          NUMBER                   NOT NULL,
  STATUS               VARCHAR2(2 BYTE)         NOT NULL,
  FECHA_SORTEO         DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  TOTAL_BOLETOS        NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_STATUS_CLIENTES
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  STATUS               VARCHAR2(3 BYTE)         NOT NULL,
  FECHA_AFILIACION     DATE,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_STATUS_CLIENTES_RESP
(
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  STATUS               VARCHAR2(3 BYTE)         NOT NULL,
  FECHA_AFILIACION     DATE,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_TRACE
(
  ID                   NUMBER                   NOT NULL,
  CTE_ALNOVA           VARCHAR2(8 BYTE)         NOT NULL,
  PASO                 VARCHAR2(2 BYTE)         NOT NULL,
  REQUEST              VARCHAR2(300 BYTE)       NOT NULL,
  RESPONSE             VARCHAR2(300 BYTE)       NOT NULL,
  FECHA                DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIAR_USR_ADMON
(
  ID_USUARIO           NUMBER                   NOT NULL,
  NOM_USUARIO          VARCHAR2(200 BYTE)       NOT NULL,
  PASSWORD             VARCHAR2(300 BYTE)       NOT NULL,
  NOM_COMPLETO         VARCHAR2(200 BYTE)       NOT NULL,
  PRIVILEGIOS          VARCHAR2(30 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FIRMA_EMISORES
(
  ID                  INTEGER                   NOT NULL,
  ID_SERVICIO         VARCHAR2(5 BYTE)          NOT NULL,
  CLIENTE_ALNOVA      VARCHAR2(20 BYTE)         NOT NULL,
  FECHA_ACTIVACION    DATE                      NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIOS_MODIFICO   VARCHAR2(30 BYTE)         NOT NULL,
  SISTEMA             VARCHAR2(25 BYTE)         NOT NULL,
  PAIS                VARCHAR2(3 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FI_BENEFICIARIO
(
  FI_CTE_ALNOVA  VARCHAR2(100 BYTE),
  FI_NOMBRE1     VARCHAR2(100 BYTE),
  FI_NOMBRE2     VARCHAR2(100 BYTE),
  FI_APATERNO    VARCHAR2(100 BYTE),
  FI_AMATERNO    VARCHAR2(100 BYTE),
  FI_PARENTESCO  VARCHAR2(100 BYTE),
  FI_EDAD        VARCHAR2(100 BYTE),
  FI_PORC_PART   VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FI_BENEFICIARIOS_ACTUALES
(
  FBA_CTE_ALNOVA              VARCHAR2(100 BYTE),
  FBA_NOMBRE1_BENEFICIARIO    VARCHAR2(100 BYTE),
  FBA_NOMBRE2_BENEFICIARIO    VARCHAR2(100 BYTE),
  FBA_APELLIDOP_BENEFICIARIO  VARCHAR2(100 BYTE),
  FBA_APELLIDOM_BENEFICIARIO  VARCHAR2(100 BYTE),
  FBA_PARENTESCO              VARCHAR2(100 BYTE),
  FBA_EDAD                    VARCHAR2(100 BYTE),
  FBA_PORCENTAJE              VARCHAR2(100 BYTE),
  FBA_FIDE_IDE                VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FOLIOCMP
(
  CONSECUTIVO    VARCHAR2(2000 BYTE)            NOT NULL,
  TARJETA        VARCHAR2(2000 BYTE),
  CUENTA         VARCHAR2(2000 BYTE),
  USUARIO        VARCHAR2(2000 BYTE),
  NOMBRECLIENTE  VARCHAR2(2000 BYTE),
  ACCION         VARCHAR2(2000 BYTE),
  FECHA          TIMESTAMP(9),
  DETALLE        VARCHAR2(2000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FONDEO
(
  ID_ALNOVA           NUMBER(20)                NOT NULL,
  CTA_SOCIO           VARCHAR2(30 BYTE)         NOT NULL,
  STATUS_SERV         NUMBER(1),
  CTA_CARGO_1         VARCHAR2(30 BYTE),
  STATUS_CTA1         NUMBER(1),
  CTA_CARGO_2         VARCHAR2(30 BYTE),
  STATUS_CTA2         NUMBER(1),
  CTA_CARGO_3         VARCHAR2(30 BYTE),
  STATUS_CTA3         NUMBER(1),
  FECHA_ACTIVACION    DATE                      NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  SISTEMA             VARCHAR2(30 BYTE)         NOT NULL,
  PAIS                VARCHAR2(30 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE FRECUENTES_SPEI
(
  ID                    NUMBER(10)              NOT NULL,
  ID_CLIENTE            NUMBER(10)              NOT NULL,
  ID_TIPOTRANSFERENCIA  NUMBER(2)               NOT NULL,
  COD_BANCO             NUMBER(6),
  CUENTA_DESTINO        VARCHAR2(50 BYTE)       NOT NULL,
  NOMBRE_DESTINO        VARCHAR2(40 BYTE),
  EMAIL_DESTINO         VARCHAR2(59 BYTE),
  NUM_CELULAR_DESTINO   VARCHAR2(15 BYTE),
  NUM_TEL_CASA          VARCHAR2(15 BYTE),
  NUM_TEL_OFFNA         VARCHAR2(15 BYTE),
  IP_ORIGEN             VARCHAR2(30 BYTE),
  FECHA_MODIFICACION    DATE,
  PLAZA                 NUMBER(2),
  TIPO_CUENTA_DESTINO   VARCHAR2(10 BYTE),
  CARRIER_NAME          VARCHAR2(18 BYTE),
  DESCRIPCION_CUENTA    VARCHAR2(100 BYTE),
  APODO                 VARCHAR2(100 BYTE),
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                VARCHAR2(2 BYTE),
  CANAL                 VARCHAR2(3 BYTE),
  TARJETA               VARCHAR2(16 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE GEOLOCALIZA
(
  IPINICIO     VARCHAR2(30 BYTE)                NOT NULL,
  IPFIN        VARCHAR2(30 BYTE)                NOT NULL,
  RANGOINICIO  VARCHAR2(30 BYTE)                NOT NULL,
  RANGOFIN     VARCHAR2(30 BYTE)                NOT NULL,
  PAIS         VARCHAR2(30 BYTE)                NOT NULL,
  ABREV        VARCHAR2(30 BYTE)                NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE HISTORICO_TEF_SPEI_TERCEROS
(
  ID                    NUMBER(10)              NOT NULL,
  ID_CLIENTE            NUMBER(10)              NOT NULL,
  ID_TIPOTRANSFERENCIA  NUMBER(2)               NOT NULL,
  COD_BANCO             NUMBER(3),
  CUENTA_DESTINO        VARCHAR2(50 BYTE)       NOT NULL,
  TIPO_CUENTA_DESTINO   VARCHAR2(10 BYTE),
  NOMBRE_DESTINO        VARCHAR2(100 BYTE),
  IP_ORIGEN             VARCHAR2(30 BYTE),
  FECHA_MODIFICACION    DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE HISTORICO_TEF_SPEI_TERCEROS_AX
(
  ID                    NUMBER(10)              NOT NULL,
  ID_CLIENTE            NUMBER(10)              NOT NULL,
  ID_TIPOTRANSFERENCIA  NUMBER(2)               NOT NULL,
  COD_BANCO             NUMBER(3),
  CUENTA_DESTINO        VARCHAR2(50 BYTE)       NOT NULL,
  NOMBRE_DESTINO        VARCHAR2(40 BYTE),
  IP_ORIGEN             VARCHAR2(30 BYTE),
  FECHA_MODIFICACION    DATE,
  TIPO_CUENTA_DESTINO   VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE HIST_CUENTA_SMS
(
  ID                   NUMBER(10)               NOT NULL,
  ID_CLIENTE           VARCHAR2(15 BYTE)        NOT NULL,
  NUMERO_CUENTA        VARCHAR2(30 BYTE)        NOT NULL,
  NUMERO_CELULAR       VARCHAR2(15 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE)         NOT NULL,
  ID_CARRIER           VARCHAR2(15 BYTE)        NOT NULL,
  FECHA_MOVIMIENTO     DATE                     NOT NULL,
  USUARIO              VARCHAR2(10 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE HIST_LOGIN
(
  ID                  NUMBER(10)                NOT NULL,
  ID_CLIENTE          VARCHAR2(10 BYTE)         NOT NULL,
  FECHA_ACCESO        DATE                      NOT NULL,
  INSTANCIA           VARCHAR2(30 BYTE)         NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  FECHA_MODIFICACION  DATE                      DEFAULT SYSDATE               NOT NULL,
  SISTEMA             VARCHAR2(30 BYTE)         NOT NULL,
  PAIS                VARCHAR2(30 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE HUELLAS_REG
(
  HUELLA_HASH  VARCHAR2(100 BYTE)               NOT NULL,
  ALIAS        VARCHAR2(100 BYTE)               NOT NULL,
  FECHA_HORA   VARCHAR2(100 BYTE),
  CTE_ALNOVA   NUMBER(10),
  IP           VARCHAR2(50 BYTE),
  STATUS       NUMBER(22)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE IMPUESTO_DEX
(
  MTCN                   VARCHAR2(80 BYTE)      NOT NULL,
  NOMBRE_IMPUESTO        VARCHAR2(150 BYTE),
  MONTO                  NUMBER(15,2)           NOT NULL,
  ID_IMPUESTO            NUMBER(3),
  ID_IMPORTE             NUMBER(3),
  NOMBRE_CORTO_IMPUESTO  VARCHAR2(50 BYTE),
  ULTIMA_MODIFICACION    DATE,
  USUARIO_MODIFICO       VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE IMPUESTO_DEX1
(
  MTCN                   VARCHAR2(80 BYTE)      NOT NULL,
  NOMBRE_IMPUESTO        VARCHAR2(150 BYTE),
  MONTO                  NUMBER(15,2)           NOT NULL,
  ID_IMPUESTO            NUMBER(3),
  ID_IMPORTE             NUMBER(3),
  NOMBRE_CORTO_IMPUESTO  VARCHAR2(50 BYTE),
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  USUARIO_MODIFICO       VARCHAR2(50 BYTE)      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE INTERBUS
(
  USER_ID               NUMBER(8)               NOT NULL,
  REFERENCIA            VARCHAR2(11 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE INTERESADOS
(
  ID            NUMBER,
  NOMBRE        VARCHAR2(50 BYTE),
  EMAIL         VARCHAR2(50 BYTE),
  NUM_EMPLEADO  VARCHAR2(50 BYTE),
  IDALBUM       NUMBER,
  TIPO          VARCHAR2(2 BYTE),
  OU            VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE INTERFACTURA_SERVICIO
(
  ID                   NUMBER(15)               NOT NULL,
  NOMBRE               VARCHAR2(100 BYTE)       NOT NULL,
  CUENTA               CHAR(20 BYTE)            NOT NULL,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE INVERSION_AZTECA
(
  ENTIDAD           VARCHAR2(4 BYTE)            NOT NULL,
  CODIGO_PRODUCTO   VARCHAR2(2 BYTE)            NOT NULL,
  SUBPRODUCTO       VARCHAR2(4 BYTE)            NOT NULL,
  OPCION_INVERSION  VARCHAR2(100 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE IP_CORE
(
  IP                   VARCHAR2(20 BYTE)        NOT NULL,
  ROL                  VARCHAR2(30 BYTE)        NOT NULL,
  NOMBRE_APLICACION    VARCHAR2(50 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE IUPIFRECUENT
(
  ID                  NUMBER(10)                NOT NULL,
  ID_CLIENTE          NUMBER(8)                 NOT NULL,
  APODO               VARCHAR2(100 BYTE)        NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  CUENTA_DESTINO      VARCHAR2(50 BYTE)         NOT NULL,
  EMAIL_DESTINO       VARCHAR2(59 BYTE)         NOT NULL,
  IP_ORIGEN           VARCHAR2(30 BYTE)         NOT NULL,
  STATUS              VARCHAR2(2 BYTE)          NOT NULL,
  CANAL               VARCHAR2(3 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE IUSACELL
(
  USER_ID               NUMBER(8)               NOT NULL,
  CUENTA                VARCHAR2(20 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE LOLO
(
  ID_LOLO  NUMBER,
  LOLO     VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE LUZYFUERZA
(
  USER_ID               NUMBER(8)               NOT NULL,
  REFERENCIA            VARCHAR2(20 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_ADDITIONAL_PROPERTIES
(
  ID                 NUMBER                     NOT NULL,
  CONNECTION_ID_FK   NUMBER                     NOT NULL,
  REF_ID_FK          NUMBER                     NOT NULL,
  REF_TYPE           VARCHAR2(4000 BYTE)        NOT NULL,
  PROPERTY_ORDER     NUMBER,
  PROP_KEY           VARCHAR2(4000 BYTE)        NOT NULL,
  VALUE              VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_APPLICATIONFILES
(
  ID                  NUMBER                    NOT NULL,
  APPLICATIONS_ID_FK  NUMBER                    NOT NULL,
  NAME                VARCHAR2(200 BYTE)        NOT NULL,
  URI                 VARCHAR2(4000 BYTE)       NOT NULL,
  TYPE                VARCHAR2(100 BYTE)        NOT NULL,
  STATE               VARCHAR2(100 BYTE)        NOT NULL,
  LANGUAGE            VARCHAR2(100 BYTE),
  LOC                 NUMBER,
  SECURITY_GROUP_ID   NUMBER                    DEFAULT 0                     NOT NULL,
  CREATED_ON          DATE                      DEFAULT sysdate               NOT NULL,
  CREATED_BY          VARCHAR2(4000 BYTE),
  UPDATED_ON          DATE,
  UPDATED_BY          VARCHAR2(4000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_APPLICATIONS
(
  ID                 NUMBER                     NOT NULL,
  NAME               VARCHAR2(4000 BYTE),
  DESCRIPTION        VARCHAR2(4000 BYTE),
  BASE_DIR           VARCHAR2(4000 BYTE),
  OUTPUT_DIR         VARCHAR2(4000 BYTE),
  BACKUP_DIR         VARCHAR2(4000 BYTE),
  INPLACE            NUMBER,
  CONNECTION_ID_FK   NUMBER                     NOT NULL,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_CATALOGS
(
  ID                 NUMBER                     NOT NULL,
  CONNECTION_ID_FK   NUMBER                     NOT NULL,
  CATALOG_NAME       VARCHAR2(4000 BYTE),
  DUMMY_FLAG         CHAR(1 BYTE)               DEFAULT 'N',
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_COLUMNS
(
  ID                         NUMBER             NOT NULL,
  TABLE_ID_FK                NUMBER             NOT NULL,
  COLUMN_NAME                VARCHAR2(4000 BYTE) NOT NULL,
  COLUMN_ORDER               NUMBER             NOT NULL,
  COLUMN_TYPE                VARCHAR2(4000 BYTE),
  PRECISION                  NUMBER,
  SCALE                      NUMBER,
  NULLABLE                   CHAR(1 BYTE),
  DEFAULT_VALUE              VARCHAR2(4000 BYTE),
  NATIVE_SQL                 CLOB,
  NATIVE_KEY                 VARCHAR2(4000 BYTE),
  DATATYPE_TRANSFORMED_FLAG  CHAR(1 BYTE),
  COMMENTS                   VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID          NUMBER             DEFAULT 0                     NOT NULL,
  CREATED_BY                 VARCHAR2(255 BYTE),
  CREATED_ON                 DATE               DEFAULT sysdate               NOT NULL,
  LAST_UPDATED_BY            VARCHAR2(255 BYTE),
  LAST_UPDATED_ON            DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_CONNECTIONS
(
  ID                           NUMBER           NOT NULL,
  PROJECT_ID_FK                NUMBER           NOT NULL,
  TYPE                         VARCHAR2(4000 BYTE),
  HOST                         VARCHAR2(4000 BYTE),
  PORT                         NUMBER,
  USERNAME                     VARCHAR2(4000 BYTE),
  PASSWORD                     VARCHAR2(4000 BYTE),
  DBURL                        VARCHAR2(4000 BYTE),
  NAME                         VARCHAR2(255 BYTE),
  NATIVE_SQL                   CLOB,
  STATUS                       VARCHAR2(30 BYTE),
  NUM_CATALOGS                 NUMBER,
  NUM_COLUMNS                  NUMBER,
  NUM_CONSTRAINTS              NUMBER,
  NUM_GROUPS                   NUMBER,
  NUM_ROLES                    NUMBER,
  NUM_INDEXES                  NUMBER,
  NUM_OTHER_OBJECTS            NUMBER,
  NUM_PACKAGES                 NUMBER,
  NUM_PRIVILEGES               NUMBER,
  NUM_SCHEMAS                  NUMBER,
  NUM_SEQUENCES                NUMBER,
  NUM_STORED_PROGRAMS          NUMBER,
  NUM_SYNONYMS                 NUMBER,
  NUM_TABLES                   NUMBER,
  NUM_TABLESPACES              NUMBER,
  NUM_TRIGGERS                 NUMBER,
  NUM_USER_DEFINED_DATA_TYPES  NUMBER,
  NUM_USERS                    NUMBER,
  NUM_VIEWS                    NUMBER,
  COMMENTS                     VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID            NUMBER           DEFAULT 0                     NOT NULL,
  CREATED_ON                   DATE             DEFAULT sysdate               NOT NULL,
  CREATED_BY                   VARCHAR2(255 BYTE),
  LAST_UPDATED_ON              DATE,
  LAST_UPDATED_BY              VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_CONSTRAINTS
(
  ID                 NUMBER                     NOT NULL,
  DELETE_CLAUSE      VARCHAR2(4000 BYTE),
  NAME               VARCHAR2(4000 BYTE),
  CONSTRAINT_TYPE    VARCHAR2(4000 BYTE),
  TABLE_ID_FK        NUMBER                     NOT NULL,
  REFTABLE_ID_FK     NUMBER,
  CONSTRAINT_TEXT    CLOB,
  LANGUAGE           VARCHAR2(40 BYTE)          NOT NULL,
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_CONSTRAINT_DETAILS
(
  ID                 NUMBER                     NOT NULL,
  REF_FLAG           CHAR(1 BYTE)               DEFAULT 'N',
  CONSTRAINT_ID_FK   NUMBER                     NOT NULL,
  COLUMN_ID_FK       NUMBER,
  COLUMN_PORTION     NUMBER,
  CONSTRAINT_TEXT    CLOB,
  DETAIL_ORDER       NUMBER                     NOT NULL,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_DERIVATIVES
(
  ID                        NUMBER              NOT NULL,
  SRC_ID                    NUMBER              NOT NULL,
  SRC_TYPE                  VARCHAR2(4000 BYTE),
  DERIVED_ID                NUMBER              NOT NULL,
  DERIVED_TYPE              VARCHAR2(4000 BYTE),
  DERIVED_CONNECTION_ID_FK  NUMBER              NOT NULL,
  TRANSFORMED               CHAR(1 BYTE),
  ORIGINAL_IDENTIFIER       VARCHAR2(4000 BYTE),
  NEW_IDENTIFIER            VARCHAR2(4000 BYTE),
  DERIVED_OBJECT_NAMESPACE  VARCHAR2(40 BYTE),
  DERIVATIVE_REASON         VARCHAR2(10 BYTE),
  SECURITY_GROUP_ID         NUMBER              DEFAULT 0                     NOT NULL,
  CREATED_ON                DATE                DEFAULT sysdate               NOT NULL,
  CREATED_BY                VARCHAR2(255 BYTE),
  LAST_UPDATED_ON           DATE,
  LAST_UPDATED_BY           VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_FILE_ARTIFACTS
(
  ID                   NUMBER CONSTRAINT MD_APP_FILE_ART_NONULL NOT NULL,
  APPLICATIONFILES_ID  NUMBER CONSTRAINT MD_APPL_FILE_FK_NONULL NOT NULL,
  PATTERN              VARCHAR2(4000 BYTE),
  STRING_FOUND         VARCHAR2(4000 BYTE),
  STRING_REPLACED      VARCHAR2(4000 BYTE),
  TYPE                 VARCHAR2(200 BYTE),
  STATUS               VARCHAR2(4000 BYTE),
  LINE                 NUMBER,
  PATTERN_START        NUMBER,
  PATTERN_END          NUMBER,
  DUE_DATE             DATE,
  DB_TYPE              VARCHAR2(100 BYTE),
  CODE_TYPE            VARCHAR2(1000 BYTE),
  DESCRIPTION          VARCHAR2(4000 BYTE),
  PRIORITY             INTEGER,
  SECURITY_GROUP_ID    VARCHAR2(20 BYTE)        DEFAULT '0'                   NOT NULL,
  CREATED_ON           DATE                     DEFAULT sysdate               NOT NULL,
  CREATED_BY           VARCHAR2(4000 BYTE),
  LAST_UPDATED         DATE,
  LAST_UPDATED_BY      VARCHAR2(4000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_GROUPS
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  GROUP_NAME         VARCHAR2(4000 BYTE),
  GROUP_FLAG         CHAR(1 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_GROUP_MEMBERS
(
  ID                  NUMBER                    NOT NULL,
  GROUP_ID_FK         NUMBER                    NOT NULL,
  USER_ID_FK          NUMBER,
  GROUP_MEMBER_ID_FK  NUMBER,
  SECURITY_GROUP_ID   NUMBER                    DEFAULT 0                     NOT NULL,
  CREATED_ON          DATE                      DEFAULT sysdate               NOT NULL,
  CREATED_BY          VARCHAR2(255 BYTE),
  LAST_UPDATED_ON     DATE,
  LAST_UPDATED_BY     VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_GROUP_PRIVILEGES
(
  ID                 NUMBER                     NOT NULL,
  GROUP_ID_FK        NUMBER                     NOT NULL,
  PRIVILEGE_ID_FK    NUMBER                     NOT NULL,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_INDEXES
(
  ID                 NUMBER                     NOT NULL,
  INDEX_TYPE         VARCHAR2(4000 BYTE),
  TABLE_ID_FK        NUMBER                     NOT NULL,
  INDEX_NAME         VARCHAR2(4000 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(4000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_INDEX_DETAILS
(
  ID                 NUMBER                     NOT NULL,
  INDEX_ID_FK        NUMBER                     NOT NULL,
  COLUMN_ID_FK       NUMBER                     NOT NULL,
  INDEX_PORTION      NUMBER,
  DETAIL_ORDER       NUMBER                     NOT NULL,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_MIGR_DEPENDENCY
(
  ID                  NUMBER                    NOT NULL,
  CONNECTION_ID_FK    NUMBER                    NOT NULL,
  PARENT_ID           NUMBER                    NOT NULL,
  CHILD_ID            NUMBER                    NOT NULL,
  PARENT_OBJECT_TYPE  VARCHAR2(4000 BYTE)       NOT NULL,
  CHILD_OBJECT_TYPE   VARCHAR2(4000 BYTE)       NOT NULL,
  SECURITY_GROUP_ID   NUMBER                    DEFAULT 0                     NOT NULL,
  CREATED_ON          DATE                      DEFAULT sysdate               NOT NULL,
  CREATED_BY          VARCHAR2(255 BYTE),
  LAST_UPDATED_ON     DATE,
  LAST_UPDATED_BY     VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_MIGR_PARAMETER
(
  ID                 NUMBER                     NOT NULL,
  CONNECTION_ID_FK   NUMBER                     NOT NULL,
  OBJECT_ID          NUMBER                     NOT NULL,
  OBJECT_TYPE        VARCHAR2(4000 BYTE)        NOT NULL,
  PARAM_EXISTING     NUMBER                     NOT NULL,
  PARAM_ORDER        NUMBER                     NOT NULL,
  PARAM_NAME         VARCHAR2(4000 BYTE)        NOT NULL,
  PARAM_TYPE         VARCHAR2(4000 BYTE)        NOT NULL,
  PARAM_DATA_TYPE    VARCHAR2(4000 BYTE)        NOT NULL,
  PERCISION          NUMBER,
  SCALE              NUMBER,
  NULLABLE           CHAR(1 BYTE)               NOT NULL,
  DEFAULT_VALUE      VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_MIGR_WEAKDEP
(
  ID                 NUMBER                     NOT NULL,
  CONNECTION_ID_FK   NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  PARENT_ID          NUMBER                     NOT NULL,
  CHILD_NAME         VARCHAR2(4000 BYTE)        NOT NULL,
  PARENT_TYPE        VARCHAR2(4000 BYTE)        NOT NULL,
  CHILD_TYPE         VARCHAR2(4000 BYTE)        NOT NULL,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_NUMROW$SOURCE
(
  NUMROWS  NUMBER(10),
  NAME     VARCHAR2(4000 BYTE),
  OBJID    NUMBER(10)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_NUMROW$TARGET
(
  NUMROWS  NUMBER(10),
  NAME     VARCHAR2(4000 BYTE),
  OBJID    NUMBER(10)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_OTHER_OBJECTS
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  NAME               VARCHAR2(4000 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_PACKAGES
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  NAME               VARCHAR2(4000 BYTE)        NOT NULL,
  PACKAGE_HEADER     CLOB,
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  LANGUAGE           VARCHAR2(40 BYTE)          NOT NULL,
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_PARTITIONS
(
  ID                    NUMBER                  NOT NULL,
  TABLE_ID_FK           NUMBER                  NOT NULL,
  NATIVE_SQL            CLOB,
  PARTITION_EXPRESSION  VARCHAR2(4000 BYTE),
  COMMENTS              VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID     NUMBER                  DEFAULT 0                     NOT NULL,
  CREATED_BY            VARCHAR2(255 BYTE),
  CREATED_ON            DATE                    DEFAULT sysdate               NOT NULL,
  LAST_UPDATED_BY       VARCHAR2(255 BYTE),
  LAST_UPDATED_ON       DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_PRIVILEGES
(
  ID                   NUMBER                   NOT NULL,
  SCHEMA_ID_FK         NUMBER                   NOT NULL,
  PRIVILEGE_NAME       VARCHAR2(4000 BYTE)      NOT NULL,
  PRIVELEGE_OBJECT_ID  NUMBER,
  PRIVELEGEOBJECTTYPE  VARCHAR2(4000 BYTE)      NOT NULL,
  PRIVELEGE_TYPE       VARCHAR2(4000 BYTE)      NOT NULL,
  ADMIN_OPTION         CHAR(1 BYTE),
  NATIVE_SQL           CLOB                     NOT NULL,
  NATIVE_KEY           VARCHAR2(4000 BYTE),
  COMMENTS             VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID    NUMBER                   DEFAULT 0                     NOT NULL,
  CREATED_ON           DATE                     DEFAULT sysdate               NOT NULL,
  CREATED_BY           VARCHAR2(255 BYTE),
  LAST_UPDATED_ON      DATE,
  LAST_UPDATED_BY      VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_PROJECTS
(
  ID                 NUMBER                     NOT NULL,
  PROJECT_NAME       VARCHAR2(4000 BYTE)        NOT NULL,
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_REGISTRY
(
  OBJECT_TYPE       VARCHAR2(30 BYTE)           NOT NULL,
  OBJECT_NAME       VARCHAR2(30 BYTE)           NOT NULL,
  DESC_OBJECT_NAME  VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_REPOVERSIONS
(
  REVISION  NUMBER                              NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_SCHEMAS
(
  ID                 NUMBER                     NOT NULL,
  CATALOG_ID_FK      NUMBER                     NOT NULL,
  NAME               VARCHAR2(4000 BYTE),
  TYPE               CHAR(1 BYTE),
  CHARACTER_SET      VARCHAR2(4000 BYTE),
  VERSION_TAG        VARCHAR2(40 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_SEQUENCES
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  NAME               VARCHAR2(4000 BYTE)        NOT NULL,
  SEQ_START          NUMBER                     NOT NULL,
  INCR               NUMBER                     DEFAULT 1                     NOT NULL,
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE)         DEFAULT '0'                   NOT NULL,
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_STORED_PROGRAMS
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  PROGRAMTYPE        VARCHAR2(20 BYTE),
  NAME               VARCHAR2(4000 BYTE),
  PACKAGE_ID_FK      NUMBER,
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  LANGUAGE           VARCHAR2(40 BYTE)          NOT NULL,
  COMMENTS           VARCHAR2(4000 BYTE),
  LINECOUNT          NUMBER,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_SYNONYMS
(
  ID                  NUMBER                    NOT NULL,
  SCHEMA_ID_FK        NUMBER                    NOT NULL,
  NAME                VARCHAR2(4000 BYTE)       NOT NULL,
  SYNONYM_FOR_ID      NUMBER                    NOT NULL,
  FOR_OBJECT_TYPE     VARCHAR2(4000 BYTE)       NOT NULL,
  PRIVATE_VISIBILITY  CHAR(1 BYTE),
  NATIVE_SQL          CLOB,
  NATIVE_KEY          VARCHAR2(4000 BYTE),
  COMMENTS            VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID   NUMBER                    DEFAULT 0                     NOT NULL,
  CREATED_ON          DATE                      DEFAULT sysdate               NOT NULL,
  CREATED_BY          VARCHAR2(255 BYTE),
  LAST_UPDATED_ON     DATE,
  LAST_UPDATED_BY     VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_TABLES
(
  ID                     NUMBER                 NOT NULL,
  SCHEMA_ID_FK           NUMBER                 NOT NULL,
  TABLE_NAME             VARCHAR2(4000 BYTE)    NOT NULL,
  NATIVE_SQL             CLOB,
  NATIVE_KEY             VARCHAR2(4000 BYTE),
  QUALIFIED_NATIVE_NAME  VARCHAR2(4000 BYTE)    NOT NULL,
  COMMENTS               VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID      NUMBER                 DEFAULT 0                     NOT NULL,
  CREATED_ON             DATE                   DEFAULT sysdate               NOT NULL,
  CREATED_BY             VARCHAR2(255 BYTE),
  LAST_UPDATED_ON        DATE,
  LAST_UPDATED_BY        VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_TABLESPACES
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  TABLESPACE_NAME    VARCHAR2(4000 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_TRIGGERS
(
  ID                   NUMBER                   NOT NULL,
  TABLE_OR_VIEW_ID_FK  NUMBER                   NOT NULL,
  TRIGGER_ON_FLAG      CHAR(1 BYTE)             NOT NULL,
  TRIGGER_NAME         VARCHAR2(4000 BYTE),
  TRIGGER_TIMING       VARCHAR2(4000 BYTE),
  TRIGGER_OPERATION    VARCHAR2(4000 BYTE),
  TRIGGER_EVENT        VARCHAR2(4000 BYTE),
  NATIVE_SQL           CLOB,
  NATIVE_KEY           VARCHAR2(4000 BYTE),
  LANGUAGE             VARCHAR2(40 BYTE)        NOT NULL,
  COMMENTS             VARCHAR2(4000 BYTE),
  LINECOUNT            NUMBER,
  SECURITY_GROUP_ID    NUMBER                   DEFAULT 0                     NOT NULL,
  CREATED_ON           DATE                     DEFAULT sysdate               NOT NULL,
  CREATED_BY           VARCHAR2(255 BYTE),
  LAST_UPDATED_ON      DATE,
  LAST_UPDATED_BY      VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_USERS
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  USERNAME           VARCHAR2(4000 BYTE)        NOT NULL,
  PASSWORD           VARCHAR2(4000 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_USER_DEFINED_DATA_TYPES
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  DATA_TYPE_NAME     VARCHAR2(4000 BYTE)        NOT NULL,
  DEFINITION         VARCHAR2(4000 BYTE)        NOT NULL,
  NATIVE_SQL         CLOB                       NOT NULL,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  COMMENTS           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_USER_PRIVILEGES
(
  ID                 NUMBER                     NOT NULL,
  USER_ID_FK         NUMBER                     NOT NULL,
  PRIVILEGE_ID_FK    NUMBER,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UDPATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MD_VIEWS
(
  ID                 NUMBER                     NOT NULL,
  SCHEMA_ID_FK       NUMBER                     NOT NULL,
  VIEW_NAME          VARCHAR2(4000 BYTE),
  NATIVE_SQL         CLOB,
  NATIVE_KEY         VARCHAR2(4000 BYTE),
  LANGUAGE           VARCHAR2(40 BYTE)          NOT NULL,
  COMMENTS           VARCHAR2(4000 BYTE),
  LINECOUNT          NUMBER,
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MENSAJE
(
  TELEFONO_ID  NUMBER(20)                       NOT NULL,
  CARRIER_ID   NUMBER(2)                        NOT NULL,
  FECHA        DATE                             NOT NULL,
  DESCRIPCION  VARCHAR2(255 BYTE)               NOT NULL,
  STATUS       VARCHAR2(1 BYTE)                 NOT NULL,
  MENSAJE_ID   NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE METODOS_CORE
(
  METODO               VARCHAR2(60 BYTE)        NOT NULL,
  EJB                  VARCHAR2(60 BYTE)        NOT NULL,
  DESCRIPCION          VARCHAR2(80 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE METODOS_CORE2
(
  METODO               VARCHAR2(60 BYTE)        NOT NULL,
  EJB                  VARCHAR2(60 BYTE)        NOT NULL,
  DESCRIPCION          VARCHAR2(80 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MIGRATION_RESERVED_WORDS
(
  KEYWORD  VARCHAR2(40 BYTE)                    NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MIGRLOG
(
  ID                NUMBER                      NOT NULL,
  PARENT_LOG_ID     NUMBER,
  LOG_DATE          TIMESTAMP(6)                NOT NULL,
  SEVERITY          NUMBER(4)                   NOT NULL,
  LOGTEXT           VARCHAR2(4000 BYTE),
  PHASE             VARCHAR2(20 BYTE),
  REF_OBJECT_ID     NUMBER,
  REF_OBJECT_TYPE   VARCHAR2(4000 BYTE),
  CONNECTION_ID_FK  NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MIGR_DATATYPE_TRANSFORM_MAP
(
  ID                 NUMBER                     NOT NULL,
  PROJECT_ID_FK      NUMBER                     NOT NULL,
  MAP_NAME           VARCHAR2(4000 BYTE),
  SECURITY_GROUP_ID  NUMBER                     DEFAULT 0                     NOT NULL,
  CREATED_ON         DATE                       DEFAULT sysdate               NOT NULL,
  CREATED_BY         VARCHAR2(255 BYTE),
  LAST_UPDATED_ON    DATE,
  LAST_UPDATED_BY    VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MIGR_DATATYPE_TRANSFORM_RULE
(
  ID                     NUMBER                 NOT NULL,
  MAP_ID_FK              NUMBER                 NOT NULL,
  SOURCE_DATA_TYPE_NAME  VARCHAR2(4000 BYTE)    NOT NULL,
  SOURCE_PRECISION       NUMBER,
  SOURCE_SCALE           NUMBER,
  TARGET_DATA_TYPE_NAME  VARCHAR2(4000 BYTE)    NOT NULL,
  TARGET_PRECISION       NUMBER,
  TARGET_SCALE           NUMBER,
  SECURITY_GROUP_ID      NUMBER                 DEFAULT 0                     NOT NULL,
  CREATED_ON             DATE                   DEFAULT sysdate               NOT NULL,
  CREATED_BY             VARCHAR2(255 BYTE),
  LAST_UPDATED_ON        DATE,
  LAST_UPDATED_BY        VARCHAR2(255 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MIGR_GENERATION_ORDER
(
  ID                NUMBER                      NOT NULL,
  CONNECTION_ID_FK  NUMBER                      NOT NULL,
  OBJECT_ID         NUMBER                      NOT NULL,
  OBJECT_TYPE       VARCHAR2(4000 BYTE)         NOT NULL,
  GENERATION_ORDER  NUMBER                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MITABLA
(
  ID_PERSONA      VARCHAR2(20 BYTE)             NOT NULL,
  CUENTA          VARCHAR2(20 BYTE),
  IP              VARCHAR2(30 BYTE)             NOT NULL,
  METODO_CONFIR   INTEGER,
  PRUEBA          INTEGER,
  PRUEBA1         INTEGER                       DEFAULT 123,
  IP1             INTEGER                       DEFAULT 0,
  PRUEBAIP        VARCHAR2(30 BYTE)             DEFAULT 'Sin Registro'        NOT NULL,
  METODO_CONFIR1  INTEGER                       DEFAULT 0
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MODAL_APP
(
  CTE_ALNOVA          VARCHAR2(20 BYTE)         NOT NULL,
  ATTEMPTS            INTEGER                   NOT NULL,
  SESSION_ACTIVA      VARCHAR2(50 BYTE)         NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  SISTEMA             VARCHAR2(25 BYTE)         NOT NULL,
  PAIS                VARCHAR2(3 BYTE)          NOT NULL,
  ESTATUS             VARCHAR2(5 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MODAL_APP_ALNOVA
(
  CTE_ALNOVA          VARCHAR2(20 BYTE)         NOT NULL,
  ATTEMPTS            INTEGER                   NOT NULL,
  SESSION_ACTIVA      VARCHAR2(50 BYTE)         NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  SISTEMA             VARCHAR2(25 BYTE)         NOT NULL,
  ESTATUS             VARCHAR2(5 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MONETXCTA
(
  FECHA        DATE                             NOT NULL,
  OPERACION    VARCHAR2(20 BYTE)                NOT NULL,
  PRODUCTO     VARCHAR2(2 BYTE)                 NOT NULL,
  SUBPRODUCTO  VARCHAR2(4 BYTE)                 NOT NULL,
  CANAL        NUMBER(1)                        NOT NULL,
  CONTADOR     NUMBER(20,1)                     NOT NULL,
  MONTO        FLOAT(126)                       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MONTOS_USER
(
  ID_MONTO_USER  NUMBER,
  MONTO_MX       VARCHAR2(256 BYTE)             NOT NULL,
  FECHA_MODIF    DATE                           DEFAULT sysdate               NOT NULL,
  ID_USER        VARCHAR2(256 BYTE)             NOT NULL,
  MONTO_COM      VARCHAR2(256 BYTE)             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MOVIMIENTOS
(
  IMPORTE     FLOAT(20),
  OPERACION   VARCHAR2(100 BYTE),
  MOVIMIENTO  NUMBER(20),
  FECHA       DATE                              DEFAULT sysdate
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MOVISTAR
(
  USER_ID               NUMBER(8)               NOT NULL,
  REFERENCIA            VARCHAR2(20 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MOVSADMIN
(
  FECHA      DATE                               NOT NULL,
  OPERACION  VARCHAR2(20 BYTE)                  NOT NULL,
  CANAL      NUMBER(1)                          NOT NULL,
  CONTADOR   NUMBER(20)                         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE MOVSXCTA
(
  FECHA        DATE                             NOT NULL,
  OPERACION    VARCHAR2(20 BYTE)                NOT NULL,
  PRODUCTO     VARCHAR2(2 BYTE)                 NOT NULL,
  SUBPRODUCTO  VARCHAR2(6 BYTE)                 NOT NULL,
  CANAL        NUMBER(1)                        NOT NULL,
  CONTADOR     NUMBER(20)                       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE M_TRACKING
(
  IDTRACKING            INTEGER                 NOT NULL,
  ID_USUARIO_OPERACION  INTEGER                 NOT NULL,
  CODIGO_OPERACION      INTEGER                 NOT NULL,
  ESTATUS_TRANSACCION   VARCHAR2(50 BYTE)       NOT NULL,
  USUARIO_MODIFICO      VARCHAR2(30 BYTE)       NOT NULL,
  FECHA_OPERACION       DATE                    NOT NULL
)
PARTITION BY RANGE (FECHA_OPERACION) 
(  
  PARTITION M_TRACKING_PARTITION1 VALUES LESS THAN (TO_DATE(' 2012-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKING_PARTITION2 VALUES LESS THAN (TO_DATE(' 2013-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKING_PARTITION3 VALUES LESS THAN (TO_DATE(' 2014-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKING_PARTITION4 VALUES LESS THAN (TO_DATE(' 2015-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKING_PARTITION5 VALUES LESS THAN (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS
)
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE M_TRACKING_DETALLE
(
  ID_TRACKING_DETALLE  INTEGER                  NOT NULL,
  IDTRACKING           INTEGER                  NOT NULL,
  CAMPO                VARCHAR2(50 BYTE)        NOT NULL,
  VALOR                VARCHAR2(50 BYTE)        NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  FECHA_OPERACION      DATE                     NOT NULL
)
PARTITION BY RANGE (FECHA_OPERACION) 
(  
  PARTITION M_TRACKINGDET_PARTITION1 VALUES LESS THAN (TO_DATE(' 2012-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKINGDET_PARTITION2 VALUES LESS THAN (TO_DATE(' 2013-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKINGDET_PARTITION3 VALUES LESS THAN (TO_DATE(' 2014-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKINGDET_PARTITION4 VALUES LESS THAN (TO_DATE(' 2015-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_TRACKINGDET_PARTITION5 VALUES LESS THAN (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS
)
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE M_USUARIOS
(
  IDUSUARIO         INTEGER                     NOT NULL,
  USER_NAME         VARCHAR2(50 BYTE)           NOT NULL,
  APLICACION        VARCHAR2(50 BYTE)           NOT NULL,
  NOMBRECOMPLETO    VARCHAR2(100 BYTE)          NOT NULL,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_OPERACION   DATE                        NOT NULL,
  USRALNOVA         VARCHAR2(8 BYTE),
  EMPLEADO          NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE M_USUARIOS_OPERACIONES
(
  ID_USUARIO_OPERACION  INTEGER                 NOT NULL,
  IDUSUARIO             INTEGER                 NOT NULL,
  OPERACION             VARCHAR2(50 BYTE)       NOT NULL,
  USUARIO_MODIFICO      VARCHAR2(30 BYTE)       NOT NULL,
  FECHA_OPERACION       DATE                    NOT NULL
)
PARTITION BY RANGE (FECHA_OPERACION) 
(  
  PARTITION M_USUARIOSOP_PARTITION1 VALUES LESS THAN (TO_DATE(' 2012-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION2 VALUES LESS THAN (TO_DATE(' 2013-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION3 VALUES LESS THAN (TO_DATE(' 2014-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION4 VALUES LESS THAN (TO_DATE(' 2015-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION5 VALUES LESS THAN (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    LOGGING
    NOCOMPRESS
)
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OPERACIONES_CLI
(
  CLIENTE    NUMBER(8),
  FECHA      DATE,
  OPERACION  VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OPERACIONES_FREC
(
  ID_OPERACION         INTEGER                  NOT NULL,
  USUARIO              INTEGER                  NOT NULL,
  CADENA_DATOS         VARCHAR2(500 BYTE)       NOT NULL,
  ALIAS                VARCHAR2(20 BYTE),
  OPERACION            VARCHAR2(25 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OPE_PROGRAMADAS
(
  ID                     NUMBER(22)             NOT NULL,
  ID_ALNOVA              VARCHAR2(10 BYTE)      NOT NULL,
  TIPO_OPERACION         VARCHAR2(10 BYTE)      NOT NULL,
  USUARIO                VARCHAR2(10 BYTE),
  ESTADO                 NUMBER,
  CORREO                 VARCHAR2(50 BYTE),
  LLAVE_VALOR            VARCHAR2(3000 BYTE),
  FECHA_PROGRAMACION     DATE,
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  FECHA_DE_EJECUCION     DATE,
  DESCRIPCION_RESPUESTA  VARCHAR2(200 BYTE),
  USUARIO_MODIFICO       VARCHAR2(10 BYTE)      NOT NULL,
  IP                     VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OTN_AIRPORTS
(
  AIRPORT_CODE  VARCHAR2(3 BYTE),
  DESCRIPTION   VARCHAR2(80 BYTE),
  NAME          VARCHAR2(40 BYTE)               NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OTN_AIRPORT_LOB_DETAILS
(
  AIRPORT_CODE      VARCHAR2(10 BYTE),
  AIRPORT_MAP       BLOB,
  AIRPORT_SUG_BOOK  CLOB
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE OTROS_SERVICIOS
(
  ID_OTRO_SERVICIO      INTEGER                 NOT NULL,
  ID_SERVICIO           INTEGER                 NOT NULL,
  NOMBRE_OTRO_SERVICIO  CHAR(100 BYTE)          NOT NULL,
  VOTOS                 INTEGER                 NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PAGO_MOVIL_ACT
(
  ID_ACT_PAGMOV        NUMBER(10)               NOT NULL,
  CTEALNOVA            NUMBER(10)               NOT NULL,
  TELEFONO             VARCHAR2(20 BYTE)        NOT NULL,
  CUENTA               VARCHAR2(25 BYTE)        NOT NULL,
  FECHA_ALTA           DATE                     DEFAULT NULL                  NOT NULL,
  UID_TEL              VARCHAR2(50 BYTE)        DEFAULT NULL                  NOT NULL,
  STATUS               NUMBER(1)                NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PAGO_MOVIL_MAXD
(
  CTEALNOVA            NUMBER(10)               NOT NULL,
  MONTO                NUMBER(12,2)             NOT NULL,
  FECHA_MOV            DATE                     DEFAULT NULL                  NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PAPA
(
  ID      NUMBER(2),
  NOMBRE  VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PHOTOS
(
  COMENTARIO     VARCHAR2(500 BYTE),
  DESCRIPCION    VARCHAR2(200 BYTE),
  ID             INTEGER,
  NAME           VARCHAR2(50 BYTE),
  RUTA           VARCHAR2(200 BYTE),
  IDALBUM        INTEGER,
  FIX_NAME       VARCHAR2(50 BYTE),
  VISITA         DATE,
  FIXFOTOUPDATE  DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PLAN_TABLE
(
  STATEMENT_ID     VARCHAR2(30 BYTE),
  TIMESTAMP        DATE,
  REMARKS          VARCHAR2(80 BYTE),
  OPERATION        VARCHAR2(30 BYTE),
  OPTIONS          VARCHAR2(30 BYTE),
  OBJECT_NODE      VARCHAR2(128 BYTE),
  OBJECT_OWNER     VARCHAR2(30 BYTE),
  OBJECT_NAME      VARCHAR2(30 BYTE),
  OBJECT_INSTANCE  INTEGER,
  OBJECT_TYPE      VARCHAR2(30 BYTE),
  OPTIMIZER        VARCHAR2(255 BYTE),
  SEARCH_COLUMNS   NUMBER,
  ID               INTEGER,
  PARENT_ID        INTEGER,
  POSITION         INTEGER,
  COST             INTEGER,
  CARDINALITY      INTEGER,
  BYTES            INTEGER,
  OTHER_TAG        VARCHAR2(255 BYTE),
  PARTITION_START  VARCHAR2(255 BYTE),
  PARTITION_STOP   VARCHAR2(255 BYTE),
  PARTITION_ID     INTEGER,
  OTHER            LONG,
  DISTRIBUTION     VARCHAR2(30 BYTE),
  CPU_COST         INTEGER,
  IO_COST          INTEGER,
  TEMP_SPACE       INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PORTABILIDAD
(
  INSTITUTIONNAME  VARCHAR2(50 BYTE)            NOT NULL,
  ACCOUNTNUMBER    VARCHAR2(30 BYTE)            NOT NULL,
  CLABE            VARCHAR2(20 BYTE),
  NAME             VARCHAR2(50 BYTE)            NOT NULL,
  PAYERACCOUNT     VARCHAR2(30 BYTE),
  EMAIL            VARCHAR2(50 BYTE)            NOT NULL,
  TARGETACCOUNT    VARCHAR2(30 BYTE)            NOT NULL,
  DEBITTARGET      VARCHAR2(30 BYTE)            NOT NULL,
  FECHAULTMODIF    DATE                         DEFAULT SYSDATE               NOT NULL,
  USRMODIF         VARCHAR2(20 BYTE)            NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
MONITORING;


CREATE TABLE PORTAFOLIO
(
  ID             NUMBER,
  NOMBRE         VARCHAR2(50 BYTE)              NOT NULL,
  CONTENIDOMAIL  CLOB
)
NOLOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PORTAL_CAT
(
  ID      NUMBER                                DEFAULT 0,
  FECHA   DATE                                  DEFAULT sysdate,
  STATUS  NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE POSTIT
(
  ID          INTEGER,
  IDALBUM     INTEGER,
  IDFOTO      INTEGER,
  COMENTARIO  VARCHAR2(500 BYTE),
  X           FLOAT(126),
  Y           FLOAT(126),
  USUARIO     VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PREACTIVACION
(
  ID                   NUMBER                   NOT NULL,
  CLIENTE_ALNOVA       NUMBER                   NOT NULL,
  CUENTA               VARCHAR2(20 BYTE)        NOT NULL,
  EMAIL                VARCHAR2(100 BYTE),
  NOMBRE               VARCHAR2(100 BYTE)       NOT NULL,
  APELLIDO_PATERNO     VARCHAR2(100 BYTE),
  APELLIDO_MATERNO     VARCHAR2(100 BYTE),
  SUCURSAL             VARCHAR2(50 BYTE)        NOT NULL,
  NUMERO_EMPLEADO      VARCHAR2(50 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  SISTEMA              VARCHAR2(25 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         NOT NULL,
  ESTATUS              NUMBER                   DEFAULT (1),
  APLICACION           VARCHAR2(20 BYTE),
  FECHA_INSERCION      DATE,
  FECHA_ACTIVACION     DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PREACTIVACION_OLD
(
  ID                   NUMBER,
  CLIENTE_ALNOVA       NUMBER,
  CUENTA               VARCHAR2(100 BYTE),
  EMAIL                VARCHAR2(100 BYTE),
  NOMBRE               VARCHAR2(100 BYTE),
  APELLIDO_PATERNO     VARCHAR2(100 BYTE),
  APELLIDO_MATERNO     VARCHAR2(100 BYTE),
  SUCURSAL             VARCHAR2(50 BYTE),
  NUMERO_EMPLEADO      VARCHAR2(50 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  SISTEMA              VARCHAR2(25 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(3 BYTE)         NOT NULL,
  ESTATUS              NUMBER                   DEFAULT (1),
  APLICACION           VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PREACTIVE_USER
(
  ID_ALNOVA            VARCHAR2(10 BYTE)        NOT NULL,
  ACCOUNT_NUMBER       VARCHAR2(20 BYTE)        NOT NULL,
  STATUS               NUMBER(1),
  MAIL                 VARCHAR2(50 BYTE),
  ALIAS                VARCHAR2(15 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  FECHA_EJECUCION      DATE,
  SUCURSAL             VARCHAR2(10 BYTE),
  USUARIO_MODIFICO     VARCHAR2(10 BYTE),
  NUM_EMPLEADO         VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE PROVEEDOR_URL
(
  URL                VARCHAR2(250 BYTE)         NOT NULL,
  NUMERO_CONEXIONES  NUMBER(10)                 NOT NULL,
  PRIORIDAD          NUMBER(10)                 NOT NULL,
  DISPONIBLE         CHAR(1 BYTE)               NOT NULL,
  CUENTA             NUMBER(10)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE GLOBAL TEMPORARY TABLE QUEST_SL_TEMP_EXPLAIN1
(
  STATEMENT_ID       VARCHAR2(30 BYTE),
  TIMESTAMP          DATE,
  REMARKS            VARCHAR2(80 BYTE),
  OPERATION          VARCHAR2(30 BYTE),
  OPTIONS            VARCHAR2(255 BYTE),
  OBJECT_NODE        VARCHAR2(128 BYTE),
  OBJECT_OWNER       VARCHAR2(30 BYTE),
  OBJECT_NAME        VARCHAR2(30 BYTE),
  OBJECT_INSTANCE    NUMBER,
  OBJECT_TYPE        VARCHAR2(30 BYTE),
  OPTIMIZER          VARCHAR2(255 BYTE),
  SEARCH_COLUMNS     NUMBER,
  ID                 NUMBER,
  PARENT_ID          NUMBER,
  POSITION           NUMBER,
  COST               NUMBER,
  CARDINALITY        NUMBER,
  BYTES              NUMBER,
  OTHER_TAG          VARCHAR2(255 BYTE),
  PARTITION_START    VARCHAR2(255 BYTE),
  PARTITION_STOP     VARCHAR2(255 BYTE),
  PARTITION_ID       NUMBER,
  OTHER              LONG,
  DISTRIBUTION       VARCHAR2(30 BYTE),
  CPU_COST           NUMBER(38),
  IO_COST            NUMBER(38),
  TEMP_SPACE         NUMBER(38),
  ACCESS_PREDICATES  VARCHAR2(4000 BYTE),
  FILTER_PREDICATES  VARCHAR2(4000 BYTE)
)
ON COMMIT PRESERVE ROWS
NOCACHE;


CREATE GLOBAL TEMPORARY TABLE QUEST_TEMP_EXPLAIN
(
  STATEMENT_ID     VARCHAR2(30 BYTE),
  TIMESTAMP        DATE,
  REMARKS          VARCHAR2(80 BYTE),
  OPERATION        VARCHAR2(30 BYTE),
  OPTIONS          VARCHAR2(30 BYTE),
  OBJECT_NODE      VARCHAR2(128 BYTE),
  OBJECT_OWNER     VARCHAR2(30 BYTE),
  OBJECT_NAME      VARCHAR2(30 BYTE),
  OBJECT_INSTANCE  INTEGER,
  OBJECT_TYPE      VARCHAR2(30 BYTE),
  OPTIMIZER        VARCHAR2(255 BYTE),
  SEARCH_COLUMNS   INTEGER,
  ID               INTEGER,
  PARENT_ID        INTEGER,
  POSITION         INTEGER,
  COST             INTEGER,
  CARDINALITY      INTEGER,
  BYTES            INTEGER,
  OTHER_TAG        VARCHAR2(255 BYTE),
  PARTITION_START  VARCHAR2(255 BYTE),
  PARTITION_STOP   VARCHAR2(255 BYTE),
  PARTITION_ID     INTEGER,
  OTHER            LONG,
  DISTRIBUTION     VARCHAR2(30 BYTE),
  CPU_COST         INTEGER,
  IO_COST          INTEGER,
  TEMP_SPACE       INTEGER
)
ON COMMIT PRESERVE ROWS
NOCACHE;


CREATE TABLE RECORDATORIOS_AGENDA
(
  ID                           NUMBER           NOT NULL,
  ID_RECORDATORIO              VARCHAR2(50 BYTE) NOT NULL,
  REFERENCIA                   VARCHAR2(100 BYTE) NOT NULL,
  FECHA_INICIO_RECORDATORIO    DATE             NOT NULL,
  FECHA_LIMITE_REPETICION      DATE             NOT NULL,
  ALARMA_ACTIVADA              VARCHAR2(5 BYTE) NOT NULL,
  NOTIFICACION_CORREO          VARCHAR2(5 BYTE) NOT NULL,
  NOTIFICACION_CELULAR         VARCHAR2(5 BYTE) NOT NULL,
  FRECUENCIA_REPETICION        VARCHAR2(30 BYTE) NOT NULL,
  REPETIR_ALARMA_NOTIFICACION  VARCHAR2(5 BYTE) NOT NULL,
  FECHA_REGISTRO               DATE             NOT NULL,
  NUM_CTE                      VARCHAR2(10 BYTE) NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE RECORDATORIOS_EVENTOS
(
  ID               NUMBER                       NOT NULL,
  ID_RECORDATORIO  NUMBER                       NOT NULL,
  FECHA            DATE,
  FECHA_ALERTA     DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE REPO_CLIENTES
(
  ID_ALNOVA            VARCHAR2(25 BYTE)        NOT NULL,
  CUENTA               VARCHAR2(20 BYTE)        NOT NULL,
  CONTRATO_TAS         VARCHAR2(30 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(10 BYTE)        NOT NULL,
  TIPO_PERSONA         VARCHAR2(20 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE REPO_REG_OPERAC
(
  FOLIO_ALNOVA         VARCHAR2(25 BYTE)        NOT NULL,
  FOLIO_TAS            VARCHAR2(25 BYTE)        NOT NULL,
  FOLIO_EBANKING       VARCHAR2(25 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(25 BYTE)        NOT NULL,
  ID_ALNOVA            VARCHAR2(25 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE REPO_TASA_PLAZO
(
  ID_TASA_PLAZO        NUMBER                   NOT NULL,
  TASA                 VARCHAR2(50 BYTE)        NOT NULL,
  PLAZO                VARCHAR2(100 BYTE)       NOT NULL,
  FECHA                DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL,
  TIPO_PERSONA         VARCHAR2(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE RMA_NOTIFICA
(
  CTE_ALNOVA             VARCHAR2(10 BYTE)      NOT NULL,
  FECHA_NOTIFICACION     DATE                   NOT NULL,
  NUMERO_NOTIFICACIONES  NUMBER                 NOT NULL,
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  USUARIO_MODIFICO       VARCHAR2(20 BYTE)      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ROL_CORE
(
  ROL                  VARCHAR2(30 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE ROL_METODO_CORE
(
  IDROL_METODO         NUMBER(30)               NOT NULL,
  METODO               VARCHAR2(60 BYTE)        NOT NULL,
  ROL                  VARCHAR2(30 BYTE)        NOT NULL,
  STATUS               VARCHAR2(2 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE               NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SCHEDULED_EMAIL
(
  SCHEDULED_EMAIL_ID  INTEGER                   NOT NULL,
  RECEIVER_EMAIL      VARCHAR2(100 BYTE)        NOT NULL,
  TEXT                VARCHAR2(3000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SCHEDULED_PAYMENT
(
  SCHEDULED_PAYMENT_ID  INTEGER                 NOT NULL,
  TX                    VARCHAR2(20 BYTE)       NOT NULL,
  REQUEST               VARCHAR2(3000 BYTE)     NOT NULL,
  RESPONSE              VARCHAR2(3000 BYTE),
  STATUS                VARCHAR2(20 BYTE)       NOT NULL,
  APPLY_DATE            DATE                    NOT NULL,
  PROGRAM_DATE          DATE                    NOT NULL,
  TX_NAME               VARCHAR2(40 BYTE)       NOT NULL,
  TEXT                  VARCHAR2(3000 BYTE)     NOT NULL,
  FOLIO_PROGRAMADO      VARCHAR2(20 BYTE),
  FOLIO_ENVIADO         VARCHAR2(20 BYTE),
  FOLIO_INTERBANCARIO   VARCHAR2(20 BYTE),
  USER_ID               NUMBER(10),
  SCHEDULED_EMAIL_ID    INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SEGURIDAD_ACCESO
(
  ID                NUMBER                      NOT NULL,
  CODIGO            VARCHAR2(50 BYTE)           NOT NULL,
  SEMILLA           VARCHAR2(50 BYTE)           NOT NULL,
  STATUS            VARCHAR2(55 BYTE),
  USUARIO_MODIFICO  VARCHAR2(50 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        DEFAULT SYSDATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SEGUROS
(
  USER_ID        NUMBER(8)                      NOT NULL,
  TIPO_SEG       VARCHAR2(20 BYTE)              NOT NULL,
  POLIZA         VARCHAR2(20 BYTE)              NOT NULL,
  NUM_OPERACION  NUMBER(10)                     NOT NULL,
  FECHA          DATE                           DEFAULT SYSDATE               NOT NULL,
  REFERENCIA_1   VARCHAR2(30 BYTE),
  REFERENCIA_2   VARCHAR2(30 BYTE),
  REFERENCIA_3   VARCHAR2(30 BYTE),
  REFERENCIA_4   VARCHAR2(30 BYTE),
  REFERENCIA_5   VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SERVICIOS
(
  ID_SERVICIO      INTEGER                      NOT NULL,
  NOMBRE_SERVICIO  CHAR(100 BYTE)               NOT NULL,
  VOTOS            INTEGER                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SERVICIOS_LOG
(
  NUM_OPERACION      NUMBER                     NOT NULL,
  CARRIER            VARCHAR2(20 BYTE)          NOT NULL,
  PAGO_SOCK          VARCHAR2(200 BYTE),
  RESP_PAGO_SOCK     VARCHAR2(200 BYTE),
  REVERSO_SOCK       VARCHAR2(200 BYTE),
  RESP_REVERSO_SOCK  VARCHAR2(200 BYTE),
  TXN                VARCHAR2(3000 BYTE),
  RESP_TXN           VARCHAR2(3000 BYTE),
  FECHA              DATE                       DEFAULT SYSDATE               NOT NULL,
  NUM_TRANSACCION    VARCHAR2(10 BYTE),
  CUENTA             VARCHAR2(20 BYTE),
  MONTO              NUMBER,
  NUM_CLIENTE        NUMBER,
  REFERENCIA         VARCHAR2(30 BYTE),
  PROCESO_FIN_OK     VARCHAR2(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SKYACCOUNTS
(
  USER_ID               NUMBER(8)               NOT NULL,
  REFERENCIA            NUMBER(12)              NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                NUMBER(2),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SOBREPRECIOSANCA
(
  PLAZO        NUMBER(4)                        NOT NULL,
  SOBREPRECIO  NUMBER(4)                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SOLICITUDCREDITO
(
  FOLIO                NUMBER(10)               NOT NULL,
  TIPOCREDITO          NUMBER(10)               NOT NULL,
  SUELDO               NUMBER(10,2)             NOT NULL,
  MONTO                NUMBER(10,2)             NOT NULL,
  TASA                 NUMBER(10,2)             NOT NULL,
  PLAZO                NUMBER(10,2),
  PERIODOPLAZO         NUMBER(10,2),
  APORTACIONADICIONAL  NUMBER(10,2),
  NOMBRE               VARCHAR2(40 BYTE),
  APELLIDO             VARCHAR2(40 BYTE),
  APELLIDOMAT          VARCHAR2(40 BYTE),
  DIRECCION            VARCHAR2(150 BYTE),
  TELEFONO             VARCHAR2(20 BYTE)        NOT NULL,
  PUESTO               VARCHAR2(20 BYTE),
  NACIONALIDAD         VARCHAR2(20 BYTE),
  DOCACREDITA          VARCHAR2(40 BYTE),
  NACIMIENTO           DATE,
  ESTADOCIVIL          VARCHAR2(1 BYTE),
  REGIMENCONYUGAL      VARCHAR2(1 BYTE),
  TIPOHABITACION       VARCHAR2(1 BYTE),
  OTROTIPO             VARCHAR2(40 BYTE),
  RFC                  VARCHAR2(15 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SPEI_PROG_30_MIN
(
  ID                   INTEGER,
  NUM_TRANSACCION      VARCHAR2(40 BYTE),
  PETICION             VARCHAR2(3000 BYTE),
  RESPUESTA            VARCHAR2(3000 BYTE),
  ESTADO               VARCHAR2(25 BYTE),
  HORA_APLICACION      DATE,
  FECHA_PROGRAMACION   DATE,
  TEXTO_ADJUNTO        VARCHAR2(3000 BYTE),
  CLAVE_RASTREO        VARCHAR2(30 BYTE),
  ID_USUARIO           INTEGER,
  ID_EMAIL             VARCHAR2(50 BYTE),
  ULTIMA_MODIFICACION  DATE                     DEFAULT SYSDATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE),
  NOMBRE_TRANSACCION   VARCHAR2(40 BYTE),
  MENSAJE_RESPUESTA    VARCHAR2(1000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE STAGE_MIGRLOG
(
  SVRID_FK         NUMBER,
  DBID_GEN_FK      NUMBER,
  ID               NUMBER                       NOT NULL,
  REF_OBJECT_ID    NUMBER,
  REF_OBJECT_TYPE  VARCHAR2(4000 BYTE),
  LOG_DATE         TIMESTAMP(6)                 NOT NULL,
  SEVERITY         NUMBER(4)                    NOT NULL,
  LOGTEXT          VARCHAR2(4000 BYTE),
  PHASE            VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SWIFTABA
(
  TIPO_CLAVE           CHAR(1 BYTE)             NOT NULL,
  CLAVE                VARCHAR2(11 BYTE)        NOT NULL,
  DESCRIPCION          VARCHAR2(70 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(40 BYTE)        NOT NULL,
  CVE_PAIS             VARCHAR2(3 BYTE)         NOT NULL,
  CIUDAD               VARCHAR2(35 BYTE)        NOT NULL,
  STATUS_BLOQUEO       NUMBER(2)                DEFAULT 1,
  FECHA_ACTUALIZACION  DATE,
  USUARIO_MODIFICA     VARCHAR2(8 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE SWIFTABAN
(
  TIPO_CLAVE           CHAR(1 BYTE)             NOT NULL,
  CLAVE                VARCHAR2(11 BYTE)        NOT NULL,
  DESCRIPCION          VARCHAR2(70 BYTE)        NOT NULL,
  PAIS                 VARCHAR2(40 BYTE)        NOT NULL,
  CVE_PAIS             VARCHAR2(3 BYTE)         NOT NULL,
  CIUDAD               VARCHAR2(35 BYTE)        NOT NULL,
  STATUS_BLOQUEO       NUMBER(2)                DEFAULT 1                     NOT NULL,
  FECHA_ACTUALIZACION  DATE                     NOT NULL,
  USUARIO_MODIFICA     VARCHAR2(8 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TAAPERTURASN2
(
  FCCLIENTE_UNICO   VARCHAR2(25 CHAR)           NOT NULL,
  FCCLIENTE_TIENDA  VARCHAR2(25 CHAR)           NOT NULL,
  FCCLIENTE_ALNOVA  VARCHAR2(30 CHAR)           NOT NULL,
  FCNUMERO_CTA      VARCHAR2(25 CHAR)           NOT NULL,
  FCNUMERO_TARJ     VARCHAR2(25 CHAR)           NOT NULL,
  FCSISTEMA         VARCHAR2(15 CHAR)           NOT NULL,
  FDFECHA_MOD       DATE                        NOT NULL,
  FCUSUARIO_MOD     VARCHAR2(20 CHAR)           NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TABLATEST
(
  CAMPO1  NUMBER,
  CAMPO2  VARCHAR2(100 BYTE)                    NOT NULL,
  CAMPO3  CHAR(1 BYTE)                          DEFAULT 1
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TABLAX
(
  CLOMUN1  NUMBER,
  VAMPO    NUMBER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TACONFIRMACION_WU
(
  FCUID                   CHAR(25 BYTE)         NOT NULL,
  FCID                    CHAR(20 BYTE)         NOT NULL,
  ID                      NUMBER                NOT NULL,
  FCIDOPERACION           CHAR(10 BYTE)         NOT NULL,
  FCSUCURSAL              CHAR(5 BYTE)          NOT NULL,
  FCCAJA                  CHAR(2 BYTE)          NOT NULL,
  FCPAIS                  CHAR(3 BYTE)          NOT NULL,
  FCCANAL                 CHAR(10 BYTE)         NOT NULL,
  FCNOMBREREMIT           CHAR(12 BYTE)         NOT NULL,
  FCAPELLIDOREMIT         CHAR(20 BYTE)         NOT NULL,
  FCDIRECCIONREMIT        VARCHAR2(100 BYTE)    NOT NULL,
  FCCPREMIT               CHAR(5 BYTE)          NOT NULL,
  FCPOBLACIONREMIT        CHAR(24 BYTE)         NOT NULL,
  FCESTADOREMIT           CHAR(24 BYTE)         NOT NULL,
  FCTELREMIT              CHAR(15 BYTE)         NOT NULL,
  FDFECHNACREMIT          CHAR(8 BYTE)          NOT NULL,
  FCTIPOIDREMIT           CHAR(3 BYTE)          NOT NULL,
  FCFOLIOREMIT            CHAR(15 BYTE)         NOT NULL,
  FCFECHVENCIMIENTOREMIT  CHAR(8 BYTE)          NOT NULL,
  FCIDEMISORREMIT         VARCHAR2(44 BYTE)     NOT NULL,
  FCNACIONALREMIT         CHAR(20 BYTE)         NOT NULL,
  FCPAISREMIT             CHAR(2 BYTE)          NOT NULL,
  FCLUGARNACREMIT         VARCHAR2(44 BYTE)     NOT NULL,
  FCNACIONAL              CHAR(10 BYTE)         NOT NULL,
  FCOCUPACION             CHAR(20 BYTE)         NOT NULL,
  FCACUSERECIBO           CHAR(3 BYTE)          NOT NULL,
  FCBENEFNOMBRE           CHAR(25 BYTE)         NOT NULL,
  FCBENEFAPELLIDOS        VARCHAR2(45 BYTE)     NOT NULL,
  FCPRINCIPAL             CHAR(11 BYTE)         NOT NULL,
  FCCARGO                 CHAR(11 BYTE)         NOT NULL,
  FCIMPUESTO              CHAR(11 BYTE)         NOT NULL,
  FCDESCUENTO             CHAR(11 BYTE)         NOT NULL,
  FCCARGOMENSAJE          CHAR(11 BYTE)         NOT NULL,
  FCTOTALPAGO             CHAR(11 BYTE)         NOT NULL,
  FCTIPOCAMBIO            CHAR(17 BYTE)         NOT NULL,
  FCMONTOPAGO             CHAR(11 BYTE)         NOT NULL,
  FCPAISORIGEN            CHAR(2 BYTE)          NOT NULL,
  FCMONEDAORIGEN          CHAR(3 BYTE)          NOT NULL,
  FCPAISDESTINO           CHAR(2 BYTE)          NOT NULL,
  FCPAISDESTINOPOBLAC     VARCHAR2(50 BYTE)     NOT NULL,
  FCPAISDESTINOESTADO     VARCHAR2(50 BYTE)     NOT NULL,
  FCMONEDADESTINO         CHAR(3 BYTE)          NOT NULL,
  FCPAGARSINID            CHAR(1 BYTE)          NOT NULL,
  FCPREGUNTA              VARCHAR2(35 BYTE)     NOT NULL,
  FCRESPUESTA             VARCHAR2(35 BYTE)     NOT NULL,
  FCMENSAJE               VARCHAR2(200 BYTE)    NOT NULL,
  FCMTCN                  CHAR(10 BYTE)         NOT NULL,
  FCREFERENCIANO          CHAR(16 BYTE)         NOT NULL,
  FCOPERADOR              CHAR(12 BYTE)         NOT NULL,
  FCOPERADORNOMBRE        CHAR(25 BYTE)         NOT NULL,
  FCOPERADORAPPATERNO     CHAR(15 BYTE)         NOT NULL,
  FCOPERADORAPMATERNO     CHAR(15 BYTE)         NOT NULL,
  FCIDSISTEMAEXT          CHAR(8 BYTE)          NOT NULL,
  FCTIPONOMBREREMIT       CHAR(1 BYTE)          NOT NULL,
  FCTIPONOMBREBENEF       CHAR(1 BYTE)          NOT NULL,
  FCTIPOTRANFDINERO       CHAR(3 BYTE)          NOT NULL,
  FCIDTARJETALEALTAD      CHAR(3 BYTE)          NOT NULL,
  FCENVIOTERCEROS         CHAR(1 BYTE)          NOT NULL,
  FCEXPIRADO              CHAR(1 BYTE)          NOT NULL,
  FCUSUARIO               CHAR(15 BYTE)         NOT NULL,
  FCPASSWORD              CHAR(15 BYTE)         NOT NULL,
  FDFECHATRANSACCION      DATE                  DEFAULT SYSDATE               NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TAOPPROG30MIN
(
  FIID                   INTEGER,
  FCNUM_TRANSACCION      VARCHAR2(40 CHAR),
  FCPETICION             VARCHAR2(3000 CHAR),
  FCRESPUESTA            VARCHAR2(3000 CHAR),
  FCESTADO               INTEGER,
  FDHORA_APLICACION      DATE,
  FDFECHA_PROGRAMACION   DATE,
  FCTEXTO_ADJUNTO        VARCHAR2(3000 CHAR),
  FCFOLIO                VARCHAR2(30 CHAR),
  FIID_USUARIO           INTEGER,
  FCID_EMAIL             VARCHAR2(50 CHAR),
  FDULTIMA_MODIFICACION  DATE                   DEFAULT SYSDATE               NOT NULL,
  FCUSUARIO_MODIFICO     VARCHAR2(30 CHAR)      NOT NULL,
  FCNOMBRE_TRANSACCION   VARCHAR2(40 CHAR)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TAPAGOMICRONEG
(
  FCSISTEMA       VARCHAR2(20 CHAR)             NOT NULL,
  FDFECHA_PAGO    DATE                          NOT NULL,
  FCGRUPO         VARCHAR2(20 CHAR)             NOT NULL,
  FNUSUARIO       NUMBER(15)                    NOT NULL,
  FCCUENTA_CARGO  VARCHAR2(30 CHAR)             NOT NULL,
  FCNOM_INTEGRAN  VARCHAR2(60 CHAR)             NOT NULL,
  FNIMPORTE       NUMBER(20,2)                  NOT NULL,
  FCREFEREN_CAJA  VARCHAR2(15 CHAR)             NOT NULL,
  FNSUCURSAL      NUMBER(10)                    NOT NULL,
  FCREFERENCIA    VARCHAR2(20 CHAR)             NOT NULL,
  FCTIENDA        VARCHAR2(80 CHAR),
  FCCAJERO        VARCHAR2(60 CHAR),
  FDFECHA_MOD     DATE                          NOT NULL,
  FCUSUARIO_MOD   VARCHAR2(20 CHAR)             NOT NULL,
  CANAL           VARCHAR2(10 CHAR),
  CREDITO         VARCHAR2(15 CHAR),
  NUM_OPER        VARCHAR2(10 CHAR)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TAPAGOSELEKTRA
(
  FCCTEALNOVA            VARCHAR2(20 CHAR)      NOT NULL,
  FCREFERENCIA           VARCHAR2(14 CHAR)      NOT NULL,
  FNMONTO                NUMBER(20,2)           NOT NULL,
  FCCUENTACARGO          VARCHAR2(23 CHAR)      NOT NULL,
  FDFECHA_PAGO           DATE                   DEFAULT SYSDATE               NOT NULL,
  FCRESP_ALNOVA          VARCHAR2(200 CHAR)     NOT NULL,
  FCAPLICACION           VARCHAR2(30 CHAR)      NOT NULL,
  FCUSUARIO_MODIFICO     VARCHAR2(30 CHAR)      NOT NULL,
  FDULTIMA_MODIFICACION  CHAR(18 BYTE)          DEFAULT SYSDATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TASAS
(
  ID            NUMBER(6)                       NOT NULL,
  PLAZOS        NUMBER(3)                       NOT NULL,
  PORCENTAJE    NUMBER(6,4)                     NOT NULL,
  TIPO_CREDITO  NUMBER                          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TASPEICELULAR
(
  FIID                   INTEGER,
  FIOPCION               INTEGER,
  FCNUMEROACC            VARCHAR2(14 CHAR),
  FCNUMEROTARJ           VARCHAR2(16 CHAR),
  FCCTACLABE             VARCHAR2(18 CHAR),
  FCNUMCEL               VARCHAR2(10 CHAR),
  FCNOMBRECNIACEL        VARCHAR2(20 CHAR),
  FCMONTOMAXPERMI        NUMBER(15,2),
  FCMONTOMAXTRANS        NUMBER(15,2),
  FCMONTOMAXSPEI         NUMBER(15,2),
  FCMONTOMAXTEF          NUMBER(15,2),
  FCBANDERALIBRE1        VARCHAR2(1 CHAR),
  FCBANDERALIBRE2        VARCHAR2(1 CHAR),
  FCCAMPOMONTOLIB1       NUMBER(15,2),
  FCCAMPOMONTOLIB2       NUMBER(15,2),
  FCCAMALFALIB1          VARCHAR2(20 CHAR),
  FCCAMALFALIB2          VARCHAR2(20 CHAR),
  FDULTIMA_OPERACION     DATE                   DEFAULT SYSDATE,
  FDULTIMA_MODIFICACION  DATE                   DEFAULT SYSDATE,
  FCUSUARIO_MODIFICO     VARCHAR2(30 CHAR)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TATOP15_PS
(
  FNEMISORID            NUMBER(4)               NOT NULL,
  FNSUCRSALID           NUMBER(4)               NOT NULL,
  FCNOMBRECOMERCIAL     VARCHAR2(200 CHAR)      NOT NULL,
  FCNOMBRECORTO         VARCHAR2(100 CHAR)      NOT NULL,
  FNESTATUS             NUMBER(1)               NOT NULL,
  FNREFERENCIAMIN       NUMBER(4)               NOT NULL,
  FNREFERENCIAMAX       NUMBER(4)               NOT NULL,
  FNFORMASPAGO          NUMBER(2)               NOT NULL,
  FNPERMITECANCELAR     NUMBER(1)               NOT NULL,
  FNREFERENCIAVARIABLE  NUMBER(1)               NOT NULL,
  FNCATEGORIAID         NUMBER(4)               NOT NULL,
  FCCATEGORIA           VARCHAR2(200 CHAR)      NOT NULL,
  FNORDENTOP            NUMBER(2)               NOT NULL,
  FECHA_MODIFICO        DATE                    DEFAULT SYSDATE,
  USUARIO_MODIFICO      VARCHAR2(30 CHAR)       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_ACERTUM_USER
(
  USER_ID               NUMBER(10)              NOT NULL,
  CELLULAR              VARCHAR2(16 BYTE),
  EMAIL                 VARCHAR2(40 BYTE),
  USER2CELLCOMPANY      NUMBER,
  CELLULAR_OLD          VARCHAR2(16 BYTE),
  EMAIL_OLD             VARCHAR2(40 BYTE),
  USER2CELLCOMPANY_OLD  NUMBER,
  FECHA_MODIFICACION    DATE                    NOT NULL,
  ULTIMA_MODIFICACION   DATE                    NOT NULL,
  USUARIO_MODIFICA      VARCHAR2(10 BYTE)       NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_BENEFAFILIA
(
  IDBENEFICIARIO    INTEGER                     NOT NULL,
  IDUSUARIO         VARCHAR2(20 BYTE)           NOT NULL,
  NUMBENEFICIARIO   INTEGER,
  APATERNO          VARCHAR2(50 BYTE),
  AMATERNO          VARCHAR2(50 BYTE),
  NOMBRE            VARCHAR2(50 BYTE),
  PARENTESCO        VARCHAR2(50 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  EMAIL             VARCHAR2(50 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_BENEFICIARIO
(
  IDBENEFICIARIO    INTEGER                     NOT NULL,
  IDTITULAR         VARCHAR2(20 BYTE)           NOT NULL,
  NUMBENEFICIARIO   INTEGER,
  APATERNO          VARCHAR2(50 BYTE),
  AMATERNO          VARCHAR2(50 BYTE),
  NOMBRE            VARCHAR2(50 BYTE),
  PARENTESCO        VARCHAR2(50 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  EMAIL             VARCHAR2(50 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL,
  PORCENTAJEF       INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_CATALOGOS
(
  IDCATALOGO        VARCHAR2(5 BYTE)            NOT NULL,
  CATALOGO          VARCHAR2(30 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_CLIENTE
(
  IDCLIENTE           INTEGER                   NOT NULL,
  IDUSUARIO           VARCHAR2(20 BYTE)         NOT NULL,
  IMEI                VARCHAR2(25 BYTE),
  EMAIL               VARCHAR2(50 BYTE),
  NOMBRECLI           VARCHAR2(30 BYTE),
  APATERNO            VARCHAR2(50 BYTE),
  AMATERNO            VARCHAR2(50 BYTE),
  CALLECLI            VARCHAR2(50 BYTE),
  NUMEXT              VARCHAR2(10 BYTE),
  NUMINT              VARCHAR2(10 BYTE),
  TIPOIDENTIFICACION  VARCHAR2(80 BYTE),
  CODPOSTALCLI        VARCHAR2(10 BYTE),
  COLONIACLI          VARCHAR2(50 BYTE),
  ESTADOCLI           VARCHAR2(50 BYTE),
  CIUDAD              VARCHAR2(50 BYTE),
  NUMFORM             INTEGER,
  GRABADO             INTEGER                   DEFAULT 0,
  PORCENTAJE          INTEGER                   DEFAULT 0,
  FECHANAC            DATE,
  TIPODISP            INTEGER,
  PREGUNTASECRET      VARCHAR2(300 BYTE),
  RESPUESTA           VARCHAR2(300 BYTE),
  PASSWD              VARCHAR2(200 BYTE),
  TELCASA             VARCHAR2(20 BYTE),
  SEXO                VARCHAR2(10 BYTE),
  ESTADOCIVIL         VARCHAR2(15 BYTE),
  CURP                VARCHAR2(20 BYTE),
  RFC                 VARCHAR2(20 BYTE),
  LADA                VARCHAR2(5 BYTE),
  NUMEXTENSION        VARCHAR2(10 BYTE),
  ACTIVIDAD           VARCHAR2(50 BYTE),
  ACTIVIDADECO        VARCHAR2(50 BYTE),
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  FECHA_MODIFICO      DATE                      NOT NULL,
  NUMIDENTIFIC        VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_CONTENIDOCAT
(
  IDCONTENIDO       INTEGER                     NOT NULL,
  IDCATALOGO        VARCHAR2(5 BYTE)            NOT NULL,
  CLAVE             VARCHAR2(5 BYTE),
  CONTENIDO         VARCHAR2(200 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL,
  STATUS            INTEGER,
  ORDEN             INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_DIRBENEF
(
  IDDIRBENEF        INTEGER                     NOT NULL,
  IDBENEFICIARIO    INTEGER                     NOT NULL,
  CALLE             VARCHAR2(50 BYTE),
  NUMEXT            VARCHAR2(10 BYTE),
  NUMINT            VARCHAR2(10 BYTE),
  CP                INTEGER,
  COLONIA           VARCHAR2(50 BYTE),
  ESTADO            VARCHAR2(30 BYTE),
  POBLACION         VARCHAR2(50 BYTE),
  LADA              INTEGER,
  TELOFICINA        VARCHAR2(20 BYTE),
  EXTENSION         INTEGER,
  TELCASA           VARCHAR2(15 BYTE),
  TELCEL            VARCHAR2(10 BYTE),
  FECHAVISITA       VARCHAR2(10 BYTE),
  HORAVISITA        VARCHAR2(10 BYTE),
  REFERENCIACALLES  VARCHAR2(80 BYTE),
  VISITA            VARCHAR2(2 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL,
  IDTITULAR         VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_DIRECCION
(
  IDDIRECCION       INTEGER                     NOT NULL,
  IDTITULAR         VARCHAR2(20 BYTE)           NOT NULL,
  CALLE             VARCHAR2(50 BYTE),
  NUMEXT            VARCHAR2(10 BYTE),
  NUMINT            VARCHAR2(10 BYTE),
  CP                INTEGER,
  COLONIA           VARCHAR2(50 BYTE),
  ESTADO            VARCHAR2(30 BYTE),
  POBLACION         VARCHAR2(50 BYTE),
  LADA              INTEGER,
  TELOFICINA        VARCHAR2(20 BYTE),
  EXTENSION         INTEGER,
  TELCASA           VARCHAR2(15 BYTE),
  TELCEL            VARCHAR2(10 BYTE),
  FECHAVISITA       VARCHAR2(10 BYTE),
  HORAVISITA        VARCHAR2(10 BYTE),
  REFERENCIACALLES  VARCHAR2(80 BYTE),
  VISITA            VARCHAR2(2 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_DIRECCIONAFI
(
  IDDIRECCION       INTEGER                     NOT NULL,
  IDUSUARIO         VARCHAR2(20 BYTE)           NOT NULL,
  IDBENEFICIARIO    INTEGER                     NOT NULL,
  CALLE             VARCHAR2(50 BYTE),
  NUMEXT            VARCHAR2(10 BYTE),
  NUMINT            VARCHAR2(10 BYTE),
  CP                INTEGER,
  COLONIA           VARCHAR2(50 BYTE),
  ESTADO            VARCHAR2(30 BYTE),
  POBLACION         VARCHAR2(50 BYTE),
  LADA              INTEGER,
  TELOFICINA        VARCHAR2(20 BYTE),
  EXTENSION         INTEGER,
  TELCASA           VARCHAR2(15 BYTE),
  TELCEL            VARCHAR2(10 BYTE),
  FECHAVISITA       VARCHAR2(10 BYTE),
  HORAVISITA        VARCHAR2(10 BYTE),
  REFERENCIACALLES  VARCHAR2(80 BYTE),
  VISITA            VARCHAR2(2 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_DOCUMENTOS
(
  IDDOCUMENTO       INTEGER                     NOT NULL,
  IDTITULAR         VARCHAR2(20 BYTE)           NOT NULL,
  IDENTIFICACION    VARCHAR2(200 BYTE),
  COMPDOMICILIO     VARCHAR2(200 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_FISCAL
(
  IDFISCAL          INTEGER                     NOT NULL,
  IDUSUARIO         VARCHAR2(20 BYTE)           NOT NULL,
  CALLE             VARCHAR2(50 BYTE),
  NUMEXT            VARCHAR2(10 BYTE),
  NUMINT            VARCHAR2(10 BYTE),
  CODPOSTAL         VARCHAR2(10 BYTE),
  COLONIA           VARCHAR2(50 BYTE),
  ESTADO            VARCHAR2(50 BYTE),
  CIUDAD            VARCHAR2(50 BYTE),
  LADA              VARCHAR2(5 BYTE),
  TELEFONO          VARCHAR2(20 BYTE),
  EXTENSION         INTEGER,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_HOV_LETTER
(
  FI_LETTER_ID             INTEGER              NOT NULL,
  FI_PRODUCT_LETTER_ID     INTEGER              NOT NULL,
  FI_STATE_ID              INTEGER              NOT NULL,
  FI_NOTIFICATION_TYPE_ID  INTEGER              NOT NULL,
  FI_STATUS                INTEGER              NOT NULL,
  FC_USER                  VARCHAR2(30 BYTE)    DEFAULT 'Default'             NOT NULL,
  FI_EMPLOYEE_ID           INTEGER              DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS            VARCHAR2(15 BYTE)    DEFAULT '172.0.0.1'           NOT NULL,
  FI_CENTER_OPERATION      INTEGER              DEFAULT 0                     NOT NULL,
  FD_CREATED_DATE          DATE                 DEFAULT sysdate               NOT NULL,
  FD_MODIFICATION_DATE     DATE                 DEFAULT sysdate               NOT NULL,
  FD_OPERATION_TIME        TIMESTAMP(6)         DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FC_TRANSACTION_NUMBER    VARCHAR2(50 BYTE)    DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_INFOECOYFIN
(
  IDINFOECOYFIN     INTEGER                     NOT NULL,
  IDTITULAR         VARCHAR2(20 BYTE)           NOT NULL,
  FUENTEINGRESOS    VARCHAR2(50 BYTE),
  EMPRESATRABAJO    VARCHAR2(50 BYTE),
  PUESTO            VARCHAR2(50 BYTE),
  TIEMPOLABORADO    VARCHAR2(30 BYTE),
  DIREMPRESA        VARCHAR2(100 BYTE),
  TELEFONO          VARCHAR2(20 BYTE),
  INGMENSUAL        INTEGER,
  EGRMENSUAL        INTEGER,
  SECTEMPRESARIAL   VARCHAR2(50 BYTE),
  PROFUOFICIO       VARCHAR2(50 BYTE),
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_NEGOCIO
(
  IDNEGOCIO         INTEGER                     NOT NULL,
  IDUSUARIO         VARCHAR2(20 BYTE)           NOT NULL,
  NOMBRENEG         VARCHAR2(50 BYTE),
  RFC               VARCHAR2(20 BYTE),
  CALLENEG          VARCHAR2(50 BYTE),
  NUMEXT            VARCHAR2(10 BYTE),
  NUMINT            VARCHAR2(10 BYTE),
  CODPOSTALNEG      VARCHAR2(10 BYTE),
  COLONIANEG        VARCHAR2(50 BYTE),
  ESTADONEG         VARCHAR2(50 BYTE),
  CIUDAD            VARCHAR2(50 BYTE),
  CORREONEG         VARCHAR2(50 BYTE),
  NUMFORM           INTEGER,
  GRABADO           INTEGER                     DEFAULT 0,
  PORCENTAJE        INTEGER                     DEFAULT 0,
  NUMEXTENSION      VARCHAR2(10 BYTE),
  TELNEG            VARCHAR2(20 BYTE),
  SECTORLAB         VARCHAR2(20 BYTE),
  LADA              VARCHAR2(5 BYTE),
  PAGWEB            VARCHAR2(100 BYTE),
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_PERSONAPEXP
(
  IDPERSONAPOLITEXP  INTEGER                    NOT NULL,
  IDTITULAR          VARCHAR2(20 BYTE)          NOT NULL,
  PUESTOTITULAR      VARCHAR2(50 BYTE),
  PUESTOFAMILIAR     VARCHAR2(50 BYTE),
  APATERNO           VARCHAR2(30 BYTE),
  AMATERNO           VARCHAR2(30 BYTE),
  NOMBRE             VARCHAR2(30 BYTE),
  CALLE              VARCHAR2(50 BYTE),
  NUMEXT             VARCHAR2(10 BYTE),
  NUMINT             VARCHAR2(10 BYTE),
  CP                 INTEGER,
  COLONIA            VARCHAR2(50 BYTE),
  ESTADO             VARCHAR2(30 BYTE),
  POBLACION          VARCHAR2(50 BYTE),
  GRABADO            INTEGER                    DEFAULT 0,
  PORCENTAJE         INTEGER                    DEFAULT 0,
  USUARIO_MODIFICO   VARCHAR2(30 BYTE)          NOT NULL,
  FECHA_MODIFICO     DATE                       NOT NULL,
  FUEPPETIT          VARCHAR2(1 BYTE),
  FUEPPEFAM          VARCHAR2(1 BYTE),
  PARENTESCO         VARCHAR2(50 BYTE),
  LADA               VARCHAR2(20 BYTE),
  TELEFONO           VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_PRODUCT_LETTER
(
  FI_PRODUCT_LETTER_ID   INTEGER                NOT NULL,
  FI_STATE_ID            INTEGER                NOT NULL,
  FC_PRODUCT_LETTER      VARCHAR2(30 BYTE)      NOT NULL,
  FC_DESCRIPTION         VARCHAR2(100 BYTE)     NOT NULL,
  FI_STATUS              INTEGER                NOT NULL,
  FC_USER                VARCHAR2(30 BYTE)      DEFAULT 'Default'             NOT NULL,
  FI_EMPLOYEE_ID         INTEGER                DEFAULT 0                     NOT NULL,
  FC_IP_ADDRESS          VARCHAR2(15 BYTE)      DEFAULT '172.0.0.1'           NOT NULL,
  FI_CENTER_OPERATION    INTEGER                DEFAULT 0                     NOT NULL,
  FD_CREATED_DATE        DATE                   DEFAULT sysdate               NOT NULL,
  FD_MODIFICATION_DATE   DATE                   DEFAULT sysdate               NOT NULL,
  FD_OPERATION_TIME      TIMESTAMP(6)           DEFAULT CURRENT_TIMESTAMP     NOT NULL,
  FC_TRANSACTION_NUMBER  VARCHAR2(50 BYTE)      DEFAULT ' '                   NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_TITULAR
(
  IDTITULAR           VARCHAR2(20 BYTE)         NOT NULL,
  EMAIL               VARCHAR2(50 BYTE)         NOT NULL,
  APATERNO            VARCHAR2(50 BYTE),
  PASSWD              VARCHAR2(200 BYTE),
  AMATERNO            VARCHAR2(50 BYTE),
  NOMBRE              VARCHAR2(50 BYTE),
  SEXO                VARCHAR2(10 BYTE),
  EDOCIVIL            VARCHAR2(15 BYTE),
  CURP                VARCHAR2(20 BYTE),
  FENACIMIENTO        DATE,
  NACIONALIDAD        VARCHAR2(30 BYTE),
  RFC                 VARCHAR2(30 BYTE),
  TIPOIDENTIFICACION  VARCHAR2(20 BYTE),
  NUMIDENTIFICACION   VARCHAR2(20 BYTE),
  IMPORTEOPERACION    INTEGER,
  ESTATUSREGISTRO     VARCHAR2(1 BYTE),
  OBSERVACIONES       VARCHAR2(30 BYTE),
  COMENTARIOS         VARCHAR2(30 BYTE),
  TITPOLITEXP         VARCHAR2(2 BYTE),
  FAMPOLITEXP         VARCHAR2(2 BYTE),
  FETERMINO           DATE,
  NUMFORMULARIO       INTEGER,
  GRABADO             INTEGER                   DEFAULT 0,
  PORCENTAJE          INTEGER                   DEFAULT 0,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  FECHA_MODIFICO      DATE                      NOT NULL,
  FECHAREGISTRO       DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_USOCUENTA
(
  IDUSOCUENTA         INTEGER                   NOT NULL,
  IDTITULAR           VARCHAR2(20 BYTE)         NOT NULL,
  ACTIVIDAD           VARCHAR2(50 BYTE),
  SECTLABORAL         VARCHAR2(10 BYTE),
  ACTECONOMICA        VARCHAR2(50 BYTE),
  TRANDEPOSITOS       VARCHAR2(2 BYTE),
  TRANRETIROS         VARCHAR2(2 BYTE),
  TRANTRANSFERENCIAS  VARCHAR2(2 BYTE),
  TRANCVD             VARCHAR2(2 BYTE),
  ORIGENRECURSOS      VARCHAR2(50 BYTE),
  USOCUENTA           VARCHAR2(50 BYTE),
  GRABADO             INTEGER                   DEFAULT 0,
  PORCENTAJE          INTEGER                   DEFAULT 0,
  USUARIO_MODIFICO    VARCHAR2(30 BYTE)         NOT NULL,
  FECHA_MODIFICO      DATE                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_USUARIO
(
  IDUSUARIO         VARCHAR2(20 BYTE)           NOT NULL,
  USUARIO           VARCHAR2(12 BYTE),
  PASSWD            VARCHAR2(255 BYTE),
  FOLIOALNOVA       VARCHAR2(255 BYTE),
  ESTATUS           INTEGER                     DEFAULT 0,
  ESTATUSLOGIN      INTEGER                     DEFAULT 0,
  PORCENTOTAL       INTEGER                     DEFAULT 0,
  USUARIO_MODIFICO  VARCHAR2(30 BYTE)           NOT NULL,
  FECHA_MODIFICO    DATE                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_WU_CONFIRMACION
(
  IDENVIO            NUMBER(22)                 NOT NULL,
  IDUSUARIO          VARCHAR2(25 BYTE)          NOT NULL,
  IDALNOVA           VARCHAR2(25 BYTE)          NOT NULL,
  UID_WU             VARCHAR2(25 BYTE)          NOT NULL,
  IDCU               VARCHAR2(20 BYTE)          NOT NULL,
  IDOPERACION        VARCHAR2(10 BYTE)          NOT NULL,
  NOMBREREMIT        VARCHAR2(12 BYTE)          NOT NULL,
  APELLIDOREMIT      VARCHAR2(20 BYTE)          NOT NULL,
  DIRECCIONREMIT     VARCHAR2(100 BYTE)         NOT NULL,
  ESTADOREMIT        VARCHAR2(24 BYTE)          NOT NULL,
  TELREMIT           VARCHAR2(15 BYTE)          NOT NULL,
  BENEFNOMBRE        VARCHAR2(25 BYTE)          NOT NULL,
  BENEFAPELLIDOS     VARCHAR2(45 BYTE)          NOT NULL,
  PRINCIPAL          VARCHAR2(11 BYTE)          NOT NULL,
  TOTALPAGO          VARCHAR2(11 BYTE)          NOT NULL,
  MONTOPAGO          VARCHAR2(11 BYTE)          NOT NULL,
  PAISORIGEN         VARCHAR2(2 BYTE)           NOT NULL,
  MONEDAORIGEN       VARCHAR2(3 BYTE)           NOT NULL,
  PAISDESTINO        VARCHAR2(2 BYTE)           NOT NULL,
  PAISDESTINOESTADO  VARCHAR2(50 BYTE)          NOT NULL,
  MTCN               VARCHAR2(10 BYTE)          NOT NULL,
  FECHAULTMODIF      TIMESTAMP(6)               DEFAULT SYSDATE               NOT NULL,
  CUENTACARGO        VARCHAR2(20 BYTE)          NOT NULL,
  USRMODIF           VARCHAR2(20 BYTE)          NOT NULL,
  IDAPLIC            VARCHAR2(10 BYTE)          NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TA_WU_CONFIRMACION1
(
  ID                   NUMBER(22)               NOT NULL,
  IDUSUARIO            VARCHAR2(25 BYTE)        NOT NULL,
  IDALNOVA             VARCHAR2(25 BYTE)        NOT NULL,
  FCUID                VARCHAR2(25 BYTE)        NOT NULL,
  FCIDCU               VARCHAR2(20 BYTE)        NOT NULL,
  FCIDOPERACION        VARCHAR2(10 BYTE)        NOT NULL,
  FCSUCURSAL           VARCHAR2(5 BYTE)         NOT NULL,
  FCCAJA               VARCHAR2(2 BYTE)         NOT NULL,
  FCPAIS               VARCHAR2(3 BYTE)         NOT NULL,
  FCCANAL              VARCHAR2(10 BYTE)        NOT NULL,
  FCNOMBREREMIT        VARCHAR2(12 BYTE)        NOT NULL,
  FCAPELLIDOREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCDIRECCIONREMIT     VARCHAR2(100 BYTE)       NOT NULL,
  FCCPREMIT            VARCHAR2(5 BYTE)         NOT NULL,
  FCPOBLACIONREMIT     VARCHAR2(24 BYTE)        NOT NULL,
  FCESTADOREMIT        VARCHAR2(24 BYTE)        NOT NULL,
  FCTELREMIT           VARCHAR2(15 BYTE)        NOT NULL,
  FCFECHNACREMIT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPOIDREMIT        VARCHAR2(3 BYTE)         NOT NULL,
  FCFOLIOREMIT         VARCHAR2(15 BYTE)        NOT NULL,
  FCFECHVENCREMIT      VARCHAR2(8 BYTE)         NOT NULL,
  FCIDEMISORREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONALREMIT      VARCHAR2(20 BYTE)        NOT NULL,
  FCPAISREMIT          VARCHAR2(2 BYTE)         NOT NULL,
  FCLUGARNACREMIT      VARCHAR2(44 BYTE)        NOT NULL,
  FCNACIONAL           VARCHAR2(10 BYTE)        NOT NULL,
  FCOCUPACION          VARCHAR2(20 BYTE)        NOT NULL,
  FCACUSERECIBO        VARCHAR2(3 BYTE)         NOT NULL,
  FCBENEFNOMBRE        VARCHAR2(25 BYTE)        NOT NULL,
  FCBENEFAPELLIDOS     VARCHAR2(45 BYTE)        NOT NULL,
  FCPRINCIPAL          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGO              VARCHAR2(11 BYTE)        NOT NULL,
  FCIMPUESTO           VARCHAR2(11 BYTE)        NOT NULL,
  FCDESCUENTO          VARCHAR2(11 BYTE)        NOT NULL,
  FCCARGOMENSAJE       VARCHAR2(11 BYTE)        NOT NULL,
  FCTOTALPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCMONTOPAGO          VARCHAR2(11 BYTE)        NOT NULL,
  FCPAISORIGEN         VARCHAR2(2 BYTE)         NOT NULL,
  FCMONEDAORIGEN       VARCHAR2(3 BYTE)         NOT NULL,
  FCPAISDESTINO        VARCHAR2(2 BYTE)         NOT NULL,
  FCPAISDESTINOPOBLAC  VARCHAR2(50 BYTE)        NOT NULL,
  FCPAISDESTINOESTADO  VARCHAR2(50 BYTE)        NOT NULL,
  FCMONEDADESTINO      VARCHAR2(3 BYTE)         NOT NULL,
  FCPAGARSINID         VARCHAR2(1 BYTE)         NOT NULL,
  FCPREGUNTA           VARCHAR2(35 BYTE)        NOT NULL,
  FCRESPUESTA          VARCHAR2(35 BYTE)        NOT NULL,
  FCMENSAJE            VARCHAR2(200 BYTE)       NOT NULL,
  FCMTCN               VARCHAR2(10 BYTE)        NOT NULL,
  FCREFERENCIANO       VARCHAR2(16 BYTE)        NOT NULL,
  FCOPERADOR           VARCHAR2(12 BYTE)        NOT NULL,
  FCOPERADORNOMBRE     VARCHAR2(25 BYTE)        NOT NULL,
  FCOPERADORAPPATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCOPERADORAPMATERNO  VARCHAR2(15 BYTE)        NOT NULL,
  FCIDSISTEMAEXT       VARCHAR2(8 BYTE)         NOT NULL,
  FCTIPONOMBREREMIT    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPONOMBREBENEF    VARCHAR2(1 BYTE)         NOT NULL,
  FCTIPOTRANFDINERO    VARCHAR2(3 BYTE)         NOT NULL,
  FCIDTARJETALEALTAD   VARCHAR2(3 BYTE)         NOT NULL,
  FCENVIOTERCEROS      VARCHAR2(1 BYTE)         NOT NULL,
  FCEXPIRADO           VARCHAR2(1 BYTE)         NOT NULL,
  FCUSUARIO            VARCHAR2(15 BYTE)        NOT NULL,
  FCPASSWORD           VARCHAR2(15 BYTE)        NOT NULL,
  FDFECHATRANSACCION   TIMESTAMP(6)             DEFAULT SYSDATE               NOT NULL,
  FCXML                VARCHAR2(3000 BYTE)      NOT NULL,
  FCNORETENCION        VARCHAR2(15 BYTE)        NOT NULL,
  FCTCORIGEN           VARCHAR2(20 BYTE)        NOT NULL,
  FCTCDESTINO          VARCHAR2(20 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TDCFRECUENT
(
  CLIENT              NUMBER(8)                 NOT NULL,
  DESTINO             VARCHAR2(18 BYTE)         NOT NULL,
  BANCO               VARCHAR2(30 BYTE)         NOT NULL,
  NOMBRE              VARCHAR2(100 BYTE)        NOT NULL,
  STATUS              NUMBER                    NOT NULL,
  FECHA_MODIFICACION  DATE                      NOT NULL,
  IP_ORIGEN           VARCHAR2(30 BYTE),
  ALIAS               VARCHAR2(30 BYTE),
  CANAL               VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEFSPEUAFRECUENT
(
  CLIENT              NUMBER(8)                 NOT NULL,
  BANK                NUMBER(3)                 NOT NULL,
  STATE               NUMBER(2)                 NOT NULL,
  PLAZA               NUMBER(2)                 NOT NULL,
  DESTINO             VARCHAR2(18 BYTE)         NOT NULL,
  NAME                VARCHAR2(40 BYTE),
  STATUS              INTEGER,
  FECHA_MODIFICACION  DATE,
  IP_ORIGEN           VARCHAR2(30 BYTE),
  EMAIL               VARCHAR2(50 BYTE),
  CELULAR             VARCHAR2(20 BYTE),
  TELCASA             VARCHAR2(20 BYTE),
  TELOFICINA          VARCHAR2(20 BYTE),
  EXTENSION           VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TELEFONO
(
  CLIENTE_ID   NUMBER(8)                        NOT NULL,
  TELEFONO_ID  NUMBER(20)                       NOT NULL,
  CARRIER_ID   NUMBER(2)                        NOT NULL,
  FECHA        DATE                             NOT NULL,
  STATUS       NUMBER(1)                        NOT NULL,
  CLAVE        NUMBER(10),
  SECUENCIA    NUMBER,
  CANAL        VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TELMEX
(
  USER_ID               NUMBER(8)               NOT NULL,
  TELEFONO              VARCHAR2(20 BYTE)       NOT NULL,
  ULTIMA_ACTUALIZACION  DATE,
  STATUS                VARCHAR2(2 BYTE),
  CANAL                 VARCHAR2(3 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEMP
(
  NUM_CLIENTE         VARCHAR2(10 BYTE),
  NUMERO_SERIE_TOKEN  VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEMP1
(
  USER_ID               NUMBER,
  CELLULAR_OLD          VARCHAR2(16 BYTE),
  EMAIL_OLD             VARCHAR2(50 BYTE),
  CELLULAR_CHANGE_DATE  DATE,
  TELEFONO_ALTERNO_OLD  VARCHAR2(16 BYTE),
  ALTERNO_CHANGE_DATE   DATE,
  EMAIL_CHANGE_DATE     DATE,
  QUESTION_CHANGE_DATE  DATE,
  ANSWER_CHANGE_DATE    DATE
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEMPORALHUELLAS
(
  FCID_BIOMETRICO   VARCHAR2(30 BYTE),
  FCHUELLA_DIGITAL  VARCHAR2(4000 BYTE),
  FIMANO            VARCHAR2(30 BYTE),
  FIDEDO            VARCHAR2(30 BYTE),
  STATUS            NUMBER                      DEFAULT 0,
  NOMBRE            VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEMP_CINEPOLIS
(
  FECHA       DATE,
  CUENTA      VARCHAR2(14 BYTE),
  OPERACION   VARCHAR2(20 BYTE),
  REFERENCIA  VARCHAR2(40 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TERCEROSFRECUENT
(
  CLIENT              NUMBER(8)                 NOT NULL,
  DESTINO             VARCHAR2(14 BYTE)         NOT NULL,
  NAME                VARCHAR2(40 BYTE),
  STATUS              INTEGER,
  FECHA_MODIFICACION  DATE,
  IP_ORIGEN           VARCHAR2(15 BYTE),
  EMAIL               VARCHAR2(50 BYTE),
  CELULAR             VARCHAR2(20 BYTE),
  TELCASA             VARCHAR2(20 BYTE),
  TELOFICINA          VARCHAR2(20 BYTE),
  EXTENSION           VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TESET_TA_WU_CONFIRMACION
(
  FCUID  VARCHAR2(25 BYTE)                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEST2_TA_WU_CONFIRMACION
(
  FCUID  VARCHAR2(25 BYTE)                      NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TESTCURSO
(
  ID         NUMBER                             NOT NULL,
  NOMBRE     VARCHAR2(30 BYTE)                  NOT NULL,
  APELLIDOP  VARCHAR2(30 BYTE),
  APELLIDOM  VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
MONITORING;


CREATE TABLE TEST_RMASMS
(
  SMSKEY          NUMBER(10)                    NOT NULL,
  ACCOUNT_NUMBER  VARCHAR2(20 BYTE),
  PHONE           VARCHAR2(20 BYTE),
  CARRIER         VARCHAR2(20 BYTE),
  STATUS          VARCHAR2(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEST_SPECIAL_CHARACTERS
(
  ID      NUMBER(6)                             NOT NULL,
  NOMBRE  VARCHAR2(40 BYTE)                     NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEST_USUARIO
(
  USERNAME  VARCHAR2(20 BYTE)                   NOT NULL,
  PASSWORD  VARCHAR2(20 BYTE)                   NOT NULL,
  STATUS    INTEGER                             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TEST_USUARIO_ROL
(
  USERNAME  VARCHAR2(20 BYTE)                   NOT NULL,
  ROL       VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIEMPOAIRE_APLICACION
(
  NOMBRE               VARCHAR2(50 BYTE)        NOT NULL,
  CANAL                CHAR(4 BYTE)             NOT NULL,
  NUMERO_TIENDA        CHAR(4 BYTE)             NOT NULL,
  NUMERO_CAJA          CHAR(10 BYTE)            NOT NULL,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIEMPOAIRE_STATUS
(
  STATUS               CHAR(1 BYTE),
  DESCRIPCION          VARCHAR2(200 BYTE),
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIEMPOAIRE_TYPE
(
  TYPE                 CHAR(2 BYTE)             NOT NULL,
  DESCRIPTION          VARCHAR2(150 BYTE)       NOT NULL,
  CARRIER              VARCHAR2(50 BYTE)        NOT NULL,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIEMPO_AIRE_LOG
(
  CARRIER             VARCHAR2(20 BYTE)         NOT NULL,
  ABONO_SOCK          VARCHAR2(200 BYTE)        NOT NULL,
  RESP_ABONO_SOCK     VARCHAR2(200 BYTE),
  REVERSO_SOCK        VARCHAR2(200 BYTE),
  RESP_REVERSO_SOCK   VARCHAR2(200 BYTE),
  SP_ELEKTRAE         VARCHAR2(200 BYTE),
  RESP_SP_ELEKTRAE    VARCHAR2(400 BYTE),
  TXN                 VARCHAR2(3000 BYTE),
  RESP_TXN            VARCHAR2(3000 BYTE),
  ESTADO              NUMBER(2)                 NOT NULL,
  FECHA               DATE                      DEFAULT SYSDATE               NOT NULL,
  RETENCION           VARCHAR2(3000 BYTE),
  RESP_RETENCION      VARCHAR2(3000 BYTE),
  LIBERACION          VARCHAR2(3000 BYTE),
  RESP_LIBERACION     VARCHAR2(3000 BYTE),
  NAVEGACION_DESC     VARCHAR2(50 BYTE),
  NUMERO_TRANSACCION  NUMBER,
  CUENTA              VARCHAR2(20 BYTE),
  MONTO               NUMBER,
  NOMBRE_CLIENTE      VARCHAR2(200 BYTE),
  TELEFONO            VARCHAR2(20 BYTE),
  RESP_COMPLETASOCK   VARCHAR2(3000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIPO_TRANSFERENCIAS
(
  ID           NUMBER(2)                        NOT NULL,
  DESCRIPCION  VARCHAR2(20 BYTE)                NOT NULL,
  STATUS       NUMBER(1)                        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TIP_BENEFI_DEX
(
  ID_TIPO      NUMBER                           NOT NULL,
  DESCRIPCION  VARCHAR2(150 BYTE)               NOT NULL,
  ESTATUS      NUMBER                           NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TMP_CINE_PAGOSERVICIOS
(
  FECHA       DATE,
  EMISOR      VARCHAR2(5 BYTE),
  CUENTA      VARCHAR2(14 BYTE),
  MONTO       FLOAT(126),
  USUARIO     VARCHAR2(8 BYTE),
  MEDIOPAGO   VARCHAR2(1 BYTE),
  REFERENCIA  VARCHAR2(40 BYTE),
  LIQUIDADAS  VARCHAR2(1 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TMP_HUELLA
(
  CLIENTE           VARCHAR2(30 BYTE),
  FCID_BIOMETRICO   VARCHAR2(30 BYTE),
  FCHUELLA_DIGITAL  VARCHAR2(4000 BYTE),
  FIMANO            VARCHAR2(30 BYTE),
  FIDEDO            VARCHAR2(30 BYTE),
  SUCURSAL          VARCHAR2(4 BYTE),
  CUENTA            VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TMP_HUELLA_MONTOS
(
  CLIENTE           VARCHAR2(30 BYTE),
  FCID_BIOMETRICO   VARCHAR2(30 BYTE),
  FIMANO            VARCHAR2(30 BYTE),
  FIDEDO            VARCHAR2(30 BYTE),
  FCHUELLA_DIGITAL  VARCHAR2(4000 BYTE)         NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TMP_PRUEBA
(
  TOTAL_CONSUL  VARCHAR2(25 BYTE),
  MONTO_CONSUL  VARCHAR2(25 BYTE)
)
LOGGING 
NOCACHE
PARALLEL ( DEGREE DEFAULT INSTANCES DEFAULT )
NOMONITORING;


CREATE TABLE TOAD_PLAN_SQL
(
  USERNAME      VARCHAR2(30 BYTE),
  STATEMENT_ID  VARCHAR2(32 BYTE),
  TIMESTAMP     DATE,
  STATEMENT     VARCHAR2(2000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOAD_PLAN_TABLE
(
  STATEMENT_ID       VARCHAR2(30 BYTE),
  PLAN_ID            NUMBER,
  TIMESTAMP          DATE,
  REMARKS            VARCHAR2(4000 BYTE),
  OPERATION          VARCHAR2(30 BYTE),
  OPTIONS            VARCHAR2(255 BYTE),
  OBJECT_NODE        VARCHAR2(128 BYTE),
  OBJECT_OWNER       VARCHAR2(30 BYTE),
  OBJECT_NAME        VARCHAR2(30 BYTE),
  OBJECT_ALIAS       VARCHAR2(65 BYTE),
  OBJECT_INSTANCE    INTEGER,
  OBJECT_TYPE        VARCHAR2(30 BYTE),
  OPTIMIZER          VARCHAR2(255 BYTE),
  SEARCH_COLUMNS     NUMBER,
  ID                 INTEGER,
  PARENT_ID          INTEGER,
  DEPTH              INTEGER,
  POSITION           INTEGER,
  COST               INTEGER,
  CARDINALITY        INTEGER,
  BYTES              INTEGER,
  OTHER_TAG          VARCHAR2(255 BYTE),
  PARTITION_START    VARCHAR2(255 BYTE),
  PARTITION_STOP     VARCHAR2(255 BYTE),
  PARTITION_ID       INTEGER,
  OTHER              LONG,
  DISTRIBUTION       VARCHAR2(30 BYTE),
  CPU_COST           INTEGER,
  IO_COST            INTEGER,
  TEMP_SPACE         INTEGER,
  ACCESS_PREDICATES  VARCHAR2(4000 BYTE),
  FILTER_PREDICATES  VARCHAR2(4000 BYTE),
  PROJECTION         VARCHAR2(4000 BYTE),
  TIME               INTEGER
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOKEN_DISP
(
  ID_ACT_DISPOSITIVO     NUMBER(7)              NOT NULL,
  ID_ALNOVA              VARCHAR2(8 BYTE)       NOT NULL,
  SEMILLA                VARCHAR2(50 BYTE),
  ESTADO                 CHAR(1 BYTE)           NOT NULL,
  DESFASE                NUMBER,
  SINCRONIZACIONES       NUMBER                 NOT NULL,
  FECHA_SOLICITUD        DATE                   NOT NULL,
  FECHA_ACTIVACION       DATE,
  SISTEMA                VARCHAR2(25 BYTE),
  PAIS                   VARCHAR2(3 BYTE),
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  USUARIO_MODIFICO       VARCHAR2(30 BYTE)      NOT NULL,
  CONTRATO_FIRMADO       CHAR(1 BYTE)           DEFAULT 0,
  ULTIMA_SINCRONIZACION  DATE                   DEFAULT '19-12-2011'          NOT NULL,
  CORREO_ELECTONICO      VARCHAR2(40 BYTE),
  NUM_MODELO             VARCHAR2(20 BYTE)      DEFAULT '100'                 NOT NULL,
  NUM_TELEFONO           VARCHAR2(15 BYTE),
  SOPERATIVO             VARCHAR2(25 BYTE)      DEFAULT 'iOS, Android, Bberry' NOT NULL,
  VERSION                VARCHAR2(8 BYTE)       DEFAULT '1.0'                 NOT NULL,
  TIPO                   NUMBER                 DEFAULT 1                     NOT NULL,
  SEM_ENCRIPTADA         VARCHAR2(132 BYTE)     DEFAULT '0'
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOKEN_DISP_PC
(
  ID_ACT_DISPOSITIVO     NUMBER(7)              NOT NULL,
  ID_ALNOVA              VARCHAR2(8 BYTE)       NOT NULL,
  SEMILLA                VARCHAR2(50 BYTE)      NOT NULL,
  ESTADO                 CHAR(1 BYTE)           NOT NULL,
  DESFASE                NUMBER,
  SINCRONIZACIONES       NUMBER                 NOT NULL,
  FECHA_SOLICITUD        DATE                   NOT NULL,
  FECHA_ACTIVACION       DATE,
  SISTEMA                VARCHAR2(25 BYTE),
  PAIS                   VARCHAR2(3 BYTE),
  ULTIMA_MODIFICACION    DATE                   NOT NULL,
  USUARIO_MODIFICO       VARCHAR2(30 BYTE)      NOT NULL,
  CONTRATO_FIRMADO       CHAR(1 BYTE)           DEFAULT 0,
  ULTIMA_SINCRONIZACION  DATE                   DEFAULT SYSDATE               NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOKEN_ENV_SMS
(
  ID_SMS               NUMBER(8)                NOT NULL,
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  NUM_CEL              VARCHAR2(10 BYTE)        NOT NULL,
  CARRIER              VARCHAR2(3 BYTE)         NOT NULL,
  STATUS               NUMBER(2)                NOT NULL,
  TIEMPO_ENVIO         DATE                     NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOKEN_HIST
(
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  TOKEN                VARCHAR2(8 BYTE)         NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TOKEN_HIST_PC
(
  ID_ALNOVA            VARCHAR2(8 BYTE)         NOT NULL,
  TOKEN                VARCHAR2(8 BYTE)         NOT NULL,
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANSCOPE_BITA
(
  CUENTA          VARCHAR2(20 BYTE)             NOT NULL,
  TARJETAVIRTUAL  VARCHAR2(20 BYTE)             NOT NULL,
  IDALNOVA        VARCHAR2(20 BYTE)             NOT NULL,
  CLIENTEUNICO    VARCHAR2(20 BYTE)             NOT NULL,
  NOMBREAPLIC     VARCHAR2(20 BYTE)             NOT NULL,
  TIPOCUENTA      VARCHAR2(3 BYTE),
  FECHAULTMODIF   TIMESTAMP(6)                  DEFAULT SYSDATE               NOT NULL,
  USRMODIF        VARCHAR2(20 BYTE)             NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANSFER_DEX
(
  CLIENTE_ID           NUMBER(20)               NOT NULL,
  MTCN                 VARCHAR2(80 BYTE)        NOT NULL,
  MONTO_ENVIADO        NUMBER(12,2)             NOT NULL,
  BENEFICIARIO_ID      NUMBER(20)               NOT NULL,
  TARIFA               NUMBER(12,2)             NOT NULL,
  NUM_CUENTA           VARCHAR2(50 BYTE)        NOT NULL,
  FECHA_ENVIO          DATE                     DEFAULT NULL                  NOT NULL,
  FOLIO_RETENCION      VARCHAR2(50 BYTE)        DEFAULT NULL                  NOT NULL,
  PAIS_ID_DESTINO      NUMBER(3),
  ESTADO_ID_DESTINO    NUMBER(3),
  CIUDAD_ID_DESTINO    NUMBER(3),
  ID_MONEDA_ENVIO      NUMBER(3),
  ID_MONEDA_DESTINO    NUMBER(3),
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANSFER_DEX2
(
  CLIENTE_ID           NUMBER(20)               NOT NULL,
  MTCN                 VARCHAR2(80 BYTE)        NOT NULL,
  MONTO_ENVIADO        NUMBER(12,2)             NOT NULL,
  BENEFICIARIO_ID      NUMBER(20)               NOT NULL,
  TARIFA               NUMBER(12,2)             NOT NULL,
  NUM_CUENTA           VARCHAR2(50 BYTE)        NOT NULL,
  FECHA_ENVIO          DATE                     DEFAULT NULL                  NOT NULL,
  FOLIO_RETENCION      VARCHAR2(50 BYTE)        DEFAULT NULL                  NOT NULL,
  PAIS_ID_DESTINO      NUMBER(3),
  ESTADO_ID_DESTINO    NUMBER(3),
  CIUDAD_ID_DESTINO    NUMBER(3),
  ID_MONEDA_ENVIO      NUMBER(3),
  ID_MONEDA_DESTINO    NUMBER(3),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(50 BYTE)        NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANSFER_WU
(
  CU                   VARCHAR2(50 BYTE)        DEFAULT NULL                  NOT NULL,
  MTCN                 VARCHAR2(80 BYTE)        NOT NULL,
  MONTO_ENVIADO        NUMBER(12,2)             NOT NULL,
  ID_BENEFICIARIO      VARCHAR2(50 BYTE)        NOT NULL,
  ID_COTIZACION        VARCHAR2(80 BYTE)        NOT NULL,
  TARIFA               NUMBER(12,2),
  NUM_CUENTA           VARCHAR2(50 BYTE)        NOT NULL,
  FECHA_ENVIO          DATE                     DEFAULT NULL                  NOT NULL,
  PAIS_ID_DESTINO      VARCHAR2(30 BYTE),
  ESTADO_ID_DESTINO    VARCHAR2(30 BYTE)        DEFAULT NULL,
  CIUDAD_DESTINO       VARCHAR2(150 BYTE)       DEFAULT NULL                  NOT NULL,
  ID_MONEDA_ENVIO      VARCHAR2(30 BYTE),
  ID_MONEDA_DESTINO    VARCHAR2(30 BYTE),
  ULTIMA_MODIFICACION  DATE                     NOT NULL,
  USUARIO_MODIFICO     VARCHAR2(50 BYTE)        NOT NULL,
  ID_BENEFICIARIO_WU   VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANSFINTERNALFRECUENT
(
  CLIENT              NUMBER(8)                 NOT NULL,
  DESTINO             VARCHAR2(34 BYTE)         NOT NULL,
  NAME                VARCHAR2(40 BYTE),
  STATUS              NUMBER(38),
  FECHA_MODIFICACION  DATE,
  IP_ORIGEN           VARCHAR2(15 BYTE),
  CLAVE_SWIFT         VARCHAR2(11 BYTE),
  CANAL               VARCHAR2(3 BYTE),
  APELLIDO_PATERNO    VARCHAR2(50 BYTE),
  APELLIDO_MATERNO    VARCHAR2(50 BYTE),
  LUGAR_NACIMIENTO    VARCHAR2(50 BYTE),
  DOMICILIO           VARCHAR2(50 BYTE),
  STATUS_BLOQUEO      NUMBER(2)                 DEFAULT 2,
  FECHA_NACIMIENTO    DATE,
  FECHA_ACTIVACION    DATE                      DEFAULT SYSDATE,
  TIPO_PERSONA        NUMBER(2)                 DEFAULT 1,
  RFC                 VARCHAR2(45 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANS_CAT_ESTADOS
(
  IDESTADO  NUMBER                              NOT NULL,
  ESTADO    VARCHAR2(30 BYTE)                   NOT NULL,
  DETALLE   VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANS_HISTORIAL_PROCESO
(
  ID_HIST_PROCESO         NUMBER(22)            NOT NULL,
  FECHA_ARRANQUE          DATE                  NOT NULL,
  FECHA_FINALIZADO        DATE,
  DESCRIPCION_FINALIZADO  VARCHAR2(200 BYTE),
  CORREO                  VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANS_PROGRAMADAS
(
  ID_TRANS_PROG               NUMBER(38)        NOT NULL,
  ID_ALNOVA                   VARCHAR2(11 BYTE) NOT NULL,
  ALIAS                       VARCHAR2(20 BYTE),
  ID_OPERACION                NUMBER            NOT NULL,
  CTA_ORIGEN                  VARCHAR2(50 BYTE) NOT NULL,
  CTA_DESTINO                 VARCHAR2(50 BYTE) NOT NULL,
  BANCO_DESTINO               VARCHAR2(15 BYTE),
  MONTO                       NUMBER(30,2)      NOT NULL,
  ESTADO                      NUMBER            NOT NULL,
  CORREO                      VARCHAR2(70 BYTE),
  LLAVE_VALOR                 VARCHAR2(3500 BYTE) NOT NULL,
  FECHA_PROGRAMADA            DATE              NOT NULL,
  FECHA_EJECUCION             DATE,
  ID_FRECUENTE                VARCHAR2(11 BYTE),
  FECHA_REGISTRO_FRECUENTE    DATE              NOT NULL,
  FECHA_ACTIVACION_FRECUENTE  DATE              NOT NULL,
  USUARIO_MODIFICO            VARCHAR2(20 BYTE),
  DESCRIPCION_RESPUESTA       VARCHAR2(300 BYTE),
  ULTIMA_MODIFICACION         DATE              DEFAULT SYSDATE               NOT NULL,
  IP                          VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANS_PROGRAMADAS_ADICIONALES
(
  ID_ADICIONALES     NUMBER(38)                 NOT NULL,
  ID_TRANS_PROG      NUMBER(38)                 NOT NULL,
  HUELLA             VARCHAR2(4000 BYTE),
  OBJ_TRANSACCIONAL  VARCHAR2(2000 BYTE),
  TOKEN              VARCHAR2(10 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE TRANS_PROG_BITACORA
(
  ID_BITACORA      NUMBER(38)                   NOT NULL,
  ID_TRANS_PROG    NUMBER(38)                   NOT NULL,
  NUM_CLIENTE      NUMBER(38)                   NOT NULL,
  TIPO_OPERACION   VARCHAR2(10 BYTE)            NOT NULL,
  IP               VARCHAR2(20 BYTE)            NOT NULL,
  CTA_ORIGEN       VARCHAR2(30 BYTE),
  CTA_DESTINO      VARCHAR2(20 BYTE),
  FECHA_OPERACION  DATE                         DEFAULT SYSDATE               NOT NULL,
  MONTO            NUMBER(30)                   NOT NULL,
  FOLIO            VARCHAR2(70 BYTE)            NOT NULL,
  METODO_CONFIR    NUMBER(38),
  DETALLE          VARCHAR2(400 BYTE)           NOT NULL,
  NOMBRE_CLIENTE   VARCHAR2(90 BYTE),
  DETALLE2         VARCHAR2(400 BYTE),
  APLICACION       VARCHAR2(20 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE "TipoCambio"
(
  ID           VARCHAR2(15 BYTE)                NOT NULL,
  VALOR        NUMBER(3,2)                      NOT NULL,
  CAMBIO       NUMBER(3,2)                      NOT NULL,
  FECHA_HORA   TIMESTAMP(6)                     NOT NULL,
  TIPO_MONEDA  VARCHAR2(30 BYTE)                NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE USERTERMINAL
(
  USUARIO   VARCHAR2(10 BYTE),
  TERMINAL  VARCHAR2(4 BYTE),
  PROD      VARCHAR2(2 BYTE),
  SPROD     VARCHAR2(4 BYTE),
  ENTITY    VARCHAR2(4 BYTE),
  BRANCH    VARCHAR2(4 BYTE),
  CHANNEL   VARCHAR2(2 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE USRUPDTERM
(
  ID_USR_CLIENTE  VARCHAR2(30 BYTE),
  MAQUINA_USR_CL  VARCHAR2(64 BYTE),
  VALOR_BUSY_MOD  VARCHAR2(2 BYTE),
  VALOR_CODE_MOD  VARCHAR2(5 BYTE),
  REGS_MOD_TIMER  DATE,
  TIME_REGST_MOD  VARCHAR2(60 BYTE),
  CONSULTA_EJECT  VARCHAR2(150 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE USR_REGISTRO_DEX
(
  ID_CLIENTE_DEX  NUMBER(20),
  STATUS_PERSONA  NUMBER(2),
  STATUS_CELULAR  NUMBER(2)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE USUARIO
(
  ID_USUARIO  NUMBER(10),
  NOMBRE      VARCHAR2(40 BYTE)                 NOT NULL,
  USUARIO     VARCHAR2(40 BYTE)                 NOT NULL,
  CONTRASENA  VARCHAR2(30 BYTE)                 NOT NULL,
  TELEFONO    VARCHAR2(30 BYTE)                 NOT NULL
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE VENTA_ACCIONES_LOG
(
  NUM_CLIENTE     VARCHAR2(10 BYTE)             NOT NULL,
  FECHA           VARCHAR2(20 BYTE)             NOT NULL,
  TX_COMPRA       VARCHAR2(1000 BYTE),
  TX_COMPRA_RESP  VARCHAR2(1000 BYTE),
  COMPRA          VARCHAR2(1000 BYTE),
  COMPRA_RESP     VARCHAR2(1000 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE VW_DIR_SUC
(
  NOMBSUC       VARCHAR2(30 BYTE),
  NUMECO        INTEGER,
  DIRECCION     VARCHAR2(30 BYTE),
  IDESTADO      INTEGER,
  IDMUNICIPIO   INTEGER,
  LATITUD       FLOAT(126),
  LONGITUD      FLOAT(126),
  IDESTATUSSUC  INTEGER,
  CODIGO        VARCHAR2(8 BYTE),
  NOMSUCARCH    VARCHAR2(30 BYTE),
  RUTAALMSUC    VARCHAR2(50 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE VW_EDO_MUN_PRESENCIA
(
  IDESTADO     INTEGER,
  NOMBESTADO   VARCHAR2(50 BYTE),
  IDMUNICIPIO  INTEGER,
  MUNICIPIO    VARCHAR2(100 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE TABLE WEBSERVICE_LOG
(
  ID                   NUMBER(15)               NOT NULL,
  HOSTNAME             VARCHAR2(150 BYTE)       NOT NULL,
  IP                   VARCHAR2(150 BYTE)       NOT NULL,
  BEGIN_DATE           DATE                     NOT NULL,
  HTTP_REQUEST         VARCHAR2(1000 BYTE)      NOT NULL,
  REQUEST              VARCHAR2(4000 BYTE)      NOT NULL,
  END_DATE             DATE,
  RESPONSE             VARCHAR2(4000 BYTE),
  NOMBRE               VARCHAR2(100 BYTE)       DEFAULT 'TiempoAire'          NOT NULL,
  ULTIMA_MODIFICACION  DATE,
  USUARIO_MODIFICO     VARCHAR2(30 BYTE)
)
LOGGING 
NOCACHE
NOPARALLEL
NOMONITORING;


CREATE INDEX ACTIVACION_IDX ON EBANKING_ACTIVATION
(ACTIVACION)
LOGGING
NOPARALLEL;


CREATE INDEX ACTIVATION_STATUS_IDX ON EBANKING_ACTIVATION
(STATUS)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX ALERTAS_BAZ_PK ON ALERTAS_BAZ
(ID_ALERTA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX ALERTAS_TEST_PK ON ALERTAS_TEST
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX BIT_REF_FAM_PK ON BIT_REF_FAM
(ID_DISPOSITIVO)
LOGGING
NOPARALLEL;


CREATE INDEX BIT_REF_TOKEN_NUM_CTE ON BIT_REF_TOKEN
(NUM_CLIENTE)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CNTPAGMOV_ID ON PAGO_MOVIL_ACT
(ID_ACT_PAGMOV)
LOGGING
NOPARALLEL;


CREATE INDEX CONSULTA_SPEI_PROGRAMADO ON SCHEDULED_PAYMENT
(USER_ID, TX_NAME, PROGRAM_DATE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_CLIENTES ON REPO_CLIENTES
(ID_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_FIAR_CLIENTES_RESP ON FIAR_CLIENTES_RESP
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_FIAR_RESPUESTAS ON FIAR_RESPUESTAS
(ID_RESPUESTA, ID_PREGUNTA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_FIAR_STATUS_CLIENTES_RESP ON FIAR_STATUS_CLIENTES_RESP
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_ID_CONSECUTIVO ON CTAS_OCULTAS
(ID_CONSECUTIVO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX CPK_REPO_TASA_PLAZO ON REPO_TASA_PLAZO
(ID_TASA_PLAZO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_CLIP_EEC_PK ON EBANKING_CLIP_EEC_OTRONOMBRE
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_IDHIST_PK ON HIST_CUENTA_SMS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_ID_PK ON ACTIVACION_SMS
(ID_CLIENTE)
LOGGING
NOPARALLEL;


CREATE INDEX EBANKING_MAX_AMOUNT_H_PK ON EBANKING_SECURITY_MAX_AMOUNT_H
(IDUSER)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_USER_CERT_VIP_PK ON EBANKING_USER_CERT_VIP
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_USER_PK ON EBANKING_USER
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX EBANKING_USER_STATUS_H_PK ON EBANKING_USER_STATUS_H
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX EBANKING_USER_STATUS_PK ON EBANKING_USER_STATUS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX FIAR_PREGUNTAS_PK ON FIAR_PREGUNTAS
(ID_PREGUNTA)
LOGGING
NOPARALLEL;


CREATE INDEX FIR_EMICTA_DX ON FIRMA_EMISORES
(CLIENTE_ALNOVA)
LOGGING
NOPARALLEL;


CREATE INDEX FIR_EMISER_DX ON FIRMA_EMISORES
(ID_SERVICIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX FIR_EMI_DX ON FIRMA_EMISORES
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX HUELLA_IDX ON HUELLAS_REG
(CTE_ALNOVA, HUELLA_HASH)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDFREC_INDEX ON ALL_FRECUENTES
(ID_FRECUENTES)
LOGGING
NOPARALLEL;


CREATE INDEX IDXAPLICACION ON M_USUARIOS
(APLICACION)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDXBENEFWU ON BENEFICIARIOWU
(CU, ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDXBENEF_WU ON BENEFICIARIOWU
(ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDXCAMBIOPWDUSERID ON EBANKING_CAMBIO_PWD
(USER_ID)
LOGGING
NOPARALLEL;


CREATE INDEX IDXFK_ID_TRACKING ON M_TRACKING_DETALLE
(IDTRACKING)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDXFK_USUARIO_OPERACION ON M_TRACKING
(ID_USUARIO_OPERACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDXIDBLOQ ON BLOQUEOINAC_H
(ID_BLOQUEO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDXOPERACIONES ON M_USUARIOS_OPERACIONES
(OPERACION)
  LOCAL (  
  PARTITION M_USUARIOSOP_PARTITION1
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION2
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION3
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION4
    LOGGING
    NOCOMPRESS,  
  PARTITION M_USUARIOSOP_PARTITION5
    LOGGING
    NOCOMPRESS
)
NOPARALLEL;


CREATE INDEX IDXPAGMOV_CTEAL ON PAGO_MOVIL_ACT
(CTEALNOVA)
LOGGING
NOPARALLEL;


CREATE INDEX IDXUSEROLDUSERID ON EBANKING_USER_OLD
(USER_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_ACTIV_WU ON ACTIVACION_WU
(CU)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ACT_DISP ON TOKEN_DISP
(ID_ACT_DISPOSITIVO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ACT_DISP_PC ON TOKEN_DISP_PC
(ID_ACT_DISPOSITIVO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_ADEX_CTEALNOVA ON ACTIVACION_DEX
(CTEALNOVA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ALNOVA ON OPE_PROGRAMADAS
(ID_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_AL_TERM_ES ON ALNOVA_TERM_ES
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_AL_TERM_SEL ON ALNOVA_TERM_SEL_RESPALD
(ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_BENEDEX03 ON BENEFI_DEX
(CTEDEX, TIP_BENEFI, ESTATUS)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BENEF ON TA_BENEFICIARIO
(IDBENEFICIARIO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BENEFAF ON TA_BENEFAFILIA
(IDBENEFICIARIO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BENEFI ON BENEFI_DEX
(CTEDEX, ID_BENEFICIARIO_DEX)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_BENEFICIARIOSWU ON BENEFICIARIOS_WU
(CU, ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BENEFICIARIO_WU ON BENEFICIARIOS_WU
(ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BENEFIWU ON BENEFI_WU
(ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_BENEWU ON BENEFI_WU
(CU, ID_BENEFICIARIO_WU)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_BITACORA_TRAN_QUEST ON EBANKING_BITACORA_TRAN
(NUM_CLIENTE, CTA_ORIGEN, ID_CAT_OPERACION, FECHA_OPER)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BIT_CAN_FA ON BIT_CAN_FA
(ID_FA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BIT_CAN_FA_EBK ON BIT_CAN_FA_EBK
(ID_FA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_BIT_REF_TOKEN ON BIT_REF_TOKEN
(ID_DIS)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_CFKIDTIT1 ON TA_USOCUENTA
(IDTITULAR)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_CFKIDTIT2 ON TA_INFOECOYFIN
(IDTITULAR)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_CFKIDTIT3 ON TA_PERSONAPEXP
(IDTITULAR)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_CLIENTE ON TA_CLIENTE
(IDCLIENTE)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_CLIENTE_ID ON DEXCLIENTE
(CLIENTE_ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_CLIENTE_IUPI_BUSQ ON IUPIFRECUENT
(ID_CLIENTE, STATUS)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_CLIENTE_NOMBRE ON EBANKING_ACTIVATION
(NAME)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_COMPRATA_TELFRECUENTES ON COMPRATA_TELEFONOSFRECUENTES
(CLIENT)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_CONSULTA_SPEI_PROGRAMADO ON SCHEDULED_PAYMENT
(USER_ID, TX_NAME, PROGRAM_DATE, APPLY_DATE)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_CONTENIDO ON TA_CONTENIDOCAT
(IDCATALOGO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_CUENTA_BITTRAN ON EBANKING_BITACORA_TRAN
(CTA_ORIGEN)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_DESTINOS_TEF_SPEI_TERCEROS ON CONFIR
(ID_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_DIRBENEF ON TA_DIRBENEF
(IDDIRBENEF)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_DIRECAFI ON TA_DIRECCIONAFI
(IDDIRECCION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_DIRECCION ON TA_DIRECCION
(IDDIRECCION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_DOCUMENTO ON TA_DOCUMENTOS
(IDDOCUMENTO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_EBANKING_LOGIN_TA_HIS ON EBANKING_LOGIN_TA_HIS
(NUM_TARJETA, LOGIN_DATE)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_EBANKING_LOGIN_TA_HIS_NTAR ON EBANKING_LOGIN_TA_HIS
(NUM_TARJETA)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_EBANKING_TARJETA_02 ON EBANKING_TOKEN_TARJETA_AG12
(ID_ALNOVA, STATUS)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_EBANKING_TARJV_TARNUM ON EBANKING_TARJV_BITACORA
(TARJETA)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_EBANK_LOG_TIMES ON EBANKING_LOGIN_TIMES
(CTE_ALNOVA, FECHA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_ENCUESTA ON EBANK_ENCUESTAS
(ID_CONSECUTIVO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ESTADO ON OPE_PROGRAMADAS
(ESTADO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FAKE_ACT_DISP ON FAKE_TOKEN_DISP
(ID_ACT_DISPOSITIVO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FAKE_SEM_ENC ON FAKE_TOKEN_DISP
(SEM_ENCRIPTADA)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_FAKE_TOKEN_DISP ON FAKE_TOKEN_DISP
(ID_ALNOVA, ESTADO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_FBLIKE ON FBLIKE
(ID_ALNOVA, EMPRESA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FCH_MEN ON PORTALCONT.MENSAJES
(FECHA_PUBLICACION)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FECHA_EJE ON OPE_PROGRAMADAS
(FECHA_DE_EJECUCION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_FISC ON TA_FISCAL
(IDFISCAL)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FONDEO ON FONDEO
(ID_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_FRECUENTES_SPEI ON FRECUENTES_SPEI
(ID_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IDCATALOGO ON TA_CATALOGOS
(IDCATALOGO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IDCONTENIDO ON TA_CONTENIDOCAT
(IDCONTENIDO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IDENCUESTA ON ENCUESTA_PBAZ
(ID_ENCUESTA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_IDOPER ON BITACORA_CORE
(ID_OPERACION)
  LOCAL (  
  PARTITION IDX2013
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2014
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2015
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2016
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2017
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2018
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2019
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2020
    LOGGING
    NOCOMPRESS,  
  PARTITION IDX2021
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXDEFAULT
    LOGGING
    NOCOMPRESS
)
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IDTRACKING ON M_TRACKING
(IDTRACKING)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IDUSUARIO ON M_USUARIOS
(IDUSUARIO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ID_ACTIVA ON ACTIVACION_SMS
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_ID_TRACKING_DETALLE ON M_TRACKING_DETALLE
(ID_TRACKING_DETALLE)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ID_USUARIO ON M_USUARIOS_OPERACIONES
(IDUSUARIO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_ID_USUARIO_OPERACION ON M_USUARIOS_OPERACIONES
(ID_USUARIO_OPERACION)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_IMPUESTO_DEX1 ON IMPUESTO_DEX
(MTCN)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_INFOEYF ON TA_INFOECOYFIN
(IDINFOECOYFIN)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_INTERBUS ON INTERBUS
(USER_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_IP_CORE ON IP_CORE
(IP, NOMBRE_APLICACION)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_MAILING_TDC ON EBANKING_MAILING
(ID_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_MAXD_PM ON PAGO_MOVIL_MAXD
(CTEALNOVA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_METODO ON METODOS_CORE
(METODO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_MEX_TRA_CTE ON BIT_MEX_TRANS
(NUM_CLIENTE)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_MEX_TRA_FA ON BIT_MEX_TRANS
(FECHA_AUTH)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_MEX_TRA_OP ON BIT_MEX_TRANS
(OPERACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_MEX_TRA_PK ON BIT_MEX_TRANS
(ID_TRANSACCION)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_MUO_FOPER ON M_USUARIOS_OPERACIONES
(FECHA_OPERACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_NEGOCIO ON TA_NEGOCIO
(IDNEGOCIO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_NIVELES_SEGIRIDAD_HIST_ID ON EBANKING_NIVELESSEGURIDADHIST
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_PERSONAPE ON TA_PERSONAPEXP
(IDPERSONAPOLITEXP)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_SEMILLA ON TOKEN_DISP
(SEMILLA, ID_ACT_DISPOSITIVO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_SEMILLA_ACCESO ON SEGURIDAD_ACCESO
(SEMILLA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_SEMILLA_DISP ON TOKEN_DISP
(SEMILLA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_SEMILLA_PC ON TOKEN_DISP_PC
(SEMILLA, ID_ACT_DISPOSITIVO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_SEM_DISP_PC ON TOKEN_DISP_PC
(SEMILLA)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_SEM_ENC ON TOKEN_DISP
(SEM_ENCRIPTADA, ID_ACT_DISPOSITIVO, SEMILLA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_SKYACCOUNTS ON SKYACCOUNTS
(USER_ID)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_SMS ON HIST_CUENTA_SMS
(ID_CLIENTE, ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TATOP15_PS ON TATOP15_PS
(FNEMISORID, FNSUCRSALID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TELEFONO ON ACTIVAR_ACRTUM
(TELEFONO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TEST ON EBANKING_USER
(ID, TRACKING)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_TIPO_OPE ON OPE_PROGRAMADAS
(TIPO_OPERACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TITULAR ON TA_TITULAR
(IDTITULAR)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_TOKEN_DISP ON TOKEN_DISP
(ID_ALNOVA, ESTADO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_TOKEN_PREV_CTE ON EBANKING_TOKEN_PREVENCION
(NUM_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TOKEN_PREV_ID ON EBANKING_TOKEN_PREVENCION
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX IDX_TOK_DISP_PC ON TOKEN_DISP_PC
(ID_ALNOVA, ESTADO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TRANSFER ON TRANSFER_DEX
(MTCN)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TRANSFER2 ON TRANSFER_DEX2
(MTCN)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_TRANSFER_DEX1 ON TRANSFER_DEX
(CLIENTE_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_TRANSFER_WU ON TRANSFER_WU
(MTCN)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_USER ON BITACORA_CORE
(USUARIO)
  LOCAL (  
  PARTITION IDXUSER2013
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2014
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2015
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2016
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2017
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2018
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2019
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2020
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSER2021
    LOGGING
    NOCOMPRESS,  
  PARTITION IDXUSERDEFAULT
    LOGGING
    NOCOMPRESS
)
NOPARALLEL;


CREATE INDEX IDX_USERAPP ON M_USUARIOS
(IDUSUARIO, USER_NAME, APLICACION)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_USOCUENTA ON TA_USOCUENTA
(IDUSOCUENTA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_USR_SESS ON EBANKING_USER_SESSION
(SESSION_ACTIVA, SESSION_START, IP)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IDX_USUARIO ON TA_USUARIO
(IDUSUARIO)
NOLOGGING
NOPARALLEL;


CREATE INDEX IDX_ZOP_CODE ON EBANKING_ZIP_CODE
(LOWZIP, UPZIP)
LOGGING
NOPARALLEL;


CREATE INDEX ID_SWIFTN_C_PAIS ON SWIFTABAN
(CLAVE, CVE_PAIS, PAIS)
NOLOGGING
NOPARALLEL;


CREATE INDEX ID_SWIFT_CLV_PAIS ON SWIFTABA
(CLAVE, CVE_PAIS, PAIS)
LOGGING
NOPARALLEL;


CREATE INDEX INDEX_MONITOR_FECHA ON EBANKING_MONITOR_SERVICES
("FECHA" DESC)
LOGGING
NOPARALLEL;


CREATE INDEX INDICE_MOVIMIENTO ON MOVIMIENTOS
(OPERACION, MOVIMIENTO, FECHA)
LOGGING
NOPARALLEL;


CREATE INDEX INDX_PRE ON PREACTIVACION
(FECHA_INSERCION, FECHA_ACTIVACION, CLIENTE_ALNOVA, CUENTA)
NOLOGGING
NOPARALLEL;


CREATE INDEX IND_PREACT_CVE_ALN ON PREACTIVACION
(CLIENTE_ALNOVA)
LOGGING
NOPARALLEL;


CREATE INDEX IND_PREACT_ID ON PREACTIVACION
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX IND_PREACT_ID_CVE ON PREACTIVACION
(ID, CLIENTE_ALNOVA)
LOGGING
NOPARALLEL;


CREATE INDEX IN_DESBLOQUEO ON DESBLOQUEO
(ID, VALIDACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IN_TASPEICELULAR ON TASPEICELULAR
(FIID)
LOGGING
NOPARALLEL;


CREATE INDEX IX01CT_HOV_LETTER ON CT_HOV_LETTER
(FI_NOTIFICATION_TYPE_ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IX01CT_STATE ON CT_STATE
(FI_COUNTRY_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IX01TA_HOV_LETTER ON TA_HOV_LETTER
(FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IX01TA_PRODUCT_LETTER ON TA_PRODUCT_LETTER
(FI_STATE_ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IX02CT_HOV_LETTER ON CT_HOV_LETTER
(FI_PRODUCT_LETTER_ID, FI_STATE_ID)
NOLOGGING
NOPARALLEL;


CREATE INDEX IX02CT_STATE ON CT_STATE
(UPPER("FC_STATE_INITIAL"))
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IXFRREG_IDREG ON FIAR_REGISTRO
(ID_REGISTRO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IX_EBANKING_ACTIVATION_ACTIVE ON EBANKING_ACTIVATION
(CLIENTE, ACTIVACION)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX IX_EBANKING_USER_ACTIVE ON EBANKING_USER
(ID, ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, 
ULT_ACCESO, TOKEN)
NOLOGGING
NOPARALLEL;


CREATE BITMAP INDEX I_AUTENTICADO ON ESTADISTICAS
(AUTENTICADO)
LOGGING
NOPARALLEL;


CREATE INDEX MD_ADDITIONAL_PROPERTIES_IDX ON MD_ADDITIONAL_PROPERTIES
(PROP_KEY)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_ADDITIONAL_PROPERTIES_PK ON MD_ADDITIONAL_PROPERTIES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_APPLICATIONFILES_PK ON MD_APPLICATIONFILES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_APPLICATIONS_PK ON MD_APPLICATIONS
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_APP_FILE_TYPE_IDX ON MD_APPLICATIONFILES
(TYPE, ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_CATALOGS_PK ON MD_CATALOGS
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_COLUMNS_PERF_IDX ON MD_COLUMNS
(TABLE_ID_FK, UPPER(TRIM("COLUMN_NAME")), ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_COLUMNS_PK ON MD_COLUMNS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_CONNECTIONS_PK ON MD_CONNECTIONS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_CONSTRAINTS_PK ON MD_CONSTRAINTS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_CONSTRAINT_DETAILS_PK ON MD_CONSTRAINT_DETAILS
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_DERIVATIVES_PERF_IDX ON MD_DERIVATIVES
(SRC_ID, DERIVED_CONNECTION_ID_FK)
LOGGING
NOPARALLEL;


CREATE INDEX MD_DERIVATIVES_PERF_IDX1 ON MD_DERIVATIVES
(SRC_TYPE, DERIVATIVE_REASON)
LOGGING
NOPARALLEL;


CREATE INDEX MD_DERIVATIVES_PERF_IDX2 ON MD_DERIVATIVES
(NEW_IDENTIFIER)
LOGGING
NOPARALLEL;


CREATE INDEX MD_DERIVATIVES_PERF_IDX3 ON MD_DERIVATIVES
(ORIGINAL_IDENTIFIER)
LOGGING
NOPARALLEL;


CREATE INDEX MD_DERIVATIVES_PERF_IDX4 ON MD_DERIVATIVES
(DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_FILE_ARTIFACTS_PK ON MD_FILE_ARTIFACTS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_GROUPS_PK ON MD_GROUPS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_GROUP_MEMBERS_PK ON MD_GROUP_MEMBERS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_GROUP_PRIVILEGES_PK ON MD_GROUP_PRIVILEGES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_INDEXES_PK ON MD_INDEXES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_INDEX_DETAILS_PK ON MD_INDEX_DETAILS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_OTHER_OBJECTS_PK ON MD_OTHER_OBJECTS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_PACKAGES_PK ON MD_PACKAGES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_PARTITIONS_PK ON MD_PARTITIONS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_PRIVILEGES_PK ON MD_PRIVILEGES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_PROJECTS_PK ON MD_PROJECTS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_REGISTRY_PK ON MD_REGISTRY
(OBJECT_TYPE, OBJECT_NAME)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_SCHEMAS_PK ON MD_SCHEMAS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_SEQUENCES_PK ON MD_SEQUENCES
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_STATE_TYPE__ID ON MD_APPLICATIONFILES
(STATE, TYPE, ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_STORED_PROGRAMS_PK ON MD_STORED_PROGRAMS
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_STORED_PROGRAS_IDX2 ON MD_STORED_PROGRAMS
(SCHEMA_ID_FK, UPPER("NAME"))
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_SYNONYMS_PK ON MD_SYNONYMS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_TABLESPACES_PK ON MD_TABLESPACES
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MD_TABLES_PERF_IDX1 ON MD_TABLES
(UPPER("TABLE_NAME"), SCHEMA_ID_FK)
LOGGING
NOPARALLEL;


CREATE INDEX MD_TABLES_PERF_IDX2 ON MD_VIEWS
(UPPER("VIEW_NAME"), SCHEMA_ID_FK)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_TABLES_PK ON MD_TABLES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_TRIGGERS_PK ON MD_TRIGGERS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_USERS_PK ON MD_USERS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_USER_DEFINED_DATA_TYPES_PK ON MD_USER_DEFINED_DATA_TYPES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_USER_PRIVILEGES_PK ON MD_USER_PRIVILEGES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MD_VIEWS_PK ON MD_VIEWS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGRDREIVATIVES_PK ON MD_DERIVATIVES
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX MIGRLOG_PERF_IDX ON MIGRLOG
(REF_OBJECT_ID, SEVERITY)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGRLOG_PK ON MIGRLOG
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_DATATYPE_TRANSFORM_M_PK ON MIGR_DATATYPE_TRANSFORM_MAP
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_DATATYPE_TRANSFORM_R_PK ON MIGR_DATATYPE_TRANSFORM_RULE
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_DEPENDENCY_PK ON MD_MIGR_DEPENDENCY
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_GENERATION_ORDER_PK ON MIGR_GENERATION_ORDER
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_PARAMETER_PK ON MD_MIGR_PARAMETER
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MIGR_WEAKDEP_PK ON MD_MIGR_WEAKDEP
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX MODAL_APP_ALNOVA_PK ON MODAL_APP_ALNOVA
(CTE_ALNOVA)
LOGGING
NOPARALLEL;


CREATE INDEX NOREF_TEF ON EBANKING_REF_TEF
(NOREFERENCIA)
LOGGING
NOPARALLEL;


CREATE INDEX OPERACIONES_CLI_CLIENTE_IDX ON OPERACIONES_CLI
(CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX OPERACIONES_FRECUENTES_PK ON OPERACIONES_FREC
(ID_OPERACION)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK ON EBANKING_TOKEN_COBRO
(NO_CTE, NO_SERIE_TOKEN)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PKCT_HOV_LETTER ON CT_HOV_LETTER
(FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PKPHOTOS ON PHOTOS
(ID, IDALBUM)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PKTA_HOV_LETTER ON TA_HOV_LETTER
(FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID, FI_LETTER_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PKTA_PRODUCT_LETTER ON TA_PRODUCT_LETTER
(FI_PRODUCT_LETTER_ID, FI_STATE_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PKV_KEY ON VENTA_ACCIONES_LOG
(NUM_CLIENTE, FECHA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ACTECONOMICA ON EBANKING_ACTECONOMICA
(ID_PROFESION, ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_BRANCH ON ALNOVA_BRANCH
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_CHANNEL ON ALNOVA_CHANNEL
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_STATUS ON ALNOVA_STATUS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_TERMINAL ON ALNOVA_TERMINAL
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_TERMINAL_ACERTUM ON ALNOVA_TERMINAL_ACERTUM
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_TRANSACTION ON ALNOVA_TRANSACTION
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ALNOVA_USER ON ALNOVA_USER
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_AL_TERM_SEL_1 ON ALNOVA_TERM_SEL
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_BCALNOVA_CODBANC ON EBANKING_SPEI_ALNOVA
(CODBANC)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_BCALNOVA_ID ON EBANKING_TEF_ALNOVA
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_BDEX_ID ON BENEFI_DEX
(ID_BENEFICIARIO_DEX)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CARRIER ON CARRIER
(CARRIER_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CLIENTE_ALNOVA ON DEXCLIENTE
(CLIENTE_ALNOVA, CLIENTE_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CREDITOSOTROSBANCOSFRECUENT ON CREDITOSOTROSBANCOSFRECUENT
(BENEFICIARIO, CLIENTE, BANCO, CUENTACREDITO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CT_COUNTRY ON CT_COUNTRY
(FI_COUNTRY_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CT_NOTIFICATION_TYPE ON CT_NOTIFICATION_TYPE
(FI_NOTIFICATION_TYPE_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CT_STATE ON CT_STATE
(FI_STATE_ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_DATOS_GOBIERNOS_PDF ON DATOS_GOBIERNOS_PDF
(LINEA_CAPTURA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_DATOS_IMSS_PDF ON DATOS_IMSS_PDF
(LINEA_CAPTURA, NUM_AUTORIZACION)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_DESTINOS_TEF_SPEI_TERCEROS ON CONFIR
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_DEXTRANSFERENCIA ON DEXTRANSFERENCIA
(MTCN)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKINGPAN_USER ON EBANKINGPAN_USER
(NSS)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_ACTIVATION ON EBANKING_ACTIVATION
(CLIENTE, CUENTAOTARJ)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_ACTIVATION_H ON EBANKING_ACTIVATION_H
(FOLIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_BAJASLDAP ON EBANKING_BAJASLDAP
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_BANKS ON EBANKING_BANKS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_BITACORA_TRAN ON EBANKING_BITACORA_TRAN
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_CAT_OPERACION ON EBANKING_CAT_OPERACION
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_CELLCOMPANY ON EBANKING_CELLCOMPANY
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_CLIP ON EBANKING_CLIP
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_CONTROL_HILOS ON EBANKING_CONTROL_HILOS
(NOMBRE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_EMPRESAS ON EBANKING_EMPRESAS
(EMPRESA_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_ESTADOS ON EBANKING_ESTADOS
(ESTADO_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_IMPUESTO_GDF ON EBANKING_IMPUESTOS_GDF
(LINEA_PAGO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_LOGIN_TA_HIS ON EBANKING_LOGIN_TA_HIS
(ID, NUM_TARJETA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_MUNICIPIOS ON EBANKING_MUNICIPIOS
(CITY_CODE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_NIVELESSEGURIDAD ON EBANKING_NIVELESSEGURIDAD
(IDUSER)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_OPERACIONES ON EBANKING_OPERACIONES
(CLIENTE, SEMANA, ANIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_PAGO_TAZ ON EBANKING_PAGO_TAZ
(NUM_CLIENTE, FECHA_PAGO, NUM_TAZ)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_RECORDATORIOS ON EBANKING_RECORDATORIOS
(ID, CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_RFC ON EBANKING_RFC
(ID_EBANKING_RFC)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_SUCURSALES ON EBANKING_SUCURSALES
(SUCURSAL)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_TARJETA ON EBANKING_TOKEN_TARJETA_AG12
(ID_TARJETA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_TARJETASNIP ON EBANKING_TARJETASNIP
(CUENTA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_TARJV_ID ON EBANKING_TARJV_BITACORA
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX PK_EBANKING_TRAN_CLIENTE ON EBANKING_BITACORA_TRAN
(NUM_CLIENTE, FECHA_OPER)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_TX_PLACES ON EBANKING_TX_PLACES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_TX_STATES ON EBANKING_TX_STATES
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_EBANKING_USER_TRACKING ON EBANKING_USER_TRACKING
(NUMERO_CLIENTE, FECHA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ENCUESTA_DESPACHO ON ENCUESTA_DESPACHO
(ID_ENCUESTA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ENCUESTA_EMPLEADO ON ENCUESTA_EMPLEADO
(ID_ENCUESTA, NUM_EMPLEADO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_BOLETOS ON FIAR_BOLETOS
(ID_PARTICIPANTE, ID_SORTEO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_CANDIDATOS ON FIAR_CANDIDATOS
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_CLIENTES ON FIAR_CLIENTES
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_CONTRATOS ON FIAR_CONTRATOS
(CTE_ALNOVA, IDCONTRATO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_DATOS_SOLICITUD ON FIAR_DATOS_SOLICITUD
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_PREMIO ON FIAR_PREMIO
(ID_SORTEO, ID_PREMIO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_SORTEO ON FIAR_SORTEO
(ID_SORTEO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_STATUS_CLIENTES ON FIAR_STATUS_CLIENTES
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FIAR_TRACE ON FIAR_TRACE
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FOLIOCMP ON FOLIOCMP
(CONSECUTIVO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FRECUENTES_SPEI ON FRECUENTES_SPEI
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_HISTORICO_PAGO_PEDIDOS ON EBANKING_HISTORICO_PAGOPEDIDOS
(IDPEDIDO, IDRETENCION)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_HISTORICO_TEF_SPEI_TERCEROS ON HISTORICO_TEF_SPEI_TERCEROS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_HIST_LOGIN ON HIST_LOGIN
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ID ON TA_WU_CONFIRMACION
(IDENVIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ID1 ON TA_WU_CONFIRMACION1
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ID_HTST ON HISTORICO_TEF_SPEI_TERCEROS_AX
(ID)
LOGGING
NOPARALLEL;


CREATE INDEX PK_ID_IUPI ON IUPIFRECUENT
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ID_USUARIO ON USUARIO
(ID_USUARIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_IMPUESTO ON DEXIMPUESTO
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_INTERESADOS ON INTERESADOS
(ID, IDALBUM)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_INTERFACTURA_SERVICIO ON INTERFACTURA_SERVICIO
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_KEY ON SERVICIOS_LOG
(NUM_OPERACION)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_MENSAJE_ID ON MENSAJE
(MENSAJE_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_MONTOS_USER ON MONTOS_USER
(ID_MONTO_USER)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_PARAMETROS ON EBANKING_PARAMETROS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_POSTIT ON POSTIT
(ID, IDALBUM, IDFOTO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_RECORDATORIOS_AGENDA ON RECORDATORIOS_AGENDA
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_RECORDATORIOS_EVENTOS ON RECORDATORIOS_EVENTOS
(ID, ID_RECORDATORIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_RMASMS ON EBANKING_RMASMS
(SMSKEY)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_SEGURIDAD_ACCESO ON SEGURIDAD_ACCESO
(ID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_SUBPRODUCTO ON EBANKING_TASAS_IA
(SUBPRODUCTO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TABLAX ON TABLAX
(CLOMUN1)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TASAS ON TASAS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TEFSPEUAFRECUENT ON TEFSPEUAFRECUENT
(STATE, PLAZA, DESTINO, CLIENT, BANK)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TELEFONO ON TELEFONO
(TELEFONO_ID, CLIENTE_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TERCEROSFRECUENT ON TERCEROSFRECUENT
(CLIENT, DESTINO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TIEMPOAIRE_APLICACION ON TIEMPOAIRE_APLICACION
(NOMBRE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TIEMPOAIRE_STATUS ON TIEMPOAIRE_STATUS
(STATUS)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TIEMPOAIRE_TYPE ON TIEMPOAIRE_TYPE
(TYPE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TMP_HUELLA_MONTOS ON TMP_HUELLA_MONTOS
(CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TRANSFERENCIAS ON TIPO_TRANSFERENCIAS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_TRANSFINTERNALFRECUENT ON TRANSFINTERNALFRECUENT
(CLIENT, DESTINO, CLAVE_SWIFT)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_USR_ADMON ON FIAR_USR_ADMON
(ID_USUARIO)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_WEBSERVICE_LOG ON WEBSERVICE_LOG
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PORTAFOLIO_PK ON PORTAFOLIO
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PREACT_ID_PK ON PREACTIVE_USER
(ID_ALNOVA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PRIMARY_KEY ON TIEMPO_AIRE_LOG
(CARRIER, ABONO_SOCK)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PROVEEDOR_URL_PK11079987718530 ON PROVEEDOR_URL
(URL)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX REPORTOS_REGISTRO_OPERACI_PK ON REPO_REG_OPERAC
(FOLIO_ALNOVA, FOLIO_TAS, FOLIO_EBANKING)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX RMA_NOTIFICA_PK ON RMA_NOTIFICA
(CTE_ALNOVA)
NOLOGGING
NOPARALLEL;


CREATE INDEX SERV_INDEX ON ALL_FRECUENTES
(ID_SERVICIO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX SPEI_FREC_30_PK ON SPEI_PROG_30_MIN
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX STAGE_MIGRLOG_PK ON STAGE_MIGRLOG
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TABLE1_PK ON TRANS_HISTORIAL_PROCESO
(ID_HIST_PROCESO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TACONFIRMACION_WU_PK ON TACONFIRMACION_WU
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TAOPPROG30MIN ON TAOPPROG30MIN
(FIID)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TBA_PK ON TRANSCOPE_BITA
(CUENTA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TESTCURSO_PK ON TESTCURSO
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TEST_RMASMS ON TEST_RMASMS
(SMSKEY)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TEST_SPECIAL_CHARACTERS_PK ON TEST_SPECIAL_CHARACTERS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TIP_BENEFI_DEX_PK ON TIP_BENEFI_DEX
(ID_TIPO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TOKEN_ENV_SMS_PK ON TOKEN_ENV_SMS
(ID_SMS)
NOLOGGING
NOPARALLEL;


CREATE INDEX TOKEN_ESTATUS_SOL ON EBANKING_TOKEN_SOLICITUD
(ESTATUS_SOL)
NOLOGGING
NOPARALLEL;


CREATE INDEX TOKEN_HIST_NUM_CTE ON EBANKING_TOKEN_HIST
(NUM_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TOKEN_HIST_PC_PK ON TOKEN_HIST_PC
(ID_ALNOVA, TOKEN)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TOKEN_HIST_PK ON TOKEN_HIST
(ID_ALNOVA, TOKEN)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TOKEN_SOL_PAGO_FOLIO ON EBANKING_TOKEN_SOL_PAGO
(FOLIO_SOLICITUD)
LOGGING
NOPARALLEL;


CREATE INDEX TOKEN_SOL_PAGO_NUM_CTE ON EBANKING_TOKEN_SOL_PAGO
(NUM_CTE)
LOGGING
NOPARALLEL;


CREATE INDEX TOKEN_STATUS_NUM_CTE ON EBANKING_TOKEN_STATUS
(NUM_CLIENTE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TPSQL_IDX ON TOAD_PLAN_SQL
(STATEMENT_ID)
LOGGING
NOPARALLEL;


CREATE INDEX TRACKING_USER_IDX ON EBANKING_USER
(TRACKING)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANSF_PROGRAMADAS_PK ON OPE_PROGRAMADAS
(ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_CAT_ESTADOS_INDEX1 ON TRANS_CAT_ESTADOS
(ESTADO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_CAT_ESTADOS_PK ON TRANS_CAT_ESTADOS
(IDESTADO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_PROGRAMADAS_EXTRAS_PK ON TRANS_PROGRAMADAS_ADICIONALES
(ID_ADICIONALES)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_PROGRAMADAS_PK ON TRANS_PROGRAMADAS
(ID_TRANS_PROG)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_PROG_BITACORA_PK ON TRANS_PROG_BITACORA
(ID_BITACORA, ID_TRANS_PROG)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX TRANS_PROG_BITACORA_UK1 ON TRANS_PROG_BITACORA
(ID_BITACORA)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UNIEJBRMA_NOM ON CORE_EJBS
(NOMBRE_EJB)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UNIMETRMA_NOM ON CORE_METODS
(IDEJB, NOMBRE_METODO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UNIQ ON TABLAX
(VAMPO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UNIQUEK ON ACTIVACION_DEX
(CTEDEX)
NOLOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UNIROLRMA_NOM ON CORE_ROL
(NOMBRE_ROL)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UQ_ALNOVA_CHANNEL_CODE ON ALNOVA_TERMINAL
(CODE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UQ_EBANKING_BANKS_CODE ON EBANKING_BANKS
(CODE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UQ_EBANKING_CELLCOMPANY_CODE ON EBANKING_CELLCOMPANY
(CODE)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX UQ_EBANKING_TX_PLACES_CODE ON EBANKING_TX_PLACES
(CODE)
LOGGING
NOPARALLEL;


CREATE INDEX USER_INDEX ON ALL_FRECUENTES
(USER_ID)
LOGGING
NOPARALLEL;


CREATE INDEX XEJBRMA_STATUS ON CORE_EJBS
(STATUS)
LOGGING
NOPARALLEL;


CREATE INDEX XMETRMA_STATUS ON CORE_METODS
(STATUS)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKRMA_EJBS ON CORE_EJBS
(IDEJB)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKRMA_METODOS ON CORE_METODS
(IDMETODO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKRMA_ROL ON CORE_ROL
(IDROL)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKRMA_ROL_METODOS ON CORE_ROL_METODS
(IDROL_METODO)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKROL_CORE ON ROL_CORE
(ROL)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX XPKROL_METODO_CORE ON ROL_METODO_CORE
(IDROL_METODO)
LOGGING
NOPARALLEL;


CREATE INDEX XRMRMA_STATUS ON CORE_ROL_METODS
(STATUS)
LOGGING
NOPARALLEL;


CREATE INDEX XROLRMA_STATUS ON CORE_ROL
(STATUS)
LOGGING
NOPARALLEL;


CREATE INDEX XSTRMA_STATUS ON CORE_MACS
(STATUS)
LOGGING
NOPARALLEL;


CREATE OR REPLACE PACKAGE "MD_META"
AS
FUNCTION get_next_id RETURN NUMBER;
-- Following code taken directly from wwv_flow_random from APEX
--
-- seed random function
procedure srand( new_seed in number );

function rand return number;
pragma restrict_references( rand, WNDS  );

procedure get_rand( r OUT number );

function rand_max( n IN number ) return number;
pragma restrict_references( rand_max, WNDS);

procedure get_rand_max( r OUT number, n IN number );

function quote(catalog IN VARCHAR2, schema IN VARCHAR2, object IN VARCHAR2, connid LONG) RETURN VARCHAR2;
END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE "MIGRATION"
AS

-- Public functions
FUNCTION copy_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL,p_scratchModel BOOLEAN := FALSE) RETURN NUMBER;
FUNCTION transform_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE, p_prefixName VARCHAR2, p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY;
FUNCTION transform_datatypes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE, p_numbytesperchar INTEGER,  p_is12c VARCHAR2 := 'N') RETURN NUMBER;
FUNCTION transform_identity_columns(p_connectionid MD_CONNECTIONS.ID%TYPE, p_is12c VARCHAR2 := 'N') RETURN NUMBER;
FUNCTION transform_rewrite_trigger(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER;
FUNCTION gatherConnectionStats(p_connectionId MD_CONNECTIONS.ID%TYPE,p_comments MD_CONNECTIONS.COMMENTS%TYPE) RETURN NUMBER;
PROCEDURE transform_clashes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE);
PROCEDURE populate_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE);
PROCEDURE revert_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE);
END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE "MIGRATION_REPORT" AS 
--get status
  FUNCTION getCaptureStatus(srcid IN NUMBER)  RETURN VARCHAR2;
  FUNCTION getConvertStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2;
  FUNCTION getGenerateStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2;
--migration details
  FUNCTION getDetails(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN MIGR_REPORT_DETAIL_TABLE PIPELINED; 
--migration summary
   FUNCTION getSum(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN MIGR_REPORT_SUM_TABLE PIPELINED;
END MIGRATION_REPORT;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE "MIGRATION_TRANSFORMER" AS
FUNCTION check_identifier_length(p_ident VARCHAR2) RETURN VARCHAR2;
FUNCTION add_suffix(p_work VARCHAR2, p_suffix VARCHAR2, p_maxlen NUMBER) RETURN VARCHAR2;
FUNCTION check_reserved_word(p_work VARCHAR2) RETURN VARCHAR2;
FUNCTION sys_check(p_work VARCHAR2) RETURN VARCHAR2;
FUNCTION check_allowed_chars(p_work NVARCHAR2) RETURN NVARCHAR2;
FUNCTION transform_identifier(p_identifier NVARCHAR2)  RETURN NVARCHAR2;
FUNCTION getDisallowedCharsNames(p_work NVARCHAR2) RETURN VARCHAR2;
FUNCTION getNameForNullCase(p_work NVARCHAR2) RETURN NVARCHAR2;
END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PCKG_WORKFLOW
AS
    TYPE refCursor IS REF CURSOR;
END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_ALNOVA AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_ALNOVA
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_ALNOVA_TERMES (PEREG IN EBANKING.ALNOVA_TERM_ES%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_ALNOVA_TERMES (P_ID               IN EBANKING.ALNOVA_TERM_ES.ID%TYPE, 
                             P_CODE             IN EBANKING.ALNOVA_TERM_ES.CODE%TYPE, 
                             P_BUSY       		IN EBANKING.ALNOVA_TERM_ES.BUSY%TYPE,
                             P_SERVER           IN EBANKING.ALNOVA_TERM_ES.SERVER%TYPE,
               				 P_TERMINAL2CHANNEL IN EBANKING.ALNOVA_TERM_ES.TERMINAL2CHANNEL%TYPE,
               				 P_APP         		IN EBANKING.ALNOVA_TERM_ES.APP%TYPE,
               				 P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_ES.USUARIO_MODIFICO%TYPE,
               				 P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_ES.FECHA_OPERACION%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERMES(PEREG IN  EBANKING.ALNOVA_TERM_ES%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERMES(P_ID               IN EBANKING.ALNOVA_TERM_ES.ID%TYPE, 
                               P_CODE             IN EBANKING.ALNOVA_TERM_ES.CODE%TYPE, 
                               P_BUSY       	  IN EBANKING.ALNOVA_TERM_ES.BUSY%TYPE,
                               P_SERVER           IN EBANKING.ALNOVA_TERM_ES.SERVER%TYPE,
               				   P_TERMINAL2CHANNEL IN EBANKING.ALNOVA_TERM_ES.TERMINAL2CHANNEL%TYPE,
               				   P_APP         	  IN EBANKING.ALNOVA_TERM_ES.APP%TYPE,
               				   P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_ES.USUARIO_MODIFICO%TYPE,
               				   P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_ES.FECHA_OPERACION%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2); 

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ALNOVA_TERM_SEL
******************************************************************************/
PROCEDURE ADD_ALNOVA_TERMSE (PEREG IN EBANKING.ALNOVA_TERM_SEL%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_ALNOVA_TERMSE (P_ID               IN EBANKING.ALNOVA_TERM_SEL.ID%TYPE, 
                             P_CODE             IN EBANKING.ALNOVA_TERM_SEL.CODE%TYPE, 
                             P_BUSY             IN EBANKING.ALNOVA_TERM_SEL.BUSY%TYPE,
                             P_APP              IN EBANKING.ALNOVA_TERM_SEL.APP%TYPE,
                             P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_SEL.USUARIO_MODIFICO%TYPE,
                             P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_SEL.FECHA_OPERACION%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERMSE(PEREG IN  EBANKING.ALNOVA_TERM_SEL%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERMSE(P_ID               IN EBANKING.ALNOVA_TERM_SEL.ID%TYPE, 
                               P_CODE             IN EBANKING.ALNOVA_TERM_SEL.CODE%TYPE, 
                               P_BUSY             IN EBANKING.ALNOVA_TERM_SEL.BUSY%TYPE,
                               P_APP              IN EBANKING.ALNOVA_TERM_SEL.APP%TYPE,
                               P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_SEL.USUARIO_MODIFICO%TYPE,
                               P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_SEL.FECHA_OPERACION%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2);
							   
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ALNOVA_TERMINAL
******************************************************************************/

PROCEDURE ADD_ALNOVA_TERM (PEREG IN EBANKING.ALNOVA_TERMINAL%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2);

PROCEDURE ADD_ALNOVA_TERM (P_ID                 IN EBANKING.ALNOVA_TERMINAL.ID%TYPE, 
                           P_CODE               IN EBANKING.ALNOVA_TERMINAL.CODE%TYPE, 
                           P_BUSY               IN EBANKING.ALNOVA_TERMINAL.BUSY%TYPE,
                           P_SERVER             IN EBANKING.ALNOVA_TERMINAL.SERVER%TYPE,
                           P_TERMINAL2CHANNEL   IN EBANKING.ALNOVA_TERMINAL.TERMINAL2CHANNEL%TYPE,
                           P_FECHA_MODIFICACION IN EBANKING.ALNOVA_TERMINAL.FECHA_MODIFICACION%TYPE,
                           PSCOD                OUT NUMBER,
                           PSMSG                OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERM(PEREG IN  EBANKING.ALNOVA_TERMINAL%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_ALNOVA_TERM(P_ID                 IN EBANKING.ALNOVA_TERMINAL.ID%TYPE, 
                             P_CODE               IN EBANKING.ALNOVA_TERMINAL.CODE%TYPE, 
                           	 P_BUSY               IN EBANKING.ALNOVA_TERMINAL.BUSY%TYPE,
                           	 P_SERVER             IN EBANKING.ALNOVA_TERMINAL.SERVER%TYPE,
                           	 P_TERMINAL2CHANNEL   IN EBANKING.ALNOVA_TERMINAL.TERMINAL2CHANNEL%TYPE,
                           	 P_FECHA_MODIFICACION IN EBANKING.ALNOVA_TERMINAL.FECHA_MODIFICACION%TYPE,
                             PSCOD                OUT NUMBER,
                             PSMSG                OUT VARCHAR2);

END PKG_CORE_GEN_ALNOVA;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_PAY_BUY AS
/******************************************************************************
   NAME:       PKG_CORE_ADMIN_PAYMENT_BUY
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_INTERBUS (PEREG IN EBANKING.INTERBUS%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2);

PROCEDURE ADD_INTERBUS (P_USER_ID              IN EBANKING.INTERBUS.USER_ID%TYPE, 
                        P_REFERENCIA           IN EBANKING.INTERBUS.REFERENCIA%TYPE, 
                        P_CANAL                IN EBANKING.INTERBUS.CANAL%TYPE,
                        P_STATUS               IN EBANKING.INTERBUS.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.INTERBUS.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_INTERBUS(PEREG IN EBANKING.INTERBUS%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_INTERBUS(P_USER_ID              IN EBANKING.INTERBUS.USER_ID%TYPE, 
                          P_REFERENCIA           IN EBANKING.INTERBUS.REFERENCIA%TYPE, 
                          P_CANAL                IN EBANKING.INTERBUS.CANAL%TYPE,
                          P_STATUS               IN EBANKING.INTERBUS.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.INTERBUS.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2); 
        
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EDCULTURALES
******************************************************************************/
PROCEDURE ADD_EDCULTURALES (PEREG IN EBANKING.EDCULTURALES%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);

PROCEDURE ADD_EDCULTURALES (P_USER_ID              IN EBANKING.EDCULTURALES.USER_ID%TYPE, 
                            P_REFERENCIA           IN EBANKING.EDCULTURALES.REFERENCIA%TYPE, 
                            P_CANAL                IN EBANKING.EDCULTURALES.CANAL%TYPE,
                            P_STATUS               IN EBANKING.EDCULTURALES.STATUS%TYPE,
                            P_ULTIMA_ACTUALIZACION IN EBANKING.EDCULTURALES.ULTIMA_ACTUALIZACION%TYPE,
                            PSCOD                  OUT NUMBER,
                            PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_EDCULTURALES(PEREG IN EBANKING.EDCULTURALES%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_EDCULTURALES(P_USER_ID              IN EBANKING.EDCULTURALES.USER_ID%TYPE, 
                              P_REFERENCIA           IN EBANKING.EDCULTURALES.REFERENCIA%TYPE, 
                              P_CANAL                IN EBANKING.EDCULTURALES.CANAL%TYPE,
                              P_STATUS               IN EBANKING.EDCULTURALES.STATUS%TYPE,
                              P_ULTIMA_ACTUALIZACION IN EBANKING.EDCULTURALES.ULTIMA_ACTUALIZACION%TYPE,
                              PSCOD                  OUT NUMBER,
                              PSMSG                  OUT VARCHAR2); 
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE SKYACCOUNTS
******************************************************************************/
PROCEDURE ADD_SKYACCOUNTS (PEREG IN EBANKING.SKYACCOUNTS%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2);

PROCEDURE ADD_SKYACCOUNTS (P_USER_ID              IN EBANKING.SKYACCOUNTS.USER_ID%TYPE, 
                           P_REFERENCIA           IN EBANKING.SKYACCOUNTS.REFERENCIA%TYPE, 
                           P_CANAL                IN EBANKING.SKYACCOUNTS.CANAL%TYPE,
                           P_STATUS               IN EBANKING.SKYACCOUNTS.STATUS%TYPE,
                           P_ULTIMA_ACTUALIZACION IN EBANKING.SKYACCOUNTS.ULTIMA_ACTUALIZACION%TYPE,
                           PSCOD                  OUT NUMBER,
                           PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_SKYACCOUNTS(PEREG IN EBANKING.SKYACCOUNTS%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_SKYACCOUNTS(P_USER_ID              IN EBANKING.SKYACCOUNTS.USER_ID%TYPE, 
                             P_REFERENCIA           IN EBANKING.SKYACCOUNTS.REFERENCIA%TYPE, 
                             P_CANAL                IN EBANKING.SKYACCOUNTS.CANAL%TYPE,
                             P_STATUS               IN EBANKING.SKYACCOUNTS.STATUS%TYPE,
                             P_ULTIMA_ACTUALIZACION IN EBANKING.SKYACCOUNTS.ULTIMA_ACTUALIZACION%TYPE,
                             PSCOD                  OUT NUMBER,
                             PSMSG                  OUT VARCHAR2); 
							 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE MOVISTAR
******************************************************************************/
PROCEDURE ADD_MOVISTAR (PEREG IN EBANKING.MOVISTAR%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2);

PROCEDURE ADD_MOVISTAR (P_USER_ID              IN EBANKING.MOVISTAR.USER_ID%TYPE, 
                        P_REFERENCIA           IN EBANKING.MOVISTAR.REFERENCIA%TYPE, 
                        P_CANAL                IN EBANKING.MOVISTAR.CANAL%TYPE,
                        P_STATUS               IN EBANKING.MOVISTAR.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.MOVISTAR.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_MOVISTAR(PEREG IN EBANKING.MOVISTAR%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_MOVISTAR(P_USER_ID              IN EBANKING.MOVISTAR.USER_ID%TYPE, 
                          P_REFERENCIA           IN EBANKING.MOVISTAR.REFERENCIA%TYPE, 
                          P_CANAL                IN EBANKING.MOVISTAR.CANAL%TYPE,
                          P_STATUS               IN EBANKING.MOVISTAR.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.MOVISTAR.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2); 
						  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IUSACELL
******************************************************************************/
PROCEDURE ADD_IUSACELL (PEREG IN EBANKING.IUSACELL%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2);

PROCEDURE ADD_IUSACELL (P_USER_ID              IN EBANKING.IUSACELL.USER_ID%TYPE, 
                        P_CUENTA           	   IN EBANKING.IUSACELL.CUENTA%TYPE, 
                        P_CANAL                IN EBANKING.IUSACELL.CANAL%TYPE,
                        P_STATUS               IN EBANKING.IUSACELL.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.IUSACELL.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_IUSACELL(PEREG IN EBANKING.IUSACELL%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_IUSACELL(P_USER_ID              IN EBANKING.IUSACELL.USER_ID%TYPE, 
                          P_CUENTA           	 IN EBANKING.IUSACELL.CUENTA%TYPE, 
                          P_CANAL                IN EBANKING.IUSACELL.CANAL%TYPE,
                          P_STATUS               IN EBANKING.IUSACELL.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.IUSACELL.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2); 
						  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TELMEX
******************************************************************************/
PROCEDURE ADD_TELMEX (PEREG IN EBANKING.TELMEX%ROWTYPE,
                      PSCOD OUT NUMBER,
                      PSMSG OUT VARCHAR2);

PROCEDURE ADD_TELMEX (P_USER_ID              IN EBANKING.TELMEX.USER_ID%TYPE, 
                      P_TELEFONO           	 IN EBANKING.TELMEX.TELEFONO%TYPE, 
                      P_CANAL                IN EBANKING.TELMEX.CANAL%TYPE,
                      P_STATUS               IN EBANKING.TELMEX.STATUS%TYPE,
                      P_ULTIMA_ACTUALIZACION IN EBANKING.TELMEX.ULTIMA_ACTUALIZACION%TYPE,
                      PSCOD                  OUT NUMBER,
                      PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_TELMEX(PEREG IN EBANKING.TELMEX%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_TELMEX(P_USER_ID              IN EBANKING.TELMEX.USER_ID%TYPE, 
                        P_TELEFONO             IN EBANKING.TELMEX.TELEFONO%TYPE, 
                        P_CANAL                IN EBANKING.TELMEX.CANAL%TYPE,
                        P_STATUS               IN EBANKING.TELMEX.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.TELMEX.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2); 
						
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TDCFRECUENT
******************************************************************************/
PROCEDURE ADD_TDCFRECUENT (PEREG IN EBANKING.TDCFRECUENT%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2);

PROCEDURE ADD_TDCFRECUENT (P_CLIENT               IN EBANKING.TDCFRECUENT.CLIENT%TYPE, 
                       	   P_DESTINO           	  IN EBANKING.TDCFRECUENT.DESTINO%TYPE, 
                      	   P_BANCO                IN EBANKING.TDCFRECUENT.BANCO%TYPE,
                      	   P_NOMBRE               IN EBANKING.TDCFRECUENT.NOMBRE%TYPE,
                      	   P_STATUS               IN EBANKING.TDCFRECUENT.STATUS%TYPE,
						   P_CANAL                IN EBANKING.TDCFRECUENT.CANAL%TYPE,
						   P_ALIAS                IN EBANKING.TDCFRECUENT.ALIAS%TYPE,
						   P_IP_ORIGEN            IN EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
						   P_FECHA_MODIFICACION   IN EBANKING.TDCFRECUENT.FECHA_MODIFICACION%TYPE,
                      	   PSCOD                  OUT NUMBER,
                      	   PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_TDCFRECUENT(PEREG IN EBANKING.TDCFRECUENT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_TDCFRECUENT(P_CLIENT               IN EBANKING.TDCFRECUENT.CLIENT%TYPE, 
                       	     P_DESTINO           	IN EBANKING.TDCFRECUENT.DESTINO%TYPE, 
                      	     P_BANCO                IN EBANKING.TDCFRECUENT.BANCO%TYPE,
                      	     P_NOMBRE               IN EBANKING.TDCFRECUENT.NOMBRE%TYPE,
                      	     P_STATUS               IN EBANKING.TDCFRECUENT.STATUS%TYPE,
						     P_CANAL                IN EBANKING.TDCFRECUENT.CANAL%TYPE,
						     P_ALIAS                IN EBANKING.TDCFRECUENT.ALIAS%TYPE,
						     P_IP_ORIGEN            IN EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
						     P_FECHA_MODIFICACION   IN EBANKING.TDCFRECUENT.FECHA_MODIFICACION%TYPE,
                             PSCOD                  OUT NUMBER,
                             PSMSG                  OUT VARCHAR2); 
 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_PAGO_TAZ
******************************************************************************/
PROCEDURE ADD_PAGO_TAZ (PEREG IN EBANKING.EBANKING_PAGO_TAZ%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2);

PROCEDURE ADD_PAGO_TAZ (P_NUM_CLIENTE   IN EBANKING.EBANKING_PAGO_TAZ.NUM_CLIENTE%TYPE, 
                       	P_NOM_ORIGEN    IN EBANKING.EBANKING_PAGO_TAZ.NOM_ORIGEN%TYPE, 
                      	P_NUM_TAZ       IN EBANKING.EBANKING_PAGO_TAZ.NUM_TAZ%TYPE,
                      	P_NOM_DESTINO   IN EBANKING.EBANKING_PAGO_TAZ.NOM_DESTINO%TYPE,
                      	P_TIPO_PAGO     IN EBANKING.EBANKING_PAGO_TAZ.TIPO_PAGO%TYPE,
						P_REFERENCIA    IN EBANKING.EBANKING_PAGO_TAZ.REFERENCIA%TYPE,
						P_PAIS          IN EBANKING.EBANKING_PAGO_TAZ.PAIS%TYPE,
						P_CANAL         IN EBANKING.EBANKING_PAGO_TAZ.CANAL%TYPE,
						P_SUCURSAL   	IN EBANKING.EBANKING_PAGO_TAZ.SUCURSAL%TYPE,
						P_FOLIO   		IN EBANKING.EBANKING_PAGO_TAZ.FOLIO%TYPE,
						P_MONTO   		IN EBANKING.EBANKING_PAGO_TAZ.MONTO%TYPE,
						P_FECHA_PAGO   	IN EBANKING.EBANKING_PAGO_TAZ.FECHA_PAGO%TYPE,
						P_TIENDA_DES   	IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_DES%TYPE,
						P_CANAL_DES   	IN EBANKING.EBANKING_PAGO_TAZ.CANAL_DES%TYPE,
						P_TIENDA_ORI   	IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_ORI%TYPE,
						P_CANAL_ORI   	IN EBANKING.EBANKING_PAGO_TAZ.CANAL_ORI%TYPE,
						P_FOLIO_OPE_ORI IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_OPE_ORI%TYPE,
						P_NUM_RETEN   	IN EBANKING.EBANKING_PAGO_TAZ.NUM_RETEN%TYPE,
						P_CUENTA_CARGO  IN EBANKING.EBANKING_PAGO_TAZ.CUENTA_CARGO%TYPE,
						P_FOLIO_ABONO   IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_ABONO%TYPE,
                      	PSCOD           OUT NUMBER,
                      	PSMSG           OUT VARCHAR2);
 
PROCEDURE MODIFY_PAGO_TAZ(PEREG IN EBANKING.EBANKING_PAGO_TAZ%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_PAGO_TAZ(P_NUM_CLIENTE   IN EBANKING.EBANKING_PAGO_TAZ.NUM_CLIENTE%TYPE, 
                       	  P_NOM_ORIGEN    IN EBANKING.EBANKING_PAGO_TAZ.NOM_ORIGEN%TYPE, 
                      	  P_NUM_TAZ       IN EBANKING.EBANKING_PAGO_TAZ.NUM_TAZ%TYPE,
                      	  P_NOM_DESTINO   IN EBANKING.EBANKING_PAGO_TAZ.NOM_DESTINO%TYPE,
                      	  P_TIPO_PAGO     IN EBANKING.EBANKING_PAGO_TAZ.TIPO_PAGO%TYPE,
						  P_REFERENCIA    IN EBANKING.EBANKING_PAGO_TAZ.REFERENCIA%TYPE,
						  P_PAIS          IN EBANKING.EBANKING_PAGO_TAZ.PAIS%TYPE,
						  P_CANAL         IN EBANKING.EBANKING_PAGO_TAZ.CANAL%TYPE,
						  P_SUCURSAL   	  IN EBANKING.EBANKING_PAGO_TAZ.SUCURSAL%TYPE,
						  P_FOLIO   	  IN EBANKING.EBANKING_PAGO_TAZ.FOLIO%TYPE,
						  P_MONTO   	  IN EBANKING.EBANKING_PAGO_TAZ.MONTO%TYPE,
						  P_FECHA_PAGO    IN EBANKING.EBANKING_PAGO_TAZ.FECHA_PAGO%TYPE,
						  P_TIENDA_DES    IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_DES%TYPE,
						  P_CANAL_DES     IN EBANKING.EBANKING_PAGO_TAZ.CANAL_DES%TYPE,
						  P_TIENDA_ORI    IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_ORI%TYPE,
						  P_CANAL_ORI     IN EBANKING.EBANKING_PAGO_TAZ.CANAL_ORI%TYPE,
						  P_FOLIO_OPE_ORI IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_OPE_ORI%TYPE,
						  P_NUM_RETEN     IN EBANKING.EBANKING_PAGO_TAZ.NUM_RETEN%TYPE,
						  P_CUENTA_CARGO  IN EBANKING.EBANKING_PAGO_TAZ.CUENTA_CARGO%TYPE,
						  P_FOLIO_ABONO   IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_ABONO%TYPE,
                          PSCOD           OUT NUMBER,
                          PSMSG           OUT VARCHAR2); 
 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IUPIFRECUENT
******************************************************************************/
PROCEDURE ADD_IUPIFRECUENT (PEREG IN EBANKING.IUPIFRECUENT%ROWTYPE,
                            PSCOD OUT NUMBER,
                        	PSMSG OUT VARCHAR2);

PROCEDURE ADD_IUPIFRECUENT (P_ID                 IN EBANKING.IUPIFRECUENT.ID%TYPE, 
                       	    P_ID_CLIENTE    	 IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE, 
                      		P_APODO       		 IN EBANKING.IUPIFRECUENT.APODO%TYPE,
                      		P_CUENTA_DESTINO   	 IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE,
                      		P_EMAIL_DESTINO      IN EBANKING.IUPIFRECUENT.EMAIL_DESTINO%TYPE,
							P_IP_ORIGEN    		 IN EBANKING.IUPIFRECUENT.IP_ORIGEN%TYPE,
							P_STATUS          	 IN EBANKING.IUPIFRECUENT.STATUS%TYPE,
							P_CANAL         	 IN EBANKING.IUPIFRECUENT.CANAL%TYPE,
							P_FECHA_MODIFICACION IN EBANKING.IUPIFRECUENT.FECHA_MODIFICACION%TYPE,						
                      		PSCOD           	 OUT NUMBER,
                      		PSMSG           	 OUT VARCHAR2);
 
PROCEDURE MODIFY_IUPIFRECUENT(PEREG IN EBANKING.IUPIFRECUENT%ROWTYPE,
                              PSCOD OUT NUMBER,
                          	  PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_IUPIFRECUENT(P_ID                 IN EBANKING.IUPIFRECUENT.ID%TYPE, 
                       	      P_ID_CLIENTE    	   IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE, 
                      	  	  P_APODO       	   IN EBANKING.IUPIFRECUENT.APODO%TYPE,
                      	  	  P_CUENTA_DESTINO     IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE,
                      	  	  P_EMAIL_DESTINO      IN EBANKING.IUPIFRECUENT.EMAIL_DESTINO%TYPE,
						  	  P_IP_ORIGEN    	   IN EBANKING.IUPIFRECUENT.IP_ORIGEN%TYPE,
						  	  P_STATUS             IN EBANKING.IUPIFRECUENT.STATUS%TYPE,
						  	  P_CANAL         	   IN EBANKING.IUPIFRECUENT.CANAL%TYPE,
						  	  P_FECHA_MODIFICACION IN EBANKING.IUPIFRECUENT.FECHA_MODIFICACION%TYPE,		
                          	  PSCOD           	   OUT NUMBER,
                          	  PSMSG           	   OUT VARCHAR2); 
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE COMPRATA_TELEFONOSFRECUENTES
******************************************************************************/
PROCEDURE ADD_BUYTA_TELFRECUEN (PEREG IN EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE,
                                PSCOD OUT NUMBER,
                        	    PSMSG OUT VARCHAR2);

PROCEDURE ADD_BUYTA_TELFRECUEN (P_CLIENT               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CLIENT%TYPE, 
                       	        P_CARRIER    	       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CARRIER%TYPE, 
                      			P_TELEPHONE       	   IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.TELEPHONE%TYPE,
                      			P_REFERENCE   	       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.REFERENCE%TYPE,
                      			P_STATUS               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.STATUS%TYPE,
								P_CANAL    		       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CANAL%TYPE,
								P_ULTIMA_ACTUALIZACION IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.ULTIMA_ACTUALIZACION%TYPE,					
                      			PSCOD           	   OUT NUMBER,
                      			PSMSG           	   OUT VARCHAR2);
 
PROCEDURE MODIFY_BUYTA_TELFRECUEN(PEREG IN EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE,
                                  PSCOD OUT NUMBER,
                          	      PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_BUYTA_TELFRECUEN(P_CLIENT               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CLIENT%TYPE, 
                       	          P_CARRIER    	       	 IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CARRIER%TYPE, 
                      			  P_TELEPHONE       	 IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.TELEPHONE%TYPE,
                      			  P_REFERENCE   	     IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.REFERENCE%TYPE,
                      			  P_STATUS               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.STATUS%TYPE,
								  P_CANAL    		     IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CANAL%TYPE,
								  P_ULTIMA_ACTUALIZACION IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.ULTIMA_ACTUALIZACION%TYPE,		
                          	  	  PSCOD           	     OUT NUMBER,
                          	  	  PSMSG           	     OUT VARCHAR2); 
END PKG_CORE_GEN_PAY_BUY;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE          PKG_CORE_GEN_RECORDS AS
/******************************************************************************
   NAME:       PPKG_CORE_GEN_RECORDS  //REGISTROS
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_BITACORA_TRAN (PEREG IN EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_BITACORA_TRAN (P_ID               IN EBANKING.EBANKING_BITACORA_TRAN.ID%TYPE, 
                             P_NUM_CLIENTE      IN EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE, 
                             P_ID_CAT_OPERACION IN EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE,
                             P_IP            	IN EBANKING.EBANKING_BITACORA_TRAN.IP%TYPE,
                    		 P_CTA_ORIGEN   	IN EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE,
                   			 P_CTA_DESTINO      IN EBANKING.EBANKING_BITACORA_TRAN.CTA_DESTINO%TYPE,
                    		 P_FECHA_OPER   	IN EBANKING.EBANKING_BITACORA_TRAN.FECHA_OPER%TYPE,
                    		 P_MONTO     		IN EBANKING.EBANKING_BITACORA_TRAN.MONTO%TYPE,
        					 P_FOLIO     		IN EBANKING.EBANKING_BITACORA_TRAN.FOLIO%TYPE,
        					 P_METODO_CONFIR   	IN EBANKING.EBANKING_BITACORA_TRAN.METODO_CONFIR%TYPE,
        					 P_DETALLE    		IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE%TYPE,
        					 P_NOMBRE_CLIENTE   IN EBANKING.EBANKING_BITACORA_TRAN.NOMBRE_CLIENTE%TYPE,
        					 P_DETALLE2    		IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE2%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2);
 
PROCEDURE MODIFY_BITACORA_TRAN(PEREG IN  EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_BITACORA_TRAN(P_ID               IN EBANKING.EBANKING_BITACORA_TRAN.ID%TYPE, 
                               P_NUM_CLIENTE      IN EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE, 
                               P_ID_CAT_OPERACION IN EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE,
                               P_IP            	  IN EBANKING.EBANKING_BITACORA_TRAN.IP%TYPE,
                    		   P_CTA_ORIGEN   	  IN EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE,
                   			   P_CTA_DESTINO      IN EBANKING.EBANKING_BITACORA_TRAN.CTA_DESTINO%TYPE,
                    		   P_FECHA_OPER   	  IN EBANKING.EBANKING_BITACORA_TRAN.FECHA_OPER%TYPE,
                    		   P_MONTO     		  IN EBANKING.EBANKING_BITACORA_TRAN.MONTO%TYPE,
        					   P_FOLIO     		  IN EBANKING.EBANKING_BITACORA_TRAN.FOLIO%TYPE,
        					   P_METODO_CONFIR    IN EBANKING.EBANKING_BITACORA_TRAN.METODO_CONFIR%TYPE,
        					   P_DETALLE    	  IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE%TYPE,
        					   P_NOMBRE_CLIENTE   IN EBANKING.EBANKING_BITACORA_TRAN.NOMBRE_CLIENTE%TYPE,
        					   P_DETALLE2    	  IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE2%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2); 

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE OPERACIONES_FREC
******************************************************************************/
PROCEDURE ADD_OPER_FRECUENT (PEREG IN EBANKING.OPERACIONES_FREC%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_OPER_FRECUENT (P_ID_OPERACION        IN EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE, 
                             P_USUARIO      	   IN EBANKING.OPERACIONES_FREC.USUARIO%TYPE, 
                             P_CADENA_DATOS 	   IN EBANKING.OPERACIONES_FREC.CADENA_DATOS%TYPE,
                             P_ALIAS               IN EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
                       		 P_OPERACION    	   IN EBANKING.OPERACIONES_FREC.OPERACION%TYPE,
                       		 P_ULTIMA_MODIFICACION IN EBANKING.OPERACIONES_FREC.ULTIMA_MODIFICACION%TYPE,
                       		 P_USUARIO_MODIFICO    IN EBANKING.OPERACIONES_FREC.USUARIO_MODIFICO%TYPE,
                             PSCOD                 OUT NUMBER,
                             PSMSG                 OUT VARCHAR2);
 
PROCEDURE MODIFY_OPER_FRECUENT(PEREG IN  EBANKING.OPERACIONES_FREC%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_OPER_FRECUENT(P_ID_OPERACION        IN EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE, 
                               P_USUARIO      	   	 IN EBANKING.OPERACIONES_FREC.USUARIO%TYPE, 
                               P_CADENA_DATOS 	     IN EBANKING.OPERACIONES_FREC.CADENA_DATOS%TYPE,
                               P_ALIAS               IN EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
                       		   P_OPERACION    	     IN EBANKING.OPERACIONES_FREC.OPERACION%TYPE,
                       		   P_ULTIMA_MODIFICACION IN EBANKING.OPERACIONES_FREC.ULTIMA_MODIFICACION%TYPE,
                       		   P_USUARIO_MODIFICO    IN EBANKING.OPERACIONES_FREC.USUARIO_MODIFICO%TYPE,
                               PSCOD              	 OUT NUMBER,
                               PSMSG              	 OUT VARCHAR2);

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE MON_TRANSACCION
******************************************************************************/
PROCEDURE ADD_MON_TRAN (PEREG IN EBANKINGGUA.MON_TRANSACCION%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2);

PROCEDURE ADD_MON_TRAN (P_ID                   IN EBANKINGGUA.MON_TRANSACCION.ID%TYPE, 
                        P_CUENTAORIGEN         IN EBANKINGGUA.MON_TRANSACCION.CUENTAORIGEN%TYPE, 
                        P_CUENTADESTINO        IN EBANKINGGUA.MON_TRANSACCION.CUENTADESTINO%TYPE,
						P_MONTO                IN EBANKINGGUA.MON_TRANSACCION.MONTO%TYPE,
						P_IP                   IN EBANKINGGUA.MON_TRANSACCION.IP%TYPE,
						P_NOMBREORIGEN         IN EBANKINGGUA.MON_TRANSACCION.NOMBREORIGEN%TYPE,
						P_NOMBREDESTINO        IN EBANKINGGUA.MON_TRANSACCION.NOMBREDESTINO%TYPE,
						P_TEXTOORIGEN          IN EBANKINGGUA.MON_TRANSACCION.TEXTOORIGEN%TYPE,
						P_TEXTODESTINO         IN EBANKINGGUA.MON_TRANSACCION.TEXTODESTINO%TYPE,
						P_FECHARETENCION       IN EBANKINGGUA.MON_TRANSACCION.FECHARETENCION%TYPE,
						P_RETENCIONREQUEST     IN EBANKINGGUA.MON_TRANSACCION.RETENCIONREQUEST%TYPE,
						P_RETENCIONRESPONSE    IN EBANKINGGUA.MON_TRANSACCION.RETENCIONRESPONSE%TYPE,
						P_LIBERACIONREQUEST    IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONREQUEST%TYPE,
						P_LIBERACIONRESPONSE   IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONRESPONSE%TYPE,
						P_FECHALIBERACION      IN EBANKINGGUA.MON_TRANSACCION.FECHALIBERACION%TYPE,
						P_LOGINORIGEN          IN EBANKINGGUA.MON_TRANSACCION.LOGINORIGEN%TYPE,
						P_IDUSUARIOLIBERACION  IN EBANKINGGUA.MON_TRANSACCION.IDUSUARIOLIBERACION%TYPE,
						P_IDSTATUS_TRANSACCION IN EBANKINGGUA.MON_TRANSACCION.IDSTATUS_TRANSACCION%TYPE,
						P_FOLIO     		   IN EBANKINGGUA.MON_TRANSACCION.FOLIO%TYPE,
						P_IDEBANKING     	   IN EBANKINGGUA.MON_TRANSACCION.IDEBANKING%TYPE,
						P_PASWORD     		   IN EBANKINGGUA.MON_TRANSACCION.PASWORD%TYPE,
						P_ERROR     		   IN EBANKINGGUA.MON_TRANSACCION.ERROR%TYPE,
						P_EMAIL     		   IN EBANKINGGUA.MON_TRANSACCION.EMAIL%TYPE,
                        PSCOD              	   OUT NUMBER,
                        PSMSG              	   OUT VARCHAR2);
 
PROCEDURE MODIFY_MON_TRAN(PEREG IN  EBANKINGGUA.MON_TRANSACCION%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_MON_TRAN(P_ID                   IN EBANKINGGUA.MON_TRANSACCION.ID%TYPE, 
                          P_CUENTAORIGEN         IN EBANKINGGUA.MON_TRANSACCION.CUENTAORIGEN%TYPE, 
                          P_CUENTADESTINO        IN EBANKINGGUA.MON_TRANSACCION.CUENTADESTINO%TYPE,
						  P_MONTO                IN EBANKINGGUA.MON_TRANSACCION.MONTO%TYPE,
						  P_IP                   IN EBANKINGGUA.MON_TRANSACCION.IP%TYPE,
						  P_NOMBREORIGEN         IN EBANKINGGUA.MON_TRANSACCION.NOMBREORIGEN%TYPE,
						  P_NOMBREDESTINO        IN EBANKINGGUA.MON_TRANSACCION.NOMBREDESTINO%TYPE,
						  P_TEXTOORIGEN          IN EBANKINGGUA.MON_TRANSACCION.TEXTOORIGEN%TYPE,
						  P_TEXTODESTINO         IN EBANKINGGUA.MON_TRANSACCION.TEXTODESTINO%TYPE,
						  P_FECHARETENCION       IN EBANKINGGUA.MON_TRANSACCION.FECHARETENCION%TYPE,
						  P_RETENCIONREQUEST     IN EBANKINGGUA.MON_TRANSACCION.RETENCIONREQUEST%TYPE,
						  P_RETENCIONRESPONSE    IN EBANKINGGUA.MON_TRANSACCION.RETENCIONRESPONSE%TYPE,
						  P_LIBERACIONREQUEST    IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONREQUEST%TYPE,
						  P_LIBERACIONRESPONSE   IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONRESPONSE%TYPE,
						  P_FECHALIBERACION      IN EBANKINGGUA.MON_TRANSACCION.FECHALIBERACION%TYPE,
						  P_LOGINORIGEN          IN EBANKINGGUA.MON_TRANSACCION.LOGINORIGEN%TYPE,
						  P_IDUSUARIOLIBERACION  IN EBANKINGGUA.MON_TRANSACCION.IDUSUARIOLIBERACION%TYPE,
						  P_IDSTATUS_TRANSACCION IN EBANKINGGUA.MON_TRANSACCION.IDSTATUS_TRANSACCION%TYPE,
						  P_FOLIO     		   	 IN EBANKINGGUA.MON_TRANSACCION.FOLIO%TYPE,
						  P_IDEBANKING     	   	 IN EBANKINGGUA.MON_TRANSACCION.IDEBANKING%TYPE,
						  P_PASWORD     		 IN EBANKINGGUA.MON_TRANSACCION.PASWORD%TYPE,
						  P_ERROR     		   	 IN EBANKINGGUA.MON_TRANSACCION.ERROR%TYPE,
						  P_EMAIL     		   	 IN EBANKINGGUA.MON_TRANSACCION.EMAIL%TYPE,
                          PSCOD              	 OUT NUMBER,
                          PSMSG              	 OUT VARCHAR2);

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_TOKEN_PREVENCION
******************************************************************************/
PROCEDURE ADD_TOKEN_PREVEN (PEREG IN EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);

PROCEDURE ADD_TOKEN_PREVEN (P_ID                 IN EBANKING.EBANKING_TOKEN_PREVENCION.ID%TYPE, 
                            P_TITULAR         	 IN EBANKING.EBANKING_TOKEN_PREVENCION.TITULAR%TYPE, 
                        	P_EMAIL        		 IN EBANKING.EBANKING_TOKEN_PREVENCION.EMAIL%TYPE,
							P_IP                 IN EBANKING.EBANKING_TOKEN_PREVENCION.IP%TYPE,
							P_NUM_SERIE_TOKEN    IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_SERIE_TOKEN%TYPE,	
							P_TEL_PARTICULAR     IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_PARTICULAR%TYPE,
							P_TEL_CELULAR        IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_CELULAR%TYPE,
							P_CARRIER_CEL        IN EBANKING.EBANKING_TOKEN_PREVENCION.CARRIER_CEL%TYPE,
							P_FEC_HORA_OPERACION IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_HORA_OPERACION%TYPE,
							P_NUM_CLIENTE        IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_CLIENTE%TYPE,
							P_ESTATUS            IN EBANKING.EBANKING_TOKEN_PREVENCION.ESTATUS%TYPE,
							P_MOTIVO_PREV_FRAUDE IN EBANKING.EBANKING_TOKEN_PREVENCION.MOTIVO_PREV_FRAUDE%TYPE,
							P_ALIAS              IN EBANKING.EBANKING_TOKEN_PREVENCION.ALIAS%TYPE,
							P_FEC_PREV_FRAU      IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PREV_FRAU%TYPE,
							P_ID_USER_PREV_FRAU  IN EBANKING.EBANKING_TOKEN_PREVENCION.ID_USER_PREV_FRAU%TYPE,
							P_NUM_INTENTOS       IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_INTENTOS%TYPE,
							P_OBSERVACION        IN EBANKING.EBANKING_TOKEN_PREVENCION.OBSERVACION%TYPE,
							P_FEC_PRI_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PRI_INTENTO%TYPE,
							P_FEC_ULT_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_ULT_INTENTO%TYPE,
							P_TIPO_OPERACION     IN EBANKING.EBANKING_TOKEN_PREVENCION.TIPO_OPERACION%TYPE,
							P_SISTEMA            IN EBANKING.EBANKING_TOKEN_PREVENCION.SISTEMA%TYPE,
							P_IDPAIS             IN EBANKING.EBANKING_TOKEN_PREVENCION.IDPAIS%TYPE,					
                        	PSCOD              	 OUT NUMBER,
                        	PSMSG              	 OUT VARCHAR2);
 
PROCEDURE MODIFY_TOKEN_PREVEN(PEREG IN  EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_TOKEN_PREVEN(P_ID                 IN EBANKING.EBANKING_TOKEN_PREVENCION.ID%TYPE, 
                              P_TITULAR            IN EBANKING.EBANKING_TOKEN_PREVENCION.TITULAR%TYPE, 
                        	  P_EMAIL        	   IN EBANKING.EBANKING_TOKEN_PREVENCION.EMAIL%TYPE,
							  P_IP                 IN EBANKING.EBANKING_TOKEN_PREVENCION.IP%TYPE,
							  P_NUM_SERIE_TOKEN    IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_SERIE_TOKEN%TYPE,	
							  P_TEL_PARTICULAR     IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_PARTICULAR%TYPE,
							  P_TEL_CELULAR        IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_CELULAR%TYPE,
							  P_CARRIER_CEL        IN EBANKING.EBANKING_TOKEN_PREVENCION.CARRIER_CEL%TYPE,
							  P_FEC_HORA_OPERACION IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_HORA_OPERACION%TYPE,
							  P_NUM_CLIENTE        IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_CLIENTE%TYPE,
							  P_ESTATUS            IN EBANKING.EBANKING_TOKEN_PREVENCION.ESTATUS%TYPE,
							  P_MOTIVO_PREV_FRAUDE IN EBANKING.EBANKING_TOKEN_PREVENCION.MOTIVO_PREV_FRAUDE%TYPE,
							  P_ALIAS              IN EBANKING.EBANKING_TOKEN_PREVENCION.ALIAS%TYPE,
							  P_FEC_PREV_FRAU      IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PREV_FRAU%TYPE,
							  P_ID_USER_PREV_FRAU  IN EBANKING.EBANKING_TOKEN_PREVENCION.ID_USER_PREV_FRAU%TYPE,
							  P_NUM_INTENTOS       IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_INTENTOS%TYPE,
							  P_OBSERVACION        IN EBANKING.EBANKING_TOKEN_PREVENCION.OBSERVACION%TYPE,
							  P_FEC_PRI_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PRI_INTENTO%TYPE,
							  P_FEC_ULT_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_ULT_INTENTO%TYPE,
							  P_TIPO_OPERACION     IN EBANKING.EBANKING_TOKEN_PREVENCION.TIPO_OPERACION%TYPE,
							  P_SISTEMA            IN EBANKING.EBANKING_TOKEN_PREVENCION.SISTEMA%TYPE,
							  P_IDPAIS             IN EBANKING.EBANKING_TOKEN_PREVENCION.IDPAIS%TYPE,		
                          	  PSCOD                OUT NUMBER,
                          	  PSMSG                OUT VARCHAR2);

END PKG_CORE_GEN_RECORDS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_SECURIT AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_SECURIT
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_HUELLAS_REG (PEREG IN EBANKING.HUELLAS_REG%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2);

PROCEDURE ADD_HUELLAS_REG (P_HUELLA_HASH IN EBANKING.HUELLAS_REG.HUELLA_HASH%TYPE, 
                           P_ALIAS       IN EBANKING.HUELLAS_REG.ALIAS%TYPE, 
                           P_FECHA_HORA  IN EBANKING.HUELLAS_REG.FECHA_HORA%TYPE,
         				   P_CTE_ALNOVA  IN EBANKING.HUELLAS_REG.CTE_ALNOVA%TYPE,
         				   P_IP          IN EBANKING.HUELLAS_REG.IP%TYPE,
         				   P_STATUS 	 IN EBANKING.HUELLAS_REG.STATUS%TYPE,
         				   PSCOD 		 OUT NUMBER,
                           PSMSG 		 OUT VARCHAR2);
 
PROCEDURE MODIFY_HUELLAS_REG(PEREG IN EBANKING.HUELLAS_REG%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_HUELLAS_REG(P_HUELLA_HASH IN EBANKING.HUELLAS_REG.HUELLA_HASH%TYPE, 
                             P_ALIAS       IN EBANKING.HUELLAS_REG.ALIAS%TYPE, 
                           	 P_FECHA_HORA  IN EBANKING.HUELLAS_REG.FECHA_HORA%TYPE,
         				   	 P_CTE_ALNOVA  IN EBANKING.HUELLAS_REG.CTE_ALNOVA%TYPE,
         				   	 P_IP          IN EBANKING.HUELLAS_REG.IP%TYPE,
         				   	 P_STATUS 	   IN EBANKING.HUELLAS_REG.STATUS%TYPE,
         				   	 PSCOD 		   OUT NUMBER,
                           	 PSMSG 		   OUT VARCHAR2); 
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_NIVELESSEGURIDAD
******************************************************************************/
PROCEDURE ADD_NIVELSECURITY (PEREG IN EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_NIVELSECURITY (P_IDUSER 		       IN EBANKING.EBANKING_NIVELESSEGURIDAD.IDUSER%TYPE, 
                             P_NIVELMOVIMIENTOS    IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELMOVIMIENTOS%TYPE, 
                           	 P_NIVELTRANSFERENCIAS IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELTRANSFERENCIAS%TYPE,
                		   	 P_NIVELFRECUENTES     IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELFRECUENTES%TYPE,                		  
                		   	 PSCOD    			   OUT NUMBER,
                           	 PSMSG    			   OUT VARCHAR2);
 
PROCEDURE MODIFY_NIVELSECURITY(PEREG IN EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_NIVELSECURITY(P_IDUSER 		     IN EBANKING.EBANKING_NIVELESSEGURIDAD.IDUSER%TYPE, 
                               P_NIVELMOVIMIENTOS    IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELMOVIMIENTOS%TYPE, 
                           	   P_NIVELTRANSFERENCIAS IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELTRANSFERENCIAS%TYPE,
                		   	   P_NIVELFRECUENTES     IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELFRECUENTES%TYPE, 
                  			   PSCOD         		 OUT NUMBER,
                               PSMSG         		 OUT VARCHAR2);

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_SECURITY_MAX_AMOUNT
******************************************************************************/
PROCEDURE ADD_SECURITMAXMON (PEREG IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_SECURITMAXMON (P_IDUSER 		       IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.IDUSER%TYPE, 
                             P_TERCEROS    		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TERCEROS%TYPE, 
                           	 P_INTERBANCARIO 	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERBANCARIO%TYPE,
                		   	 P_PAGOS     		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.PAGOS%TYPE,
							 P_TIEMPOAIRE     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TIEMPOAIRE%TYPE, 
							 P_DIARIO     		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.DIARIO%TYPE, 
							 P_MOV_TERCEROS        IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TERCEROS%TYPE, 
							 P_MOV_INTER     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTER%TYPE, 
							 P_MOV_PAGOS     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_PAGOS%TYPE, 
							 P_MOV_TIEMPOAIRE      IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TIEMPOAIRE%TYPE, 
							 P_MOV_DIARIO          IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_DIARIO%TYPE,    
							 P_ULTIMO_MOVIMIENTO   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.ULTIMO_MOVIMIENTO%TYPE,             		  
                		   	 P_INTERNACIONALES     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERNACIONALES%TYPE, 
							 P_MOV_INTERNACIONALES IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTERNACIONALES%TYPE, 
							 PSCOD    			   OUT NUMBER,
                           	 PSMSG    			   OUT VARCHAR2);
 
PROCEDURE MODIFY_SECURITMAXMON(PEREG IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_SECURITMAXMON(P_IDUSER 		     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.IDUSER%TYPE, 
                               P_TERCEROS    		 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TERCEROS%TYPE, 
                           	   P_INTERBANCARIO 	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERBANCARIO%TYPE,
                		   	   P_PAGOS     		   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.PAGOS%TYPE,
							   P_TIEMPOAIRE     	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TIEMPOAIRE%TYPE, 
							   P_DIARIO     		 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.DIARIO%TYPE, 
							   P_MOV_TERCEROS        IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TERCEROS%TYPE, 
							   P_MOV_INTER     	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTER%TYPE, 
							   P_MOV_PAGOS     	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_PAGOS%TYPE, 
							   P_MOV_TIEMPOAIRE      IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TIEMPOAIRE%TYPE, 
							   P_MOV_DIARIO          IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_DIARIO%TYPE,    
							   P_ULTIMO_MOVIMIENTO   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.ULTIMO_MOVIMIENTO%TYPE,             		  
                		   	   P_INTERNACIONALES     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERNACIONALES%TYPE, 
							   P_MOV_INTERNACIONALES IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTERNACIONALES%TYPE, 
                  			   PSCOD         		 OUT NUMBER,
                               PSMSG         		 OUT VARCHAR2);

END PKG_CORE_GEN_SECURIT;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_SESSION AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_SESSION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_EBANKING_LOGIN (PEREG IN EBANKING.EBANKING_LOGIN%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);

PROCEDURE ADD_EBANKING_LOGIN (P_USER_ID IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE, 
                              P_ATTEMPTS IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE, 
                              P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN.LOGIN_DATE%TYPE,
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_EBANKING_LOGIN(PEREG IN EBANKING.EBANKING_LOGIN%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_EBANKING_LOGIN(P_USER_ID IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE, 
          					    P_ATTEMPTS IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE, 
          						P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN.LOGIN_DATE%TYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2); 
								
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_SESSION
******************************************************************************/
PROCEDURE ADD_EBANKING_SESSION (PEREG IN EBANKING.EBANKING_USER_SESSION%ROWTYPE,
                                     PSCOD OUT NUMBER,
                                     PSMSG OUT VARCHAR2);

PROCEDURE ADD_EBANKING_SESSION (P_ID             IN EBANKING.EBANKING_USER_SESSION.ID%TYPE, 
                                     P_SESSION_ACTIVA IN EBANKING.EBANKING_USER_SESSION.SESSION_ACTIVA%TYPE, 
                                     P_SESSION_START  IN EBANKING.EBANKING_USER_SESSION.SESSION_START%TYPE,
									 P_IP             IN EBANKING.EBANKING_USER_SESSION.IP%TYPE,
							         PSCOD          OUT NUMBER,
                                     PSMSG 			OUT VARCHAR2);
 
PROCEDURE MODIFY_EBANKING_SESSION(PEREG IN EBANKING.EBANKING_USER_SESSION%ROWTYPE,
                                       PSCOD OUT NUMBER,
                                       PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_EBANKING_SESSION(P_ID 	 	      IN EBANKING.EBANKING_USER_SESSION.ID%TYPE, 
                                       P_SESSION_ACTIVA IN EBANKING.EBANKING_USER_SESSION.SESSION_ACTIVA%TYPE, 
                                       P_SESSION_START  IN EBANKING.EBANKING_USER_SESSION.SESSION_START%TYPE,
									   P_IP 			  IN EBANKING.EBANKING_USER_SESSION.IP%TYPE,
                                       PSCOD 		  OUT NUMBER,
                                       PSMSG 		  OUT VARCHAR2); 
 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_SESSION
******************************************************************************/
PROCEDURE ADD_LOGIN_HIST (PEREG IN EBANKING.EBANKING_LOGIN_HIST%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);

PROCEDURE ADD_LOGIN_HIST (P_ID         IN EBANKING.EBANKING_LOGIN_HIST.ID%TYPE, 
                          P_USER_ID    IN EBANKING.EBANKING_LOGIN_HIST.USER_ID%TYPE, 
                          P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN_HIST.LOGIN_DATE%TYPE,
						  P_ALIAS      IN EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE,
						  P_ATTEMPT    IN EBANKING.EBANKING_LOGIN_HIST.ATTEMPT%TYPE,							  
						  P_IP         IN EBANKING.EBANKING_LOGIN_HIST.IP%TYPE,
						  P_VALIDACION IN EBANKING.EBANKING_LOGIN_HIST.VALIDACION%TYPE,
						  PSCOD        OUT NUMBER,
                          PSMSG 	   OUT VARCHAR2);
 
PROCEDURE MODIFY_LOGIN_HIST(PEREG IN EBANKING.EBANKING_LOGIN_HIST%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_LOGIN_HIST(P_ID         IN EBANKING.EBANKING_LOGIN_HIST.ID%TYPE, 
                            P_USER_ID    IN EBANKING.EBANKING_LOGIN_HIST.USER_ID%TYPE, 
                          	P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN_HIST.LOGIN_DATE%TYPE,
						  	P_ALIAS      IN EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE,
						  	P_ATTEMPT    IN EBANKING.EBANKING_LOGIN_HIST.ATTEMPT%TYPE,							  
						  	P_IP         IN EBANKING.EBANKING_LOGIN_HIST.IP%TYPE,
						  	P_VALIDACION IN EBANKING.EBANKING_LOGIN_HIST.VALIDACION%TYPE,
						  	PSCOD        OUT NUMBER,
                          	PSMSG 	     OUT VARCHAR2); 
END PKG_CORE_GEN_SESSION;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_TRANS AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_TRANS
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_DEST_TEFSPEITERC (PEREG IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2);

PROCEDURE ADD_DEST_TEFSPEITERC (P_ID                   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID%TYPE, 
                                P_ID_CLIENTE           IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE, 
                              	P_ID_TIPOTRANSFERENCIA IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
                           		P_COD_BANCO            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
         						P_CUENTA_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
         						P_NOMBRE_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
         						P_EMAIL_DESTINO        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
         						P_NUM_CELULAR_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
                           		P_NUM_TEL_CASA         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
         						P_NUM_TEL_OFFNA        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
         						P_IP_ORIGEN            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
         						P_FECHA_MODIFICACION   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.FECHA_MODIFICACION%TYPE,
         						P_PLAZA          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
         						P_TIPO_CUENTA_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
         						P_CARRIER_NAME         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
         						P_DESCRIPCION_CUENTA   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
            					P_APODO          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
         						P_ULTIMA_ACTUALIZACION IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ULTIMA_ACTUALIZACION%TYPE,
         						P_STATUS      		   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.STATUS%TYPE,
         						P_CANAL          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CANAL%TYPE,
         						P_NOTIFICACION         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOTIFICACION%TYPE,
                           		PSCOD                  OUT NUMBER,
                           		PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_DEST_TEFSPEIT(PEREG IN  EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_DEST_TEFSPEIT(P_ID                   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID%TYPE, 
                               P_ID_CLIENTE           IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE, 
                               P_ID_TIPOTRANSFERENCIA IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
                           	   P_COD_BANCO            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
         					   P_CUENTA_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
         					   P_NOMBRE_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
         					   P_EMAIL_DESTINO        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
         					   P_NUM_CELULAR_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
                           	   P_NUM_TEL_CASA         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
         					   P_NUM_TEL_OFFNA        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
         					   P_IP_ORIGEN            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
         					   P_FECHA_MODIFICACION   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.FECHA_MODIFICACION%TYPE,
         					   P_PLAZA          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
         					   P_TIPO_CUENTA_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
         					   P_CARRIER_NAME         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
         					   P_DESCRIPCION_CUENTA   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
            				   P_APODO          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
         					   P_ULTIMA_ACTUALIZACION IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ULTIMA_ACTUALIZACION%TYPE,
         					   P_STATUS      		  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.STATUS%TYPE,
         					   P_CANAL          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CANAL%TYPE,
         					   P_NOTIFICACION         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOTIFICACION%TYPE,
                               PSCOD                  OUT NUMBER,
                               PSMSG                  OUT VARCHAR2); 

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ACTIVACION_DEX
******************************************************************************/
PROCEDURE ADD_ACTIVACIONDEX (PEREG IN EBANKING.ACTIVACION_DEX%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_ACTIVACIONDEX (P_CTEALNOVA            IN EBANKING.ACTIVACION_DEX.CTEALNOVA%TYPE, 
                             P_CTEDEX           	IN EBANKING.ACTIVACION_DEX.CTEDEX%TYPE, 
                             P_U_ID 				IN EBANKING.ACTIVACION_DEX.U_ID%TYPE,
                           	 P_FECHAACTIVACION      IN EBANKING.ACTIVACION_DEX.FECHAACTIVACION%TYPE,
         					 P_ULTIMA_MODIFICACION  IN EBANKING.ACTIVACION_DEX.ULTIMA_MODIFICACION%TYPE,
         					 P_USUARIO_MODIFICO     IN EBANKING.ACTIVACION_DEX.USUARIO_MODIFICO%TYPE,
         					 P_PAIS_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.PAIS_IDENTIFICACION%TYPE,
         					 P_TIPO_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.TIPO_IDENTIFICACION%TYPE,
                           	 P_FOLIO_IDENTIFICACION IN EBANKING.ACTIVACION_DEX.FOLIO_IDENTIFICACION%TYPE,
         					 PSCOD                  OUT NUMBER,
                           	 PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_ACTIVACIONDEX(PEREG IN  EBANKING.ACTIVACION_DEX%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_ACTIVACIONDEX(P_CTEALNOVA            IN EBANKING.ACTIVACION_DEX.CTEALNOVA%TYPE, 
                               P_CTEDEX           	  IN EBANKING.ACTIVACION_DEX.CTEDEX%TYPE, 
                               P_U_ID 				  IN EBANKING.ACTIVACION_DEX.U_ID%TYPE,
                           	   P_FECHAACTIVACION      IN EBANKING.ACTIVACION_DEX.FECHAACTIVACION%TYPE,
         					   P_ULTIMA_MODIFICACION  IN EBANKING.ACTIVACION_DEX.ULTIMA_MODIFICACION%TYPE,
         					   P_USUARIO_MODIFICO     IN EBANKING.ACTIVACION_DEX.USUARIO_MODIFICO%TYPE,
         					   P_PAIS_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.PAIS_IDENTIFICACION%TYPE,
         					   P_TIPO_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.TIPO_IDENTIFICACION%TYPE,
                           	   P_FOLIO_IDENTIFICACION IN EBANKING.ACTIVACION_DEX.FOLIO_IDENTIFICACION%TYPE,
                               PSCOD                  OUT NUMBER,
                               PSMSG                  OUT VARCHAR2);
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE BENEFI_DEX
******************************************************************************/
PROCEDURE ADD_BENEFI_DEX (PEREG IN EBANKING.BENEFI_DEX%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_BENEFI_DEX (P_ID_BENEFICIARIO_DEX  IN EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE, 
                          P_ALIAS_BENEFICIARIO   IN EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE, 
                          P_CTEDEX 				 IN EBANKING.BENEFI_DEX.CTEDEX%TYPE,
                          P_FECHAACTIVACION      IN EBANKING.BENEFI_DEX.FECHAACTIVACION%TYPE,
         				  P_ULTIMA_MODIFICACION  IN EBANKING.BENEFI_DEX.ULTIMA_MODIFICACION%TYPE,
         				  P_USUARIO_MODIFICO     IN EBANKING.BENEFI_DEX.USUARIO_MODIFICO%TYPE,         					
         				  PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2);
 
PROCEDURE MODIFY_BENEFI_DEX(PEREG IN  EBANKING.BENEFI_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_BENEFI_DEX(P_ID_BENEFICIARIO_DEX  IN EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE, 
                            P_ALIAS_BENEFICIARIO   IN EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE, 
                          	P_CTEDEX 			   IN EBANKING.BENEFI_DEX.CTEDEX%TYPE,
                          	P_FECHAACTIVACION      IN EBANKING.BENEFI_DEX.FECHAACTIVACION%TYPE,
         				  	P_ULTIMA_MODIFICACION  IN EBANKING.BENEFI_DEX.ULTIMA_MODIFICACION%TYPE,
         				  	P_USUARIO_MODIFICO     IN EBANKING.BENEFI_DEX.USUARIO_MODIFICO%TYPE,
                            PSCOD                  OUT NUMBER,
                            PSMSG                  OUT VARCHAR2);
  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TRANSFER_DEX
******************************************************************************/
PROCEDURE ADD_TRANSFER_DEX (PEREG IN EBANKING.TRANSFER_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_TRANSFER_DEX (P_CLIENTE_ID          IN EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE, 
                            P_MTCN                IN EBANKING.TRANSFER_DEX.MTCN%TYPE, 
                            P_MONTO_ENVIADO       IN EBANKING.TRANSFER_DEX.MONTO_ENVIADO%TYPE,
                           	P_BENEFICIARIO_ID     IN EBANKING.TRANSFER_DEX.BENEFICIARIO_ID%TYPE,
         					P_TARIFA              IN EBANKING.TRANSFER_DEX.TARIFA%TYPE,
         					P_NUM_CUENTA          IN EBANKING.TRANSFER_DEX.NUM_CUENTA%TYPE,
         					P_FECHA_ENVIO         IN EBANKING.TRANSFER_DEX.FECHA_ENVIO%TYPE,
         					P_FOLIO_RETENCION     IN EBANKING.TRANSFER_DEX.FOLIO_RETENCION%TYPE,
                           	P_PAIS_ID_DESTINO     IN EBANKING.TRANSFER_DEX.PAIS_ID_DESTINO%TYPE,
         					P_ESTADO_ID_DESTINO   IN EBANKING.TRANSFER_DEX.ESTADO_ID_DESTINO%TYPE,
         					P_CIUDAD_ID_DESTINO   IN EBANKING.TRANSFER_DEX.CIUDAD_ID_DESTINO%TYPE,
         					P_ID_MONEDA_ENVIO     IN EBANKING.TRANSFER_DEX.ID_MONEDA_ENVIO%TYPE,
         					P_ID_MONEDA_DESTINO   IN EBANKING.TRANSFER_DEX.ID_MONEDA_DESTINO%TYPE,
         					P_ULTIMA_MODIFICACION IN EBANKING.TRANSFER_DEX.ULTIMA_MODIFICACION%TYPE,
         					P_USUARIO_MODIFICO    IN EBANKING.TRANSFER_DEX.USUARIO_MODIFICO%TYPE,
                           	PSCOD                 OUT NUMBER,
                           	PSMSG                 OUT VARCHAR2);
 
PROCEDURE MODIFY_TRANSFER_DEX(PEREG IN  EBANKING.TRANSFER_DEX%ROWTYPE,                               
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_TRANSFER_DEX(P_CLIENTE_ID          IN EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE, 
                              P_MTCN                IN EBANKING.TRANSFER_DEX.MTCN%TYPE, 
                              P_MONTO_ENVIADO       IN EBANKING.TRANSFER_DEX.MONTO_ENVIADO%TYPE,
                           	  P_BENEFICIARIO_ID     IN EBANKING.TRANSFER_DEX.BENEFICIARIO_ID%TYPE,
         					  P_TARIFA              IN EBANKING.TRANSFER_DEX.TARIFA%TYPE,
         					  P_NUM_CUENTA          IN EBANKING.TRANSFER_DEX.NUM_CUENTA%TYPE,
         					  P_FECHA_ENVIO         IN EBANKING.TRANSFER_DEX.FECHA_ENVIO%TYPE,
         					  P_FOLIO_RETENCION     IN EBANKING.TRANSFER_DEX.FOLIO_RETENCION%TYPE,
                           	  P_PAIS_ID_DESTINO     IN EBANKING.TRANSFER_DEX.PAIS_ID_DESTINO%TYPE,
         					  P_ESTADO_ID_DESTINO   IN EBANKING.TRANSFER_DEX.ESTADO_ID_DESTINO%TYPE,
         					  P_CIUDAD_ID_DESTINO   IN EBANKING.TRANSFER_DEX.CIUDAD_ID_DESTINO%TYPE,
         					  P_ID_MONEDA_ENVIO     IN EBANKING.TRANSFER_DEX.ID_MONEDA_ENVIO%TYPE,
         					  P_ID_MONEDA_DESTINO   IN EBANKING.TRANSFER_DEX.ID_MONEDA_DESTINO%TYPE,
         					  P_ULTIMA_MODIFICACION IN EBANKING.TRANSFER_DEX.ULTIMA_MODIFICACION%TYPE,
         					  P_USUARIO_MODIFICO    IN EBANKING.TRANSFER_DEX.USUARIO_MODIFICO%TYPE,
                              PSCOD                 OUT NUMBER,
                              PSMSG                 OUT VARCHAR2);
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IMPUESTO_DEX
******************************************************************************/
PROCEDURE ADD_IMPUESTO_DEX (PEREG IN EBANKING.IMPUESTO_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_IMPUESTO_DEX (P_MTCN                  IN EBANKING.IMPUESTO_DEX.MTCN%TYPE, 
                            P_NOMBRE_IMPUESTO       IN EBANKING.IMPUESTO_DEX.NOMBRE_IMPUESTO%TYPE,
                           	P_MONTO                 IN EBANKING.IMPUESTO_DEX.MONTO%TYPE,
         					P_ID_IMPUESTO           IN EBANKING.IMPUESTO_DEX.ID_IMPUESTO%TYPE,
         					P_ID_IMPORTE            IN EBANKING.IMPUESTO_DEX.ID_IMPORTE%TYPE,
         					P_NOMBRE_CORTO_IMPUESTO IN EBANKING.IMPUESTO_DEX.NOMBRE_CORTO_IMPUESTO%TYPE,
         					P_ULTIMA_MODIFICACION   IN EBANKING.IMPUESTO_DEX.ULTIMA_MODIFICACION%TYPE,
                           	P_USUARIO_MODIFICO      IN EBANKING.IMPUESTO_DEX.USUARIO_MODIFICO%TYPE,
                           	PSCOD                   OUT NUMBER,
                           	PSMSG                   OUT VARCHAR2);
 
PROCEDURE MODIFY_IMPUESTO_DEX(PEREG IN  EBANKING.IMPUESTO_DEX%ROWTYPE,                               
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_IMPUESTO_DEX(P_MTCN                  IN EBANKING.IMPUESTO_DEX.MTCN%TYPE, 
                              P_NOMBRE_IMPUESTO       IN EBANKING.IMPUESTO_DEX.NOMBRE_IMPUESTO%TYPE,
                           	  P_MONTO                 IN EBANKING.IMPUESTO_DEX.MONTO%TYPE,
         					  P_ID_IMPUESTO           IN EBANKING.IMPUESTO_DEX.ID_IMPUESTO%TYPE,
         					  P_ID_IMPORTE            IN EBANKING.IMPUESTO_DEX.ID_IMPORTE%TYPE,
         					  P_NOMBRE_CORTO_IMPUESTO IN EBANKING.IMPUESTO_DEX.NOMBRE_CORTO_IMPUESTO%TYPE,
         					  P_ULTIMA_MODIFICACION   IN EBANKING.IMPUESTO_DEX.ULTIMA_MODIFICACION%TYPE,
                           	  P_USUARIO_MODIFICO      IN EBANKING.IMPUESTO_DEX.USUARIO_MODIFICO%TYPE,
                              PSCOD                 OUT NUMBER,
                              PSMSG                 OUT VARCHAR2);
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_TRACKING
******************************************************************************/
PROCEDURE ADD_USER_TRACKING (PEREG IN EBANKING.EBANKING_USER_TRACKING%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_USER_TRACKING (P_NUMERO_CLIENTE IN EBANKING.EBANKING_USER_TRACKING.NUMERO_CLIENTE%TYPE, 
                             P_FECHA          IN EBANKING.EBANKING_USER_TRACKING.FECHA%TYPE,
                           	 P_DESCRIPCION    IN EBANKING.EBANKING_USER_TRACKING.DESCRIPCION%TYPE,
         					 P_SISTEMA        IN EBANKING.EBANKING_USER_TRACKING.SISTEMA%TYPE,
         					 P_ALIAS          IN EBANKING.EBANKING_USER_TRACKING.ALIAS%TYPE,
         					 P_ESTATUS 		  IN EBANKING.EBANKING_USER_TRACKING.ESTATUS%TYPE,
         					 P_USR_PREV   	  IN EBANKING.EBANKING_USER_TRACKING.USR_PREV%TYPE,
                           	 PSCOD            OUT NUMBER,
                           	 PSMSG            OUT VARCHAR2);
 
PROCEDURE MODIFY_USER_TRACKING(PEREG IN  EBANKING.EBANKING_USER_TRACKING%ROWTYPE,                               
							   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_USER_TRACKING(P_NUMERO_CLIENTE IN EBANKING.EBANKING_USER_TRACKING.NUMERO_CLIENTE%TYPE, 
                               P_FECHA          IN EBANKING.EBANKING_USER_TRACKING.FECHA%TYPE,
                           	   P_DESCRIPCION    IN EBANKING.EBANKING_USER_TRACKING.DESCRIPCION%TYPE,
         					   P_SISTEMA        IN EBANKING.EBANKING_USER_TRACKING.SISTEMA%TYPE,
         					   P_ALIAS          IN EBANKING.EBANKING_USER_TRACKING.ALIAS%TYPE,
         					   P_ESTATUS 		IN EBANKING.EBANKING_USER_TRACKING.ESTATUS%TYPE,
         					   P_USR_PREV   	IN EBANKING.EBANKING_USER_TRACKING.USR_PREV%TYPE,
                               PSCOD            OUT NUMBER,
                               PSMSG            OUT VARCHAR2);
							   
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE SCHEDULED_PAYMENT
******************************************************************************/
PROCEDURE ADD_SCHEDULED_PAY (PEREG IN EBANKING.SCHEDULED_PAYMENT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);
				

PROCEDURE ADD_SCHEDULED_PAY (P_SCHEDULED_PAYMENT_ID IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_PAYMENT_ID%TYPE, 
                             P_TX                   IN EBANKING.SCHEDULED_PAYMENT.TX%TYPE,
                           	 P_REQUEST    			IN EBANKING.SCHEDULED_PAYMENT.REQUEST%TYPE,
         					 P_RESPONSE        		IN EBANKING.SCHEDULED_PAYMENT.RESPONSE%TYPE,
         					 P_STATUS          		IN EBANKING.SCHEDULED_PAYMENT.STATUS%TYPE,
         					 P_APPLY_DATE 		    IN EBANKING.SCHEDULED_PAYMENT.APPLY_DATE%TYPE,
         					 P_PROGRAM_DATE   	  	IN EBANKING.SCHEDULED_PAYMENT.PROGRAM_DATE%TYPE,
							 P_TX_NAME        		IN EBANKING.SCHEDULED_PAYMENT.TX_NAME%TYPE,
							 P_TEXT               	IN EBANKING.SCHEDULED_PAYMENT.TEXT%TYPE,
							 P_FOLIO_PROGRAMADO     IN EBANKING.SCHEDULED_PAYMENT.FOLIO_PROGRAMADO%TYPE,
							 P_FOLIO_ENVIADO        IN EBANKING.SCHEDULED_PAYMENT.FOLIO_ENVIADO%TYPE,
							 P_FOLIO_INTERBANCARIO  IN EBANKING.SCHEDULED_PAYMENT.FOLIO_INTERBANCARIO%TYPE,
							 P_USER_ID              IN EBANKING.SCHEDULED_PAYMENT.USER_ID%TYPE,
							 P_SCHEDULED_EMAIL_ID   IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_EMAIL_ID%TYPE,
                           	 PSCOD            		OUT NUMBER,
                           	 PSMSG            		OUT VARCHAR2);
 
PROCEDURE MODIFY_SCHEDULED_PAY(PEREG IN  EBANKING.SCHEDULED_PAYMENT%ROWTYPE,                               
							   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
PROCEDURE MODIFY_SCHEDULED_PAY(P_SCHEDULED_PAYMENT_ID IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_PAYMENT_ID%TYPE, 
                               P_TX                   IN EBANKING.SCHEDULED_PAYMENT.TX%TYPE,
                           	   P_REQUEST    		  IN EBANKING.SCHEDULED_PAYMENT.REQUEST%TYPE,
         					   P_RESPONSE        	  IN EBANKING.SCHEDULED_PAYMENT.RESPONSE%TYPE,
         					   P_STATUS          	  IN EBANKING.SCHEDULED_PAYMENT.STATUS%TYPE,
         					   P_APPLY_DATE 		  IN EBANKING.SCHEDULED_PAYMENT.APPLY_DATE%TYPE,
         					   P_PROGRAM_DATE   	  IN EBANKING.SCHEDULED_PAYMENT.PROGRAM_DATE%TYPE,
							   P_TX_NAME        	  IN EBANKING.SCHEDULED_PAYMENT.TX_NAME%TYPE,
							   P_TEXT                 IN EBANKING.SCHEDULED_PAYMENT.TEXT%TYPE,
							   P_FOLIO_PROGRAMADO     IN EBANKING.SCHEDULED_PAYMENT.FOLIO_PROGRAMADO%TYPE,
							   P_FOLIO_ENVIADO        IN EBANKING.SCHEDULED_PAYMENT.FOLIO_ENVIADO%TYPE,
							   P_FOLIO_INTERBANCARIO  IN EBANKING.SCHEDULED_PAYMENT.FOLIO_INTERBANCARIO%TYPE,
							   P_USER_ID              IN EBANKING.SCHEDULED_PAYMENT.USER_ID%TYPE,
							   P_SCHEDULED_EMAIL_ID   IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_EMAIL_ID%TYPE,
                               PSCOD            	  OUT NUMBER,
                               PSMSG            	  OUT VARCHAR2);

END PKG_CORE_GEN_TRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_GEN_USER AS
/******************************************************************************
   NAME:       PKG_CORE_AUTENTICATION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_EBANKING_USER (PEREG IN EBANKING.EBANKING_USER%ROWTYPE,
		  					 PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2);

PROCEDURE ADD_EBANKING_USER (P_ID 	   	   	  		    IN EBANKING.EBANKING_USER.ID%TYPE, 
					         P_ACTIVATION    	  	    IN EBANKING.EBANKING_USER.ACTIVATION%TYPE, 
					         P_ACTIVE 	   	  		    IN EBANKING.EBANKING_USER.ACTIVE%TYPE, 
					         P_ANSWER 	   	  		    IN EBANKING.EBANKING_USER.ANSWER%TYPE, 
					         P_CELLULAR 	   	  	    IN EBANKING.EBANKING_USER.CELLULAR%TYPE, 
					         P_EMAIL 		   	  	    IN EBANKING.EBANKING_USER.EMAIL%TYPE, 
					         P_QUESTION 	   	  	    IN EBANKING.EBANKING_USER.QUESTION%TYPE, 
					         P_USER2CELLCOMPANY 	    IN EBANKING.EBANKING_USER.USER2CELLCOMPANY%TYPE, 
					         P_ADVANCEDSERVICE  	    IN EBANKING.EBANKING_USER.ADVANCEDSERVICE%TYPE, 
					         P_SECUREDATA 	  		    IN EBANKING.EBANKING_USER.SECUREDATA%TYPE,
					         P_ACTIVATIONTYPE   	    IN EBANKING.EBANKING_USER.ACTIVATIONTYPE%TYPE, 
					         P_SECURITY_LEVEL   	    IN EBANKING.EBANKING_USER.SECURITY_LEVEL%TYPE, 
					         P_STATUSNS 		  	    IN EBANKING.EBANKING_USER.STATUSNS%TYPE, 
					         P_CODIGONS 		  		IN EBANKING.EBANKING_USER.CODIGONS%TYPE, 
					         P_CONFIRMNS 		  		IN EBANKING.EBANKING_USER.CONFIRMNS%TYPE, 
					         P_STATUS_CONT_TRAN 		IN EBANKING.EBANKING_USER.STATUS_CONT_TRAN%TYPE, 
					         P_MAIL_RECEIVE 	  		IN EBANKING.EBANKING_USER.MAIL_RECEIVE%TYPE, 
					         P_TRACKING 		  		IN EBANKING.EBANKING_USER.TRACKING%TYPE, 
					         P_PWD_CONFIRM 	  		    IN EBANKING.EBANKING_USER.PWD_CONFIRM%TYPE, 
					         P_PWD_BANCA_TEL 	  		IN EBANKING.EBANKING_USER.PWD_BANCA_TEL%TYPE, 
					         P_PWD_CHANGE_DATE  	 	IN EBANKING.EBANKING_USER.PWD_CHANGE_DATE%TYPE, 
					         P_PWD_STATUS 	  	        IN EBANKING.EBANKING_USER.PWD_STATUS%TYPE, 
					         P_PWD_CONFIRM_CHANGE_DATE  IN EBANKING.EBANKING_USER.PWD_CONFIRM_CHANGE_DATE%TYPE, 
					         P_BIOMETRICO 			    IN EBANKING.EBANKING_USER.BIOMETRICO%TYPE, 
					         P_TELEFONO_OFICINA 		IN EBANKING.EBANKING_USER.TELEFONO_OFICINA%TYPE, 
					         P_OLD_ADVANCEDSERVICE 	    IN EBANKING.EBANKING_USER.OLD_ADVANCEDSERVICE%TYPE, 
					         P_ULT_ACCESO 			    IN EBANKING.EBANKING_USER.ULT_ACCESO%TYPE, 
					         P_ULT_IP 				    IN EBANKING.EBANKING_USER.ULT_IP%TYPE, 
					         P_BAN_MAIL 				IN EBANKING.EBANKING_USER.BAN_MAIL%TYPE, 
					         P_TOKEN 					IN EBANKING.EBANKING_USER.TOKEN%TYPE, 
					         P_FECHA_CAMBIO_STATUS_BAJA IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS_BAJA%TYPE, 
					         P_STATUS_BAJA 			    IN EBANKING.EBANKING_USER.STATUS_BAJA%TYPE, 
					         P_USER_STATUS 			    IN EBANKING.EBANKING_USER.USER_STATUS%TYPE, 
					         P_FECHA_CAMBIO_STATUS 	    IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS%TYPE, 
					         P_RFC_CLIENTE 			    IN EBANKING.EBANKING_USER.RFC_CLIENTE%TYPE, 
					         P_NIP_RED_MOVIL 		    IN EBANKING.EBANKING_USER.NIP_RED_MOVIL%TYPE,
							 PSCOD 						OUT NUMBER,
                             PSMSG 						OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_USER(PEREG IN EBANKING.EBANKING_USER%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_USER(P_ID 	   	   	  		  IN EBANKING.EBANKING_USER.ID%TYPE, 
					           P_ACTIVATION    	  		  IN EBANKING.EBANKING_USER.ACTIVATION%TYPE, 
					           P_ACTIVE 	   	  		  IN EBANKING.EBANKING_USER.ACTIVE%TYPE, 
					           P_ANSWER 	   	  		  IN EBANKING.EBANKING_USER.ANSWER%TYPE, 
					           P_CELLULAR 	   	  		  IN EBANKING.EBANKING_USER.CELLULAR%TYPE, 
					           P_EMAIL 		   	  		  IN EBANKING.EBANKING_USER.EMAIL%TYPE, 
					           P_QUESTION 	   	  		  IN EBANKING.EBANKING_USER.QUESTION%TYPE, 
					           P_USER2CELLCOMPANY 		  IN EBANKING.EBANKING_USER.USER2CELLCOMPANY%TYPE, 
					           P_ADVANCEDSERVICE  		  IN EBANKING.EBANKING_USER.ADVANCEDSERVICE%TYPE, 
					           P_SECUREDATA 	  		  IN EBANKING.EBANKING_USER.SECUREDATA%TYPE,
					           P_ACTIVATIONTYPE   		  IN EBANKING.EBANKING_USER.ACTIVATIONTYPE%TYPE, 
					           P_SECURITY_LEVEL   		  IN EBANKING.EBANKING_USER.SECURITY_LEVEL%TYPE, 
					           P_STATUSNS 		  		  IN EBANKING.EBANKING_USER.STATUSNS%TYPE, 
					           P_CODIGONS 		  		  IN EBANKING.EBANKING_USER.CODIGONS%TYPE, 
					           P_CONFIRMNS 		  		  IN EBANKING.EBANKING_USER.CONFIRMNS%TYPE, 
					           P_STATUS_CONT_TRAN 		  IN EBANKING.EBANKING_USER.STATUS_CONT_TRAN%TYPE, 
					           P_MAIL_RECEIVE 	  		  IN EBANKING.EBANKING_USER.MAIL_RECEIVE%TYPE, 
					           P_TRACKING 		  		  IN EBANKING.EBANKING_USER.TRACKING%TYPE, 
					           P_PWD_CONFIRM 	  		  IN EBANKING.EBANKING_USER.PWD_CONFIRM%TYPE, 
					           P_PWD_BANCA_TEL 	  		  IN EBANKING.EBANKING_USER.PWD_BANCA_TEL%TYPE, 
					           P_PWD_CHANGE_DATE  	 	  IN EBANKING.EBANKING_USER.PWD_CHANGE_DATE%TYPE, 
					           P_PWD_STATUS 	  	      IN EBANKING.EBANKING_USER.PWD_STATUS%TYPE, 
					           P_PWD_CONFIRM_CHANGE_DATE  IN EBANKING.EBANKING_USER.PWD_CONFIRM_CHANGE_DATE%TYPE, 
					           P_BIOMETRICO 			  IN EBANKING.EBANKING_USER.BIOMETRICO%TYPE, 
					           P_TELEFONO_OFICINA 		  IN EBANKING.EBANKING_USER.TELEFONO_OFICINA%TYPE, 
					           P_OLD_ADVANCEDSERVICE 	  IN EBANKING.EBANKING_USER.OLD_ADVANCEDSERVICE%TYPE, 
					           P_ULT_ACCESO 			  IN EBANKING.EBANKING_USER.ULT_ACCESO%TYPE, 
					           P_ULT_IP 				  IN EBANKING.EBANKING_USER.ULT_IP%TYPE, 
					           P_BAN_MAIL 				  IN EBANKING.EBANKING_USER.BAN_MAIL%TYPE, 
					           P_TOKEN 					  IN EBANKING.EBANKING_USER.TOKEN%TYPE, 
					           P_FECHA_CAMBIO_STATUS_BAJA IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS_BAJA%TYPE, 
					           P_STATUS_BAJA 			  IN EBANKING.EBANKING_USER.STATUS_BAJA%TYPE, 
					           P_USER_STATUS 			  IN EBANKING.EBANKING_USER.USER_STATUS%TYPE, 
					           P_FECHA_CAMBIO_STATUS 	  IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS%TYPE, 
					           P_RFC_CLIENTE 			  IN EBANKING.EBANKING_USER.RFC_CLIENTE%TYPE, 
					           P_NIP_RED_MOVIL 			  IN EBANKING.EBANKING_USER.NIP_RED_MOVIL%TYPE,
                               PSCOD 				      OUT NUMBER,
                               PSMSG 				      OUT VARCHAR2);
							  
							  
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_OLD
******************************************************************************/
PROCEDURE ADD_EBANKING_USEROLD (PEREG IN EBANKING.EBANKING_USER_OLD%ROWTYPE,
		  					    PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2);

PROCEDURE ADD_EBANKING_USEROLD (P_USER_ID 	   	   	  	IN EBANKING.EBANKING_USER_OLD.USER_ID%TYPE, 
						        P_CELLULAR_OLD    	  	IN EBANKING.EBANKING_USER_OLD.CELLULAR_OLD%TYPE, 
						        P_CELLULAR_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.CELLULAR_CHANGE_DATE%TYPE, 
						        P_TELEFONO_ALTERNO_OLD  IN EBANKING.EBANKING_USER_OLD.TELEFONO_ALTERNO_OLD%TYPE, 
						        P_ALTERNO_CHANGE_DATE 	IN EBANKING.EBANKING_USER_OLD.ALTERNO_CHANGE_DATE%TYPE, 
						        P_EMAIL_OLD  		   	IN EBANKING.EBANKING_USER_OLD.EMAIL_OLD%TYPE, 
						        P_EMAIL_CHANGE_DATE 	IN EBANKING.EBANKING_USER_OLD.EMAIL_CHANGE_DATE%TYPE, 
						        P_QUESTION_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.QUESTION_CHANGE_DATE%TYPE, 
						        P_ANSWER_CHANGE_DATE  	IN EBANKING.EBANKING_USER_OLD.ANSWER_CHANGE_DATE%TYPE, 
						        P_IP 	  				IN EBANKING.EBANKING_USER_OLD.IP%TYPE,						        				       
								PSCOD 					OUT NUMBER,
	                            PSMSG 					OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_USEROLD(PEREG IN EBANKING.EBANKING_USER_OLD%ROWTYPE,
                                  PSCOD OUT NUMBER,
                                  PSMSG OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_USEROLD(P_USER_ID 	   	   	 IN EBANKING.EBANKING_USER_OLD.USER_ID%TYPE, 
						          P_CELLULAR_OLD    	 IN EBANKING.EBANKING_USER_OLD.CELLULAR_OLD%TYPE, 
						          P_CELLULAR_CHANGE_DATE IN EBANKING.EBANKING_USER_OLD.CELLULAR_CHANGE_DATE%TYPE, 
						          P_TELEFONO_ALTERNO_OLD IN EBANKING.EBANKING_USER_OLD.TELEFONO_ALTERNO_OLD%TYPE, 
						          P_ALTERNO_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.ALTERNO_CHANGE_DATE%TYPE, 
						          P_EMAIL_OLD  		     IN EBANKING.EBANKING_USER_OLD.EMAIL_OLD%TYPE, 
						          P_EMAIL_CHANGE_DATE 	 IN EBANKING.EBANKING_USER_OLD.EMAIL_CHANGE_DATE%TYPE, 
						          P_QUESTION_CHANGE_DATE IN EBANKING.EBANKING_USER_OLD.QUESTION_CHANGE_DATE%TYPE, 
						          P_ANSWER_CHANGE_DATE   IN EBANKING.EBANKING_USER_OLD.ANSWER_CHANGE_DATE%TYPE, 
						          P_IP 	  			     IN EBANKING.EBANKING_USER_OLD.IP%TYPE,
                             	  PSCOD 				 OUT NUMBER,
                             	  PSMSG 				 OUT VARCHAR2);	
								   						   
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_ACTIVATION
******************************************************************************/		
				   
PROCEDURE ADD_EBANKING_ACTIVA (PEREG IN EBANKING.EBANKING_ACTIVATION%ROWTYPE,
		  					   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2);

PROCEDURE ADD_EBANKING_ACTIVA (P_ALIAS 	   	   	  	IN EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE, 
						       P_CLIENTE    	  	IN EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE, 
						       P_EMAIL 	   	  		IN EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE, 
						       P_CUENTAOTARJ 	   	IN EBANKING.EBANKING_ACTIVATION.CUENTAOTARJ%TYPE, 
						       P_QUESTION 	   	  	IN EBANKING.EBANKING_ACTIVATION.QUESTION%TYPE, 
						       P_ANSWER 		   	IN EBANKING.EBANKING_ACTIVATION.ANSWER%TYPE, 
						       P_CEL_PHONE 	   	  	IN EBANKING.EBANKING_ACTIVATION.CEL_PHONE%TYPE, 
						       P_COMPANY 	    	IN EBANKING.EBANKING_ACTIVATION.COMPANY%TYPE, 
						       P_OFFICE_PHONE  	    IN EBANKING.EBANKING_ACTIVATION.OFFICE_PHONE%TYPE, 
						       P_STATUS 	  		IN EBANKING.EBANKING_ACTIVATION.STATUS%TYPE,
						       P_ACTIVACION   	    IN EBANKING.EBANKING_ACTIVATION.ACTIVACION%TYPE, 
						       P_CODE   	    	IN EBANKING.EBANKING_ACTIVATION.CODE%TYPE, 
						       P_CUENTA 		  	IN EBANKING.EBANKING_ACTIVATION.CUENTA%TYPE, 
						       P_IP 		  		IN EBANKING.EBANKING_ACTIVATION.IP%TYPE, 
						       P_TARJETA	  		IN EBANKING.EBANKING_ACTIVATION.TARJETA%TYPE, 
						       P_TIPO 				IN EBANKING.EBANKING_ACTIVATION.TIPO%TYPE, 
						       P_MONITOR 	  		IN EBANKING.EBANKING_ACTIVATION.MONITOR%TYPE, 
						       P_COMENTARIO 		IN EBANKING.EBANKING_ACTIVATION.COMENTARIO%TYPE, 
						       P_INTENTOS_LOCALIZAR	IN EBANKING.EBANKING_ACTIVATION.INTENTOS_LOCALIZAR%TYPE, 
						       P_NAME 	  			IN EBANKING.EBANKING_ACTIVATION.NAME%TYPE, 
						       P_TIPOPROD 	 		IN EBANKING.EBANKING_ACTIVATION.TIPOPROD%TYPE, 
						       P_FIRSTINTENTO 	  	IN EBANKING.EBANKING_ACTIVATION.FIRSTINTENTO%TYPE, 
						       P_LASTINTENTO  		IN EBANKING.EBANKING_ACTIVATION.LASTINTENTO%TYPE, 
						       P_CONFIRMACION		IN EBANKING.EBANKING_ACTIVATION.CONFIRMACION%TYPE, 					       
							   PSCOD 				OUT NUMBER,
	                           PSMSG 				OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_ACTIVA(PEREG IN EBANKING.EBANKING_ACTIVATION%ROWTYPE,
                                 PSCOD OUT NUMBER,
                                 PSMSG OUT VARCHAR2);
 
 
PROCEDURE MODIFY_EBANKING_ACTIVA(P_ALIAS 	   	   	  	IN EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE, 
					             P_CLIENTE    	  	    IN EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE, 
					             P_EMAIL 	   	  		IN EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE, 
					             P_CUENTAOTARJ 	   	  	IN EBANKING.EBANKING_ACTIVATION.CUENTAOTARJ%TYPE, 
					             P_QUESTION 	   	  	IN EBANKING.EBANKING_ACTIVATION.QUESTION%TYPE, 
					             P_ANSWER 		   	  	IN EBANKING.EBANKING_ACTIVATION.ANSWER%TYPE, 
					         	 P_CEL_PHONE 	   	  	IN EBANKING.EBANKING_ACTIVATION.CEL_PHONE%TYPE, 
					         	 P_COMPANY 	    		IN EBANKING.EBANKING_ACTIVATION.COMPANY%TYPE, 
					         	 P_OFFICE_PHONE  	    IN EBANKING.EBANKING_ACTIVATION.OFFICE_PHONE%TYPE, 
					             P_STATUS 	  		    IN EBANKING.EBANKING_ACTIVATION.STATUS%TYPE,
					         	 P_ACTIVACION   	    IN EBANKING.EBANKING_ACTIVATION.ACTIVACION%TYPE, 
					             P_CODE   	    		IN EBANKING.EBANKING_ACTIVATION.CODE%TYPE, 
					             P_CUENTA 		  	    IN EBANKING.EBANKING_ACTIVATION.CUENTA%TYPE, 
					         	 P_IP 		  			IN EBANKING.EBANKING_ACTIVATION.IP%TYPE, 
					         	 P_TARJETA	  			IN EBANKING.EBANKING_ACTIVATION.TARJETA%TYPE, 
					         	 P_TIPO 				IN EBANKING.EBANKING_ACTIVATION.TIPO%TYPE, 
					         	 P_MONITOR 	  			IN EBANKING.EBANKING_ACTIVATION.MONITOR%TYPE, 
					         	 P_COMENTARIO 		  	IN EBANKING.EBANKING_ACTIVATION.COMENTARIO%TYPE, 
					         	 P_INTENTOS_LOCALIZAR	IN EBANKING.EBANKING_ACTIVATION.INTENTOS_LOCALIZAR%TYPE, 
					         	 P_NAME 	  			IN EBANKING.EBANKING_ACTIVATION.NAME%TYPE, 
					         	 P_TIPOPROD 	 		IN EBANKING.EBANKING_ACTIVATION.TIPOPROD%TYPE, 
					         	 P_FIRSTINTENTO 	  	IN EBANKING.EBANKING_ACTIVATION.FIRSTINTENTO%TYPE, 
					         	 P_LASTINTENTO  		IN EBANKING.EBANKING_ACTIVATION.LASTINTENTO%TYPE, 
					         	 P_CONFIRMACION			IN EBANKING.EBANKING_ACTIVATION.CONFIRMACION%TYPE,
                             	 PSCOD 				    OUT NUMBER,
                             	 PSMSG 				    OUT VARCHAR2);
  
END PKG_CORE_GEN_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_PAR_DATOS AS
     
     FUNCTION GETEBAKINGCORE(PECADENA IN VARCHAR2)RETURN SYS_REFCURSOR;
  
END PKG_CORE_PAR_DATOS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_PAR_SESSION AS
/******************************************************************************
   NAME:       PKG_CORE_PAR_SESSION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE EBANKING_LOGIN (P_USER_ID    IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
		  				  P_ATTEMPTS   IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE,
		  				  P_ACCION     IN NUMBER,
                          PSCOD 	   OUT NUMBER,
                          PSMSG 	   OUT VARCHAR2);

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_SESSION
******************************************************************************/
PROCEDURE EBANKING_SESSION (PEREG    USERSESSIONBEAN,
		  					P_ACCION IN NUMBER,
                            PSCOD    OUT NUMBER,
                            PSMSG    OUT VARCHAR2);

END PKG_CORE_PAR_SESSION;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_PAR_USER AS
/******************************************************************************
   NAME:       PKG_CORE_PAR_USER
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE EBANKING_USER (PEREG    USERBEAN,
		  				 P_ACCION IN NUMBER,
		  				 PSCOD    OUT NUMBER,
                         PSMSG    OUT VARCHAR2);	

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_ACTIVATION
******************************************************************************/
 
PROCEDURE EBANKING_ACTIVATION (PEREG    ACTIVATIONBEAN,
		  				 	   P_ACCION IN NUMBER,
		  				 	   PSCOD    OUT NUMBER,
                         	   PSMSG    OUT VARCHAR2);	
							   
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_OLD
******************************************************************************/

PROCEDURE EBANKING_USER_OLD (PEREG    USEROLDBEAN,
		  				 	 P_ACCION IN NUMBER,
		  				 	 PSCOD    OUT NUMBER,
                         	 PSMSG    OUT VARCHAR2);	
							   
END PKG_CORE_PAR_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE PKG_CORE_SERVICES IS
/******************************************************************************
   NAME:       PKG_CORE_SERVICES
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        13/06/2012             1. Created this package.
******************************************************************************/
    
  PROCEDURE CAT_ROL (P_IDROL              IN EBANKING.CORE_ROL.IDROL%TYPE,
                     P_NOMBRE_ROL         IN EBANKING.CORE_ROL.NOMBRE_ROL%TYPE,                             
                     P_STATUS             IN EBANKING.CORE_ROL.STATUS%TYPE,
                     P_USUARIO_MODIFICO   IN EBANKING.CORE_ROL.USUARIO_MODIFICO%TYPE,
                     P_ACCION             IN NUMBER,
                     P_RESULTADO          OUT NUMBER,
                     P_RESULTADODES       OUT VARCHAR2);
    
  PROCEDURE CAT_EJBS(P_IDEJB              IN EBANKING.CORE_EJBS.IDEJB%TYPE,
                     P_NOMBRE_EJB         IN EBANKING.CORE_EJBS.NOMBRE_EJB%TYPE,                             
                     P_STATUS             IN EBANKING.CORE_EJBS.STATUS%TYPE,
                     P_USUARIO_MODIFICO   IN EBANKING.CORE_EJBS.USUARIO_MODIFICO%TYPE,
                     P_ACCION             IN NUMBER,
                     P_RESULTADO          OUT NUMBER,
                     P_RESULTADODES       OUT VARCHAR2);
  
  PROCEDURE CAT_METODOS(P_IDMETODO            IN EBANKING.CORE_METODS.IDMETODO%TYPE,
                        P_IDEJB               IN EBANKING.CORE_METODS.IDEJB%TYPE,                             
                        P_NOMBRE_METODO       IN EBANKING.CORE_METODS.NOMBRE_METODO%TYPE,
						P_DESCRIPCION_FUNCION IN EBANKING.CORE_METODS.DESCRIPCION_FUNCION%TYPE,
                        P_STATUS              IN EBANKING.CORE_METODS.STATUS%TYPE,
                        P_USUARIO_MODIFICO    IN EBANKING.CORE_METODS.USUARIO_MODIFICO%TYPE,
                        P_ACCION              IN NUMBER,
                        P_RESULTADO           OUT NUMBER,
                        P_RESULTADODES        OUT VARCHAR2);
    
  PROCEDURE CAT_ROL_METODO(P_IDROL_METODO       IN EBANKING.CORE_ROL_METODS.IDROL_METODO%TYPE,
                           P_IDMETODO           IN EBANKING.CORE_ROL_METODS.IDMETODO%TYPE,   
                           P_IDROL              IN EBANKING.CORE_ROL_METODS.IDROL%TYPE,     
                           P_STATUS             IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           P_USUARIO_MODIFICO   IN EBANKING.CORE_ROL_METODS.USUARIO_MODIFICO%TYPE,
                           P_ACCION             IN NUMBER,
                           P_RESULTADO          OUT NUMBER,
                           P_RESULTADODES       OUT VARCHAR2);
  
  PROCEDURE CAT_MACS(P_MAC                 IN EBANKING.CORE_MACS.MAC%TYPE,
  					 P_MAC_M               IN EBANKING.CORE_MACS.MAC%TYPE,
                     P_IDROL               IN EBANKING.CORE_MACS.IDROL%TYPE,                             
                     P_NOMBRE_APLICACION   IN EBANKING.CORE_MACS.NOMBRE_APLICACION%TYPE,
					 P_NOMBRE_APLICACION_M IN EBANKING.CORE_MACS.NOMBRE_APLICACION%TYPE,
                     P_STATUS              IN EBANKING.CORE_MACS.STATUS%TYPE,
                     P_USUARIO_MODIFICO    IN EBANKING.CORE_MACS.USUARIO_MODIFICO%TYPE,
                     P_ACCION              IN NUMBER,
                     P_RESULTADO           OUT NUMBER,
                     P_RESULTADODES        OUT VARCHAR2);
					 
  FUNCTION GET_CAT_ROL (P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
					    P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_CAT_EJBS (P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						 P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_CAT_METODOS (P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                            P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						    P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						    P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_CAT_ROL_METODOS(P_STATUSRM_INI  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           	   P_STATUSRM_FIN  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
							   P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                           	   P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						   	   P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						   	   P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE,
							   P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
						   	   P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_ID_ROL_METODOS(P_STATUSRM_INI  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           	   P_STATUSRM_FIN  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
							   P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                           	   P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						   	   P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						   	   P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE,
							   P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
						   	   P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE,
							   P_IDROL IN EBANKING.CORE_ROL_METODS.IDROL%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_CAT_MACS (P_STATUSMAC_INI  IN EBANKING.CORE_MACS.STATUS%TYPE,
                         P_STATUSMAC_FIN  IN EBANKING.CORE_MACS.STATUS%TYPE,
						 P_STATUSROL_INI  IN EBANKING.CORE_ROL.STATUS%TYPE,
						 P_STATUSROL_FIN  IN EBANKING.CORE_ROL.STATUS%TYPE) RETURN SYS_REFCURSOR;
  
  FUNCTION GET_ID_MAC (P_STATUSMAC_INI  IN EBANKING.CORE_MACS.STATUS%TYPE,
                        P_STATUSMAC_FIN  IN EBANKING.CORE_MACS.STATUS%TYPE,
					    P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
					    P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE,
					    P_MAC IN EBANKING.CORE_MACS.MAC%TYPE) RETURN SYS_REFCURSOR;
  
    
END PKG_CORE_SERVICES;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE pkg_dinero_express
AS
   FUNCTION get_cliente (cl_cliente_alnova VARCHAR2)
      RETURN TYPES.refcursor;

   FUNCTION get_transferencia (
      tr_num_cuenta     VARCHAR2,
      tr_fecha_inicio   DATE,
      tr_fecha_fin      DATE
   )
      RETURN TYPES.refcursor;

   FUNCTION get_descuento (des_mtcn VARCHAR2)
      RETURN TYPES.refcursor;

   FUNCTION get_impuesto (imp_mtcn VARCHAR2)
      RETURN TYPES.refcursor;

   PROCEDURE add_cliente (
      cl_cliente_alnova        VARCHAR2,
      cl_cliente_id        	   NUMBER,
      cl_nombre            	   VARCHAR2,
      cl_apellido_paterno      VARCHAR2,
      cl_apellido_materno      VARCHAR2,
      cl_fecha_nacimiento  	   DATE,
	  cl_pais_identificacion   NUMBER,
	  cl_tipo_identificacion   NUMBER,
	  cl_folio_identificacion  VARCHAR2,
	  cl_usuario_modifico 	   VARCHAR2
   );

   PROCEDURE add_transferencias (
      tr_cliente_id        NUMBER,
      tr_mtcn              VARCHAR2,
      tr_monto_enviado     NUMBER,
      tr_beneficiario_id   NUMBER,
      tr_tarifa            NUMBER,
      tr_num_cuenta        VARCHAR2,
	  tr_folio_retencion   VARCHAR2,
      tr_fecha_envio	   DATE,
	  tr_pais_id_destino   NUMBER,
	  tr_estado_id_destino NUMBER,
	  tr_ciudad_id_destino NUMBER,
	  tr_id_moneda_envio   NUMBER,
	  tr_id_moneda_destino NUMBER,
	  tr_usuario_modifico  VARCHAR2
   );

   PROCEDURE add_descuento (
      des_mtcn             	   VARCHAR2,
      des_descripcion   	   VARCHAR2,
      des_monto         	   NUMBER,
	  des_id_descuento		   NUMBER,
	  des_usuario_modifico	   VARCHAR2
   );

   PROCEDURE add_impuesto (
      imp_mtcn          VARCHAR2,
      imp_nombre_impuesto   VARCHAR2,
      imp_monto         	   NUMBER,
	  imp_id_impuesto 		   NUMBER,
	  imp_id_importe			   NUMBER,
	  imp_nombre_corto_imp	   VARCHAR2,
	  imp_usuario_modifico	   VARCHAR2
   );
END pkg_dinero_express;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE          types
		AS
		    TYPE refCursor IS REF CURSOR;
	END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY "MD_META" AS

    multiplier constant number  := 22695477;
    increment  constant number  := 1;
    "2^32"     constant number  := 2 ** 32;
    "2^16"     constant number  := 2 ** 16;
    "0x7fff"   constant number  := 32767;
    Seed       number := 1;
    g_curr_val NUMBER DEFAULT NULL;
/*
 * Get the next available id for objectids.
 * @return the next id that can be used in objectid fields
 * This code is taken from wwv_flows
 */
FUNCTION get_next_id RETURN NUMBER
IS
BEGIN
/*
	select  to_number(
                 to_char(dbobjectid_sequence.nextval) ||
                      lpad( substr( abs(rand), 1, 5 ),5, '0' ) ||
                   ltrim(to_char(mod(abs(hsecs),1000000),'000000')))
    into    g_curr_val
    from   sys.v_$timer;

	select to_number(
				to_char(dbobjectid_sequence.nextval) ||
					lpad( substr( abs(rand), 1, 5 ), 5, '0') ||
				ltrim(to_char(mod(dbms_random.value(100000000000, 999999999999),1000000),'000000')))
    into    g_curr_val
	from dual;				
*/
	select dbobjectid_sequence.nextval
    into    g_curr_val
	from dual;	
    return g_curr_val;
END get_next_id;
-- Following code taken from wwv_flows_random 
 procedure srand( new_seed in number ) is
 begin
  Seed := new_seed;
 end srand;
--
  function rand return number is
    s number;
  begin
    seed := mod( multiplier * seed + increment, "2^32" );
    begin
       return bitand( seed/"2^16", "0x7fff" );
    --mhichwa
    exception when others then
       select dbobjectid_sequence.nextval into s from dual;
       return s||to_char(sysdate,'HH24MISS');
    end;
  end rand;
--
  procedure get_rand( r OUT number ) is
  begin
    r := rand;
  end get_rand;
--
  function rand_max( n IN number ) return number is
  begin
    return mod( rand, n ) + 1;
  end rand_max;
--
  procedure get_rand_max( r OUT number, n IN number )  is
  begin
    r := rand_max( n );
  end get_rand_max;
  
 FUNCTION quote(catalog IN VARCHAR2, schema IN VARCHAR2, object IN VARCHAR2, connid LONG ) RETURN VARCHAR2
  AS
  v_plugin VARCHAR2(1000);
  v_result VARCHAR2(4000) :='';
  v_ldelim VARCHAR2(1);
  v_rdelim VARCHAR2(1);
  v_isCatalogRequired BOOLEAN;
  v_isSchemaRequired BOOLEAN;
  v_maxCharsToDelim INT;
  BEGIN
  -- get database type using connid
   SELECT lower(VALUE) 
   INTO v_plugin
   FROM MD_ADDITIONAL_PROPERTIES
   WHERE LOWER(PROP_KEY) = 'plugin_id'
   AND connection_id_fk = connid;
    
    -- get the delimeter
    IF      v_plugin like '%sybase12%'   THEN
            v_ldelim := '[';
            v_rdelim := ']';     
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 28;
    ELSIF   v_plugin like '%sybase%'   THEN
            v_ldelim := '[';
            v_rdelim := ']';     
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;    
            v_maxCharsToDelim := 300;
    ELSIF   v_plugin like '%sqlserver%' THEN 
            v_ldelim := '[';
            v_rdelim := ']';    
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF  v_plugin like '%msaccess%'  THEN
            v_ldelim := '[';
            v_rdelim := ']'; 
            v_isCatalogRequired := false;
            v_isSchemaRequired :=false;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%mysql%'    THEN
            v_ldelim :='`'; 
            v_rdelim :='`';
            v_isCatalogRequired :=false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%db2%'        THEN
            v_ldelim :='"';
            v_rdelim :='"';
            v_isCatalogRequired := false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSIF v_plugin like '%teradata%'   THEN
            v_ldelim :='"';
            v_rdelim :='"';
            v_isCatalogRequired :=false;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    ELSE
            v_ldelim :='[';
            v_rdelim :=']';
            v_isCatalogRequired := true;
            v_isSchemaRequired := true;
            v_maxCharsToDelim := 300;
    END IF;
       
    IF LENGTH(catalog) > v_maxCharsToDelim THEN
      v_result := v_result || catalog ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result || v_ldelim || catalog ||v_rdelim;
    END IF ;
    
    IF LENGTH(schema) > v_maxCharsToDelim THEN
      v_result := v_result || '.' || schema ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result ||'.' || v_ldelim || schema || v_rdelim;
    END IF ;
    
    IF LENGTH(object) > v_maxCharsToDelim THEN
      v_result := v_result ||'.' || object ;-- do not quote as it is using the max amount of chars allowed 
    ELSE  
      v_result := v_result ||'.' || v_ldelim || object ||v_rdelim;
    END IF;      
    
    
   return v_result; 
END quote;  
  
--
-- One time initialisation
begin
  select to_char(sysdate,'JSSSSS')
    into seed
    from dual;
end;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY "MIGRATION" AS
/**
 * The migration package contains all of the PL/SQL Procedures and functions required by the migration
 * system.
 * @author Barry McGillin
 * @author Dermot Daly.
 */
--a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, 
--B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
TYPE DERIVATIVE_REC IS RECORD (
     schema_id          NUMBER,
     schema_name        VARCHAR2(4000 BYTE),
     catalog_id         NUMBER,
     catalog_name       VARCHAR2(4000 BYTE),
     dummy_flag         CHAR(1 BYTE),
     cap_type           CHAR(1 BYTE),    
     character_set      VARCHAR2(4000 BYTE),
     version_tag        VARCHAR2(40 BYTE)
     ); 
     
TYPE DERIVATIVE_REC2 IS RECORD (
     schemaid  NUMBER, 
     newid     NUMBER
);     
     
v_prefixName VARCHAR2(4) :=''; --text to prefix objects with ,set using transform_all_identifiers
-- Constants that are used throughout the package body.
C_CONNECTIONTYPE_CONVERTED   CONSTANT MD_CONNECTIONS.TYPE%TYPE := 'CONVERTED';
C_CONNECTIONTYPE_SCRATCH   CONSTANT MD_CONNECTIONS.TYPE%TYPE := 'SCRATCH'; -- enterprise capture/convert
-- Supported object types.
C_OBJECTTYPE_CONNECTIONS     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONNECTIONS';
C_OBJECTTYPE_CATALOGS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CATALOGS';
C_OBJECTTYPE_SCHEMAS         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SCHEMAS';
C_OBJECTTYPE_TABLES          CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TABLES';
C_OBJECTTYPE_COLUMNS         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_COLUMNS';
C_OBJECTTYPE_CNSTRNT_DETAILS CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONSTRAINT_DETAILS';
C_OBJECTTYPE_CONSTRAINTS     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_CONSTRAINTS';
C_OBJECTTYPE_INDEX_DETAILS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_INDEX_DETAILS';
C_OBJECTTYPE_INDEXES         CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_INDEXES';
C_OBJECTTYPE_TRIGGERS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TRIGGERS';
C_OBJECTTYPE_VIEWS           CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_VIEWS';
C_OBJECTTYPE_USERS           CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USERS';
C_OBJECTTYPE_GROUP_MEMBERS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_GROUPMEMBERS';
C_OBJECTTYPE_GROUPS          CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_GROUPS';
C_OBJECTTYPE_OTHER_OBJECTS   CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_OTHER_OBJECTS';
C_OBJECTTYPE_TABLESPACES     CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_TABLESPACES';
C_OBJECTTYPE_UDDT            CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USER_DEFINED_DATA_TYPES';
C_OBJECTTYPE_STORED_PROGRAMS CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_STORED_PROGRAMS';
C_OBJECTTYPE_PACKAGES        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_PACKAGES';
C_OBJECTTYPE_SYNONYMS        CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SYNONYMS';
C_OBJECTTYPE_SEQUENCES       CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_SEQUENCES';
C_OBJECTTYPE_PRIVILEGES      CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_PRIVILEGES';
C_OBJECTTYPE_USER_PRIVILEGES CONSTANT MD_DERIVATIVES.SRC_TYPE%TYPE := 'MD_USER_PRIVILEGES';
-- Dummy flag for a dummy catalog.
C_DUMMYFLAG_TRUE             CONSTANT MD_CATALOGS.DUMMY_FLAG%TYPE := 'Y';
-- Flag in MD_DERIVATIVES to show if something has been transformed
C_TRANSFORMED_TRUE           CONSTANT MD_DERIVATIVES.TRANSFORMED%TYPE := 'Y';
-- Flag in MD_SYNONYMS.PRIVATE_VISIBILITY to highlight that a synonym is marked as private
C_SYNONYM_PRIVATE            CONSTANT MD_SYNONYMS.PRIVATE_VISIBILITY%TYPE := 'Y';
-- Flag in MD_GROUPS.GROUP_FLAG to show this is a role
C_ROLE_FLAG                  CONSTANT MD_GROUPS.GROUP_FLAG%TYPE := 'R';
-- Flag in MD_COLUMNS TO SHOW A COLUMN IS NULLABLE
C_NULLABLE_YES               CONSTANT MD_COLUMNS.NULLABLE%TYPE := 'Y';
-- Special defined additional properties.
C_PROPKEY_SEEDVALUE          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'SEEDVALUE';
C_PROPKEY_INCREMENT          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'INCREMENT';
C_PROPKEY_LASTVALUE          CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'LASTVALUE';
C_PROPKEY_EXTENDEDINDEXTYPE	 CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'EXTENDEDINDEXTYPE';
C_PROPKEY_SEQUENCEID	       CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'SEQUENCEID';
C_PROPKEY_TRIGGER_REWRITE	   CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'TRIGGER_REWRITE';
C_PROPKEY_REAL_IDENTITY      CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'REALIDENTITY';
C_PROPKEY_ALREADY_IDENTITY   CONSTANT MD_ADDITIONAL_PROPERTIES.PROP_KEY%TYPE := 'ALREADYIDENTITY';
-- Name spaces for identifiers
C_NS_SCHEMA_OBJS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_SCHEMAOBJS';
C_NS_INDEXES                 CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_INDEXES';
C_NS_CONSTRAINTS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_CONSTRAINTS';
C_NS_CLUSTERS                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_CLUSTERS';
C_NS_DB_TRIGGERS             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DB_TRIGGERS';
C_NS_PRIVATE_DBLINKS         CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PRIVATEDBLINKS';
C_NS_DIMENSIONS              CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DIMENSIONS';
C_NS_USER_ROLES              CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_USERROLES';
C_NS_PUBLIC_SYNONYMS         CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PUB_SYNONYMS';
C_NS_PUBLIC_DBLINKS          CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PUBLICDBLINKS';
C_NS_TABLESPACES             CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_TABLESPACES';
C_NS_PROFILES                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_PROFILES';
C_NS_DATABASE                CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_DATABASE';
C_NS_USERS                   CONSTANT MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := 'NS_USERS';
-- Constants for Filter Types
 -- Filter Types are 0-> ALL, 1->NAMELIST, 2->WHERE CLAUSE, 3->OBJECTID LIST
C_FILTERTYPE_ALL	     CONSTANT INTEGER := 0;
C_FILTERTYPE_NAMELIST	     CONSTANT INTEGER := 1;
C_FILTERTYPE_WHERECLAUSE     CONSTANT INTEGER := 2;
C_FILTERTYPE_OBJECTIDLIST    CONSTANT INTEGER := 3;
-- Constatns for TEXT INDEX TYPES
-- see http://download-west.oracle.com/docs/cd/B10501_01/text.920/a96518/csql.htm#19446
-- Use this index type when there is one CLOB or BLOB column in the index only
C_INDEXTYPE_CONTEXT	CONSTANT MD_ADDITIONAL_PROPERTIES.VALUE%TYPE := 'ctxsys.context';
-- Use this index type when the index containst a CLOB or BLOB column.
C_INDEXTYPE_CTXCAT CONSTANT  MD_ADDITIONAL_PROPERTIES.VALUE%TYPE := 'ctxsys.ctxcat';
-- Constant for LANGUAGE - Used in MD_TRIGGERS, MD_PACKAGES, MD_STORED_PROGRAMS, MD_VIEWS, and MD_CONSTRAINTS
C_LANGUAGEID_ORACLE CONSTANT MD_TRIGGERS.LANGUAGE%TYPE := 'OracleSQL';
-- Type for a generic REF CURSOR
TYPE REF_CURSOR IS REF CURSOR;
/**
 * Find a filter element from a filter list
 */
FUNCTION find_filter_for_type(p_filterSet MIGR_FILTER_SET, p_objtype MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE) RETURN MIGR_FILTER
IS
BEGIN
  IF p_filterset is NULL OR p_objtype is NULL then
    return NULL;
  END IF;
  FOR indx in p_filterset.FIRST .. p_filterset.LAST
  LOOP
    if p_filterset(indx).OBJTYPE = p_objtype THEN
      return p_filterset(indx);
    end if;
  END LOOP;
  return NULL;
END find_filter_for_type;

/**
 * Convert a name list from a filter into a condition for use in a where clause.
 * @param p_nameList the set of names that form part of the filter
 * @param p_nameField the name of the field to be compared against.
 * @return A condition that can be used in a where clause.
 */
FUNCTION namelist_to_where_clause(p_nameList NAMELIST, p_nameField VARCHAR2) RETURN VARCHAR2
IS
  v_ret VARCHAR2(4000);
BEGIN
  v_ret := p_nameField || ' IN (';
  FOR indx IN p_nameList.FIRST .. p_nameList.LAST
  LOOP
    v_ret := v_ret || '''' || p_nameList(indx) || '''';
    IF  indx != p_nameList.LAST THEN
      v_ret := v_ret || ', ';
    END IF;
  END LOOP;
  v_ret := v_ret || ')';
  return v_ret;
END namelist_to_where_clause;

/**
 * Convert an object id list from a filter into a condition for use in a where clause.
 * @param p_oidList The list of object ids taken from the filter.
 * @param p_idFIeld The field to be tested against.
 * @return A condition that can be used in a where clause.
 */
FUNCTION objectIdList_to_where_clause(p_oidList OBJECTIDLIST, p_idField VARCHAR2) RETURN VARCHAR2
IS
  v_ret VARCHAR2(4000);
BEGIN
  V_RET := p_idField || ' IN (';
  FOR indx IN p_oidList.FIRST .. p_oidList.LAST
  LOOP
    v_ret := v_ret || TO_CHAR(p_oidList(indx));
    IF indx != p_oidList.LAST THEN
      v_ret := v_ret || ', ';
    END IF;
  END LOOP;
  v_ret := v_ret || ')';
  return v_ret;
END objectIdList_to_where_clause;

/**
 * Convert a filter to a condition for use in a where clause.
 * @param p_filter The filter
 * @param p_nameFileld The name field that will be used in the names list or where clause.
 * @param p_idField The id field that will be used if the filter is an objectid list.
 * @return A condition that could be used in a where clause.  NULL if no additional filtering is required.
 */
FUNCTION where_clause_from_filter(p_filter MIGR_FILTER, p_nameField VARCHAR2, p_idField VARCHAR2) RETURN VARCHAR2
IS
BEGIN
	IF p_filter.FILTER_TYPE = C_FILTERTYPE_ALL THEN
	  RETURN NULL;
    ELSIF p_filter.FILTER_TYPE = C_FILTERTYPE_NAMELIST THEN
      RETURN namelist_to_where_clause(p_filter.NAMES, p_nameField);
    ELSIF p_filter.FILTER_TYPE = C_FILTERTYPE_WHERECLAUSE THEN
	  RETURN p_nameField || ' ' || p_filter.WHERECLAUSE;
    ELSE
	  RETURN objectidlist_to_where_clause(p_filter.OBJECTIDS, p_idField);
	END IF;
END where_clause_from_filter;

/**
 * Apply a filter to an existing select statement
 * @param p_filter_set The filter set.
 * @param p_filter_type The type of the object, for finding in the filter set.
 * @param p_name_field The name field of the table being filtered
 * @param p_id_field The id field of the table being filtered.
 * @param p_select_stmt The select statment to tag the new condition on to
 * @return The select statement with the new condition added to it (or the original statement if
 *         there is no applicable filter for this object type.
 */
FUNCTION apply_filter(p_filter_set MIGR_FILTER_SET,
                      p_filter_type MD_DERIVATIVES.SRC_TYPE%TYPE,
                      p_name_field VARCHAR2,
                      p_id_field VARCHAR2,
                      p_select_stmt VARCHAR2) RETURN VARCHAR2
IS
  v_filt MIGR_FILTER;
  v_condition VARCHAR2(4000);
BEGIN
  v_filt := find_filter_for_type(p_filter_set, p_filter_type);
  --if the filter is null, then we need to set a value that will fail always so nothing is moved.
  -- ie 1=2
  IF v_filt IS NOT NULL THEN
    v_condition := where_clause_from_filter(v_filt, p_name_field, p_id_field);
    IF v_condition IS NOT NULL THEN
      RETURN p_select_stmt || ' AND ' || v_condition;
    ELSE
     RETURN p_select_stmt;
    END IF;
  END IF;
  RETURN p_select_stmt || ' AND 1=2';
END apply_filter;
                      
                      
/**
 * Find the copy of a particular object.  This function checks for a copied object of a particular
 * type by searching the MD_DERIVATIVES table.
 * @param p_objectid The id of the object to search for.
 * @param p_objecttype The type of the object to search for.
 * @return the id of the copy object if it is present, or NULL if it is not.
 */
FUNCTION find_object_copy(p_objectid md_projects.id%TYPE, p_objecttype MD_DERIVATIVES.SRC_TYPE%TYPE, p_derivedconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS 
  v_ret MD_DERIVATIVES.DERIVED_ID%TYPE;
BEGIN
  SELECT derived_id INTO v_ret FROM MD_DERIVATIVES
    WHERE src_id = p_objectid 
     AND src_type = p_objecttype
     AND derived_type = p_objecttype 
     AND derived_connection_id_fk = p_derivedconnectionid;
  RETURN v_ret;
EXCEPTION
  WHEN NO_DATA_FOUND then
    -- Should we raise an error?
    RETURN NULL;
END find_object_copy;

/**
 * Copy additional properties. function copies the additional properties for an object.
 * @param p_refobjectid The object id whose additional properties have to be copied
 * @param p_newrefobject The id of the copied object the new properties should refer to
 * @return number of additional properties copied
 */
FUNCTION copy_additional_properties(p_refobjectid MD_ADDITIONAL_PROPERTIES.REF_ID_FK%TYPE, p_newrefobject MD_PROJECTS.ID%TYPE, p_newconnectionid MD_ADDITIONAL_PROPERTIES.CONNECTION_ID_FK%TYPE) RETURN NUMBER
IS
  CURSOR ORIGINAL_RECS IS SELECT PROPERTY_ORDER, PROP_KEY, REF_TYPE, VALUE FROM MD_ADDITIONAL_PROPERTIES WHERE REF_ID_FK=p_refobjectid;
  v_numcopied NUMBER := 0;
BEGIN
  for newrec in ORIGINAL_RECS LOOP
    INSERT INTO MD_ADDITIONAL_PROPERTIES (ref_id_fk, ref_type, property_order, prop_key, value, connection_id_fk)
      VALUES (p_newrefobject, newrec.ref_type, newrec.property_order, newrec.prop_key, newrec.value, p_newconnectionid);
    v_numcopied := v_numcopied + 1;
  END LOOP;
  commit;
  return v_numcopied;
END copy_additional_properties;

FUNCTION copy_connection(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE) RETURN NUMBER
IS
  newrec MD_CONNECTIONS%ROWTYPE;
  newid MD_CONNECTIONS.ID%TYPE;
  origName MD_CONNECTIONS.NAME%TYPE;
BEGIN
  SELECT * INTO newrec from MD_CONNECTIONS WHERE id = p_connectionid;

  newrec.HOST := NULL;
  newrec.PORT := NULL;
  newrec.USERNAME := NULL;
  newrec.DBURL := NULL;
  -- TODO.  Need to do this in a more i18n friendly manner.
  origName := newrec.NAME;
  
  IF p_scratchModel = FALSE 
  THEN
     newrec.TYPE :=C_CONNECTIONTYPE_CONVERTED;  
     newrec.NAME := 'Converted:' || newrec.NAME;
  ELSE
     newrec.TYPE :=C_CONNECTIONTYPE_SCRATCH;  
     newrec.NAME := 'Scratch:' || newrec.NAME;     
  END IF;
  -- Let the trigger create the new ID
  newrec.ID := NULL;
  INSERT INTO MD_CONNECTIONS VALUES newrec
  	RETURNING id into newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, original_identifier, new_identifier)
    VALUES (p_connectionid, C_OBJECTTYPE_CONNECTIONS, newid, C_OBJECTTYPE_CONNECTIONS, newid, origName, newrec.NAME);
  commit;
  return newid;
END copy_connection;


FUNCTION create_dummy_catalog(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_CATALOGS.ID%TYPE;
BEGIN
  INSERT INTO MD_CATALOGS (CONNECTION_ID_FK, CATALOG_NAME, DUMMY_FLAG, NATIVE_SQL, NATIVE_KEY)
  VALUES (p_connectionid, ' ', C_DUMMYFLAG_TRUE, NULL, NULL)
  RETURNING ID INTO newid;
  RETURN newid;
END create_dummy_catalog;

FUNCTION find_or_create_dummy_catalog(p_connectionid MD_CONNECTIONS.ID%TYPE, p_catalogid MD_CATALOGS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_CATALOGS%ROWTYPE;
  newid MD_CATALOGS.ID%TYPE;
BEGIN
  SELECT * INTO newrec from MD_CATALOGS where connection_id_fk = p_connectionid and "ID" = p_catalogid;
  return newrec.id;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
  INSERT INTO MD_CATALOGS (CONNECTION_ID_FK, CATALOG_NAME, DUMMY_FLAG, NATIVE_SQL, NATIVE_KEY)
  VALUES (p_connectionid, ' ', C_DUMMYFLAG_TRUE, NULL, NULL)
  RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, DERIVED_OBJECT_NAMESPACE)
    VALUES (p_catalogid, C_OBJECTTYPE_CATALOGS, newid, C_OBJECTTYPE_CATALOGS, p_connectionid, C_NS_DATABASE);
  commit;
  return newid;
END find_or_create_dummy_catalog;

-- Enterprise convert may have 1 catalog belonging to a given connection id
PROCEDURE create_dummy_catalogs(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN) 
IS
  CURSOR curcats(connId MD_CONNECTIONS.ID%TYPE) IS select * from MD_CATALOGS where connection_id_fk = connId;
  cat_row MD_CATALOGS%ROWTYPE;
  newid MD_CATALOGS."ID"%TYPE;
  v_sql VARCHAR2(300);
BEGIN
   OPEN curcats(p_connectionid);
   FETCH curcats INTO cat_row;  
   LOOP
     EXIT WHEN curcats%NOTFOUND;
     newid := find_or_create_dummy_catalog(p_newconnectionid, cat_row."ID");
     v_sql := 'UPDATE MD_CATALOGS SET CATALOG_NAME = ''' || cat_row."CATALOG_NAME"  || ''' WHERE ID = ' || TO_CHAR(newid);
     EXECUTE IMMEDIATE v_sql;
     FETCH curcats INTO cat_row;  
   END LOOP;
  CLOSE curcats; 
  COMMIT;
END create_dummy_catalogs;


FUNCTION copy_individual_catalog(p_catalogid MD_CATALOGS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_CATALOGS%ROWTYPE;
  newconnectionid MD_CATALOGS.CONNECTION_ID_FK%TYPE;
  dummycatalogid MD_CATALOGS.ID%TYPE;
  originalconnectionid MD_CATALOGS.CONNECTION_ID_FK%TYPE;
BEGIN
  -- Catalogs aren't copied as such. Instead, we make a single DUMMY catalog
  -- Within the new connection
  -- So..first see if one exists for the copied connection
  SELECT CONNECTION_ID_FK INTO originalconnectionid FROM MD_CATALOGS WHERE ID = p_catalogid;
  -- For connections, we have a special case.  We can't store the new connection, but 0 is ok.
  newconnectionid := find_object_copy(originalconnectionid, C_OBJECTTYPE_CONNECTIONS, 0);
  IF newconnectionid IS NULL THEN
    newconnectionid := copy_connection(originalconnectionid);
  END IF;
  dummycatalogid := find_or_create_dummy_catalog(newconnectionid, p_catalogid);
  RETURN dummycatalogid;  
END copy_individual_catalog;

FUNCTION copy_individual_schema(p_schemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_SCHEMAS.ID%TYPE;
  newrec MD_SCHEMAS%ROWTYPE;
  newcatalogid MD_CATALOGS.ID%TYPE;
  originalcatalogname MD_CATALOGS.CATALOG_NAME%TYPE;
  originalcatalogid MD_SCHEMAS.CATALOG_ID_FK%TYPE;
  originalschemaname MD_SCHEMAS.NAME%TYPE;
  originalisdummy CHAR;
BEGIN
  SELECT * INTO newrec FROM md_schemas WHERE id = p_schemaid;
  newcatalogid := find_object_copy(newrec.catalog_id_fk,   C_OBJECTTYPE_CATALOGS, p_newconnectionid);
  originalcatalogid := newrec.catalog_id_fk;
  originalschemaname := newrec.NAME;
  select CATALOG_NAME, DUMMY_FLAG into originalcatalogname, originalisdummy from MD_CATALOGS WHERE ID = originalcatalogid;
  IF newcatalogid IS NULL THEN
    newcatalogid := copy_individual_catalog(newrec.catalog_id_fk);
  END IF;

  newrec.catalog_id_fk := newcatalogid;
  if originalisdummy <> C_DUMMYFLAG_TRUE THEN
    newrec.name := originalcatalogname || '_' || newrec.name;
  end if;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO MD_SCHEMAS VALUES newrec RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES (p_schemaid, C_OBJECTTYPE_SCHEMAS, newid, C_OBJECTTYPE_SCHEMAS, originalschemaname, newrec.name, C_NS_DATABASE);
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type)
    VALUES (originalcatalogid, C_OBJECTTYPE_CATALOGS, newid, C_OBJECTTYPE_SCHEMAS);
  COMMIT;
  return newid;
END copy_individual_schema;

FUNCTION copy_individual_table(p_tableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newrec MD_TABLES%rowtype;
  newid MD_TABLES.ID%TYPE;
  newschemaid MD_SCHEMAS.ID%TYPE;
BEGIN
  SELECT * INTO newrec FROM MD_tables WHERE id = p_tableid;
  newschemaid := find_object_copy(newrec.schema_id_fk,   C_OBJECTTYPE_SCHEMAS, p_newconnectionid);
  IF newschemaid IS NULL THEN
    newschemaid := copy_individual_schema(newrec.schema_id_fk, p_newconnectionid);
  END IF;

  newrec.schema_id_fk := newschemaid;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO MD_TABLES VALUES newrec RETURNING ID INTO newid;
  INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(p_tableid,   C_OBJECTTYPE_TABLES,   newid,   C_OBJECTTYPE_TABLES, p_newconnectionid, newrec.table_name, newrec.table_name, C_NS_SCHEMA_OBJS || TO_CHAR(newschemaid));
  COMMIT;
  RETURN newid;
END copy_individual_table;

FUNCTION copy_individual_column(p_columnid MD_COLUMNS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  newid MD_COLUMNS.ID%TYPE;
  newrec MD_COLUMNS%rowtype;
  newtableid MD_TABLES.ID%TYPE;
BEGIN
  SELECT * INTO newrec FROM md_columns WHERE id = p_columnid;
  -- TODO: How do I check if this worked?
  -- OK. We need to fix up table id
  newtableid := find_object_copy(newrec.table_id_fk,   C_OBJECTTYPE_TABLES, p_newconnectionid);

  IF newtableid IS NULL THEN
    newtableid := copy_individual_table(newrec.table_id_fk, p_newconnectionid);
  END IF;

  newrec.table_id_fk := newtableid;
  -- Let the trigger work out the new id
  newrec.ID := NULL;
  INSERT INTO md_columns VALUES newrec RETURNING ID INTO newid;
  -- Columns have their own namespace.  They must be unique within the given table.  So..we'll use the table id as the namespace
  INSERT INTO md_derivatives(src_id,   src_type,   derived_id,   derived_type, derived_connection_id_fk, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(p_columnid,   C_OBJECTTYPE_COLUMNS,   newid,   C_OBJECTTYPE_COLUMNS, p_newconnectionid, newrec.column_name, newrec.column_name, C_OBJECTTYPE_COLUMNS || TO_CHAR(newtableid));
  COMMIT;
  RETURN newid;
END copy_individual_column;

FUNCTION copy_all_tables(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR all_tables_cursor is select table_id from mgv_all_tables where connection_id = p_connectionid;
  v_count NUMBER := 0;
  newid MD_TABLES.ID%TYPE;
BEGIN
  FOR v_tableid IN all_tables_cursor LOOP
    newid := copy_individual_table(v_tableid.table_id, p_newconnectionid);
    v_count := v_count + 1;
  END LOOP;
  RETURN v_count;
END copy_all_tables;

FUNCTION copy_all_columns(p_connectionid MD_CONNECTIONS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR all_columns_cursor is select id from MD_COLUMNS where table_id_fk in 
    (select table_id from MGV_ALL_TABLES where connection_id = p_connectionid);
  v_count NUMBER :=0;
  newid MD_COLUMNS.ID%TYPE;
BEGIN
  FOR v_columnid IN all_columns_cursor LOOP
    newid := copy_individual_column(v_columnid.id, p_newconnectionid);
    v_count := v_count + 1;
  END LOOP;
  return v_count;
END copy_all_columns;

FUNCTION copy_constraint_details(p_oldconsid MD_CONSTRAINTS.ID%TYPE, p_newconsid MD_CONSTRAINTS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_CONSTRAINT_DETAILS WHERE CONSTRAINT_ID_FK = p_oldconsid;
  v_newid MD_CONSTRAINT_DETAILS.ID%TYPE;
  v_count NUMBER := 0;
  v_originalid MD_CONSTRAINT_DETAILS.ID%TYPE;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.COLUMN_ID_FK := find_object_copy(v_row.COLUMN_ID_FK , C_OBJECTTYPE_COLUMNS, p_newconnectionid);
    v_row.CONSTRAINT_ID_FK := p_newconsid;
    INSERT INTO MD_CONSTRAINT_DETAILS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Constraint details don't have an identifier, so don't need a namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid, C_OBJECTTYPE_CNSTRNT_DETAILS, v_newid, C_OBJECTTYPE_CNSTRNT_DETAILS, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_constraint_details;

FUNCTION copy_all_constraints_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
   v_selectStmt VARCHAR2(4000) :=     
  'SELECT * FROM MD_CONSTRAINTS WHERE TABLE_ID_FK IN       
    (SELECT SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = ''' || C_OBJECTTYPE_TABLES ||''' AND DERIVED_TYPE = '''
    || C_OBJECTTYPE_TABLES || ''' AND DERIVED_ID IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE SCHEMA_ID = ' || p_newschemaid || '))';
  v_count NUMBER := 0;
  v_newid MD_CONSTRAINTS.ID%TYPE;
  v_originalid MD_CONSTRAINTS.ID%TYPE;
  v_ret NUMBER;
  v_row MD_CONSTRAINTS%ROWTYPE;
  v_storeRefTableId MD_TABLES.ID%TYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_CONSTRAINTS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := find_object_copy(v_row.TABLE_ID_FK , C_OBJECTTYPE_TABLES, p_newconnectionid);
    if v_row.REFTABLE_ID_FK IS NOT NULL THEN
      v_storeRefTableId := v_row.REFTABLE_ID_FK;
      v_row.REFTABLE_ID_FK := find_object_copy(v_row.REFTABLE_ID_FK , C_OBJECTTYPE_TABLES, p_newconnectionid);
    END IF;
    INSERT INTO MD_CONSTRAINTS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_CONSTRAINTS, v_newid, C_OBJECTTYPE_CONSTRAINTS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_CONSTRAINTS|| TO_CHAR(p_newschemaid));
    v_ret := copy_constraint_details(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  return v_count;    
END copy_all_constraints_cascade;

FUNCTION copy_all_columns_cascade(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_COLUMNS WHERE TABLE_ID_FK = ' || p_oldtableid;
  v_originalId MD_COLUMNS.ID%TYPE;
  v_newid MD_COLUMNS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_COLUMNS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_COLUMNS, 'COLUMN_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := p_newtableid;
    INSERT INTO MD_COLUMNS values  v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Columns don't need a namespace as such, they must not clash within the table.  We'll handle this
	-- As a special case.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, original_identifier, new_identifier, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_COLUMNS, v_newid, C_OBJECTTYPE_COLUMNS, p_newconnectionid, v_row.column_name, v_row.column_name, C_OBJECTTYPE_COLUMNS || TO_CHAR(p_newtableid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_columns_cascade;

FUNCTION copy_index_details(p_oldindexid MD_INDEXES.ID%TYPE, p_newindexid MD_INDEXES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_INDEX_DETAILS WHERE MD_INDEX_DETAILS.INDEX_ID_FK = p_oldindexid;
  v_originalid MD_INDEX_DETAILS.ID%TYPE;
  v_newid MD_INDEX_DETAILS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN CURS LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.INDEX_ID_FK := p_newindexid;
    v_row.COLUMN_ID_FK := find_object_copy(v_row.COLUMN_ID_FK, C_OBJECTTYPE_COLUMNS, p_newconnectionid);
    INSERT INTO MD_INDEX_DETAILS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Index details don't have identifiers, so don't need a namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
    VALUES(v_originalid, C_OBJECTTYPE_INDEX_DETAILS, v_newid, C_OBJECTTYPE_INDEX_DETAILS, p_newconnectionid);
  END LOOP;
  RETURN v_count;
END copy_index_details;

FUNCTION copy_all_indexes(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_INDEXES WHERE MD_INDEXES.TABLE_ID_FK = ' || p_oldtableid;
  v_originalid MD_INDEXES.ID%TYPE;
  v_newid MD_INDEXES.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_INDEXES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_INDEXES, 'INDEX_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    
    v_row.ID := NULL;
    v_row.TABLE_ID_FK := p_newtableid;
    INSERT INTO MD_INDEXES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_INDEXES, v_newid, C_OBJECTTYPE_INDEXES, p_newconnectionid, v_row.INDEX_NAME, v_row.INDEX_NAME, C_NS_INDEXES || p_newschemaid);
    v_ret := copy_index_details(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_indexes;

FUNCTION copy_all_table_triggers(p_oldtableid MD_TABLES.ID%TYPE, p_newtableid MD_TABLES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = ' || p_oldtableid;
  v_originalid MD_TRIGGERS.ID%TYPE;
  v_newid MD_TRIGGERS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TRIGGERS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TRIGGERS, 'TRIGGER_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_OR_VIEW_ID_FK := p_newtableid;
    INSERT INTO MD_TRIGGERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_TRIGGERS, v_newid, C_OBJECTTYPE_TRIGGERS, p_newconnectionid, v_row.TRIGGER_NAME, v_row.TRIGGER_NAME, C_NS_DB_TRIGGERS);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_table_triggers;

FUNCTION copy_all_tables_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET :=NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  /*CURSOR curs IS SELECT * FROM MD_TABLES where SCHEMA_ID_FK = p_oldschemaid; */
  v_newid MD_TABLES.ID%TYPE := NULL;
  v_originalid MD_TABLES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TABLES%ROWTYPE;
  v_filt MIGR_FILTER;
  v_condition VARCHAR2(4000);
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLES where SCHEMA_ID_FK = ' || p_oldschemaid;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TABLES, 'TABLE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_TABLES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_TABLES, v_newid, C_OBJECTTYPE_TABLES, p_newconnectionid, v_row.TABLE_NAME, v_row.TABLE_NAME,  C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_all_columns_cascade(v_originalid, v_newid, p_newconnectionid, p_filter_set);
    v_ret := copy_all_indexes(v_originalid, v_newid, p_newconnectionid, p_newschemaid, p_filter_set);
    v_ret := copy_all_table_triggers(v_originalid, v_newid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_tables_cascade;

FUNCTION copy_all_view_triggers(p_oldviewid MD_VIEWS.ID%TYPE, p_newviewid MD_VIEWS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs IS SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = p_oldviewid;
  v_originalid MD_TRIGGERS.ID%TYPE;
  v_newid MD_TRIGGERS.ID%TYPE;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.TABLE_OR_VIEW_ID_FK := p_newviewid;
    INSERT INTO MD_TRIGGERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
    VALUES(v_originalid, C_OBJECTTYPE_TRIGGERS, v_newid, C_OBJECTTYPE_TRIGGERS, p_newconnectionid, v_row.TRIGGER_NAME, v_row.TRIGGER_NAME, C_NS_DB_TRIGGERS);
  END LOOP;
  return v_count;
END copy_all_view_triggers;

FUNCTION copy_all_views_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_VIEWS.ID%TYPE := NULL;
  v_originalid MD_VIEWS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_VIEWS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_VIEWS, 'VIEW_NAME' ,'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_VIEWS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_VIEWS,   v_newid,   C_OBJECTTYPE_VIEWS, p_newconnectionid, v_row.VIEW_NAME, v_row.VIEW_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_all_view_triggers(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  RETURN v_count;
END copy_all_views_cascade;

FUNCTION copy_group_members(p_oldgroupid MD_GROUPS.ID%TYPE, p_newgroupid MD_GROUPS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs IS SELECT * FROM MD_GROUP_MEMBERS WHERE GROUP_ID_FK = p_oldgroupid;
  v_newid MD_GROUP_MEMBERS.ID%TYPE := NULL;
  v_originalid MD_GROUP_MEMBERS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.GROUP_ID_FK := p_newgroupid;
    v_row.USER_ID_FK := find_object_copy(v_row.USER_ID_FK, C_OBJECTTYPE_USERS, p_newconnectionid);
    INSERT INTO MD_GROUP_MEMBERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Group members do not have identifiers, so don't need a namespace
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid,   C_OBJECTTYPE_GROUP_MEMBERS,   v_newid,   C_OBJECTTYPE_GROUP_MEMBERS, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_group_members;

FUNCTION copy_all_groups_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_GROUPS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_GROUPS.ID%TYPE := NULL;
  v_originalid MD_GROUPS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_namespace MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE := NULL;
  v_row MD_GROUPS%ROWTYPE;
  v_catalogname MD_CATALOGS.CATALOG_NAME%TYPE;
  v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
  v_oldname MD_GROUPS.GROUP_NAME%TYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_GROUPS, 'GROUP_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    SELECT CATALOG_NAME, DUMMY_FLAG INTO v_catalogname, v_catalogdummy
      FROM MD_CATALOGS, MD_SCHEMAS WHERE MD_CATALOGS.ID = MD_SCHEMAS.CATALOG_ID_FK 
      AND MD_SCHEMAS.ID = p_oldschemaid;
    v_oldname := v_row.GROUP_NAME;
    if v_catalogdummy <> C_DUMMYFLAG_TRUE then
      v_row.GROUP_NAME := v_row.GROUP_NAME || '_' || v_catalogname;
    END IF;
    INSERT INTO MD_GROUPS values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	IF v_row.GROUP_FLAG = C_ROLE_FLAG THEN
		v_namespace := C_NS_USER_ROLES;
	ELSE
		v_namespace := C_NS_DATABASE;
	END IF;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_GROUPS, v_newid, C_OBJECTTYPE_GROUPS, p_newconnectionid, v_oldname, v_row.GROUP_NAME, v_namespace);
    v_ret := copy_group_members(v_originalid, v_newid, p_newconnectionid);   
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_groups_cascade;

FUNCTION copy_all_users_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_USERS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_USERS.ID%TYPE := NULL;
  v_originalid MD_USERS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_USERS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_USERS, 'USERNAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_USERS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_USERS,   v_newid,   C_OBJECTTYPE_USERS, p_newconnectionid, v_row.USERNAME, v_row.USERNAME, C_NS_USERS);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_users_cascade;

FUNCTION copy_all_other_objects_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_OTHER_OBJECTS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_OTHER_OBJECTS.ID%TYPE := NULL;
  v_originalid MD_OTHER_OBJECTS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_OTHER_OBJECTS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_OTHER_OBJECTS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_OTHER_OBJECTS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_OTHER_OBJECTS,   v_newid,   C_OBJECTTYPE_OTHER_OBJECTS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_other_objects_cascade;

FUNCTION copy_all_tablespaces_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLESPACES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_TABLESPACES.ID%TYPE := NULL;
  v_originalid MD_TABLESPACES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_TABLESPACES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_TABLESPACES, 'TABLESPACE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_TABLESPACES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_TABLESPACES,   v_newid,   C_OBJECTTYPE_TABLESPACES, p_newconnectionid, v_row.TABLESPACE_NAME, v_row.TABLESPACE_NAME, C_NS_TABLESPACES);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_tablespaces_cascade;

FUNCTION copy_all_udds_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_USER_DEFINED_DATA_TYPES.ID%TYPE := NULL;
  v_originalid MD_USER_DEFINED_DATA_TYPES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_USER_DEFINED_DATA_TYPES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_UDDT, 'DATA_TYPE_NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_USER_DEFINED_DATA_TYPES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_UDDT,   v_newid,   C_OBJECTTYPE_UDDT, p_newconnectionid, v_row.DATA_TYPE_NAME, v_row.DATA_TYPE_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_udds_cascade;

FUNCTION copy_child_procedures(p_oldpackageid MD_PACKAGES.ID%TYPE, p_newpackageid MD_PACKAGES.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE PACKAGE_ID_FK = ' || p_oldpackageid;
  v_newid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_originalid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_STORED_PROGRAMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.PACKAGE_ID_FK := p_newpackageid;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_STORED_PROGRAMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- No need for namespace here, the namespace is the package itself.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
      VALUES(v_originalid,   C_OBJECTTYPE_STORED_PROGRAMS,   v_newid,   C_OBJECTTYPE_STORED_PROGRAMS, p_newconnectionid, v_row.NAME, v_row.NAME);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_child_procedures;
  
FUNCTION copy_all_packages_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_PACKAGES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_PACKAGES.ID%TYPE := NULL;
  v_originalid MD_PACKAGES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_PACKAGES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_PACKAGES, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_PACKAGES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_PACKAGES,   v_newid,   C_OBJECTTYPE_PACKAGES, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_child_procedures(v_originalid, v_newid, p_newschemaid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_packages_cascade;

FUNCTION copy_all_unpackaged_sps(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = ' || p_oldschemaid ||' AND PACKAGE_ID_FK IS NULL';
  v_newid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_originalid MD_STORED_PROGRAMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_STORED_PROGRAMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.schema_id_fk := p_newschemaid;
    INSERT INTO MD_STORED_PROGRAMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Non-packaged procedures belong in the schema objects namespace.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_STORED_PROGRAMS, v_newid, C_OBJECTTYPE_STORED_PROGRAMS, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_unpackaged_sps;

FUNCTION copy_all_synonyms_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SYNONYMS WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_SYNONYMS.ID%TYPE := NULL;
  v_originalid MD_SYNONYMS.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_namespace MD_DERIVATIVES.DERIVED_OBJECT_NAMESPACE%TYPE;
  v_row MD_SYNONYMS%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SYNONYMS, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.SYNONYM_FOR_ID := find_object_copy(v_row.SYNONYM_FOR_ID, v_row.FOR_OBJECT_TYPE, p_newconnectionid);
    INSERT INTO MD_SYNONYMS VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
	-- Synonyms have two potential name spaces:  Private synonyms belong in the schema objects, while public 
	-- synonyms belong in their own namespace.
	IF v_row.PRIVATE_VISIBILITY = C_SYNONYM_PRIVATE THEN
		v_namespace := C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid);
	ELSE
		v_namespace := C_NS_PUBLIC_SYNONYMS;
        END IF;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_SYNONYMS, v_newid, C_OBJECTTYPE_SYNONYMS, p_newconnectionid, v_row.NAME, v_row.NAME, v_namespace);
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_synonyms_cascade;

FUNCTION copy_all_sequences_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_SEQUENCES.ID%TYPE := NULL;
  v_originalid MD_SEQUENCES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_SEQUENCES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SEQUENCES, 'NAME', 'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    INSERT INTO MD_SEQUENCES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, derived_connection_id_fk, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid, C_OBJECTTYPE_SEQUENCES, v_newid, C_OBJECTTYPE_SEQUENCES, p_newconnectionid, v_row.NAME, v_row.NAME, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
  END LOOP;
  CLOSE cv_curs;
  return v_count;
END copy_all_sequences_cascade;

FUNCTION copy_user_privileges(p_olduserid MD_PRIVILEGES.ID%TYPE, p_newuserid MD_PRIVILEGES.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR curs is SELECT * FROM MD_USER_PRIVILEGES WHERE PRIVILEGE_ID_FK = p_olduserid;
  v_newid MD_USER_PRIVILEGES.ID%TYPE;
  v_count NUMBER := 0;
  v_originalid MD_USER_PRIVILEGES.ID%TYPE;
  v_ret NUMBER;
BEGIN
  FOR v_row IN curs LOOP
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.USER_ID_FK := find_object_copy(v_row.USER_ID_FK , C_OBJECTTYPE_USERS, p_newconnectionid);
    v_row.PRIVILEGE_ID_FK := p_newuserid;
    INSERT INTO MD_USER_PRIVILEGES values v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK)
      VALUES(v_originalid, C_OBJECTTYPE_USER_PRIVILEGES, v_newid, C_OBJECTTYPE_USER_PRIVILEGES, p_newconnectionid);
  END LOOP;
  return v_count;
END copy_user_privileges;

FUNCTION copy_all_privileges_cascade(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_PRIVILEGES WHERE SCHEMA_ID_FK = ' || p_oldschemaid;
  v_newid MD_PRIVILEGES.ID%TYPE := NULL;
  v_originalid MD_PRIVILEGES.ID%TYPE := NULL;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_row MD_PRIVILEGES%ROWTYPE;
BEGIN
  v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_PRIVILEGES, 'PRIVILEGE_NAME' ,'ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    v_originalid := v_row.ID;
    v_row.ID := NULL;
    v_row.PRIVELEGE_OBJECT_ID := find_object_copy(v_row.PRIVELEGE_OBJECT_ID , v_row.PRIVELEGEOBJECTTYPE, p_newconnectionid);
    v_row.SCHEMA_ID_FK := p_newschemaid;
    INSERT INTO MD_PRIVILEGES VALUES v_row RETURNING ID INTO v_newid;
    v_ret := copy_additional_properties(v_originalid, v_newid, p_newconnectionid);
    v_count := v_count + 1;
    -- No need to pass on the identifiers to the derivatives as no need to worry about the clashes for the same.
    INSERT INTO MD_DERIVATIVES(src_id, src_type, derived_id, derived_type, DERIVED_CONNECTION_ID_FK, DERIVED_OBJECT_NAMESPACE)
      VALUES(v_originalid,   C_OBJECTTYPE_PRIVILEGES,   v_newid,   C_OBJECTTYPE_PRIVILEGES, p_newconnectionid, C_NS_SCHEMA_OBJS || TO_CHAR(p_newschemaid));
    v_ret := copy_user_privileges(v_originalid, v_newid, p_newconnectionid);
  END LOOP;
  CLOSE cv_curs;
  RETURN v_count;
END copy_all_privileges_cascade;

FUNCTION copy_all_cross_schema_objects(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
-- DD; Can't do this until all schema tables are done
-- There may be foreign keys between schema
  v_ret := copy_all_constraints_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_groups_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_other_objects_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_privileges_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  -- Do synonyms last: This way, we can be sure that the oject for which it is a synonym
  -- has already been copied.
  v_ret := copy_all_synonyms_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  return v_ret;
END copy_all_cross_schema_objects;

FUNCTION copy_all_schema_objects(p_oldschemaid MD_SCHEMAS.ID%TYPE, p_newschemaid MD_SCHEMAS.ID%TYPE, p_newconnectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := copy_all_tables_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_views_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_users_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_tablespaces_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_udds_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_packages_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_unpackaged_sps(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  v_ret := copy_all_sequences_cascade(p_oldschemaid, p_newschemaid, p_newconnectionid, p_filter_set);
  -- TODO: Roles are wrong in the model right now.  I need to fix these up.
  --v_ret := copy_all_roles_cascade(p_oldschemaid, p_newschemaid);
  return v_ret;  
END copy_all_schema_objects;

FUNCTION copy_catalogs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                   p_catalogid MD_CATALOGS.ID%TYPE, 
                                   p_newcatalogid MD_CATALOGS.ID%TYPE, 
                                   p_newconnectionid MD_CONNECTIONS.ID%TYPE, 
                                   p_filter_set MIGR_FILTER_SET :=NULL) RETURN NUMBER
IS
  cv_curs REF_CURSOR;
  v_newid NUMBER;
  v_count NUMBER := 0;
  v_ret NUMBER;
  v_newName MD_SCHEMAS.NAME%TYPE;
  v_filt MIGR_FILTER;
  v_selectStmt VARCHAR2(4000) := 'SELECT a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
      FROM MD_SCHEMAS A, MD_CATALOGS B
      WHERE 
      	A.CATALOG_ID_FK = B.ID 
        AND B.ID =' || p_catalogid  || 
        ' AND CONNECTION_ID_FK = ' || p_connectionid ;
--  v_schemaid MD_SCHEMAS.ID%TYPE;
--  v_schemaname MD_SCHEMAS.NAME%TYPE;
--  v_catalogid MD_CATALOGS.ID%TYPE;
--  v_catalogname MD_CATALOGS.CATALOG_NAME%TYPE;
--  v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
--  v_schematype MD_SCHEMAS.TYPE%TYPE;
--  v_schemacharset MD_SCHEMAS.CHARACTER_SET%TYPE;
--  v_schemaversiontag MD_SCHEMAS.VERSION_TAG%TYPE;
  
  v_derivedRec  DERIVATIVE_REC;
  v_derivedRec2 DERIVATIVE_REC2;
BEGIN
  --v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_CATALOGS, 'B.CATALOG_NAME', 'B.ID', v_selectStmt);
  -- NOTE: May need to apply a schema filter here too
  --v_selectStmt := apply_filter(p_filter_set, C_OBJECTTYPE_SCHEMAS, 'A.NAME', 'A.ID', v_selectStmt);
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    --FETCH cv_curs INTO v_schemaid, v_schemaname, v_catalogid, v_catalogname, v_catalogdummy, v_schematype, v_schemacharset, v_schemaversiontag;
    FETCH cv_curs INTO v_derivedRec;
    EXIT WHEN cv_curs%NOTFOUND;
    
    /*
     schema_id          NUMBER,
     schema_name        VARCHAR2(4000 BYTE),
     catalog_id         NUMBER,
     catalog_name       VARCHAR2(4000 BYTE),
     dummy_flag         CHAR(1 BYTE),
     character_set      VARCHAR2(4000 BYTE),
     version_tag        VARCHAR2(40 BYTE)
    
    */
    -- TODO: Handle wrapping here.
    if v_derivedRec.dummy_flag  <> C_DUMMYFLAG_TRUE then
      v_newName := v_derivedRec.schema_name || '_' || v_derivedRec.catalog_name;
	else
	  v_newName := v_derivedRec.schema_name;
	end if;
    INSERT INTO MD_SCHEMAS(CATALOG_ID_FK, NAME, TYPE, CHARACTER_SET, VERSION_TAG)
    VALUES (p_newcatalogid,  v_newName, v_derivedRec.cap_type, v_derivedRec.character_set, v_derivedRec.version_tag)
    RETURNING ID INTO v_newid;
    -- Here's and interesting situation.  What will we do with the additional properties?
    -- I can coalesce them such that they are in the condensed catalog/schema pair
    -- But their order could (will) contain duplicates.....
    v_ret := copy_additional_properties(p_catalogid, v_newid, p_newconnectionid);
    v_ret := copy_additional_properties(v_derivedRec.schema_id, v_newid, p_newconnectionid);
	-- No Need for namespace stuff for catalogs.
    INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
      ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
    VALUES (v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, v_newid, C_OBJECTTYPE_SCHEMAS, p_newconnectionid, v_derivedRec.schema_name, v_newName);
    INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
    VALUES (v_derivedRec.catalog_id, C_OBJECTTYPE_CATALOGS, v_newid, C_OBJECTTYPE_SCHEMAS, p_newconnectionid, v_derivedRec.catalog_name, v_newName);
    -- TODO: ADD THE FILTER TO THE PARAMETERS BELOW
    v_ret := copy_all_schema_objects(v_derivedRec.schema_id, v_newid, p_newconnectionid, p_filter_set);
    v_count := v_count + 1;
    v_newName :='';
  END LOOP;
  CLOSE cv_curs;
  -- Now...Once all of the schema objects have been done, we have to copy all of those objects that could cross
  -- schema boundaries.  So we need to loop through them again
v_selectStmt := 'SELECT SRC_ID, DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = ' 
  					|| '''' || C_OBJECTTYPE_SCHEMAS || ''' AND DERIVED_TYPE = ''' || C_OBJECTTYPE_SCHEMAS ||''''
  					--|| ' AND DERIVED_CONNECTION_ID_FK = ' || p_newconnectionid
                      || ' AND DERIVED_ID IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CATALOG_ID = ' || p_newcatalogid || ' AND CONNECTION_ID = ' || p_newconnectionid || ')';
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs into v_derivedRec2;
    EXIT when cv_curs%NOTFOUND;
    v_ret := copy_all_cross_schema_objects(v_derivedRec2.schemaid, v_derivedRec2.newid, p_newconnectionid, p_filter_set);
  END LOOP;
  CLOSE cv_curs;  					
  return v_count;
END copy_catalogs_cascade;

FUNCTION remove_duplicate_indexes(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs IS select  index_id_fk, sum(md_index_details.column_id_fk * md_index_details.detail_order) simplehash from md_index_details 
    where index_id_fk in (select id from md_indexes where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)) 
    group by index_id_fk
    order by simplehash, index_id_fk;
  v_lasthash NUMBER :=0;
  v_currenthash NUMBER :=0;
  v_currentid MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;
  v_lastid MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;
  v_count NUMBER := 0;
  v_sql VARCHAR(255);
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_currentid, v_currenthash;
    EXIT WHEN v_curs%NOTFOUND;
    if v_currenthash = v_lasthash THEN
      -- dbms_output.put_line('Index ' || TO_CHAR(v_currentid) || ' is a duplicate');
      v_sql := 'DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid;
      EXECUTE IMMEDIATE v_sql;
      --dbms_output.put_line('DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid);
      v_sql := 'UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = ''DUPIND'', DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid);
      EXECUTE IMMEDIATE v_sql;
      -- dbms_output.put_line('UPDATE MD_DERIVATIVES SET DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid));
      v_count := v_count + 1;
    else
      v_lasthash := v_currenthash;
      v_lastid := v_currentid;
    end if;
  END LOOP;
  CLOSE v_curs;
  return v_count;    
END remove_duplicate_indexes;

FUNCTION remove_indexes_used_elsewhere(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs IS
    select INDEX_ID_FK from 
      (select  index_id_fk, sum(md_index_details.column_id_fk * md_index_details.detail_order) simplehash from md_index_details 
       where index_id_fk in (select id from md_indexes where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)) 
       group by index_id_fk
       order by simplehash) a
    WHERE A.SIMPLEHASH 
    IN
    (
      SELECT b.simplehash FROM 
      (
        SELECT SUM(MD_CONSTRAINT_DETAILS.COLUMN_ID_FK * MD_CONSTRAINT_DETAILS.DETAIL_ORDER) simplehash from md_constraint_details
        where constraint_id_fk in (select id from md_constraints where table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid))
        group by constraint_id_fk
        order by simplehash
      ) b
     );
  v_currentId MD_INDEX_DETAILS.INDEX_ID_FK%TYPE;     
  v_sql VARCHAR2(255);
  v_count NUMBER := 0;
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_currentid;
    EXIT WHEN v_curs%NOTFOUND;
      v_sql := 'DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid;
      EXECUTE IMMEDIATE v_sql;
      --dbms_output.put_line('DELETE FROM MD_INDEXES WHERE ID = ' || v_currentid);
      v_sql := 'DELETE FROM MD_DERIVATIVES WHERE DERIVED_ID = ' || TO_CHAR(v_currentid);
      EXECUTE IMMEDIATE v_sql;
      -- dbms_output.put_line('UPDATE MD_DERIVATIVES SET DERIVED_ID = ' || TO_CHAR(v_lastid)  || ' WHERE DERIVED_ID = ' || TO_CHAR(v_currentid));
      v_count := v_count + 1;
  END LOOP;
  CLOSE v_curs;
  RETURN v_count;
END remove_indexes_used_elsewhere;    

PROCEDURE cut_lob_indexes_to_25(p_connectionId MD_CONNECTIONS.ID%TYPE)
IS
  CURSOR v_curs (context MD_ADDITIONAL_PROPERTIES.VALUE%TYPE, ctxcat MD_ADDITIONAL_PROPERTIES.VALUE%TYPE) is 
    SELECT * FROM MD_INDEXES WHERE 
    TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND LENGTH(INDEX_NAME) > 25 AND  
    ( EXISTS (SELECT 1 FROM MD_ADDITIONAL_PROPERTIES WHERE ( VALUE = context 
    OR VALUE = ctxcat ) AND REF_ID_FK = MD_INDEXES.ID ) )
    FOR UPDATE OF INDEX_NAME;
  v_numIndexCount INTEGER := 1;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;
  v_row MD_INDEXES%ROWTYPE;
BEGIN
-- totierne: for each lob index cut to 23 or 22 or 21 to put _XXX up to 25 chars (should be bytes)
  OPEN v_curs (C_INDEXTYPE_CONTEXT, C_INDEXTYPE_CTXCAT);
  LOOP
    FETCH v_curs INTO v_row;
    EXIT WHEN v_curs%NOTFOUND;
    v_newName := MIGRATION_TRANSFORMER.add_suffix(v_row.INDEX_NAME, '_' || TO_CHAR(v_numIndexCount), 25);
    update MD_INDEXES SET index_name = v_newName where current of v_curs;
    v_numIndexCount := v_numIndexCount + 1;
  END LOOP;
  CLOSE v_curs;
  commit;
END cut_lob_indexes_to_25;

FUNCTION fixupTextIndexes(p_connectionId MD_CONNECTIONS.ID%TYPE) return NUMBER
IS
  CURSOR v_curs is
    select index_id_fk, count(*) numcols from md_index_details where
    index_id_fk in (
      select c.id
      from md_columns a, md_index_details b, md_indexes c
      where b.column_id_fk = a.id
      and column_type in ('BLOB', 'CLOB')
      and b.index_id_fk = c.id
      and c.table_id_fk in (select table_id from mgv_all_tables where connection_id = p_connectionid)
    ) group by index_id_fk;
  v_indexId MD_INDEXES.ID%TYPE;
  v_numCols INTEGER;
  v_extendedIndexType MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
BEGIN        
  OPEN v_curs;
  LOOP
    FETCH v_curs into v_indexId, v_numCols;
    EXIT WHEN v_curs%NOTFOUND;
    IF v_numCols = 1 THEN
      v_extendedIndexType := C_INDEXTYPE_CONTEXT;
    ELSE
      v_extendedIndexType := C_INDEXTYPE_CTXCAT;
    END IF;
    INSERT INTO MD_ADDITIONAL_PROPERTIES(CONNECTION_ID_FK ,REF_ID_FK, REF_TYPE, PROP_KEY, VALUE)
    VALUES (p_connectionId, v_indexId, C_OBJECTTYPE_INDEXES, C_PROPKEY_EXTENDEDINDEXTYPE, v_extendedIndexType);
    COMMIT;
  END LOOP;
  -- NCLOBs cannot be indexed.  They aren't allowed in normal indexes, and they aren't allowed in TEXT 
  -- indexes.   The only thing to do here is to remove it.
  -- TODO: We can't just do this silently.
   -- Mark THE derivative RECORD AS DELETEd.
  UPDATE md_derivatives SET DERIVATIVE_REASON = 'NCLOBIND' WHERE DERIVED_TYPE = 'MD_INDEXES' AND DERIVED_CONNECTION_ID_FK = p_connectionid
      AND  DERIVED_ID IN 
             (SELECT C.ID   FROM MD_COLUMNS A, MD_INDEX_DETAILS B, MD_INDEXES C, MGV_ALL_TABLES D
                 WHERE B.COLUMN_ID_FK = A.ID AND COLUMN_TYPE ='NCLOB' AND B.INDEX_ID_FK = C.ID
                  AND C.TABLE_ID_FK = D.TABLE_ID AND D.CONNECTION_ID = p_connectionid);
  DELETE FROM MD_INDEXES WHERE ID IN
             (SELECT C.ID   FROM MD_COLUMNS A, MD_INDEX_DETAILS B, MD_INDEXES C, MGV_ALL_TABLES D
                 WHERE B.COLUMN_ID_FK = A.ID AND COLUMN_TYPE ='NCLOB' AND B.INDEX_ID_FK = C.ID
                  AND C.TABLE_ID_FK = D.TABLE_ID AND D.CONNECTION_ID = p_connectionid);
  -- cut blob/clob index string to 25 characters with _nn incrementing marker
  cut_lob_indexes_to_25(p_connectionId);
  CLOSE v_curs;
  return 0;
END fixupTextIndexes;

PROCEDURE createDummyScrTblPerSchema_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                               
  v_qualified_native_name VARCHAR2(300);
  n_newtblid NUMBER;
  tbltrigRec MD_TRIGGERS%ROWTYPE;
  n_newtrigId MD_TRIGGERS."ID"%TYPE;
  origtrigId MD_TRIGGERS."ID"%TYPE;
  CURSOR curtblTrig(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_TRIGGERS 
                                       WHERE TRIGGER_ON_FLAG = 'T'
                                           AND TABLE_OR_VIEW_ID_FK IN (
                                                SELECT "ID" 
                                                FROM MD_TABLES
                                                WHERE SCHEMA_ID_FK = schId);
                                                  
BEGIN
   SELECT A.catalog_name || '.' || B."NAME" || 'DUMMY' INTO v_qualified_native_name
             FROM MD_CATALOGS A, MD_SCHEMAS B
             WHERE A."ID" = B.catalog_id_fk
                   AND B."ID" = schemaId;

   -- insert 1 DUMMY table per schema.  We don't want to create peer records in md_tables for each table entry
   INSERT INTO MD_TABLES(schema_id_fk, table_name, qualified_native_name)
                  VALUES(new_schemaId, 'DUMMY', v_qualified_native_name)
                  RETURNING "ID" INTO n_newtblid;
   -- There is no additional property to copy as this is a dummy table with no src peer
   -- This table is used to attached all the translated triggers
                  
   -- insert corresponding row into md_derivatives
   INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (n_newtblid, C_OBJECTTYPE_TABLES, n_newtblId, C_OBJECTTYPE_TABLES, p_scratchConn, 'DUMMY', 'DUMMY');  
                   
   --copy_all_tbl_trigs_ee
   OPEN curtblTrig(schemaId);
   FETCH curtblTrig INTO tbltrigRec;
   LOOP
      EXIT WHEN curtblTrig%NOTFOUND;
      origtrigId := tbltrigRec."ID";
      tbltrigRec."ID" := NULL;
      tbltrigRec.table_or_view_id_fk := n_newtblid;
      INSERT INTO MD_TRIGGERS VALUES tbltrigRec RETURNING "ID" INTO n_newtrigId;

      -- insert corresponding row into md_derivatives
      INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (origtrigId, C_OBJECTTYPE_TRIGGERS, n_newtrigId, C_OBJECTTYPE_TRIGGERS, p_scratchConn, tbltrigRec.TRIGGER_NAME, tbltrigRec.TRIGGER_NAME);  

      
      FETCH curtblTrig INTO tbltrigRec;
   END LOOP;
   CLOSE curtblTrig;
                                     
END createDummyScrTblPerSchema_ee;

PROCEDURE copy_all_views_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                         
   CURSOR curViews(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = schId;
   viewRec MD_VIEWS%ROWTYPE;
   n_newVwid MD_VIEWS."ID"%TYPE;
   norigVwid MD_VIEWS."ID"%TYPE;
   n_ret NUMBER;
   
  vwtrigRec MD_TRIGGERS%ROWTYPE;
  n_newtrigId MD_TRIGGERS."ID"%TYPE;
  origtrigId MD_TRIGGERS."ID"%TYPE;
  CURSOR curvwTrig(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_TRIGGERS 
                                       WHERE TRIGGER_ON_FLAG = 'V'
                                           AND TABLE_OR_VIEW_ID_FK IN (
                                                SELECT "ID" 
                                                FROM MD_TABLES
                                                WHERE SCHEMA_ID_FK = schId);   
BEGIN
   OPEN curViews(schemaId);
   FETCH curViews INTO viewRec;
   LOOP
      EXIT WHEN curViews%NOTFOUND;
      norigVwid := viewRec."ID";
      viewRec."ID" := NULL;
      viewRec.SCHEMA_ID_FK := new_schemaId;
      INSERT INTO MD_VIEWS VALUES viewRec RETURNING "ID" INTO n_newVwId;
      n_ret := copy_additional_properties(viewRec."ID", n_newVwId, p_scratchConn);
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES(norigVwid,   
                                  C_OBJECTTYPE_VIEWS,   
                                  n_newVwId,   
                                  C_OBJECTTYPE_VIEWS, 
                                  p_scratchConn, viewRec.VIEW_NAME, viewRec.VIEW_NAME, C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaId));
                                  
      -- Handle view triggers
      OPEN curvwTrig(schemaId);
      FETCH curvwTrig INTO vwtrigRec;
      LOOP
         EXIT WHEN curvwTrig%NOTFOUND;
         origtrigId := vwtrigRec."ID";
         vwtrigRec."ID" := NULL;
         vwtrigRec.table_or_view_id_fk := n_newVwId;
         
         INSERT INTO MD_TRIGGERS VALUES vwtrigRec RETURNING "ID" INTO n_newtrigId;
         
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (origtrigId, C_OBJECTTYPE_TRIGGERS, n_newtrigId, C_OBJECTTYPE_TRIGGERS, p_scratchConn, vwtrigRec.TRIGGER_NAME, vwtrigRec.TRIGGER_NAME);           
         
         FETCH curvwTrig INTO vwtrigRec;         
      END LOOP; -- end vw trigger loop
      CLOSE curvwTrig;
      
      FETCH curViews INTO viewRec;
      --copy_all_tbl_trigs_ee      
   END LOOP; -- end vw loop
   CLOSE curViews;
END copy_all_views_ee;

PROCEDURE copy_all_unpackaged_sps_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS              
   CURSOR curSps(schId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = schId;
   spRec MD_STORED_PROGRAMS%ROWTYPE;
   n_newSpid MD_STORED_PROGRAMS."ID"%TYPE;
   norigSpid MD_STORED_PROGRAMS."ID"%TYPE;
   n_ret NUMBER;
BEGIN
   OPEN curSps(schemaId);
   FETCH curSps INTO spRec;
   LOOP
      EXIT WHEN curSps%NOTFOUND;
      norigSpid := spRec."ID";
      spRec."ID" := NULL;
      spRec.schema_id_fk := new_schemaId;

      INSERT INTO MD_STORED_PROGRAMS VALUES spRec RETURNING "ID" INTO n_newSpid;
      n_ret := copy_additional_properties(spRec."ID", n_newSpid, p_scratchConn);
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES(norigSpid,   
                                  C_OBJECTTYPE_STORED_PROGRAMS,   
                                  n_newSpid,   
                                  C_OBJECTTYPE_STORED_PROGRAMS, 
                                  p_scratchConn, spRec."NAME", spRec."NAME", C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaId));
      FETCH curSps INTO spRec;
   END LOOP;
   CLOSE curSps;
END copy_all_unpackaged_sps_ee;

PROCEDURE copy_all_tbl_trigs_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
   NULL;
END copy_all_tbl_trigs_ee;

PROCEDURE copy_all_vw_trigs_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
   NULL;
END copy_all_vw_trigs_ee;

PROCEDURE createIndexEntry(tableId MD_TABLES."ID"%TYPE, 
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curIndexes(tableId MD_TABLES."ID"%TYPE) IS SELECT * FROM md_indexes WHERE table_id_fk = tableId;
   idxRow MD_INDEXES%ROWTYPE;

BEGIN
   OPEN curIndexes(tableId);
   FETCH curIndexes INTO idxRow;
   
   LOOP
      EXIT WHEN curIndexes%NOTFOUND;

      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              idxRow."ID",
                              C_OBJECTTYPE_INDEXES,
                              idxRow."ID",
                              'MD_INDEXES',
                              p_scratchConn,
                              idxRow.index_name,
                              idxRow.index_name,
                              C_OBJECTTYPE_INDEXES || TO_CHAR(tableId)         
                           );      
      FETCH curIndexes INTO idxRow;
   END LOOP;
   CLOSE curIndexes;

END;

PROCEDURE createColumnEntry(tableId MD_TABLES."ID"%TYPE, 
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curColumns(tableId MD_TABLES."ID"%TYPE) IS SELECT * FROM md_columns WHERE table_id_fk = tableId;
   colRow MD_COLUMNS%ROWTYPE;
BEGIN
   OPEN curColumns(tableId);
   FETCH curColumns INTO colRow;
   
   LOOP
      EXIT WHEN curColumns%NOTFOUND;

      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              colRow."ID",
                              C_OBJECTTYPE_COLUMNS,
                              colRow."ID",
                              'MD_COLUMNS',
                              p_scratchConn,
                              colRow.column_name,
                              colRow.column_name,
                              C_OBJECTTYPE_COLUMNS || TO_CHAR(tableId)         
                           );      
      FETCH curColumns INTO colRow;
   END LOOP;
   CLOSE curColumns;
END;


PROCEDURE createTableEntry(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
   CURSOR curTables(schemaId MD_SCHEMAS."ID"%TYPE) IS SELECT * FROM md_tables WHERE schema_id_fk = schemaId;
   tblRow MD_TABLES%ROWTYPE;
BEGIN
   OPEN curTables(schemaId);
   FETCH curTables INTO tblRow;
   
   LOOP
      EXIT WHEN curTables%NOTFOUND;
      
      INSERT INTO MD_DERIVATIVES(src_id, 
                                 src_type, 
                                 derived_id, 
                                 derived_type, 
                                 DERIVED_CONNECTION_ID_FK, 
                                 ORIGINAL_IDENTIFIER, 
                                 NEW_IDENTIFIER, 
                                 DERIVED_OBJECT_NAMESPACE)
                           VALUES
                           (
                              tblRow."ID",
                              C_OBJECTTYPE_TABLES,
                              tblRow."ID",
                              'MD_TABLES',
                              p_scratchConn,
                              tblRow.table_name,
                              tblRow.table_name,
                              C_NS_SCHEMA_OBJS || TO_CHAR(new_schemaid)         
                           );      
      createColumnEntry(tblRow."ID", p_scratchConn);      
      createIndexEntry(tblRow."ID", p_scratchConn);      
      FETCH curTables INTO tblRow;
   END LOOP;
   CLOSE curTables;
END;
    
    
PROCEDURE createConstraintEntry(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS
BEGIN
   NULL;
END;


PROCEDURE copy_schema_objects_ee(schemaId MD_SCHEMAS."ID"%TYPE, 
                                 new_schemaId MD_SCHEMAS."ID"%TYPE,
                                 p_scratchConn MD_CONNECTIONS."ID"%TYPE)
IS                                 
BEGIN
    --This create scratch model for table triggers as well
    createDummyScrTblPerSchema_ee(schemaId,   
                                 new_schemaId,
                                 p_scratchConn);
    -- Make md_derivatives entry only for the following objects -- begin 
    createTableEntry(schemaId, new_schemaId, p_scratchConn);
    createConstraintEntry(schemaId, new_schemaId, p_scratchConn);    
    -- Make md_derivatives entry only for the following objects -- end
    
    --This create scratch model for view triggers as well                                 
    copy_all_views_ee(schemaId, 
                   new_schemaId,
                   p_scratchConn);
                   
    copy_all_unpackaged_sps_ee(schemaId, 
                 new_schemaId,
                 p_scratchConn);                                    
END copy_schema_objects_ee;

-- p_connectionid -- scratch model connection id
PROCEDURE copy_catalogs_cascade_ee(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
   CURSOR curDerivatives(conId MD_CONNECTIONS."ID"%TYPE) IS
                SELECT *
                       FROM MD_DERIVATIVES 
                       WHERE DERIVED_CONNECTION_ID_FK = conId
                       AND SRC_TYPE = C_OBJECTTYPE_CATALOGS;
   recDerived MD_DERIVATIVES%ROWTYPE;
   
   CURSOR curSchemas(catId MD_SCHEMAS.CATALOG_ID_FK%TYPE) IS
                SELECT * FROM MD_SCHEMAS WHERE CATALOG_ID_FK = catId;
   recSchema MD_SCHEMAS%ROWTYPE;
   
   ncatId MD_SCHEMAS.CATALOG_ID_FK%TYPE;
   n_newschId MD_SCHEMAS."ID"%TYPE;
   v_ret NUMBER;
   v_catalogdummy MD_CATALOGS.DUMMY_FLAG%TYPE;
   v_catalogname VARCHAR2(300);
   v_newName VARCHAR2(300); 
BEGIN
   OPEN curDerivatives(p_connectionid);
   FETCH curDerivatives INTO recDerived;
   LOOP -- for each of the catalog process its schemas
      EXIT WHEN curDerivatives%NOTFOUND;
      SELECT dummy_flag, catalog_name INTO v_catalogdummy, v_catalogname FROM MD_CATALOGS WHERE "ID" = recDerived.src_id;
      ncatId := recDerived.src_id;
      OPEN curSchemas(ncatId);
      FETCH curSchemas INTO recSchema;
      LOOP
         EXIT WHEN curSchemas%NOTFOUND;
         
         v_newName := recSchema."NAME" || '_' || v_catalogname;
         
         INSERT INTO MD_SCHEMAS(CATALOG_ID_FK, "NAME", "TYPE", CHARACTER_SET, VERSION_TAG)
                          VALUES (recDerived.derived_id, 
                                  v_newName, 
                                  recSchema."TYPE",
                                  recSchema.CHARACTER_SET, 
                                  recSchema.VERSION_TAG)
                          RETURNING "ID" INTO n_newschId;
         v_ret := copy_additional_properties(ncatId, n_newschId, p_connectionid);                          
         v_ret := copy_additional_properties(recSchema."ID", n_newschId, p_connectionid);
         
	       -- No Need for namespace stuff for catalogs.
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK,
               ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (recSchema."ID", C_OBJECTTYPE_SCHEMAS, n_newschId, C_OBJECTTYPE_SCHEMAS, p_connectionid, recSchema."NAME", v_newName);
    
         INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER)
                   VALUES (recDerived.src_id, C_OBJECTTYPE_CATALOGS, n_newschId, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_catalogname, v_newName);         
                   
         copy_schema_objects_ee(recSchema."ID", n_newschId, p_connectionId);
         FETCH curSchemas INTO recSchema;
      END LOOP; -- end schema loop
      CLOSE curSchemas;
      
      FETCH curDerivatives INTO recDerived;
   END LOOP;  -- end catalog loop
   CLOSE curDerivatives;
END copy_catalogs_cascade_ee;

FUNCTION copy_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE, p_filter_set MIGR_FILTER_SET := NULL, p_scratchModel BOOLEAN := FALSE) RETURN NUMBER
IS
  v_newConnectionId MD_CONNECTIONS.ID%TYPE;
  v_numProps NUMBER;
  v_catalogId MD_CATALOGS.ID%TYPE;
  v_catalogName MD_CATALOGS.CATALOG_NAME%TYPE;
  v_numCatalogs NUMBER;
  v_numDuplicateIndexes NUMBER;
  v_sql VARCHAR(255);   
  
  CURSOR curDerivatives(conId MD_CONNECTIONS."ID"%TYPE) IS
                SELECT distinct 
                           id,
                           src_id,
                           src_type,
                           derived_id,
                           derived_type,
                           derived_connection_id_fk,
                           transformed,
                           original_identifier,
                           new_identifier,
                           derived_object_namespace,
                           derivative_reason,
                           security_group_id,
                           created_on,
                           created_by,
                           last_updated_on,
                           last_updated_by
                       FROM MD_DERIVATIVES 
                       WHERE DERIVED_CONNECTION_ID_FK = conId
                       AND SRC_TYPE = C_OBJECTTYPE_CATALOGS;
                       
   recDerived MD_DERIVATIVES%ROWTYPE;
  
  
BEGIN
	
  --DROP ANY EXISTING CONVERTED MODEL, AS WE ONLY HAVE A ONE TO ONE RELATIONSHIP WITH CAPTURED AND CONVERTED MODELS NOW
  DELETE FROM Md_Connections C 
  WHERE C.Type = 'CONVERTED' --only want to delete CONVERTED MODELS
  AND C.Id IN ( -- delete all converted models associated with this captured model
  SELECT d.derived_id FROM md_derivatives d WHERE d.src_id =  p_connectionid
  );
  
  -- The connection doesn't use the filter, because it is called for a single connection.
  v_newConnectionId := copy_connection(p_connectionid, p_scratchModel);
  -- Don't forget its additional props
  v_numProps := copy_additional_properties(p_connectionid, v_newConnectionId, v_newConnectionId);
  -- OK - Next coalesce the schema/catalogs
  
  IF p_scratchModel = FALSE 
  THEN
      --v_catalogId := create_dummy_catalog(v_newConnectionId);
      --select CATALOG_NAME INTO v_catalogName FROM MD_CATALOGS WHERE CONNECTION_ID_FK = p_connectionid;
      --v_sql := 'UPDATE MD_CATALOGS SET CATALOG_NAME = ''' || v_catalogName  || ''' WHERE ID = ' || TO_CHAR(v_catalogId);
      --EXECUTE IMMEDIATE v_sql;
      create_dummy_catalogs(p_connectionid, v_newConnectionId, FALSE);
      
      OPEN curDerivatives(v_newConnectionId);
      
      LOOP
            FETCH curDerivatives INTO recDerived;
            EXIT WHEN curDerivatives%NOTFOUND;
           --v_numCatalogs := copy_catalogs_cascade(p_connectionid, v_catalogid, v_newConnectionId, p_filter_set);
           v_numCatalogs := copy_catalogs_cascade(p_connectionid, recDerived.src_id, recDerived.derived_id, v_newConnectionId, p_filter_set);
           --FETCH curDerivatives INTO recDerived;
      END LOOP;
      CLOSE curDerivatives;
      v_numDuplicateIndexes := remove_duplicate_indexes(v_newConnectionId);
      v_numDuplicateIndexes := v_numDuplicateIndexes + remove_indexes_used_elsewhere(v_newConnectionId);
  ELSE -- enterprise capture
      create_dummy_catalogs(p_connectionid, v_newConnectionId, TRUE);
      copy_catalogs_cascade_ee(v_newConnectionId);
  END IF;
  COMMIT;
  return v_newConnectionId;
END copy_connection_cascade;

PROCEDURE update_derivative_record(p_orig VARCHAR2, p_new VARCHAR2, p_derivedid MD_DERIVATIVES.DERIVED_ID%TYPE,
p_derivedtype MD_DERIVATIVES.DERIVED_TYPE%TYPE, p_connectionid MD_DERIVATIVES.DERIVED_CONNECTION_ID_FK%TYPE)
IS	
BEGIN
    UPDATE MD_DERIVATIVES SET TRANSFORMED = C_TRANSFORMED_TRUE, ORIGINAL_IDENTIFIER = p_orig, NEW_IDENTIFIER = p_new
      WHERE DERIVED_ID = p_derivedid
      AND DERIVED_TYPE = p_derivedtype
      AND DERIVED_CONNECTION_ID_FK = p_connectionid;
END update_derivative_record;

/*
 * This procedure is like update_derivative_record except it should be used at name clash stage
 * basically, this will work the same as update_derivative_record except in those cases where
 * there is already a derivative record.  In this latter case, we want ORIGINAL_IDENTIFIER preserved
 * (this is called when there is a possiblity that we've carried out a second transformation
 */
PROCEDURE second_update_derivative(p_orig VARCHAR2, p_new VARCHAR2, p_derivedid MD_DERIVATIVES.DERIVED_ID%TYPE,
p_derivedtype MD_DERIVATIVES.DERIVED_TYPE%TYPE, p_connectionid MD_DERIVATIVES.DERIVED_CONNECTION_ID_FK%TYPE)
IS
  v_firstOriginal MD_DERIVATIVES.ORIGINAL_IDENTIFIER%TYPE;
BEGIN
  -- see if p_orig is already the new identifier
  select ORIGINAL_IDENTIFIER INTO v_firstOriginal FROM MD_DERIVATIVES
      WHERE DERIVED_ID = p_derivedid
      AND DERIVED_TYPE = p_derivedtype
      AND NEW_IDENTIFIER = p_orig
      AND DERIVED_CONNECTION_ID_FK = p_connectionid;
  if v_firstOriginal IS NULL then
    update_derivative_record(p_orig, p_new, p_derivedid, p_derivedtype, p_connectionid);
  else
    update_derivative_record(v_firstOriginal, p_new, p_derivedid, p_derivedtype, p_connectionid);
  end if;
EXCEPTION
  when NO_DATA_FOUND THEN
    update_derivative_record(p_orig, p_new, p_derivedid, p_derivedtype, p_connectionid);
  WHEN TOO_MANY_ROWS THEN
    dbms_output.put_line(TO_CHAR(p_derivedid) || ' ' || TO_CHAR(p_derivedtype) || ' '|| TO_CHAR(p_connectionid));
  
END second_update_derivative;

FUNCTION transform_column_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                 p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
    SELECT * FROM MD_COLUMNS
    WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(COLUMN_NAME) != COLUMN_NAME 
    FOR UPDATE OF COLUMN_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
    SELECT c.*, d.NEW_IDENTIFIER FROM MD_COLUMNS c, MD_DERIVATIVES d
    WHERE (c.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE= C_OBJECTTYPE_COLUMNS AND DERIVED_CONNECTION_ID_FK = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != COLUMN_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF COLUMN_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);

    update_derivative_record(v_rec.COLUMN_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_COLUMNS, p_connectionid);    
    IF p_scratchModel = FALSE -- Update md_columns only for non migration estimation models
    THEN
        UPDATE MD_COLUMNS SET COLUMN_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_COLUMNS, v_count);
  --return v_count;
END transform_column_identifiers;

FUNCTION transform_constraint_idents(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_CONSTRAINTS
  WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT c.*, d.NEW_IDENTIFIER FROM MD_CONSTRAINTS c, MD_DERIVATIVES d
  WHERE (c.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE = C_OBJECTTYPE_CONSTRAINTS AND DERIVED_CONNECTION_ID_FK = connid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != c.NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_CONSTRAINTS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
       UPDATE MD_CONSTRAINTS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_CONSTRAINTS, v_count);
END transform_constraint_idents;

FUNCTION transform_group_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                          p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_GROUPS WHERE
   SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(GROUP_NAME) != GROUP_NAME
    FOR UPDATE OF GROUP_NAME;
*/    

  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_GROUPS WHERE
   ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE = C_OBJECTTYPE_GROUPS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(GROUP_NAME) != GROUP_NAME
    FOR UPDATE OF GROUP_NAME;
  v_rec MD_GROUPS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.GROUP_NAME);
    
    update_derivative_record(v_rec.GROUP_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_GROUPS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
       UPDATE MD_GROUPS SET GROUP_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_GROUPS, v_count);
END transform_group_identifiers;

FUNCTION transform_index_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_INDEXES WHERE TABLE_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||INDEX_NAME) != INDEX_NAME
    FOR UPDATE OF INDEX_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT i.*, d.NEW_IDENTIFIER FROM MD_INDEXES i, MD_DERIVATIVES d WHERE (i.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_INDEXES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != i.INDEX_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF INDEX_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.INDEX_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_INDEXES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN    
        UPDATE MD_INDEXES SET INDEX_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  commit;
  CLOSE v_curs;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_INDEXES, v_count);
END transform_index_identifiers;

FUNCTION transform_othobj_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                          p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_OTHER_OBJECTS  WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_OTHER_OBJECTS  WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_OTHER_OBJECTS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_OTHER_OBJECTS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_OTHER_OBJECTS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_OTHER_OBJECTS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_OTHER_OBJECTS, v_count);
END transform_othobj_identifiers;

FUNCTION transform_package_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                        p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_PACKAGES  WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_PACKAGES  WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
    WHERE SRC_TYPE = C_OBJECTTYPE_PACKAGES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_PACKAGES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_PACKAGES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_PACKAGES SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_PACKAGES, v_count);
END transform_package_identifiers;

FUNCTION transform_schema_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                         p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SCHEMAS WHERE ID IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT s.*, d.NEW_IDENTIFIER FROM MD_SCHEMAS s, MD_DERIVATIVES d WHERE (s.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_SCHEMAS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(d.NEW_IDENTIFIER) != NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName:= MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SCHEMAS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SCHEMAS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SCHEMAS, v_count);
END transform_schema_identifiers;

FUNCTION transform_sequence_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                           p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT s.*, d.NEW_IDENTIFIER FROM MD_SEQUENCES s, MD_DERIVATIVES d WHERE (s.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_SEQUENCES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SEQUENCES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SEQUENCES SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SEQUENCES, v_count);
END transform_sequence_identifiers;

FUNCTION transform_sproc_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                         p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT sp.*, d.NEW_IDENTIFIER FROM MD_STORED_PROGRAMS sp, MD_DERIVATIVES d WHERE (sp.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_STORED_PROGRAMS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != sp.NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_STORED_PROGRAMS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_STORED_PROGRAMS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_STORED_PROGRAMS, v_count);
END transform_sproc_identifiers;

FUNCTION transform_synonym_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                       p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SYNONYMS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_SYNONYMS WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
       WHERE SRC_TYPE =  C_OBJECTTYPE_SYNONYMS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||NAME) != NAME
    FOR UPDATE OF NAME;
  v_rec MD_SYNONYMS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NAME);
    
    update_derivative_record(v_rec.NAME, v_newName, v_rec.ID, C_OBJECTTYPE_SYNONYMS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_SYNONYMS SET NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_SYNONYMS, v_count);
END transform_synonym_identifiers;

FUNCTION transform_table_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TABLE_NAME) != TABLE_NAME
    FOR UPDATE OF TABLE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT t.*, d.NEW_IDENTIFIER FROM MD_TABLES t, MD_DERIVATIVES d WHERE (t.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_TABLES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != TABLE_NAME 
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF TABLE_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.TABLE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TABLES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TABLES SET TABLE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TABLES, v_count);
END transform_table_identifiers;

FUNCTION transform_view_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||VIEW_NAME) != VIEW_NAME
    FOR UPDATE OF VIEW_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT v.*, d.NEW_IDENTIFIER FROM MD_VIEWS v, MD_DERIVATIVES d WHERE (v.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_VIEWS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != VIEW_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH 
    FOR UPDATE OF VIEW_NAME;
  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);
    
    update_derivative_record(v_rec.VIEW_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_VIEWS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_VIEWS SET VIEW_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_VIEWS, v_count);
END transform_view_identifiers;

FUNCTION transform_tablespace_idents(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLESPACES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(TABLESPACE_NAME) != TABLESPACE_NAME
    FOR UPDATE OF TABLESPACE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_TABLESPACES WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE = C_OBJECTTYPE_TABLESPACES AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(TABLESPACE_NAME) != TABLESPACE_NAME
    FOR UPDATE OF TABLESPACE_NAME;
  v_rec MD_TABLESPACES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.TABLESPACE_NAME);
    
    update_derivative_record(v_rec.TABLESPACE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TABLESPACES, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TABLESPACES SET TABLESPACE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TABLESPACES, v_count);
END transform_tablespace_idents;

FUNCTION transform_trigger_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                       p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs IS 
  SELECT * FROM MD_TRIGGERS  WHERE TABLE_OR_VIEW_ID_FK IN
    (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TRIGGER_NAME) != TRIGGER_NAME
    FOR UPDATE OF TRIGGER_NAME;
  CURSOR v_view_trigger_curs IS 
    SELECT * FROM MD_TRIGGERS  WHERE TABLE_OR_VIEW_ID_FK IN
    (SELECT VIEW_ID FROM MGV_ALL_VIEWS WHERE CONNECTION_ID =  p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||TRIGGER_NAME) != TRIGGER_NAME
    FOR UPDATE OF TRIGGER_NAME;
*/    
  CURSOR v_curs IS 
  SELECT t.*, d.NEW_IDENTIFIER FROM MD_TRIGGERS t, MD_DERIVATIVES d WHERE (t.ID, d.SRC_ID) IN
    (SELECT DERIVED_ID, SRC_ID FROM MD_DERIVATIVES 
      WHERE SRC_TYPE =  C_OBJECTTYPE_TRIGGERS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||d.NEW_IDENTIFIER) != t.TRIGGER_NAME
    AND d.DERIVATIVE_REASON = C_CONNECTIONTYPE_SCRATCH
    FOR UPDATE OF TRIGGER_NAME;

  v_rec v_curs%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs;
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.NEW_IDENTIFIER);

    update_derivative_record(v_rec.TRIGGER_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TRIGGERS, p_connectionid);
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;       

  END LOOP;
  CLOSE v_curs;
  /*
  OPEN v_view_trigger_curs;
  LOOP
    FETCH v_view_trigger_curs INTO v_rec;
    EXIT WHEN v_view_trigger_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.TRIGGER_NAME);
    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_newName WHERE CURRENT OF v_view_trigger_curs;
    END IF;
    
    update_derivative_record(v_rec.TRIGGER_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_TRIGGERS, p_connectionid);
  END LOOP;
  CLOSE v_view_trigger_curs;
  */
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_TRIGGERS, v_count);
END transform_trigger_identifiers;

FUNCTION transform_uddt_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                      p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||DATA_TYPE_NAME) != DATA_TYPE_NAME
    FOR UPDATE OF DATA_TYPE_NAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USER_DEFINED_DATA_TYPES WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_UDDT AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||DATA_TYPE_NAME) != DATA_TYPE_NAME
    FOR UPDATE OF DATA_TYPE_NAME;
  v_rec MD_USER_DEFINED_DATA_TYPES%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_prefixName||v_rec.DATA_TYPE_NAME);
    
    update_derivative_record(v_rec.DATA_TYPE_NAME, v_newName, v_rec.ID, C_OBJECTTYPE_UDDT, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_USER_DEFINED_DATA_TYPES SET DATA_TYPE_NAME = v_newName WHERE CURRENT OF v_curs;
    END IF;
    
  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_UDDT, v_count);
END transform_uddt_identifiers;

FUNCTION transform_user_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_T
IS
/*
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USERS WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME
    FOR UPDATE OF USERNAME;
*/    
  CURSOR v_curs(connid MD_CONNECTIONS.ID%TYPE) IS 
  SELECT * FROM MD_USERS WHERE ID IN
    (SELECT DERIVED_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_USERS AND DERIVED_CONNECTION_ID_FK = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME
    FOR UPDATE OF USERNAME;
  v_rec MD_USERS%ROWTYPE;
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_T;
  v_newName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
BEGIN
  OPEN v_curs(p_connectionid);
  LOOP
    FETCH v_curs INTO v_rec;
    EXIT WHEN v_curs%NOTFOUND;
    v_count := v_count + 1;
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_rec.USERNAME);
    
    update_derivative_record(v_rec.USERNAME, v_newName, v_rec.ID, C_OBJECTTYPE_USERS, p_connectionid);    
    IF p_scratchModel = FALSE
    THEN        
       UPDATE MD_USERS SET USERNAME = v_newName WHERE CURRENT OF v_curs;
    END IF;

  END LOOP;
  CLOSE v_curs;
  commit;
  return NAME_AND_COUNT_T(C_OBJECTTYPE_USERS, v_count);
END transform_user_identifiers;

PROCEDURE rename_duplicate_index_names(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE)
IS
    CURSOR v_curs IS
    select * from md_derivatives a 
          where a.derived_connection_id_fk = p_connectionid
                and 1 < (select count(*) 
                          from md_derivatives b 
                              where a.new_identifier = b.new_identifier 
                                  and a.derived_type='MD_INDEXES'
                                      and a.derived_connection_id_fk = b.derived_connection_id_fk)
                                      order by new_identifier;
                                          
  v_row MD_DERIVATIVES%ROWTYPE;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;

  v_id MD_DERIVATIVES.DERIVED_ID%TYPE;

  v_curName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_count NUMBER := 1;
BEGIN
  v_curName := 'dsa;lkjsd;alskj;';
  OPEN v_curs;
  LOOP
    FETCH v_curs INTO v_row;
    EXIT WHEN v_curs%NOTFOUND;
    

   IF UPPER(v_row.NEW_IDENTIFIER) = UPPER(v_curName) THEN
      v_newName := MIGRATION_TRANSFORMER.ADD_SUFFIX(v_row.NEW_IDENTIFIER, '_' || TO_CHAR(v_count), 30);
      v_count := v_count + 1;
      
      if p_scratchModel = FALSE
      THEN
         update MD_INDEXES SET index_name = v_newName where id = v_row.DERIVED_ID;
      END IF;
      second_update_derivative(v_row.NEW_IDENTIFIER, v_newName, v_row.DERIVED_ID, C_OBJECTTYPE_INDEXES, p_connectionid);
    else
      v_curName := v_row.NEW_IDENTIFIER;
      v_count := 1;
    END IF;
  END LOOP;
  CLOSE v_curs;
  commit;
END rename_duplicate_index_names;

PROCEDURE fixup_duplicate_identifier(p_connectionid MD_CONNECTIONS.ID%TYPE, 
                                      p_mdrec_id MD_DERIVATIVES.ID%TYPE,
                                      p_derived_type MD_DERIVATIVES.DERIVED_TYPE%TYPE,
                                      p_derived_id MD_DERIVATIVES.DERIVED_ID%TYPE,
                                      p_new_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE,
                                      p_suffix INTEGER, 
                                      p_scratchModel BOOLEAN := FALSE)
IS
	v_transform_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
	v_did_a_transform CHAR(1) := 'Y';
	--v_underscoresuffixsize NUMBER;
	--v_underscoresuffix VARCHAR2(100);
  --v_sizebeforeprefix NUMBER;
BEGIN
  --v_underscoresuffix := '_' || TO_CHAR(p_suffix);
  --v_underscoresuffixsize := LENGTH(v_underscoresuffix);
  --v_sizebeforeprefix := 30 - v_underscoresuffixsize;
  v_transform_identifier := MIGRATION_TRANSFORMER.ADD_SUFFIX(p_new_identifier, '_' || TO_CHAR(p_suffix) ,30);
  
  IF p_scratchModel = FALSE
  THEN
     CASE p_derived_type
      WHEN C_OBJECTTYPE_CONNECTIONS THEN
        UPDATE MD_CONNECTIONS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_CATALOGS THEN
        UPDATE MD_CATALOGS SET CATALOG_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SCHEMAS THEN
        UPDATE MD_SCHEMAS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TABLES THEN
        UPDATE MD_TABLES SET TABLE_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_CONSTRAINTS THEN
        UPDATE MD_CONSTRAINTS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_INDEXES THEN
        UPDATE MD_INDEXES SET INDEX_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TRIGGERS THEN
        UPDATE MD_TRIGGERS SET TRIGGER_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_VIEWS THEN
        UPDATE MD_VIEWS SET VIEW_NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_USERS THEN
        UPDATE MD_USERS SET USERNAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_GROUPS THEN
        UPDATE MD_GROUPS SET GROUP_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_OTHER_OBJECTS THEN
        UPDATE MD_OTHER_OBJECTS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_TABLESPACES THEN
        UPDATE MD_TABLESPACES SET TABLESPACE_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_UDDT THEN
        UPDATE MD_USER_DEFINED_DATA_TYPES SET DATA_TYPE_NAME  = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_STORED_PROGRAMS THEN
        UPDATE MD_STORED_PROGRAMS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_PACKAGES THEN
        UPDATE MD_PACKAGES SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SYNONYMS THEN
        UPDATE MD_SYNONYMS SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      WHEN C_OBJECTTYPE_SEQUENCES THEN
        UPDATE MD_SEQUENCES SET NAME = v_transform_identifier WHERE ID = p_derived_id;
      ELSE
        -- Handle column namespace here.
        IF SUBSTR(P_DERIVED_TYPE,1, LENGTH(C_OBJECTTYPE_COLUMNS)) = C_OBJECTTYPE_COLUMNS THEN
          UPDATE MD_COLUMNS SET COLUMN_NAME = v_transform_identifier WHERE ID = p_derived_id;
        ELSE
          v_did_a_transform := 'N';
        END IF;
      END CASE;
  END IF; -- end if scratch model
  
	IF v_did_a_transform = 'Y' THEN
	  UPDATE MD_DERIVATIVES SET NEW_IDENTIFIER = v_transform_identifier WHERE ID = p_mdrec_id;
	  commit;
    END IF;
    commit;
END fixup_duplicate_identifier;

FUNCTION getClashCount(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN INTEGER 
IS
  v_clashCount INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_clashCount FROM md_derivatives a
    where rowid > (
      select min(rowid) from md_derivatives b
      where
        b.derived_connection_id_fk = p_connectionid
        AND b.derived_connection_id_fk = a.derived_connection_id_fk
        AND UPPER(b.new_identifier) = UPPER(a.new_identifier)--  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
        AND b.derived_object_namespace = a.derived_object_namespace);
  RETURN v_clashCount;
END getClashCount;

PROCEDURE transform_clashes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_scratchModel BOOLEAN := FALSE)
IS
  CURSOR v_curs IS
    select id,derived_type, derived_id, UPPER(new_identifier) --  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
    from md_derivatives a
    where rowid > (
      select min(rowid) from md_derivatives b
      where
        b.derived_connection_id_fk = p_connectionid
        AND b.derived_connection_id_fk = a.derived_connection_id_fk
        AND UPPER(b.new_identifier) = UPPER(a.new_identifier) --  Uppercasing the name so that case sensitve names are caught (see bug 6922052)
        AND b.derived_object_namespace = a.derived_object_namespace)
        ORDER BY new_identifier, derived_type;
  v_derived_type MD_DERIVATIVES.DERIVED_TYPE%TYPE;
  v_curr_type v_derived_type%TYPE := '~~dasdddfl;';
  v_derived_id MD_DERIVATIVES.DERIVED_ID%TYPE;
  v_new_identifier MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_curr_identifier v_new_identifier%TYPE := '~~~~asdasnc';
  v_suffix INTEGER := 0;
  v_innerSuffix INTEGER;
  v_clashCount INTEGER;
  v_mdrec_id MD_DERIVATIVES.ID%TYPE;
BEGIN

  rename_duplicate_index_names(p_connectionid, p_scratchModel);
  
  v_clashCount := getClashCount(p_connectionid);
  WHILE v_clashCount > 0 
  LOOP
	v_suffix := v_suffix + 1;
	v_innerSuffix := v_suffix; 
    -- Now lets see if there are any identifier clashes
    OPEN v_curs;
    LOOP 
      FETCH v_curs into v_mdrec_id, v_derived_type, v_derived_id, v_new_identifier;
      EXIT WHEN v_curs%NOTFOUND;
 	  IF v_derived_type = v_curr_type AND v_new_identifier = v_curr_identifier THEN
		  v_innerSuffix := v_innerSuffix + 1;
	  else
		  v_curr_type := v_derived_type;
		  v_curr_identifier := v_new_identifier;
	  END IF;
      -- We have to fix up all of these identifiers
      fixup_duplicate_identifier(p_connectionid, v_mdrec_id, v_derived_type, v_derived_id, v_new_identifier, v_innerSuffix, p_scratchModel);
    END LOOP;
	CLOSE v_curs;
    v_clashCount := getClashCount(p_connectionid);
  END LOOP;
END transform_clashes;

FUNCTION transform_all_identifiers_x(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                             p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY
IS
  v_count INTEGER := 0;
  v_ret NAME_AND_COUNT_ARRAY;
  v_rec NAME_AND_COUNT_T;
BEGIN
  v_ret := NAME_AND_COUNT_ARRAY();
  -- We need to update identifiers on pretty much the whole schema
  -- MD_COLUMNS
  v_rec := transform_column_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  
  -- MD_CONSTRAINTS
  v_rec := transform_constraint_idents(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_GROUPS
  v_rec := transform_group_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_INDEXES
  v_rec := transform_index_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_OTHER_OBJECTS
  v_rec := transform_othobj_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_PACKAGES
  v_rec := transform_package_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SCHEMAS
  v_rec := transform_schema_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SEQUENCES
  v_rec := transform_sequence_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_STORED_PROGRAMS
  v_rec := transform_sproc_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_SYNONYMS
  v_rec := transform_synonym_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TABLES
  v_rec := transform_table_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TABLESPACES
  v_rec := transform_tablespace_idents(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_TRIGGERS
  v_rec := transform_trigger_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_USER_DEFINED_DATA_TYPES
  v_rec := transform_uddt_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  -- MD_USERS
  v_rec := transform_user_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  /*
  UPDATE MD_USERS SET USERNAME = MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) WHERE SCHEMA_ID_FK IN
    (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionid)
    AND MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(USERNAME) != USERNAME;
  dbms_output.put_line(SQL%ROWCOUNT || ' USER names updated');
  */
  -- MD_VIEWS
  v_rec := transform_view_identifiers(p_connectionid, p_scratchModel);
  v_ret.EXTEND;
  v_ret(v_ret.count) := v_rec;
  dbms_output.put_line(v_rec.UPDATE_COUNT || v_rec.OBJECT_NAME || ' names udpates');
  transform_clashes(p_connectionid, p_scratchModel);
  -- TODO: Something meaningful if all goes wrong
  return v_ret;
  COMMIT;
END transform_all_identifiers_x;

FUNCTION transform_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE, p_prefixName VARCHAR2, p_scratchModel BOOLEAN := FALSE) RETURN NAME_AND_COUNT_ARRAY
IS
BEGIN
v_prefixName := p_prefixName;
RETURN  transform_all_identifiers_x(p_connectionid, p_scratchModel);
END transform_all_identifiers;

FUNCTION rule_specificity(p_precision MIGR_DATATYPE_TRANSFORM_RULE.SOURCE_PRECISION%TYPE, p_scale MIGR_DATATYPE_TRANSFORM_RULE.SOURCE_SCALE%TYPE) RETURN INTEGER
IS
BEGIN
  IF p_precision is NULL then 
    return 1;
  END IF;
  IF p_scale is NULL then
    return 2;
  END IF;
  return 3;
END rule_specificity;

FUNCTION addToWhereClause(p_whereclause VARCHAR2, p_toAdd VARCHAR2) return VARCHAR2
IS
BEGIN
  IF p_whereclause is NULL then
    return p_toAdd;
  else
    return p_whereclause || ' AND ' || p_toAdd;
  END IF;
END addToWhereClause;

FUNCTION precision_val(p_srcPrecision MD_COLUMNS.PRECISION%TYPE, p_newDataType VARCHAR2) RETURN VARCHAR2
IS
  v_newDataType VARCHAR2(255);
  v_ret VARCHAR2(255);
BEGIN
  v_newDataType := UPPER(to_char(p_newDataType));
  -- Assume that no precision should be present
  v_ret := 'NULL';
  -- No see what the new data type is and ensure that a precision is required
  IF v_newDataType = 'VARCHAR2' OR
     v_newDataType = 'NVARCHAR2' OR
     v_newDataType = 'NUMBER' OR
     v_newDataType = 'TIMESTAMP' OR
     v_newDataType = 'INTERVAL YEAR' OR
     v_newDataType = 'INTERVAL DAY' OR
     v_newDataType = 'UROWID' OR
     v_newDataType = 'CHAR' OR
     v_newDataType = 'RAW' OR
     v_newDataType = 'NCHAR' THEN
     v_ret := p_srcPrecision;
  END IF;
  return v_ret;
END precision_val;

FUNCTION scale_val(p_srcPrecision MD_COLUMNS.SCALE%TYPE, p_newDataType VARCHAR2) RETURN VARCHAR2
IS
  v_newDataType VARCHAR2(255);
  v_ret VARCHAR2(255);
BEGIN
  v_newDataType := UPPER(to_char(p_newDataType));
  v_ret := 'NULL';
  IF v_newDataType = 'NUMBER' THEN
    v_ret := p_srcPrecision;
  END IF;
  return v_ret;
END scale_val;

FUNCTION check_for_invalid_data_types(p_connectionid MD_CONNECTIONS.ID%TYPE, p_numbytesperchar INTEGER, p_is12c CHAR:= 'N') RETURN NUMBER
IS
    --make limits that vary in 12c variables
    v_limitVarchar2 MD_COLUMNS.PRECISION%TYPE :=4000;
    v_limitChar MD_COLUMNS.PRECISION%TYPE := 2000;
    v_limitNChar MD_COLUMNS.PRECISION%TYPE := 2000;
    v_limitNChar_2 MD_COLUMNS.PRECISION%TYPE := 1000;
    v_limitNVarchar2 MD_COLUMNS.PRECISION%TYPE := 4000;
    v_limitNVarchar2_2 MD_COLUMNS.PRECISION%TYPE := 2000;
    v_limitRaw MD_COLUMNS.PRECISION%TYPE := 2000;
BEGIN
    IF (p_is12c = 'Y') THEN
        v_limitVarchar2 :=32767;
        v_limitChar := 32767;
        v_limitNChar := 32767;
        v_limitNChar_2 := 16383;
        v_limitNVarchar2 := 32767;
        v_limitNVarchar2_2 := 16383;
        v_limitRaw := 32767;
    END IF;
    -- First, for char(n) columns, drop back to varchar2 - this could go up to 4k.
    -- If its even greater than this, it will be caught later on and made into a CLOB.
    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
        AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'CHAR' AND PRECISION > v_limitChar
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'VARCHAR2' WHERE COLUMN_TYPE = 'CHAR' AND PRECISION > v_limitChar
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- We'll do something similar for NCHARs
    IF p_numbytesperchar = 1 THEN
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > v_limitNChar 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NVARCHAR2' WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > v_limitNChar 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    ELSE   
        -- 2 bytes per char - max is actually 1k          
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > v_limitNChar_2 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NVARCHAR2' WHERE COLUMN_TYPE = 'NCHAR' AND PRECISION > v_limitNChar_2 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    END IF;            
    -- VARCHAR or VARCHAR2 can't go above 4000 (32767 in 12c).  If they do, they need to fallback to a CLOB
    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'VARCHAR' AND PRECISION > v_limitVarchar2 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'CLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'VARCHAR' AND PRECISION > v_limitVarchar2 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS  WHERE COLUMN_TYPE = 'VARCHAR2' AND PRECISION > v_limitVarchar2 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'CLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'VARCHAR2' AND PRECISION > v_limitVarchar2 
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- NUMBER has a max precision of 38, and scale must be between -84 and 127
    -- We can only narrow this.  

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND PRECISION > 38
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 38 WHERE COLUMN_TYPE = 'NUMBER' AND PRECISION > 38
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND SCALE < -84
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = -84 WHERE COLUMN_TYPE = 'NUMBER' AND SCALE < -84
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NUMBER' AND SCALE > 127
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = 127 WHERE COLUMN_TYPE = 'NUMBER' AND SCALE > 127
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- NVARCHAR has a max of 4000 (32767 in 12c) bytes.  But its definition depends on the character set in use.
    IF  p_numbytesperchar = 1 THEN
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > v_limitNVarchar2 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NCLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > v_limitNVarchar2 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    ELSE
        UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
          AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > v_limitNVarchar2_2 
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
        UPDATE MD_COLUMNS SET COLUMN_TYPE = 'NCLOB', PRECISION = NULL, SCALE = NULL WHERE COLUMN_TYPE = 'NVARCHAR2' AND PRECISION > v_limitNVarchar2_2
            AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    END IF;            
    -- TIMESTAMP has a max size of 9

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'TIMESTAMP' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'TIMESTAMP' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL YEAR' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'INTERVAL YEAR' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL DAY' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 9 WHERE COLUMN_TYPE = 'INTERVAL DAY' AND PRECISION > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'INTERVAL DAY' AND SCALE > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET SCALE = 9 WHERE COLUMN_TYPE = 'INTERVAL DAY' AND SCALE > 9
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'UROWID' AND PRECISION > 4000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET PRECISION = 4000 WHERE COLUMN_TYPE = 'UROWID' AND PRECISION > 4000
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    -- Too large RAW?  Make it a CLOB        

    UPDATE MD_DERIVATIVES SET DERIVATIVE_REASON = 'INVDTTYPE' WHERE DERIVED_CONNECTION_ID_FK = p_connectionid
      AND DERIVED_TYPE = 'MD_COLUMNS' AND DERIVED_ID IN (SELECT ID FROM MD_COLUMNS WHERE COLUMN_TYPE = 'RAW' AND PRECISION > v_limitRaw
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid));
    UPDATE MD_COLUMNS SET COLUMN_TYPE = 'BLOB', PRECISION = NULL WHERE COLUMN_TYPE = 'RAW' AND PRECISION > v_limitRaw
        AND TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionid);
    commit;
    RETURN 0;        
END check_for_invalid_data_types;

FUNCTION transform_datatypes(p_connectionid MD_CONNECTIONS.ID%TYPE, p_mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE, p_numbytesperchar INTEGER, p_is12c VARCHAR2 :=  'N') RETURN NUMBER
IS
  v_projectid MD_PROJECTS.ID%TYPE;
  v_mapProjectid MD_PROJECTS.ID%TYPE;
  CURSOR v_curs(mapid MIGR_DATATYPE_TRANSFORM_MAP.ID%TYPE) IS
    SELECT * FROM MIGR_DATATYPE_TRANSFORM_RULE WHERE map_ID_fk = mapid
    ORDER BY     DECODE(source_precision,
            NULL, 0,
            1) +
    DECODE(source_scale,
            NULL, 0,
            1)  DESC;
  v_rule MIGR_DATATYPE_TRANSFORM_RULE%ROWTYPE;
  v_whereClause VARCHAR2(4000);
  v_updateClause VARCHAR2(4000);
  v_count NUMBER := 0;
  v_ret NUMBER;
BEGIN
  -- We should only work with our "own" maps.  I.e. The map should be part of this project.
  SELECT project_id_fk into v_projectid from MD_CONNECTIONS where id = p_connectionid;
  SELECT project_id_fk into v_mapProjectid from MIGR_DATATYPE_TRANSFORM_MAP where id = p_mapid;
  IF v_projectid != v_mapProjectid then 
    -- TODO.  Some nice RAISE_APPLICATION_ERROR stuff here.
    return 0;
  END IF;
  -- OK We can work with our map
  OPEN v_curs(p_mapid);
  LOOP
    fetch v_curs INTO v_rule;
    EXIT WHEN v_curs%NOTFOUND;
    v_whereClause := 'UPPER(COLUMN_TYPE) = ''' || UPPER(v_rule.SOURCE_DATA_TYPE_NAME) || '''';
    if v_rule.SOURCE_PRECISION is not NULL then
      v_whereClause := addToWhereClause(v_whereClause, 'PRECISION = ' || to_char(v_rule.source_precision));
      IF v_rule.SOURCE_SCALE is not NULL then
        v_whereClause := addToWhereClause(v_whereClause, 'SCALE = ' || to_char(v_rule.source_scale));
      end IF;
    END IF;
    v_whereClause := addToWhereClause(v_whereClause, 'table_id_fk in (SELECT table_id from MGV_ALL_TABLES WHERE connection_id = ' || to_char(p_connectionid) || ')');
    v_whereClause := addTowhereclause(v_whereClause, 'DATATYPE_TRANSFORMED_FLAG IS NULL');
    v_updateClause := 'UPDATE MD_COLUMNS SET COLUMN_TYPE = ''' || v_rule.TARGET_DATA_TYPE_NAME || ''', DATATYPE_TRANSFORMED_FLAG=''Y''';
    IF v_rule.TARGET_PRECISION is not NULL then
      v_updateClause := v_updateClause || ', PRECISION = ' || precision_val(v_rule.TARGET_PRECISION, v_rule.TARGET_DATA_TYPE_NAME);
      IF v_rule.TARGET_SCALE is not NULL then
        -- The rule says change it to a specific scale, but we may override this is the data type shouldn't have a scale
        v_updateClause := v_updateClause || ', SCALE = ' || scale_val(v_rule.TARGET_SCALE, v_rule.TARGET_DATA_TYPE_NAME);
      ELSE
        -- There was no mention on the rule to touch the scale, so we should leave it alone...
        -- ..unless of course the data type forbids having it.
        IF scale_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
          v_updateClause := v_updateClause || ', SCALE = NULL';
        END IF;
      END IF;
    ELSE
      -- There was no metion on the rul to touch the precision, so we should leave it alone...
      -- ..unless of course the data type forbids having it.
      IF precision_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
        v_updateClause := v_updateClause || ', PRECISION = NULL';
      END IF;
      IF scale_val(1, v_rule.TARGET_DATA_TYPE_NAME) = 'NULL' THEN
        v_updateClause := v_updateClause || ', SCALE = NULL';
      END IF;
    END IF;
    v_updateClause := v_updateClause || ' WHERE ' || v_whereClause;
    dbms_output.put_line(v_updateClause);
    EXECUTE IMMEDIATE v_updateClause;
    v_count := v_count + SQL%ROWCOUNT;
  END LOOP;
  CLOSE v_curs;
  COMMIT;
  -- OK.  Lets see if we've made any columns invalid.
  v_ret := check_for_invalid_data_types(p_connectionid, p_numbytesperchar, p_is12c);  
  -- Now that we know the data types of the index columns, we may have flag some of the indexes
  -- as text indexes.
  v_ret := fixupTextIndexes(p_connectionid);

  RETURN v_count;
END transform_datatypes;

FUNCTION GET_SIMPLE_IDENTITY_TRIGGER(v_triggerName VARCHAR2 , v_tableName VARCHAR2  , 
v_ColumnName VARCHAR2,v_emulationPkgNamePrefix VARCHAR2 ) RETURN VARCHAR2
as
 v_identityClause VARCHAR2(200);
BEGIN

IF v_emulationpkgnameprefix = 'mysql_utilities.' THEN
  v_identityclause := '  --used to emulate LAST_INSERT_ID()'|| chr(10) || '  --'||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
ELSE
  v_identityclause := '  -- save this to emulate @@identity'|| chr(10) || '  '||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
END IF;
       
return 'CREATE OR REPLACE TRIGGER ' || v_triggerName || ' AFTER INSERT ON ' || v_tableName || CHR(10) ||
       'FOR EACH ROW' || CHR(10) ||
       'DECLARE ' || CHR(10)||
       'v_newVal NUMBER(12) := 0;' ||CHR(10) ||
       'BEGIN' || CHR(10) ||
       '  v_newVal := :new.' || v_ColumnName || ';' || CHR(10) ||
       v_identityClause
      ||
       'END;' || CHR(10);
END GET_SIMPLE_IDENTITY_TRIGGER;

FUNCTION GET_IDENTITY_TRIGGER(v_triggerName VARCHAR2 , v_tableName VARCHAR2  , 
v_ColumnName VARCHAR2  ,v_seqName VARCHAR2 ,v_emulationPkgNamePrefix VARCHAR2 ) RETURN VARCHAR2
as
 v_identityClause VARCHAR2(200);
BEGIN

IF v_emulationpkgnameprefix = 'mysql_utilities.' THEN
  v_identityclause := '    --used to emulate LAST_INSERT_ID()'|| chr(10) || '    --'||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
ELSE
  v_identityclause := '    -- save this to emulate @@identity'|| chr(10) || '   '||v_emulationpkgnameprefix || 'identity := v_newVal; '|| chr(10) ;
END IF;
       
return 'CREATE OR REPLACE TRIGGER ' || v_triggerName || ' BEFORE INSERT ON ' || v_tableName || CHR(10) ||
       'FOR EACH ROW' || CHR(10) ||
       'DECLARE ' || CHR(10)||
       'v_newVal NUMBER(12) := 0;' ||CHR(10) ||
	   'v_incval NUMBER(12) := 0;'||CHR(10) ||
       'BEGIN' || CHR(10) ||
       '  IF INSERTING AND :new.' || v_ColumnName || ' IS NULL THEN' || CHR(10) ||
       '    SELECT  ' || v_seqName || '.NEXTVAL INTO v_newVal FROM DUAL;' || CHR(10) ||
	   '    -- If this is the first time this table have been inserted into (sequence == 1)' || CHR(10) ||
	   '    IF v_newVal = 1 THEN ' || CHR(10) ||
	   '      --get the max indentity value from the table' || CHR(10) ||
	   '      SELECT NVL(max(' || v_ColumnName || '),0) INTO v_newVal FROM ' || v_tableName || ';'|| CHR(10) || 
	   '      v_newVal := v_newVal + 1;' || CHR(10) || 
	   '      --set the sequence to that value'|| CHR(10) || 
	   '      LOOP'|| CHR(10) || 
	   '           EXIT WHEN v_incval>=v_newVal;'|| CHR(10) || 
	   '           SELECT ' || v_seqName || '.nextval INTO v_incval FROM dual;'|| CHR(10) || 
       '      END LOOP;'|| CHR(10) || 
       '    END IF;'|| chr(10) ||    
       v_identityClause
      ||
       '   -- assign the value from the sequence to emulate the identity column'|| CHR(10) || 
       '   :new.' || v_ColumnName || ' := v_newVal;'|| CHR(10) || 
       '  END IF;' || CHR(10) ||
       'END;' || CHR(10);
END GET_IDENTITY_TRIGGER;

FUNCTION get_plugin_name(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN VARCHAR2
IS
  CURSOR v_pluginNameCur IS SELECT value FROM MD_ADDITIONAL_PROPERTIES WHERE prop_key='PLUGIN_ID' AND connection_id_fk = p_connectionid;
  v_pluginName MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
  BEGIN
	  OPEN v_pluginNameCur;
	  FETCH v_pluginNameCur INTO v_pluginName;
	  CLOSE v_pluginNameCur;
	  RETURN v_pluginName;
END get_plugin_name;	  
	  
FUNCTION get_emulation_pkg_name(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN VARCHAR2
AS
v_pkgName VARCHAR2(1000);
v_pluginName MD_ADDITIONAL_PROPERTIES.VALUE%TYPE;
BEGIN
	v_pluginName := get_plugin_name(p_connectionid);
	IF LOWER(v_pluginName) LIKE '%sqlserver%'THEN
	  	v_pkgName := 'utils.';
	  ELSIF LOWER(v_pluginName) LIKE '%access%'THEN
	    v_pkgName := 'msaccess_utilities.';
	  ELSIF LOWER(v_pluginName) LIKE '%sybase%'THEN
	    v_pkgName := 'utils.';
	  ELSIF LOWER(v_pluginName) LIKE '%mysql%' THEN
	    v_pkgName := 'mysql_utilities.';
	  ELSIF LOWER(v_pluginName) LIKE '%db2%' THEN
	    v_pkgName := 'db2_utilities.';
	END IF;
  RETURN v_pkgName;
END get_emulation_pkg_name;

FUNCTION transform_identity_columns(p_connectionid MD_CONNECTIONS.ID%TYPE, p_is12c VARCHAR2 := 'N') RETURN NUMBER
IS
  CURSOR v_curs IS SELECT a.schema_id_fk, a.id tableid, a.TABLE_NAME, b.id, b.column_name, b.NULLABLE
                   FROM md_tables a, md_columns b WHERE b.id IN
                     (SELECT ref_id_fk FROM md_additional_properties WHERE prop_key = C_PROPKEY_SEEDVALUE)
                   AND table_id_fk IN (SELECT table_id FROM mgv_all_tables WHERE connection_id = p_connectionid)
                   AND a.id = b.table_id_fk
                   AND b.id NOT IN (SELECT SRC_ID FROM MD_DERIVATIVES WHERE SRC_TYPE = C_OBJECTTYPE_COLUMNS AND DERIVED_TYPE = C_OBJECTTYPE_SEQUENCES AND 
                                    DERIVED_CONNECTION_ID_FK = p_connectionid);  
  	v_schemaId MD_SCHEMAS.ID%TYPE;
	v_tableId MD_TABLES.ID%TYPE;
        v_tableName MD_TABLES.TABLE_NAME%TYPE;
	v_columnId MD_COLUMNS.ID%TYPE;
	v_columnName MD_COLUMNS.COLUMN_NAME%TYPE;
	v_row MD_ADDITIONAL_PROPERTIES%ROWTYPE;
	v_seedValue NUMBER;
	-- Default the increment to 1 if it is not supplied.
	v_increment NUMBER := 1;
	v_lastVal NUMBER := NULL;
	v_retId MD_SEQUENCES.ID%TYPE;
	v_retSeqId MD_SEQUENCES.ID%TYPE;
	v_seqName MD_SEQUENCES.NAME%TYPE;
        v_trgName MD_TRIGGERS.TRIGGER_NAME%TYPE;
	v_triggerText VARCHAR2(4000);
        v_lob CLOB;
	v_transRet NAME_AND_COUNT_T;
	v_dbTypeCurs VARCHAR2(1000);
	v_emulationPkgNamePrefix VARCHAR2(100) := '';
	v_nullable MD_COLUMNS.NULLABLE%TYPE;
    v_alreadyDone NUMBER;
    v_continueTriggered BOOLEAN := FALSE;
BEGIN
  -- Auxillary, get the emulation package name
  v_emulationPkgNamePrefix := get_emulation_pkg_name(p_connectionid);
  
  OPEN v_curs;
  LOOP
    v_continueTriggered := FALSE;
  	FETCH v_curs into v_schemaId, v_tableId, v_tableName, v_columnId, v_columnName, v_nullable;
  	EXIT WHEN v_curs%NOTFOUND;
  	-- The above query excludes already created sequences, so we should be ok.
  	-- create the sequence:
  	-- 1. Get the seedvalue, increment, lastvalue if present
    v_alreadyDone := 0;
    BEGIN
      IF (p_is12c = 'Y') THEN
        SELECT 1 INTO  v_alreadyDone FROM MD_ADDITIONAL_PROPERTIES
        WHERE CONNECTION_ID_FK = p_connectionid 
        AND REF_ID_FK = v_tableId 
        AND REF_TYPE = C_OBJECTTYPE_TABLES 
        AND PROP_KEY = C_PROPKEY_ALREADY_IDENTITY;
      ELSE
        v_alreadyDone:=0;
      END IF;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN v_alreadyDone :=0;
    END;

    IF (v_nullable = 'N' AND p_is12c = 'Y' AND v_alreadyDone != 1) THEN
      INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
      VALUES (p_connectionid, v_columnId, C_OBJECTTYPE_COLUMNS, C_PROPKEY_REAL_IDENTITY, 'GENERATED BY DEFAULT ON NULL AS IDENTITY');
      INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
      VALUES (p_connectionid, v_tableId, C_OBJECTTYPE_TABLES, C_PROPKEY_ALREADY_IDENTITY, '');
      v_continueTriggered:=TRUE;
      --DONE do it in create table/ enable - 
      --ISSUES: DONE can be ascending or decending 
      --        DONE top (bottom) value has to be set at end (along with enable constraints)
      --ISSUE   If no entries sequence next val will be 0+increment - there was some work by Indian integrator to recapture current sequence,
      --            if capture convert generate is not done at the same time, or the sequence is otherwise above max/min value.
  	END IF;
  	if (v_continueTriggered = TRUE) THEN /* need simple trigger to fill @@identity */
      v_trgName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_tableName || '_' || v_columnName || '_TRG');
      v_triggerText := GET_SIMPLE_IDENTITY_TRIGGER(v_trgName, v_tableName , v_ColumnName ,v_emulationPkgNamePrefix);
      -- Note: I'm adding _TRG to the column name for now.We'll have to use the collsion manager in the futre.
  	  INSERT INTO MD_TRIGGERS(TABLE_OR_VIEW_ID_FK, TRIGGER_ON_FLAG, TRIGGER_NAME, TRIGGER_TIMING, TRIGGER_OPERATION, NATIVE_SQL, LANGUAGE)
      VALUES(v_tableId, 'T', v_trgName, 'AFTER', 'INSERT OR UPDATE', EMPTY_CLOB(), C_LANGUAGEID_ORACLE)
      RETURNING ID INTO v_retId;
      INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
        VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_TRIGGER_REWRITE, '');
      --INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
      --  VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_SEQUENCEID, TO_CHAR(v_retSeqId));  
      INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
        VALUES(v_columnId, C_OBJECTTYPE_COLUMNS, v_retId, C_OBJECTTYPE_TRIGGERS, p_connectionId, C_TRANSFORMED_TRUE, NULL, v_trgName, C_NS_SCHEMA_OBJS || TO_CHAR(v_schemaId));
      SELECT NATIVE_SQL INTO v_lob FROM MD_TRIGGERS WHERE ID = v_retId;          
        DBMS_LOB.OPEN(v_lob, DBMS_LOB.LOB_READWRITE);
        DBMS_LOB.WRITE(v_lob, LENGTH(v_triggerText), 1, v_triggerText);
        DBMS_LOB.CLOSE(v_lob);
  	ELSE
  	 FOR v_row in (SELECT * FROM MD_ADDITIONAL_PROPERTIES WHERE REF_ID_FK = v_columnId)
  	LOOP
  	  IF v_row.PROP_KEY = C_PROPKEY_SEEDVALUE THEN
  	    v_seedValue := TO_NUMBER(v_row.VALUE);
          END IF;
  	  IF v_row.PROP_KEY = C_PROPKEY_INCREMENT THEN
  	    v_increment := TO_NUMBER(v_row.VALUE);
          END IF;
  	  IF v_row.PROP_KEY = C_PROPKEY_LASTVALUE THEN
  	    v_lastVal := TO_NUMBER(v_row.VALUE);
  	  END IF;
  	END LOOP;
  	-- Note: We'll start our sequence where the source left off.
  	IF v_lastVal IS NOT NULL THEN
  	  v_seedValue := v_lastVal;
  	END IF;
      
  	-- 2. Create the sequence
  	-- Note: I'm adding _SEQ to the column name for now. We'll have to use the collision manager in the
  	-- future.
  	v_seqName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_tableName || '_' || v_columnName || '_SEQ');
  	INSERT INTO MD_SEQUENCES(SCHEMA_ID_FK, NAME, SEQ_START, INCR)
  	  VALUES (v_schemaId, v_seqName, v_seedValue, v_increment)
  	  RETURNING ID INTO v_retId;
  	v_retSeqId := v_retId;
  	-- And of course a new derivative record
  	INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
  	  VALUES(v_columnId, C_OBJECTTYPE_COLUMNS, v_retId, C_OBJECTTYPE_SEQUENCES, p_connectionId, C_TRANSFORMED_TRUE, NULL, v_seqName, C_NS_SCHEMA_OBJS || TO_CHAR(v_schemaId));
  	-- Create the trigger
        v_trgName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_tableName || '_' || v_columnName || '_TRG');
  	v_triggerText := GET_IDENTITY_TRIGGER(v_trgName, v_tableName , v_ColumnName ,v_seqName ,v_emulationPkgNamePrefix);
  	-- Note: I'm adding _TRG to the column name for now.We'll have to use the collsion manager in the futre.
  	INSERT INTO MD_TRIGGERS(TABLE_OR_VIEW_ID_FK, TRIGGER_ON_FLAG, TRIGGER_NAME, TRIGGER_TIMING, TRIGGER_OPERATION, NATIVE_SQL, LANGUAGE)
  	  VALUES(v_tableId, 'T', v_trgName, 'BEFORE', 'INSERT OR UPDATE', EMPTY_CLOB(), C_LANGUAGEID_ORACLE)
  	  RETURNING ID INTO v_retId;
  	INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
       VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_TRIGGER_REWRITE, '');
    INSERT INTO MD_ADDITIONAL_PROPERTIES ( CONNECTION_ID_FK, REF_ID_FK, REF_TYPE, PROP_KEY, VALUE )
       VALUES (p_connectionid, v_retId, C_OBJECTTYPE_TRIGGERS, C_PROPKEY_SEQUENCEID, TO_CHAR(v_retSeqId));	
  	INSERT INTO MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED, ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE)
  	  VALUES(v_columnId, C_OBJECTTYPE_COLUMNS, v_retId, C_OBJECTTYPE_TRIGGERS, p_connectionId, C_TRANSFORMED_TRUE, NULL, v_trgName, C_NS_SCHEMA_OBJS || TO_CHAR(v_schemaId));
        SELECT NATIVE_SQL INTO v_lob FROM MD_TRIGGERS WHERE ID = v_retId;          
        DBMS_LOB.OPEN(v_lob, DBMS_LOB.LOB_READWRITE);
        DBMS_LOB.WRITE(v_lob, LENGTH(v_triggerText), 1, v_triggerText);
        DBMS_LOB.CLOSE(v_lob);
    END IF;
  END LOOP;
  COMMIT;
  CLOSE v_curs;
  RETURN 0;
END transform_identity_columns;




FUNCTION transform_rewrite_trigger(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  CURSOR v_curs is SELECT ID, TABLE_OR_VIEW_ID_FK, TRIGGER_ON_FLAG, TRIGGER_NAME,
    TRIGGER_TIMING, TRIGGER_OPERATION, TRIGGER_EVENT, NATIVE_SQL, NATIVE_KEY,
    LANGUAGE, COMMENTS from MD_TRIGGERS where ID in
    (SELECT REF_ID_FK from MD_ADDITIONAL_PROPERTIES
    WHERE CONNECTION_ID_FK = p_connectionid and PROP_KEY = C_PROPKEY_TRIGGER_REWRITE);
  
  v_rowTriggers MD_TRIGGERS%ROWTYPE;
  v_tableName MD_TABLES.TABLE_NAME%TYPE;
	v_columnName MD_COLUMNS.COLUMN_NAME%TYPE;
	v_retId MD_SEQUENCES.ID%TYPE;
  v_retSeqId MD_SEQUENCES.ID%TYPE;
	v_seqName MD_SEQUENCES.NAME%TYPE;
  v_seqName2 MD_SEQUENCES.NAME%TYPE;
	v_triggerText VARCHAR2(4000);
  v_lob CLOB;
  v_projectName VARCHAR2(100);
  v_emulationPkgNamePrefix VARCHAR2(100) := '';
BEGIN
  -- Auxillary, get the emulation package name
  v_emulationPkgNamePrefix := get_emulation_pkg_name(p_connectionid);
  
  open v_curs;
  loop
    fetch v_curs into v_rowTriggers.ID, v_rowTriggers.TABLE_OR_VIEW_ID_FK, v_rowTriggers.TRIGGER_ON_FLAG, v_rowTriggers.TRIGGER_NAME,
    v_rowTriggers.TRIGGER_TIMING, v_rowTriggers.TRIGGER_OPERATION, v_rowTriggers.TRIGGER_EVENT, v_rowTriggers.NATIVE_SQL, v_rowTriggers.NATIVE_KEY,
    v_rowTriggers.LANGUAGE, v_rowTriggers.COMMENTS ;
    EXIT WHEN v_curs%NOTFOUND;
    update MD_TRIGGERS set native_sql = empty_clob() where id = v_rowTriggers.ID;

    -- get table and column name from the derivative of this trigger
    select T.TABLE_NAME, C.COLUMN_NAME into v_tableName, v_columnName from MD_TABLES T,
      MD_COLUMNS C where C.TABLE_ID_FK = T.ID and C.ID =
      (select SRC_ID from MD_DERIVATIVES where DERIVED_ID =  v_rowTriggers.ID and SRC_TYPE =
      C_OBJECTTYPE_COLUMNS and DERIVED_CONNECTION_ID_FK = p_connectionid);
    -- get sequence name from id got from additional property
    BEGIN
      select s.NAME into v_seqName from MD_SEQUENCES s where s.ID =
        (select TO_NUMBER(VALUE) from MD_ADDITIONAL_PROPERTIES where CONNECTION_ID_FK = p_connectionid
        AND REF_ID_FK = v_rowTriggers.ID and PROP_KEY = C_PROPKEY_SEQUENCEID);
      v_triggerText := GET_IDENTITY_TRIGGER(v_rowTriggers.TRIGGER_NAME, v_tableName , v_ColumnName ,v_seqName ,v_emulationPkgNamePrefix);
    EXCEPTION WHEN NO_DATA_FOUND THEN
      --no sequence known (its 12 c identity)
      v_triggerText := GET_SIMPLE_IDENTITY_TRIGGER(v_rowTriggers.TRIGGER_NAME, v_tableName , v_ColumnName ,v_emulationPkgNamePrefix);
    END;
    SELECT NATIVE_SQL INTO v_lob FROM MD_TRIGGERS WHERE ID = v_rowTriggers.ID;          
    DBMS_LOB.OPEN(v_lob, DBMS_LOB.LOB_READWRITE);
    DBMS_LOB.WRITE(v_lob, LENGTH(v_triggerText), 1, v_triggerText);
    DBMS_LOB.CLOSE(v_lob);
  END LOOP;
  COMMIT;
  CLOSE v_curs;
  return 0;
END transform_rewrite_trigger;

PROCEDURE RefreshLineCountViews(p_connectionId MD_CONNECTIONS.ID%TYPE DEFAULT NULL)
IS
BEGIN
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_stored_programs s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1
	 	WHERE linecount IS NULL;
	 	
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_views s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1
	 	WHERE linecount IS NULL;
	 	
	 	UPDATE (select s.*, ltrim(rtrim(s.native_sql,' ' ||'  '|| chr(10)||chr(13)),' ' ||'  '|| chr(10)||chr(13)) trimmed from md_triggers s)  x
	 	SET LINECOUNT = LENGTH(trimmed) -  LENGTH(replace(trimmed,chr(10))) +1 
	 	WHERE linecount IS NULL;
END;

FUNCTION gatherConnectionStats(p_connectionId MD_CONNECTIONS.ID%TYPE,p_comments MD_CONNECTIONS.COMMENTS%TYPE) RETURN NUMBER
IS
	v_numCatalogs INTEGER := 0;
	v_numColumns INTEGER := 0;
	v_numConstraints INTEGER := 0;
	v_numGroups INTEGER := 0;
	v_numRoles INTEGER := 0;
	v_numIndexes INTEGER := 0;
	v_numOtherObjects INTEGER := 0;
	v_numPackages INTEGER := 0;
	v_numPrivileges INTEGER := 0;
	v_numSchemas INTEGER := 0;
	v_numSequences INTEGER := 0;
	v_numStoredPrograms INTEGER := 0;
	v_numSynonyms INTEGER := 0;
	v_numTables INTEGER := 0;
	v_numTableSpaces INTEGER := 0;
	v_numTriggers INTEGER := 0;
	v_numUserDefinedDataTypes INTEGER := 0;
	v_numUsers INTEGER := 0;
	v_numViews INTEGER := 0;
BEGIN
	SELECT COUNT(*) INTO v_numCatalogs FROM MD_CATALOGS  WHERE CONNECTION_ID_FK = p_connectionId;
	SELECT COUNT(*) INTO v_numColumns FROM MD_COLUMNS WHERE TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numConstraints FROM MD_CONSTRAINTS WHERE  TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numGroups FROM MD_GROUPS WHERE GROUP_FLAG = 'G' AND SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId); 
	SELECT COUNT(*) INTO v_numRoles FROM MD_GROUPS WHERE GROUP_FLAG = 'R' AND SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numIndexes FROM MD_INDEXES  WHERE TABLE_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numOtherObjects FROM MD_OTHER_OBJECTS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numPackages FROM MD_PACKAGES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);  
	SELECT COUNT(*) INTO v_numPrivileges FROM MD_PRIVILEGES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSchemas FROM MD_SCHEMAS WHERE CATALOG_ID_FK IN (SELECT CATALOG_ID FROM MGV_ALL_CATALOGS WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSequences FROM MD_SEQUENCES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numStoredPrograms FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numSynonyms FROM MD_SYNONYMS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTables FROM MD_TABLES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTableSpaces FROM MD_TABLESPACES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numTriggers FROM MD_TRIGGERS WHERE TABLE_OR_VIEW_ID_FK IN (SELECT TABLE_ID FROM MGV_ALL_TABLES WHERE CONNECTION_ID = p_connectionId
                                                                                          UNION SELECT VIEW_ID FROM MGV_ALL_VIEWS WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numUserDefinedDataTypes FROM MD_USER_DEFINED_DATA_TYPES WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numUsers FROM MD_USERS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
	SELECT COUNT(*) INTO v_numViews FROM MD_VIEWS WHERE SCHEMA_ID_FK IN (SELECT SCHEMA_ID FROM MGV_ALL_SCHEMA WHERE CONNECTION_ID = p_connectionId);
  	UPDATE MD_CONNECTIONS SET  
		NUM_CATALOGS = v_numCatalogs,
		NUM_COLUMNS = v_numColumns,
		NUM_CONSTRAINTS = v_numConstraints,
		NUM_GROUPS = v_numGroups,
		NUM_ROLES = v_numRoles,
		NUM_INDEXES = v_numIndexes,
		NUM_OTHER_OBJECTS = v_numOtherObjects,
		NUM_PACKAGES = v_numPackages,
		NUM_PRIVILEGES = v_numPrivileges,
		NUM_SCHEMAS = v_numSchemas,
		NUM_SEQUENCES = v_numSequences,
		NUM_STORED_PROGRAMS = v_numStoredPrograms,
		NUM_SYNONYMS = v_numSynonyms,
		NUM_TABLES = v_numTables,
		NUM_TABLESPACES = v_numTableSpaces,
		NUM_TRIGGERS = v_numTriggers,
		NUM_USER_DEFINED_DATA_TYPES = v_numUserDefinedDataTypes,
		num_users = v_numusers,
        num_views = v_numviews,
        COMMENTS = COMMENTS || p_comments    
	WHERE ID = p_connectionId;
	COMMIT;
    RefreshLineCountViews(p_connectionId);
	COMMIT;
	RETURN 0;
END gatherConnectionStats;

--
-- Procedures that start with "insert_*" insert a copy of MD_* values into MD_DERIVATIVES table.
-- MD_* are MD_COLUMNS, MD_CONSTRAINTS, MD_TABLES, MD_TRIGGERS, MD_INDEXES, MD_SEQUENCES, MD_STORED_PROGRAMS 
-- AND MD_VIEWS
--
PROCEDURE insert_all_columns(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_COLUMNS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_COLUMNS WHERE TABLE_ID_FK = ' || p_tableid;
  v_newName MD_COLUMNS.COLUMN_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.COLUMN_NAME);
    if v_row.COLUMN_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_COLUMNS, v_row.id, C_OBJECTTYPE_COLUMNS, p_connectionid, v_transformed,
                  v_row.COLUMN_NAME, v_newName, C_OBJECTTYPE_COLUMNS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_columns;

PROCEDURE insert_all_indexes(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_INDEXES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_INDEXES WHERE MD_INDEXES.TABLE_ID_FK = ' || p_tableid;
  v_newName MD_INDEXES.INDEX_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.INDEX_NAME);
    if v_row.INDEX_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_INDEXES, v_row.id, C_OBJECTTYPE_INDEXES, p_connectionid, v_transformed,
                  v_row.INDEX_NAME, v_newName, C_OBJECTTYPE_INDEXES || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_indexes;

PROCEDURE insert_all_table_triggers(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                     p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_TRIGGERS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = ' || p_tableid;
  v_newName MD_TRIGGERS.TRIGGER_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.TRIGGER_NAME);
    if v_row.TRIGGER_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_TRIGGERS, v_row.id, C_OBJECTTYPE_TRIGGERS, p_connectionid, v_transformed,
                  v_row.TRIGGER_NAME, v_newName, C_NS_DB_TRIGGERS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_table_triggers;

PROCEDURE insert_all_constraints(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                 p_tableid MD_TABLES.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_CONSTRAINTS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_CONSTRAINTS WHERE MD_CONSTRAINTS.TABLE_ID_FK = ' || p_tableid;
  v_newName MD_CONSTRAINTS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_CONSTRAINTS, v_row.id, C_OBJECTTYPE_CONSTRAINTS, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_CONSTRAINTS || TO_CHAR(p_tableid), C_CONNECTIONTYPE_SCRATCH);
    
  END LOOP;
  close cv_curs;
END insert_all_constraints;


PROCEDURE insert_all_tables_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_TABLES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_TABLES where SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_TABLES.TABLE_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.TABLE_NAME);
    if v_row.TABLE_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_TABLES, v_row.id, C_OBJECTTYPE_TABLES, p_connectionid, v_transformed,
                  v_row.TABLE_NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
                  
     insert_all_columns(p_connectionid, v_row.id);
     insert_all_indexes(p_connectionid, v_row.id);
     insert_all_table_triggers(p_connectionid, v_row.id);
     insert_all_constraints(p_connectionid, v_row.id);
     
  END LOOP;
  close cv_curs;	
END insert_all_tables_cascade;

PROCEDURE insert_all_views(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_VIEWS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_VIEWS WHERE SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_VIEWS.VIEW_NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.VIEW_NAME);
    if v_row.VIEW_NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_VIEWS, v_row.id, C_OBJECTTYPE_VIEWS, p_connectionid, v_transformed,
                  v_row.VIEW_NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_views;

PROCEDURE insert_all_sequences(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_SEQUENCES%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_SEQUENCES WHERE SCHEMA_ID_FK = ' || p_schemaid;
  v_newName MD_SEQUENCES.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_SEQUENCES, v_row.id, C_OBJECTTYPE_SEQUENCES, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_sequences;

PROCEDURE insert_all_unpackaged_sps(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                    p_schemaid MD_SCHEMAS.ID%TYPE)
IS
  cv_curs REF_CURSOR;
  v_row MD_STORED_PROGRAMS%ROWTYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_STORED_PROGRAMS WHERE SCHEMA_ID_FK = ' || p_schemaid || ' AND PACKAGE_ID_FK IS NULL';
  v_newName MD_STORED_PROGRAMS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;

BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.NAME);
    if v_row.NAME <> v_newName then
       v_transformed := C_TRANSFORMED_TRUE;
    end if;
    
    INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_row.id, C_OBJECTTYPE_STORED_PROGRAMS, v_row.id, C_OBJECTTYPE_STORED_PROGRAMS, p_connectionid, v_transformed,
                  v_row.NAME, v_newName, C_NS_SCHEMA_OBJS || TO_CHAR(p_schemaid), C_CONNECTIONTYPE_SCRATCH);
     
  END LOOP;
  close cv_curs;	
END insert_all_unpackaged_sps;


PROCEDURE insert_all_schobjs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                            p_schemaid MD_SCHEMAS.ID%TYPE)
IS 
BEGIN
  insert_all_tables_cascade(p_connectionid, p_schemaid);
  insert_all_views(p_connectionid, p_schemaid);
  insert_all_sequences(p_connectionid, p_schemaid);
  insert_all_unpackaged_sps(p_connectionid, p_schemaid);
END insert_all_schobjs_cascade;	  
                                              

PROCEDURE insert_catalogs_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE,
                                  p_catalogid MD_CATALOGS.ID%TYPE)
IS
  cv_curs REF_CURSOR; 
  v_selectStmt VARCHAR2(4000) := 'SELECT a.id schema_id, A.name schema_name, b.id catalog_id, B.CATALOG_NAME, B.DUMMY_FLAG, A.type, A.character_set, A.version_tag 
      FROM MD_SCHEMAS A, MD_CATALOGS B
      WHERE 
      	A.CATALOG_ID_FK = B.ID 
        AND B.ID =' || p_catalogid  || 
        ' AND CONNECTION_ID_FK = ' || p_connectionid ;
  v_derivedRec  DERIVATIVE_REC;
  v_newName MD_SCHEMAS.NAME%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
BEGIN
   OPEN cv_curs FOR v_selectStmt;
   LOOP
     FETCH cv_curs INTO v_derivedRec;
     EXIT WHEN cv_curs%NOTFOUND;
     
     if v_derivedRec.dummy_flag  <> C_DUMMYFLAG_TRUE then
        v_newName := v_derivedRec.schema_name || '_' || v_derivedRec.catalog_name;
        v_transformed := C_TRANSFORMED_TRUE;
     else
	    v_newName := v_derivedRec.schema_name;
     end if;
     
     if v_newName <> MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName) then
        v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName);
        v_transformed := C_TRANSFORMED_TRUE;
     end if;
     
     INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES (v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, v_derivedRec.schema_id, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_transformed,
                  v_derivedRec.schema_name, v_newName, C_NS_DATABASE, C_CONNECTIONTYPE_SCRATCH);
     
     INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                  ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_derivedRec.catalog_id, C_OBJECTTYPE_CATALOGS, v_derivedRec.catalog_id, C_OBJECTTYPE_SCHEMAS, p_connectionid, v_transformed, 
                  v_derivedRec.catalog_name, v_newName, NULL, C_CONNECTIONTYPE_SCRATCH);
      
     insert_all_schobjs_cascade(p_connectionid, v_derivedRec.schema_id);
     
   END LOOP;
   close cv_curs;
END insert_catalogs_cascade;


PROCEDURE insert_connection_cascade(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
  v_connectionsRow MD_CONNECTIONS%ROWTYPE;
  v_origName MD_CONNECTIONS.NAME%TYPE;
  v_newName MD_CONNECTIONS.NAME%TYPE;
  v_id MD_CONNECTIONS.ID%TYPE;
  v_catid MD_CATALOGS.ID%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE := NULL;
  cv_curs REF_CURSOR;
    
BEGIN
  SELECT * INTO v_connectionsRow from MD_CONNECTIONS WHERE "ID" = p_connectionid;
      v_origName := v_connectionsRow.NAME;
      v_newName := v_origName;
      v_id := v_connectionsRow.ID;
      
      if v_newName <> MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName) then
        v_newName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_newName);
        v_transformed := C_TRANSFORMED_TRUE;
      end if;
      
      INSERT INTO 
          MD_DERIVATIVES(SRC_ID, SRC_TYPE, DERIVED_ID, DERIVED_TYPE, DERIVED_CONNECTION_ID_FK, TRANSFORMED,
                      ORIGINAL_IDENTIFIER, NEW_IDENTIFIER, DERIVED_OBJECT_NAMESPACE, DERIVATIVE_REASON)
          VALUES(v_id , C_OBJECTTYPE_CONNECTIONS, v_id, C_OBJECTTYPE_CONNECTIONS, v_id, v_transformed, 
                      v_origName, v_newName, '', C_CONNECTIONTYPE_SCRATCH);
  
  OPEN cv_curs FOR 'SELECT id from MD_CATALOGS where connection_id_fk ='|| v_connectionsRow.id;
  LOOP
    FETCH cv_curs INTO v_catid;
    EXIT WHEN cv_curs%NOTFOUND;
                       
      insert_catalogs_cascade(v_id, v_catid);
   END LOOP;   
END insert_connection_cascade;

PROCEDURE populate_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
BEGIN
  insert_connection_cascade(p_connectionid);
END populate_derivatives_table;

--
-- reverts NEW_IDENTIFIER values back to their default(derived) values in MD_DERIVATIVES table.
--
PROCEDURE revert_derivatives_table(p_connectionid MD_CONNECTIONS.ID%TYPE)
IS
  cv_curs REF_CURSOR;  
  v_row MD_DERIVATIVES%ROWTYPE;
  v_origName MD_DERIVATIVES.ORIGINAL_IDENTIFIER%TYPE;
  v_derivedName MD_DERIVATIVES.NEW_IDENTIFIER%TYPE;
  v_transformed MD_DERIVATIVES.TRANSFORMED%TYPE;
  v_selectStmt VARCHAR2(4000) := 'SELECT * FROM MD_DERIVATIVES 
         WHERE DERIVED_CONNECTION_ID_FK = ' || p_connectionid ;
BEGIN
  OPEN cv_curs FOR v_selectStmt;
  LOOP
    FETCH cv_curs INTO v_row;
    EXIT WHEN cv_curs%NOTFOUND;
    
    v_transformed := NULL;
    v_derivedName := MIGRATION_TRANSFORMER.TRANSFORM_IDENTIFIER(v_row.ORIGINAL_IDENTIFIER);
    if v_row.NEW_IDENTIFIER <> v_derivedName then
      if v_row.ORIGINAL_IDENTIFIER <> v_derivedName then
         v_transformed := C_TRANSFORMED_TRUE;
      end if;
      
      UPDATE MD_DERIVATIVES SET TRANSFORMED = v_transformed, NEW_IDENTIFIER = v_derivedName WHERE 
         SRC_ID = v_row.SRC_ID and DERIVED_CONNECTION_ID_FK = p_connectionid ;
    end if;
  END LOOP;
  CLOSE cv_curs;
END revert_derivatives_table;


-- One time initialisation
begin
NULL;
end;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY "MIGRATION_REPORT" AS
--Function getCaptureStatus
FUNCTION getCaptureStatus(srcid IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';
BEGIN
  select decode((select count(*) from migrlog where ref_object_id=srcid and severity>800),0,'Passed','Failed') into status from dual;
  return status;
END getCaptureStatus;
--Function getConvertStatus
FUNCTION getConvertStatus(srcid IN NUMBER,convert_conn_id IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';
ifconvert NUMBER default 0;
BEGIN
  SELECT count(*) into ifconvert FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk=convert_conn_id;
  IF ifconvert=0 THEN
      RETURN 'NotConverted';
  ELSIF getCaptureStatus(srcid)='Failed' THEN
     RETURN 'Failed';
  ELSE
   BEGIN
    SELECT 
   decode((SELECT DISTINCT severity from migrlog 
                  WHERE  ref_object_id IN (SELECT derived_id FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk= convert_conn_id) 
                         and severity=1000
           UNION
           SELECT DISTINCT severity from migrlog 
                  WHERE ref_object_id IN (SELECT derived_id FROM md_derivatives where src_id=srcid and derived_connection_id_fk=convert_conn_id)
                  AND severity=900 
                  AND logtext like '%limitation%'),
                  null,'Passed',1000,'Failed',900,'Limitation',' ') 
  into status from dual;
  return status;
  END;
  END IF;
END getConvertStatus;
--Function getGenerateStatus
FUNCTION getGenerateStatus(srcid IN number,convert_conn_id IN NUMBER)  RETURN VARCHAR2 IS
status VARCHAR(20) default ' ';

BEGIN
   status:=getConvertStatus(srcid,convert_conn_id);   
   IF status='NotConverted' THEN
      RETURN 'NotGenerated';
   ELSIF  status='Failed'  THEN
      RETURN 'Failed';      
   ELSE
     BEGIN
        SELECT 
           decode((SELECT count(*) FROM migrlog 
                   WHERE ref_object_id IN (SELECT derived_id FROM md_derivatives WHERE src_id=srcid and derived_connection_id_fk=convert_conn_id) 
                         AND phase='Generate'
                         AND severity>800),
                    0,'Passed','Failed')
             INTO status FROM dual;
        RETURN status;
    END;
   END IF;
END getGenerateStatus;
--migration details for each objects
FUNCTION getDetails(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN migr_report_detail_table PIPELINED IS
BEGIN
FOR cur IN (
    select allobjs.ObjID captured_id,
           allobjs.ObjName captured_name,
           md.new_identifier converted_name,
           allobjs.ObjType captured_type,
           decode(md.derived_type,'MD_INDEXES', substr(md.derived_type,4, length(md.derived_type)-5),substr(md.derived_type,4, length(md.derived_type)-4)) converted_type,
           allobjs.CaptureStatus capture_status,
           allobjs.ConvertStatus convert_status,
           allobjs.GenerateStatus generate_status,
           decode(mlog.logtext,null,' ',mlog.logtext) logtext from (
 --schema
     SELECT md_schemas.id ObjID,md_schemas.name ObjName,'SCHEMA' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_schemas.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_schemas.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_schemas.id,convert_conn_id) GenerateStatus
       FROM md_schemas,md_catalogs
       WHERE md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--table
UNION ALL
      SELECT md_tables.id ObjID,md_tables.table_name ObjName,'TABLE' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_tables.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_tables.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_tables.id,convert_conn_id) GenerateStatus
       FROM md_tables,md_schemas,md_catalogs
       WHERE md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--view
UNION ALL
      SELECT md_views.id ObjID,md_views.view_name ObjName,'View' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_views.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_views.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_views.id,convert_conn_id) GenerateStatus
       FROM md_views,md_schemas,md_catalogs
       WHERE md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--storedprogram
UNION ALL
      SELECT md_stored_programs.id ObjID,md_stored_programs.name ObjName,'STORED_PROGRAM' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_stored_programs.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_stored_programs.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_stored_programs.id,convert_conn_id) GenerateStatus
       FROM md_stored_programs,md_schemas,md_catalogs
       WHERE md_stored_programs.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
--index
UNION ALL
      SELECT md_indexes.id ObjID,md_indexes.index_name ObjName,'INDEX' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_indexes.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_indexes.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_indexes.id,convert_conn_id) GenerateStatus
       FROM md_indexes, md_tables,md_schemas,md_catalogs
       WHERE md_indexes.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
UNION ALL
      SELECT md_constraints.id ObjID,md_constraints.name ObjName,'CONSTRAINT' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_constraints.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_constraints.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_constraints.id,convert_conn_id) GenerateStatus
       FROM md_constraints, md_tables,md_schemas,md_catalogs
       WHERE md_constraints.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id  
UNION ALL
      SELECT md_triggers.id ObjID,md_triggers.trigger_name ObjName,'TRIGGER' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,convert_conn_id) GenerateStatus
       FROM md_triggers, md_tables,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id 
UNION ALL
       SELECT md_triggers.id ObjID,md_triggers.trigger_name ObjName,'TRIGGER' ObjType,
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,convert_conn_id) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,convert_conn_id) GenerateStatus
       FROM md_triggers, md_views,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_views.id
            AND md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=capture_conn_id
  ) allobjs left join (select md_derivatives.src_id,migrlog.logtext 
                        from migrlog,md_derivatives 
                        where migrlog.ref_object_id = md_derivatives.derived_id or migrlog.ref_object_id=md_derivatives.src_id) mlog 
                                on allobjs.objid=mlog.src_id  left join md_derivatives md on allobjs.objid=md.src_id
    ) 
  LOOP
     PIPE ROW(MIGR_REPORT_DETAIL_ROW(cur.captured_id,
                              cur.captured_name,
                              cur.converted_name,
                              cur.captured_type,
                              cur.converted_type,
                              cur.capture_status,
                              cur.convert_status,
                              cur.generate_status,
                              cur.logtext
                              ));       
    
  END LOOP;  
  RETURN;
 END getDetails; 

--migration summary
FUNCTION getSum(capture_conn_id IN NUMBER,convert_conn_id IN NUMBER) RETURN migr_report_sum_table PIPELINED IS
--
capture_passed_schema number default 0;
capture_passed_table number default 0;
capture_passed_view number default 0;
capture_passed_sp number default 0;
capture_passed_index number default 0;
capture_passed_constraint number default 0;
capture_passed_trigger number default 0;
--
capture_failed_schema number default 0;
capture_failed_table number default 0;
capture_failed_view number default 0;
capture_failed_sp number default 0;
capture_failed_index number default 0;
capture_failed_constraint number default 0;
capture_failed_trigger number default 0;
--
convert_passed_schema number default 0;
convert_passed_table number default 0;
convert_passed_view number default 0;
convert_passed_sp number default 0;
convert_passed_index number default 0;
convert_passed_constraint number default 0;
convert_passed_trigger number default 0;
--
convert_limit_schema number default 0;
convert_limit_table number default 0;
convert_limit_view number default 0;
convert_limit_sp number default 0;
convert_limit_index number default 0;
convert_limit_constraint number default 0;
convert_limit_trigger number default 0;
--
convert_failed_schema number default 0;
convert_failed_table number default 0;
convert_failed_view number default 0;
convert_failed_sp number default 0;
convert_failed_index number default 0;
convert_failed_constraint number default 0;
convert_failed_trigger number default 0;
--
convert_not_schema number default 0;
convert_not_table number default 0;
convert_not_view number default 0;
convert_not_sp number default 0;
convert_not_index number default 0;
convert_not_constraint number default 0;
convert_not_trigger number default 0;
--
generate_passed_schema number default 0;
generate_passed_table number default 0;
generate_passed_view number default 0;
generate_passed_sp number default 0;
generate_passed_index number default 0;
generate_passed_constraint number default 0;
generate_passed_trigger number default 0;
--
generate_failed_schema number default 0;
generate_failed_table number default 0;
generate_failed_view number default 0;
generate_failed_sp number default 0;
generate_failed_index number default 0;
generate_failed_constraint number default 0;
generate_failed_trigger number default 0;
--
generate_not_schema number default 0;
generate_not_table number default 0;
generate_not_view number default 0;
generate_not_sp number default 0;
generate_not_index number default 0;
generate_not_constraint number default 0;
generate_not_trigger number default 0;
--CURSORS
--SCHEMAS CURSOR
CURSOR schema_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_schemas.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_schemas.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_schemas.id,did) GenerateStatus
       FROM md_schemas,md_catalogs
       WHERE md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--TABLES CURSOR
CURSOR table_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_tables.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_tables.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_tables.id,did) GenerateStatus
       FROM md_tables,md_schemas,md_catalogs
       WHERE md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--VIEWS CURSOR
CURSOR view_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_views.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_views.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_views.id,did) GenerateStatus
       FROM md_views,md_schemas,md_catalogs
       WHERE md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--STORED_PROGRAMS CURSOR
CURSOR sp_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_stored_programs.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_stored_programs.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_stored_programs.id,did) GenerateStatus
       FROM md_stored_programs,md_schemas,md_catalogs
       WHERE md_stored_programs.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--INDEXES CURSOR
CURSOR index_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_indexes.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_indexes.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_indexes.id,did) GenerateStatus
       FROM md_indexes, md_tables,md_schemas,md_catalogs
       WHERE md_indexes.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
--CONSTRAINTS CURSOR
CURSOR constraint_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_constraints.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_constraints.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_constraints.id,did) GenerateStatus
       FROM md_constraints, md_tables,md_schemas,md_catalogs
       WHERE md_constraints.table_id_fk= md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;  
--TRIGGERS CURSOR
CURSOR trigger_status(cid IN NUMBER,did IN NUMBER) IS
      SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,did) GenerateStatus
       FROM md_triggers, md_tables,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_tables.id
            AND md_tables.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid 
       UNION ALL
       SELECT 
          MIGRATION_REPORT.getCaptureStatus(md_triggers.id) CaptureStatus,
          MIGRATION_REPORT.getConvertStatus(md_triggers.id,did) ConvertStatus,
          MIGRATION_REPORT.getGenerateStatus(md_triggers.id,did) GenerateStatus
       FROM md_triggers, md_views,md_schemas,md_catalogs
       WHERE md_triggers.table_or_view_id_fk=md_views.id
            AND md_views.schema_id_fk=md_schemas.id
            AND md_schemas.catalog_id_fk= md_catalogs.id
            AND md_catalogs.connection_id_fk=cid;
BEGIN
 --count
 --schemas
 FOR cur IN schema_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_schema:=capture_failed_schema+1;
                ELSE capture_passed_schema:=capture_passed_schema+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_schema:=convert_failed_schema+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_schema:=convert_limit_schema+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_schema:=convert_passed_schema+1;
                 ELSE   convert_not_schema:=convert_not_schema+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_schema:=generate_failed_schema+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_schema:=generate_passed_schema+1;
                ELSE  generate_not_schema:=generate_not_schema+1;
                END IF;            
 END LOOP;
 --tables
 FOR cur IN table_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_table:=capture_failed_table+1;
                ELSE capture_passed_table:=capture_passed_table+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_table:=convert_failed_table+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_table:=convert_limit_table+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_table:=convert_passed_table+1;
                 ELSE   convert_not_table:=convert_not_table+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_table:=generate_failed_table+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_table:=generate_passed_table+1;
                ELSE  generate_not_table:=generate_not_table+1;
                END IF;            
 END LOOP;
 --views
 FOR cur IN view_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_view:=capture_failed_view+1;
                ELSE capture_passed_view:=capture_passed_view+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_view:=convert_failed_view+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_view:=convert_limit_view+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_view:=convert_passed_view+1;
                 ELSE   convert_not_view:=convert_not_view+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_view:=generate_failed_view+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_view:=generate_passed_view+1;
                ELSE  generate_not_view:=generate_not_view+1;
                END IF;            
 END LOOP;
 --stored programs
 FOR cur IN sp_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_sp:=capture_failed_sp+1;
                ELSE capture_passed_sp:=capture_passed_sp+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_sp:=convert_failed_sp+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_sp:=convert_limit_sp+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_sp:=convert_passed_sp+1;
                 ELSE   convert_not_sp:=convert_not_sp+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_sp:=generate_failed_sp+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_sp:=generate_passed_sp+1;
                ELSE  generate_not_sp:=generate_not_sp+1;
                END IF;            
 END LOOP;
 --index
 FOR cur IN index_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_index:=capture_failed_index+1;
                ELSE capture_passed_index:=capture_passed_index+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_index:=convert_failed_index+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_index:=convert_limit_index+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_index:=convert_passed_index+1;
                 ELSE   convert_not_index:=convert_not_index+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_index:=generate_failed_index+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_index:=generate_passed_index+1;
                ELSE  generate_not_index:=generate_not_index+1;
                END IF;            
 END LOOP;
 --constraints
 FOR cur IN constraint_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_constraint:=capture_failed_constraint+1;
                ELSE capture_passed_constraint:=capture_passed_constraint+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_constraint:=convert_failed_constraint+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_constraint:=convert_limit_constraint+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_constraint:=convert_passed_constraint+1;
                 ELSE   convert_not_constraint:=convert_not_constraint+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_constraint:=generate_failed_constraint+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_constraint:=generate_passed_constraint+1;
                ELSE  generate_not_constraint:=generate_not_constraint+1;
                END IF;            
 END LOOP;
 --triggers
 FOR cur IN trigger_status(capture_conn_id,convert_conn_id)
 LOOP
                IF cur.capturestatus='Failed' 
                 THEN capture_failed_trigger:=capture_failed_trigger+1;
                ELSE capture_passed_trigger:=capture_passed_trigger+1;
                END IF;
                
                 IF cur.convertstatus='Failed' 
                    THEN convert_failed_trigger:=convert_failed_trigger+1;
                 ELSIF cur.convertstatus='Limitation' 
                    THEN convert_limit_trigger:=convert_limit_trigger+1;
                 ELSIF cur.convertstatus='Passed'
                    THEN  convert_passed_trigger:=convert_passed_trigger+1;
                 ELSE   convert_not_trigger:=convert_not_trigger+1;
                 END IF;
                
                IF cur.generatestatus='Failed' 
                 THEN generate_failed_trigger:=generate_failed_trigger+1;
                ELSIF cur.generatestatus='Passed' 
                 THEN generate_passed_trigger:=generate_passed_trigger+1;
                ELSE  generate_not_trigger:=generate_not_trigger+1;
                END IF;            
 END LOOP; 
 --source exists row
  FOR cur IN (  
      SELECT 
        'Source Exists' Label,
         num_schemas,
         num_tables,
         num_indexes,
         num_constraints,
         num_views,
         num_stored_programs,        
         num_triggers
         FROM  md_connections
         WHERE type IS NULL and id=capture_conn_id
 )
 LOOP
   PIPE ROW(MIGR_REPORT_SUM_ROW(
           cur.Label, 
           cur.num_schemas,
           cur.num_tables,
           cur.num_indexes,
           cur.num_constraints,
           cur.num_views,
           cur.num_triggers,
           cur.num_stored_programs
             ));
 END LOOP; 
   PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Capture Passed', 
           capture_passed_schema,
           capture_passed_table,
           capture_passed_index,
           capture_passed_constraint,
           capture_passed_view,
           capture_passed_trigger,
           capture_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Capture Failed', 
           capture_failed_schema,
           capture_failed_table,
           capture_failed_index,
           capture_failed_constraint,
           capture_failed_view,
           capture_failed_trigger,
           capture_failed_sp
             ));
             
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Passed', 
           convert_passed_schema,
           convert_passed_table,
           convert_passed_index,
           convert_passed_constraint,
           convert_passed_view,
           convert_passed_trigger,
           convert_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Limitation', 
           convert_limit_schema,
           convert_limit_table,
           convert_limit_index,
           convert_limit_constraint,
           convert_limit_view,
           convert_limit_trigger,
           convert_limit_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Convert Failed', 
           convert_failed_schema,
           convert_failed_table,
           convert_failed_index,
           convert_failed_constraint,
           convert_failed_view,
           convert_failed_trigger,
           convert_failed_sp
             ));
             
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Generate Passed', 
           generate_passed_schema,
           generate_passed_table,
           generate_passed_index,
           generate_passed_constraint,
           generate_passed_view,
           generate_passed_trigger,
           generate_passed_sp
             ));
  PIPE ROW(MIGR_REPORT_SUM_ROW(
           'Generate Failed', 
           generate_failed_schema,
           generate_failed_table,
           generate_failed_index,
           generate_failed_constraint,
           generate_failed_view,
           generate_failed_trigger,
           generate_failed_sp
             )); 
  RETURN;
END getSum;
END MIGRATION_REPORT;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY "MIGRATION_TRANSFORMER" AS
  -- Maximum length of an identifier
  MAX_IDENTIFIER_LEN NUMBER:=30;
C_DISALLOWED_CHARS   CONSTANT NVARCHAR2(100) := ' .@`!"%^&*()-+=[]{};:,.<>?/~'''||UNISTR('\00A3');

--PRIVATE FUNCTION
FUNCTION truncateStringByteSize(p_work VARCHAR2, p_bsize NUMBER) RETURN VARCHAR2
IS
v_work VARCHAR2(4000);
v_bsize NUMBER(10);
BEGIN
 IF LENGTHB(p_work) <= p_bsize THEN
    return p_work;
  END IF;
  v_work := p_work;
  v_work := SUBSTRB(v_work, 1, p_bsize);
  WHILE INSTRC(p_work, v_work , 1, 1) <> 1 LOOP -- a character has been cut in half or in 2/3 or 3/4 by substrb (multibyte can have up to 4 bytes) 
  --note each left over corrupt byte can be a single character
   BEGIN
     v_bsize := LENGTHB(v_work);
  	 v_work := SUBSTRB(v_work, 1, v_bsize-1);
   END;
  END LOOP; 
  return v_work;
END;

FUNCTION add_suffix(p_work VARCHAR2, p_suffix VARCHAR2, p_maxlen NUMBER) RETURN VARCHAR2
IS
  v_suflen NUMBER := LENGTHB(p_suffix);
  v_truncamount NUMBER;
BEGIN
  IF LENGTHB(p_work) < p_maxlen - v_suflen THEN
    RETURN p_work || p_suffix;
  END IF;
  v_truncamount := LENGTHB(p_work) + v_suflen - p_maxlen;
  RETURN truncateStringByteSize(p_work, LENGTHB(p_work)-v_truncamount) || p_suffix;
END add_suffix;
  

FUNCTION check_identifier_length(p_ident VARCHAR2) RETURN VARCHAR2
IS
  v_work VARCHAR2(4000);
BEGIN
  return truncateStringByteSize(p_ident,  MAX_IDENTIFIER_LEN);
END;

FUNCTION check_reserved_word(p_work VARCHAR2) RETURN VARCHAR2
IS
  v_count NUMBER := 0;
BEGIN
  SELECT COUNT(*) INTO v_count FROM MIGRATION_RESERVED_WORDS WHERE KEYWORD = UPPER(p_work);
  IF v_count > 0 THEN
    -- It is a reserved word
    RETURN add_suffix(p_work, '_', MAX_IDENTIFIER_LEN);
  END IF;
  RETURN p_work;
END check_reserved_word;

FUNCTION sys_check(p_work VARCHAR2) RETURN VARCHAR2
IS
BEGIN
  IF LENGTH(p_work) < 4 THEN
    return p_work;
  END IF;
  IF SUBSTR(p_work, 1, 4) <> 'SYS_' THEN
    return p_work;
  END IF;
  RETURN 'SIS_' || SUBSTR(p_work, 5);
END sys_check;

FUNCTION first_char_check(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 * Never want to start with anything but AlphaNumeri
 */
IS
  v_firstChar NCHAR(1);
  v_allowed NCHAR(200);
BEGIN
  v_allowed := C_DISALLOWED_CHARS || '0123456789_$#';
  v_firstChar := SUBSTR(p_work,1,1);
  if INSTR(v_allowed, v_firstChar) > 0 THEN
    return 'A' ||p_work;
  END IF;
  return p_work;
END first_char_check;



FUNCTION lTrimNonAlphaNumeric(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 *Remove all non alphanumeric characters from the start 
 */
IS
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
  v_work NVARCHAR2(4000):=p_work;
  v_forbiddenChars VARCHAR2(100);
  v_firstgoodchar NUMBER;
BEGIN
  v_forbiddenChars := C_DISALLOWED_CHARS ||'_$#';
   FOR v_index in 1..LENGTH(v_work) LOOP
    v_testChar := SUBSTR(p_work, v_index, 1);
    IF INSTR(v_forbiddenChars, v_testChar) <= 0 THEN
      v_firstgoodchar := v_index;
      EXIT;--make sure to leave loop now as first real char reached
    END IF;
  END LOOP;
  return substr(p_work,v_firstgoodchar);
END lTrimNonAlphaNumeric;

FUNCTION removeQuotes(p_work NVARCHAR2) RETURN NVARCHAR2
/**
 * Removed Quotes around a identifier name
 */
IS
  v_firstChar NCHAR(1);
  v_lastChar NCHAR(1);
  v_quote NCHAR(200):= '"[]'; -- strip these from start and end;
  v_work NVARCHAR2(4000) := p_work;
BEGIN
  v_firstChar := SUBSTR(v_work,1,1);
  v_lastChar  := SUBSTR(v_work,LENGTH(v_work),1);
  if INSTR(v_quote, v_firstChar) > 0 THEN
  	v_work := SUBSTR(v_work, 2);
  	if INSTR(v_quote, v_lastChar) > 0 THEN
  	  v_work := SUBSTR(v_work,0,LENGTH(v_work)-1);
      return v_work;
    END IF;
      return v_work;
  END IF;
  return v_work;
END removeQuotes;


FUNCTION check_allowed_chars(p_work NVARCHAR2) RETURN NVARCHAR2
/* The documentation states 
 * "Nonquoted identifiers can contain only alphanumeric characters from your database character set and the
 *  underscore (_), dollar sign ($), and pound sign (#). Database links can also contain periods (.) and "at" signs (@).
 *  Oracle strongly discourages you from using $ and # in nonquoted identifiers."
 *  Heres a couple of gotchas
 *  1) We don't know where we will be generated to, so dunno what that database character set will be
 *  2) We've now way of knowing if a character is alphanumeric on the character set.
 * So... Here's what we'll do
 *  1) given that its come from a database, we'll assume with was alphanumeric
 *  2) We'll remove any "regular" symbol characters (i.e. one's on my keyboard!)
 *  3) We'll be storing in NVARCHAR2 in the hope that this will preserve everything.
 * 
 */
IS
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
  -- Folowing syntax is a workaround for a problem with wrap.  Do not change it.
  v_forbiddenChars NVARCHAR2(100) := C_DISALLOWED_CHARS;
  v_work VARCHAR2(4000) := p_work;
  v_endswithunderscore boolean := FALSE;
BEGIN
  IF INSTR('_',SUBSTR(p_work, LENGTH(p_work))) >0 THEN
    v_endswithunderscore := TRUE;
  END IF;
  
 
  FOR v_index in 1..LENGTH(v_work) LOOP
    v_testChar := SUBSTR(p_work, v_index, 1);
     
    --check for existing underscores.these existed in the original and should be preserved as later we remove multiple underscores
    --bug:10405027
    IF v_testChar = '_' THEN
    	v_work :=SUBSTR(v_work,1,v_index-1)||'!' || SUBSTR(v_work,v_index+1);
    ELSIF INSTR(v_forbiddenChars, v_testChar) > 0 THEN
      v_work := SUBSTR(v_work, 1, v_index-1) || '_' || SUBSTR(v_work, v_index+1);
    END IF;
  END LOOP;
 
  --NOW REMOVE DOUBLE UNDERSCORES see bug 6647397
  v_work := replace(replace (replace (v_work,'__','_'),'__','_'),'__','_');--replace 2 underscores with 1 underscore
 
  --bug:10405027 , original underscore and a new one
  v_work := replace(v_work,'!_','_');
  v_work := replace(v_work,'_!','_'); 
  	
  --NOW ADD BACK IN EXISTING ORGINAL UNDERSCORES bug:10405027
  v_work := replace(v_work,'!','_');
  
  --REMOVE THE LT CHAR IF IT IS AN UNDERSCORE
  IF v_endswithunderscore=false AND INSTR('_',SUBSTR(v_Work,LENGTH(v_work))) > 0 THEN
    v_work := SUBSTR(v_work,0,LENGTH(v_work)-1);
  END IF;
  return v_work;
END check_allowed_chars;

FUNCTION transform_identifier(p_identifier NVARCHAR2)  RETURN NVARCHAR2
IS
  v_work VARCHAR2(4000);
BEGIN
  v_work := p_identifier;
  
  -- There are 10 rules defined for identifier naming:
  -- See http://st-doc.us.oracle.com/10/102/server.102/b14200/sql_elements008.htm#i27570
 
  v_work := removeQuotes(v_work);
  v_work := lTrimNonAlphaNumeric(v_work);
  IF v_work is null THEN
    v_work := getNameForNullCase(p_identifier);	 ---bug no. 8904200 
  END IF;
  
  --moving this to first as we can shrink the size of the name if they have more than 1 invalid char in a row.
  --see bug 6647397
   -- 5. Must begin withan alpha character from your character set
  v_work := first_char_check(v_work);
   -- 6. Alphanumeric characters from your database charset plus '_', '$', '#' only
  v_work := check_allowed_chars(v_work);
  -- 1. Length
  v_work := check_identifier_length(v_work);
  -- 2. Reserved words
  v_work := check_reserved_word(v_work);
  -- 3. "Special words" -I've handled these in reserved words, but still have to check if it starts with SYS
  v_work := sys_check(v_work);
  -- 4. "You should use ASCII characters in database names, global database names, and database link names,
  --    because ASCII characters provide optimal compatibility across different platforms and operating systems."
  -- This doesn't apply as we are not doing anything with DB names
  -- 7. Name collisions; we'll handle this at a higher level.
  -- 8. Nonquoted identifiers are case insensitive.  This is a doubl edged sword: If we use quoted, we can possible
  --    Keep it similar to the source platform.  However this is not how it is typically done in Oracle.
  -- 9. Columns in the same table.  See point 7. above.
  -- 10. All about overloading for functions and parameters.  We don't have to handle this here either, at this
  --     Should all be done by parsing technology.
  return v_work;
END transform_identifier;
FUNCTION fix_all_schema_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := 0;
  -- First, we transform all identifiers to meet our rules
  -- Then, we need to see if we've caused any collisions in the process
  -- And if so, fix them
  -- Right now, this is a dummy stub.
  return v_ret;
END fix_all_schema_identifiers;

FUNCTION fix_all_identifiers(p_connectionid MD_CONNECTIONS.ID%TYPE) RETURN NUMBER
IS
  v_ret NUMBER;
BEGIN
  v_ret := fix_all_schema_identifiers(p_connectionid);
  return v_ret;
END fix_all_identifiers;  

FUNCTION getNameForNullCase(p_work NVARCHAR2) RETURN NVARCHAR2
IS
  v_work VARCHAR2(4000);
  v_testChar VARCHAR2(2000);
  v_index NUMBER;
BEGIN
  FOR v_index in 1..LENGTH(p_work) LOOP
    v_testchar := SUBSTR(p_work,v_index,1);
    v_work := v_work || getDisallowedCharsNames(v_testchar);
  END LOOP;
  return v_work;
END;

FUNCTION getDisallowedCharsNames(p_work NVARCHAR2) RETURN VARCHAR2
IS
  v_work VARCHAR2(4000) := p_work;
BEGIN
  ----' .@`!"%^&*()-+=[]{};:,.<>?/~''' 
    v_work := ( CASE p_work
    WHEN '.' THEN 'DOT'
    WHEN '@' THEN 'AT'
    WHEN '`' THEN 'APOSTROPHE'
    WHEN '!' THEN 'EXCLAMATION'
    WHEN '"' THEN 'D_QUOTE'
    WHEN '%' THEN 'PERCENT'
    WHEN '^' THEN 'CARET'
    WHEN '&' THEN 'AMPERSAND'
    WHEN '*' THEN 'STAR'
    WHEN '(' THEN 'LEFTPARENTHESIS'
    WHEN ')' THEN 'RIGHTPARANTHESIS'
    WHEN '-' THEN 'MINUS'
    WHEN '+' THEN 'PLUS'
    WHEN '=' THEN 'EQUAL'
    WHEN '[' THEN 'LEFTSQUARE_B'
    WHEN ']' THEN 'RIGHTSQUARE_B'
    WHEN '{' THEN 'LEFTCURLY_B'
    WHEN '}' THEN 'RIGHTCURLY_B'
    WHEN ';' THEN 'COLON'
    WHEN ':' THEN 'SEMICOLON'
    WHEN ',' THEN 'COMMA'
    WHEN '<' THEN 'LESSTHAN'
    WHEN '>' THEN 'GREATERTHAN'
    WHEN '?' THEN 'QUESTIONMARK'
    WHEN '~' THEN 'TILDE'
    WHEN '/' THEN 'BACKSLASH'
    WHEN '''' THEN 'S_QUOTE'
    WHEN '$' THEN 'DOLLAR'
    ELSE 'UNKNOWN'
    END);
    return v_work;
END;

END;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_ALNOVA AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_ALNOVA
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_ALNOVA_TERMES (PEREG IN EBANKING.ALNOVA_TERM_ES%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.ALNOVA_TERM_ES(ID,CODE,BUSY,SERVER,TERMINAL2CHANNEL,APP,USUARIO_MODIFICO,FECHA_OPERACION) 
                                 VALUES(PEREG.ID,PEREG.CODE,PEREG.BUSY,PEREG.SERVER,PEREG.TERMINAL2CHANNEL,
								        PEREG.APP,PEREG.USUARIO_MODIFICO,PEREG.FECHA_OPERACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERMES(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_ALNOVA_TERMES (P_ID               IN EBANKING.ALNOVA_TERM_ES.ID%TYPE, 
                             P_CODE             IN EBANKING.ALNOVA_TERM_ES.CODE%TYPE, 
                             P_BUSY             IN EBANKING.ALNOVA_TERM_ES.BUSY%TYPE,
                             P_SERVER           IN EBANKING.ALNOVA_TERM_ES.SERVER%TYPE,
                             P_TERMINAL2CHANNEL IN EBANKING.ALNOVA_TERM_ES.TERMINAL2CHANNEL%TYPE,
                             P_APP              IN EBANKING.ALNOVA_TERM_ES.APP%TYPE,
                             P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_ES.USUARIO_MODIFICO%TYPE,
                             P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_ES.FECHA_OPERACION%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERM_ES%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.SERVER           := P_SERVER;
  PEREG.TERMINAL2CHANNEL := P_TERMINAL2CHANNEL;
  PEREG.APP              := P_APP;
  PEREG.USUARIO_MODIFICO := P_USUARIO_MODIFICO;
  PEREG.FECHA_OPERACION  := P_FECHA_OPERACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERMES(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_ALNOVA_TERMES(PEREG IN  EBANKING.ALNOVA_TERM_ES%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.ALNOVA_TERM_ES T SET   
         T.CODE             = NVL(PEREG.CODE,T.CODE),
     	 T.BUSY         	= NVL(PEREG.BUSY,T.BUSY),
     	 T.SERVER           = NVL(PEREG.SERVER,T.SERVER),
     	 T.TERMINAL2CHANNEL = NVL(PEREG.TERMINAL2CHANNEL,T.TERMINAL2CHANNEL),
		 T.APP              = NVL(PEREG.APP,T.APP),
		 T.USUARIO_MODIFICO = NVL(PEREG.USUARIO_MODIFICO,T.USUARIO_MODIFICO),
		 T.FECHA_OPERACION  = NVL(PEREG.FECHA_OPERACION,T.FECHA_OPERACION)
     WHERE T.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERMES(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_ALNOVA_TERMES(P_ID               IN EBANKING.ALNOVA_TERM_ES.ID%TYPE, 
                               P_CODE             IN EBANKING.ALNOVA_TERM_ES.CODE%TYPE, 
                               P_BUSY             IN EBANKING.ALNOVA_TERM_ES.BUSY%TYPE,
                               P_SERVER           IN EBANKING.ALNOVA_TERM_ES.SERVER%TYPE,
                               P_TERMINAL2CHANNEL IN EBANKING.ALNOVA_TERM_ES.TERMINAL2CHANNEL%TYPE,
                               P_APP              IN EBANKING.ALNOVA_TERM_ES.APP%TYPE,
                               P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_ES.USUARIO_MODIFICO%TYPE,
                               P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_ES.FECHA_OPERACION%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERM_ES%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.SERVER           := P_SERVER;
  PEREG.TERMINAL2CHANNEL := P_TERMINAL2CHANNEL;
  PEREG.APP              := P_APP;
  PEREG.USUARIO_MODIFICO := P_USUARIO_MODIFICO;
  PEREG.FECHA_OPERACION  := P_FECHA_OPERACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERMES(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ALNOVA_TERM_SEL
******************************************************************************/
PROCEDURE ADD_ALNOVA_TERMSE (PEREG IN EBANKING.ALNOVA_TERM_SEL%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.ALNOVA_TERM_SEL(ID,CODE,BUSY,APP,USUARIO_MODIFICO,FECHA_OPERACION) 
                                  VALUES(PEREG.ID,PEREG.CODE,PEREG.BUSY,PEREG.APP,
								         PEREG.USUARIO_MODIFICO,PEREG.FECHA_OPERACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERMSE(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_ALNOVA_TERMSE (P_ID               IN EBANKING.ALNOVA_TERM_SEL.ID%TYPE, 
                             P_CODE             IN EBANKING.ALNOVA_TERM_SEL.CODE%TYPE, 
                             P_BUSY             IN EBANKING.ALNOVA_TERM_SEL.BUSY%TYPE,
                             P_APP              IN EBANKING.ALNOVA_TERM_SEL.APP%TYPE,
                             P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_SEL.USUARIO_MODIFICO%TYPE,
                             P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_SEL.FECHA_OPERACION%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERM_SEL%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.APP              := P_APP;
  PEREG.USUARIO_MODIFICO := P_USUARIO_MODIFICO;
  PEREG.FECHA_OPERACION  := P_FECHA_OPERACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERMSE(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_ALNOVA_TERMSE(PEREG IN  EBANKING.ALNOVA_TERM_SEL%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.ALNOVA_TERM_SEL T SET   
         T.CODE             = NVL(PEREG.CODE,T.CODE),
     	 T.BUSY         	= NVL(PEREG.BUSY,T.BUSY),
		 T.APP              = NVL(PEREG.APP,T.APP),
		 T.USUARIO_MODIFICO = NVL(PEREG.USUARIO_MODIFICO,T.USUARIO_MODIFICO),
		 T.FECHA_OPERACION  = NVL(PEREG.FECHA_OPERACION,T.FECHA_OPERACION)
     WHERE T.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERMSE(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_ALNOVA_TERMSE(P_ID               IN EBANKING.ALNOVA_TERM_SEL.ID%TYPE, 
                               P_CODE             IN EBANKING.ALNOVA_TERM_SEL.CODE%TYPE, 
                               P_BUSY             IN EBANKING.ALNOVA_TERM_SEL.BUSY%TYPE,
                               P_APP              IN EBANKING.ALNOVA_TERM_SEL.APP%TYPE,
                               P_USUARIO_MODIFICO IN EBANKING.ALNOVA_TERM_SEL.USUARIO_MODIFICO%TYPE,
                               P_FECHA_OPERACION  IN EBANKING.ALNOVA_TERM_SEL.FECHA_OPERACION%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERM_SEL%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.APP              := P_APP;
  PEREG.USUARIO_MODIFICO := P_USUARIO_MODIFICO;
  PEREG.FECHA_OPERACION  := P_FECHA_OPERACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERMSE(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ALNOVA_TERMINAL
******************************************************************************/

PROCEDURE ADD_ALNOVA_TERM (PEREG IN EBANKING.ALNOVA_TERMINAL%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.ALNOVA_TERMINAL(ID,CODE,BUSY,SERVER,TERMINAL2CHANNEL,FECHA_MODIFICACION) 
                                 VALUES(PEREG.ID,PEREG.CODE,PEREG.BUSY,PEREG.SERVER,PEREG.TERMINAL2CHANNEL,
								        PEREG.FECHA_MODIFICACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERM(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_ALNOVA_TERM (P_ID                 IN EBANKING.ALNOVA_TERMINAL.ID%TYPE, 
                           P_CODE               IN EBANKING.ALNOVA_TERMINAL.CODE%TYPE, 
                           P_BUSY               IN EBANKING.ALNOVA_TERMINAL.BUSY%TYPE,
                           P_SERVER             IN EBANKING.ALNOVA_TERMINAL.SERVER%TYPE,
                           P_TERMINAL2CHANNEL   IN EBANKING.ALNOVA_TERMINAL.TERMINAL2CHANNEL%TYPE,
                           P_FECHA_MODIFICACION IN EBANKING.ALNOVA_TERMINAL.FECHA_MODIFICACION%TYPE,
                           PSCOD                OUT NUMBER,
                           PSMSG                OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERMINAL%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.SERVER           := P_SERVER;
  PEREG.TERMINAL2CHANNEL := P_TERMINAL2CHANNEL;
  PEREG.FECHA_MODIFICACION  := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.ADD_ALNOVA_TERM(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_ALNOVA_TERM(PEREG IN  EBANKING.ALNOVA_TERMINAL%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.ALNOVA_TERMINAL T SET   
         T.CODE             = NVL(PEREG.CODE,T.CODE),
     	 T.BUSY         	= NVL(PEREG.BUSY,T.BUSY),
     	 T.SERVER           = NVL(PEREG.SERVER,T.SERVER),
     	 T.TERMINAL2CHANNEL = NVL(PEREG.TERMINAL2CHANNEL,T.TERMINAL2CHANNEL),
		 T.FECHA_MODIFICACION  = NVL(PEREG.FECHA_MODIFICACION,T.FECHA_MODIFICACION)
     WHERE T.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERM(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_ALNOVA_TERM(P_ID                 IN EBANKING.ALNOVA_TERMINAL.ID%TYPE, 
                             P_CODE               IN EBANKING.ALNOVA_TERMINAL.CODE%TYPE, 
                           	 P_BUSY               IN EBANKING.ALNOVA_TERMINAL.BUSY%TYPE,
                           	 P_SERVER             IN EBANKING.ALNOVA_TERMINAL.SERVER%TYPE,
                           	 P_TERMINAL2CHANNEL   IN EBANKING.ALNOVA_TERMINAL.TERMINAL2CHANNEL%TYPE,
                           	 P_FECHA_MODIFICACION IN EBANKING.ALNOVA_TERMINAL.FECHA_MODIFICACION%TYPE,
                             PSCOD                OUT NUMBER,
                             PSMSG                OUT VARCHAR2)IS
PEREG EBANKING.ALNOVA_TERMINAL%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.CODE             := P_CODE;
  PEREG.BUSY             := P_BUSY;
  PEREG.SERVER           := P_SERVER;
  PEREG.TERMINAL2CHANNEL := P_TERMINAL2CHANNEL;
  PEREG.FECHA_MODIFICACION  := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_ALNOVA.MODIFY_ALNOVA_TERM(PEREG,PSCOD,PSMSG);
END;

END PKG_CORE_GEN_ALNOVA;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_PAY_BUY AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_PAY_BUY
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_INTERBUS (PEREG IN EBANKING.INTERBUS%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.INTERBUS(USER_ID,REFERENCIA,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                           VALUES(PEREG.USER_ID, PEREG.REFERENCIA, PEREG.CANAL, PEREG.STATUS, 
                                  PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_INTERBUS(' || SQLCODE || '  ' || SQLERRM || ')');
END;


PROCEDURE ADD_INTERBUS (P_USER_ID              IN EBANKING.INTERBUS.USER_ID%TYPE, 
                        P_REFERENCIA           IN EBANKING.INTERBUS.REFERENCIA%TYPE, 
                        P_CANAL                IN EBANKING.INTERBUS.CANAL%TYPE,
                        P_STATUS               IN EBANKING.INTERBUS.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.INTERBUS.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.INTERBUS%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_INTERBUS(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_INTERBUS(PEREG IN EBANKING.INTERBUS%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.INTERBUS I SET   
         I.REFERENCIA           = NVL(PEREG.REFERENCIA,I.REFERENCIA),
     	 I.CANAL         	    = NVL(PEREG.CANAL,I.CANAL),
     	 I.STATUS               = NVL(PEREG.STATUS,I.STATUS),
     	 I.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,I.ULTIMA_ACTUALIZACION)
     WHERE I.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_INTERBUS(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_INTERBUS(P_USER_ID              IN EBANKING.INTERBUS.USER_ID%TYPE, 
                          P_REFERENCIA           IN EBANKING.INTERBUS.REFERENCIA%TYPE, 
                          P_CANAL                IN EBANKING.INTERBUS.CANAL%TYPE,
                          P_STATUS               IN EBANKING.INTERBUS.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.INTERBUS.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.INTERBUS%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_INTERBUS(PEREG,PSCOD,PSMSG);
END;
        
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EDCULTURALES
******************************************************************************/
PROCEDURE ADD_EDCULTURALES (PEREG IN EBANKING.EDCULTURALES%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EDCULTURALES(USER_ID,REFERENCIA,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                               VALUES(PEREG.USER_ID, PEREG.REFERENCIA, PEREG.CANAL, PEREG.STATUS, 
                                      PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;     
	    ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_EDCULTURALES(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EDCULTURALES (P_USER_ID              IN EBANKING.EDCULTURALES.USER_ID%TYPE, 
                            P_REFERENCIA           IN EBANKING.EDCULTURALES.REFERENCIA%TYPE, 
                            P_CANAL                IN EBANKING.EDCULTURALES.CANAL%TYPE,
                            P_STATUS               IN EBANKING.EDCULTURALES.STATUS%TYPE,
                            P_ULTIMA_ACTUALIZACION IN EBANKING.EDCULTURALES.ULTIMA_ACTUALIZACION%TYPE,
                            PSCOD                  OUT NUMBER,
                            PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.EDCULTURALES%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_EDCULTURALES(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_EDCULTURALES(PEREG IN EBANKING.EDCULTURALES%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EDCULTURALES E SET   
         E.REFERENCIA           = NVL(PEREG.REFERENCIA,E.REFERENCIA),
         E.CANAL                = NVL(PEREG.CANAL,E.CANAL),
         E.STATUS               = NVL(PEREG.STATUS,E.STATUS),
         E.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,E.ULTIMA_ACTUALIZACION)
     WHERE E.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_EDCULTURALES(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_EDCULTURALES(P_USER_ID              IN EBANKING.EDCULTURALES.USER_ID%TYPE, 
                              P_REFERENCIA           IN EBANKING.EDCULTURALES.REFERENCIA%TYPE, 
                              P_CANAL                IN EBANKING.EDCULTURALES.CANAL%TYPE,
                              P_STATUS               IN EBANKING.EDCULTURALES.STATUS%TYPE,
                              P_ULTIMA_ACTUALIZACION IN EBANKING.EDCULTURALES.ULTIMA_ACTUALIZACION%TYPE,
                              PSCOD                  OUT NUMBER,
                              PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.EDCULTURALES%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_EDCULTURALES(PEREG,PSCOD,PSMSG);
END;
         
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE SKYACCOUNTS
******************************************************************************/
PROCEDURE ADD_SKYACCOUNTS (PEREG IN EBANKING.SKYACCOUNTS%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.SKYACCOUNTS(USER_ID,REFERENCIA,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                              VALUES(PEREG.USER_ID, PEREG.REFERENCIA, PEREG.CANAL, PEREG.STATUS, 
                                     PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_SKYACCOUNTS(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_SKYACCOUNTS (P_USER_ID              IN EBANKING.SKYACCOUNTS.USER_ID%TYPE, 
                           P_REFERENCIA           IN EBANKING.SKYACCOUNTS.REFERENCIA%TYPE, 
                           P_CANAL                IN EBANKING.SKYACCOUNTS.CANAL%TYPE,
                           P_STATUS               IN EBANKING.SKYACCOUNTS.STATUS%TYPE,
                           P_ULTIMA_ACTUALIZACION IN EBANKING.SKYACCOUNTS.ULTIMA_ACTUALIZACION%TYPE,
                           PSCOD                  OUT NUMBER,
                           PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.SKYACCOUNTS%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_SKYACCOUNTS(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_SKYACCOUNTS(PEREG IN EBANKING.SKYACCOUNTS%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.SKYACCOUNTS S SET   
         S.REFERENCIA           = NVL(PEREG.REFERENCIA,S.REFERENCIA),
         S.CANAL                = NVL(PEREG.CANAL,S.CANAL),
         S.STATUS               = NVL(PEREG.STATUS,S.STATUS),
         S.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,S.ULTIMA_ACTUALIZACION)
     WHERE S.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_SKYACCOUNTS(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_SKYACCOUNTS(P_USER_ID              IN EBANKING.SKYACCOUNTS.USER_ID%TYPE, 
                             P_REFERENCIA           IN EBANKING.SKYACCOUNTS.REFERENCIA%TYPE, 
                             P_CANAL                IN EBANKING.SKYACCOUNTS.CANAL%TYPE,
                             P_STATUS               IN EBANKING.SKYACCOUNTS.STATUS%TYPE,
                             P_ULTIMA_ACTUALIZACION IN EBANKING.SKYACCOUNTS.ULTIMA_ACTUALIZACION%TYPE,
                             PSCOD                  OUT NUMBER,
                             PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.SKYACCOUNTS%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_SKYACCOUNTS(PEREG,PSCOD,PSMSG);
END;
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE MOVISTAR
******************************************************************************/
PROCEDURE ADD_MOVISTAR (PEREG IN EBANKING.MOVISTAR%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.MOVISTAR(USER_ID,REFERENCIA,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                           VALUES(PEREG.USER_ID, PEREG.REFERENCIA, PEREG.CANAL, PEREG.STATUS, 
                                  PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_MOVISTAR(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_MOVISTAR (P_USER_ID              IN EBANKING.MOVISTAR.USER_ID%TYPE, 
                        P_REFERENCIA           IN EBANKING.MOVISTAR.REFERENCIA%TYPE, 
                        P_CANAL                IN EBANKING.MOVISTAR.CANAL%TYPE,
                        P_STATUS               IN EBANKING.MOVISTAR.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.MOVISTAR.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.MOVISTAR%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_MOVISTAR(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_MOVISTAR(PEREG IN EBANKING.MOVISTAR%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.MOVISTAR M SET   
         M.REFERENCIA           = NVL(PEREG.REFERENCIA,M.REFERENCIA),
         M.CANAL                = NVL(PEREG.CANAL,M.CANAL),
         M.STATUS               = NVL(PEREG.STATUS,M.STATUS),
         M.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,M.ULTIMA_ACTUALIZACION)
     WHERE M.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
	    ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_MOVISTAR(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_MOVISTAR(P_USER_ID              IN EBANKING.MOVISTAR.USER_ID%TYPE, 
                          P_REFERENCIA           IN EBANKING.MOVISTAR.REFERENCIA%TYPE, 
                          P_CANAL                IN EBANKING.MOVISTAR.CANAL%TYPE,
                          P_STATUS               IN EBANKING.MOVISTAR.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.MOVISTAR.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.MOVISTAR%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.REFERENCIA           := P_REFERENCIA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_MOVISTAR(PEREG,PSCOD,PSMSG);
END; 
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IUSACELL
******************************************************************************/
PROCEDURE ADD_IUSACELL (PEREG IN EBANKING.IUSACELL%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.IUSACELL(USER_ID,CUENTA,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                        VALUES(PEREG.USER_ID, PEREG.CUENTA, PEREG.CANAL, PEREG.STATUS, 
                PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_IUSACELL(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_IUSACELL (P_USER_ID              IN EBANKING.IUSACELL.USER_ID%TYPE, 
                        P_CUENTA               IN EBANKING.IUSACELL.CUENTA%TYPE, 
                        P_CANAL                IN EBANKING.IUSACELL.CANAL%TYPE,
                        P_STATUS               IN EBANKING.IUSACELL.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.IUSACELL.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.IUSACELL%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.CUENTA               := P_CUENTA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_IUSACELL(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_IUSACELL(PEREG IN EBANKING.IUSACELL%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.IUSACELL I SET   
         I.CUENTA               = NVL(PEREG.CUENTA,I.CUENTA),
         I.CANAL                = NVL(PEREG.CANAL,I.CANAL),
     	 I.STATUS               = NVL(PEREG.STATUS,I.STATUS),
     	 I.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,I.ULTIMA_ACTUALIZACION)
     WHERE I.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
	    ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_IUSACELL(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_IUSACELL(P_USER_ID              IN EBANKING.IUSACELL.USER_ID%TYPE, 
                          P_CUENTA             IN EBANKING.IUSACELL.CUENTA%TYPE, 
                          P_CANAL                IN EBANKING.IUSACELL.CANAL%TYPE,
                          P_STATUS               IN EBANKING.IUSACELL.STATUS%TYPE,
                          P_ULTIMA_ACTUALIZACION IN EBANKING.IUSACELL.ULTIMA_ACTUALIZACION%TYPE,
                          PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.IUSACELL%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.CUENTA               := P_CUENTA;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_IUSACELL(PEREG,PSCOD,PSMSG);
END; 
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TELMEX
******************************************************************************/
PROCEDURE ADD_TELMEX (PEREG IN EBANKING.TELMEX%ROWTYPE,
                      PSCOD OUT NUMBER,
                      PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.TELMEX(USER_ID,TELEFONO,CANAL,STATUS,ULTIMA_ACTUALIZACION) 
                         VALUES(PEREG.USER_ID, PEREG.TELEFONO, PEREG.CANAL, PEREG.STATUS, 
                                PEREG.ULTIMA_ACTUALIZACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_TELMEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_TELMEX (P_USER_ID              IN EBANKING.TELMEX.USER_ID%TYPE, 
                      P_TELEFONO             IN EBANKING.TELMEX.TELEFONO%TYPE, 
                      P_CANAL                IN EBANKING.TELMEX.CANAL%TYPE,
                      P_STATUS               IN EBANKING.TELMEX.STATUS%TYPE,
                      P_ULTIMA_ACTUALIZACION IN EBANKING.TELMEX.ULTIMA_ACTUALIZACION%TYPE,
                      PSCOD                  OUT NUMBER,
                      PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.TELMEX%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.TELEFONO             := P_TELEFONO;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_TELMEX(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_TELMEX(PEREG IN EBANKING.TELMEX%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.TELMEX T SET   
         T.TELEFONO             = NVL(PEREG.TELEFONO,T.TELEFONO),
     	 T.CANAL                = NVL(PEREG.CANAL,T.CANAL),
     	 T.STATUS               = NVL(PEREG.STATUS,T.STATUS),
     	 T.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,T.ULTIMA_ACTUALIZACION)
     WHERE T.USER_ID = PEREG.USER_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
        WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_IUSACELL(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_TELMEX(P_USER_ID              IN EBANKING.TELMEX.USER_ID%TYPE, 
                        P_TELEFONO             IN EBANKING.TELMEX.TELEFONO%TYPE, 
                        P_CANAL                IN EBANKING.TELMEX.CANAL%TYPE,
                        P_STATUS               IN EBANKING.TELMEX.STATUS%TYPE,
                        P_ULTIMA_ACTUALIZACION IN EBANKING.TELMEX.ULTIMA_ACTUALIZACION%TYPE,
                        PSCOD                  OUT NUMBER,
                        PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.TELMEX%ROWTYPE;
BEGIN
  PEREG.USER_ID              := P_USER_ID;
  PEREG.TELEFONO             := P_TELEFONO;
  PEREG.CANAL                := P_CANAL;
  PEREG.STATUS               := P_STATUS;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_TELMEX(PEREG,PSCOD,PSMSG);
END; 

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TDCFRECUENT
******************************************************************************/
PROCEDURE ADD_TDCFRECUENT (PEREG IN EBANKING.TDCFRECUENT%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.TDCFRECUENT(CLIENT,DESTINO,BANCO,NOMBRE,STATUS,CANAL,ALIAS,IP_ORIGEN,FECHA_MODIFICACION) 
                              VALUES(PEREG.CLIENT, PEREG.DESTINO, PEREG.BANCO, PEREG.NOMBRE, PEREG.STATUS, 
							         PEREG.CANAL, PEREG.ALIAS, PEREG.IP_ORIGEN, PEREG.FECHA_MODIFICACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_TDCFRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_TDCFRECUENT (P_CLIENT               IN EBANKING.TDCFRECUENT.CLIENT%TYPE, 
                       	   P_DESTINO           	  IN EBANKING.TDCFRECUENT.DESTINO%TYPE, 
                      	   P_BANCO                IN EBANKING.TDCFRECUENT.BANCO%TYPE,
                      	   P_NOMBRE               IN EBANKING.TDCFRECUENT.NOMBRE%TYPE,
                      	   P_STATUS               IN EBANKING.TDCFRECUENT.STATUS%TYPE,
						   P_CANAL                IN EBANKING.TDCFRECUENT.CANAL%TYPE,
						   P_ALIAS                IN EBANKING.TDCFRECUENT.ALIAS%TYPE,
						   P_IP_ORIGEN            IN EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
						   P_FECHA_MODIFICACION   IN EBANKING.TDCFRECUENT.FECHA_MODIFICACION%TYPE,
                      	   PSCOD                  OUT NUMBER,
                      	   PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.TDCFRECUENT%ROWTYPE;
BEGIN
  PEREG.CLIENT             := P_CLIENT;
  PEREG.DESTINO            := P_DESTINO;
  PEREG.BANCO              := P_BANCO;
  PEREG.NOMBRE             := P_NOMBRE;
  PEREG.STATUS             := P_STATUS;
  PEREG.CANAL              := P_CANAL;
  PEREG.ALIAS              := P_ALIAS;
  PEREG.IP_ORIGEN          := P_IP_ORIGEN;
  PEREG.FECHA_MODIFICACION := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_TDCFRECUENT(PEREG,PSCOD,PSMSG);
END; 
 
PROCEDURE MODIFY_TDCFRECUENT(PEREG IN EBANKING.TDCFRECUENT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.TDCFRECUENT T SET   
     	 T.DESTINO              = NVL(PEREG.DESTINO,T.DESTINO),
     	 T.BANCO                = NVL(PEREG.BANCO,T.BANCO),
     	 T.NOMBRE               = NVL(PEREG.NOMBRE,T.NOMBRE),
		 T.STATUS 				= NVL(PEREG.STATUS,T.STATUS),
		 T.CANAL 				= NVL(PEREG.CANAL,T.CANAL),
		 T.ALIAS 				= NVL(PEREG.ALIAS,T.ALIAS),
		 T.IP_ORIGEN 			= NVL(PEREG.IP_ORIGEN,T.IP_ORIGEN),
		 T.FECHA_MODIFICACION	= NVL(PEREG.FECHA_MODIFICACION,T.FECHA_MODIFICACION)
     WHERE T.CLIENT = PEREG.CLIENT;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
        WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_TDCFRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_TDCFRECUENT(P_CLIENT               IN EBANKING.TDCFRECUENT.CLIENT%TYPE, 
                       	     P_DESTINO           	IN EBANKING.TDCFRECUENT.DESTINO%TYPE, 
                      	     P_BANCO                IN EBANKING.TDCFRECUENT.BANCO%TYPE,
                      	     P_NOMBRE               IN EBANKING.TDCFRECUENT.NOMBRE%TYPE,
                      	     P_STATUS               IN EBANKING.TDCFRECUENT.STATUS%TYPE,
						     P_CANAL                IN EBANKING.TDCFRECUENT.CANAL%TYPE,
						     P_ALIAS                IN EBANKING.TDCFRECUENT.ALIAS%TYPE,
						     P_IP_ORIGEN            IN EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
						     P_FECHA_MODIFICACION   IN EBANKING.TDCFRECUENT.FECHA_MODIFICACION%TYPE,
                             PSCOD                  OUT NUMBER,
                             PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.TDCFRECUENT%ROWTYPE;
BEGIN
  PEREG.CLIENT             := P_CLIENT;
  PEREG.DESTINO            := P_DESTINO;
  PEREG.BANCO              := P_BANCO;
  PEREG.NOMBRE             := P_NOMBRE;
  PEREG.STATUS             := P_STATUS;
  PEREG.CANAL              := P_CANAL;
  PEREG.ALIAS              := P_ALIAS;
  PEREG.IP_ORIGEN          := P_IP_ORIGEN;
  PEREG.FECHA_MODIFICACION := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_TDCFRECUENT(PEREG,PSCOD,PSMSG);
END; 
 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_PAGO_TAZ
******************************************************************************/
PROCEDURE ADD_PAGO_TAZ (PEREG IN EBANKING.EBANKING_PAGO_TAZ%ROWTYPE,
                        PSCOD OUT NUMBER,
                        PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_PAGO_TAZ(NUM_CLIENTE,NOM_ORIGEN,NUM_TAZ,NOM_DESTINO,TIPO_PAGO,REFERENCIA,PAIS,
								           CANAL,SUCURSAL,FOLIO,MONTO,FECHA_PAGO,TIENDA_DES,CANAL_DES,TIENDA_ORI,
									       CANAL_ORI,FOLIO_OPE_ORI,NUM_RETEN,CUENTA_CARGO,FOLIO_ABONO)
                                    VALUES(PEREG.NUM_CLIENTE, PEREG.NOM_ORIGEN, PEREG.NUM_TAZ, PEREG.NOM_DESTINO, 
							  		       PEREG.TIPO_PAGO,PEREG.REFERENCIA, PEREG.PAIS, PEREG.CANAL, PEREG.SUCURSAL, 
									       PEREG.FOLIO, PEREG.MONTO, PEREG.FECHA_PAGO, PEREG.TIENDA_DES, 
										   PEREG.CANAL_DES,PEREG.TIENDA_ORI, PEREG.CANAL_ORI, PEREG.FOLIO_OPE_ORI, 
										   PEREG.NUM_RETEN,PEREG.CUENTA_CARGO, PEREG.FOLIO_ABONO);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_PAGO_TAZ(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_PAGO_TAZ (P_NUM_CLIENTE   IN EBANKING.EBANKING_PAGO_TAZ.NUM_CLIENTE%TYPE, 
                       	P_NOM_ORIGEN    IN EBANKING.EBANKING_PAGO_TAZ.NOM_ORIGEN%TYPE, 
                      	P_NUM_TAZ       IN EBANKING.EBANKING_PAGO_TAZ.NUM_TAZ%TYPE,
                      	P_NOM_DESTINO   IN EBANKING.EBANKING_PAGO_TAZ.NOM_DESTINO%TYPE,
                      	P_TIPO_PAGO     IN EBANKING.EBANKING_PAGO_TAZ.TIPO_PAGO%TYPE,
						P_REFERENCIA    IN EBANKING.EBANKING_PAGO_TAZ.REFERENCIA%TYPE,
						P_PAIS          IN EBANKING.EBANKING_PAGO_TAZ.PAIS%TYPE,
						P_CANAL         IN EBANKING.EBANKING_PAGO_TAZ.CANAL%TYPE,
						P_SUCURSAL   	IN EBANKING.EBANKING_PAGO_TAZ.SUCURSAL%TYPE,
						P_FOLIO   		IN EBANKING.EBANKING_PAGO_TAZ.FOLIO%TYPE,
						P_MONTO   		IN EBANKING.EBANKING_PAGO_TAZ.MONTO%TYPE,
						P_FECHA_PAGO   	IN EBANKING.EBANKING_PAGO_TAZ.FECHA_PAGO%TYPE,
						P_TIENDA_DES   	IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_DES%TYPE,
						P_CANAL_DES   	IN EBANKING.EBANKING_PAGO_TAZ.CANAL_DES%TYPE,
						P_TIENDA_ORI   	IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_ORI%TYPE,
						P_CANAL_ORI   	IN EBANKING.EBANKING_PAGO_TAZ.CANAL_ORI%TYPE,
						P_FOLIO_OPE_ORI IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_OPE_ORI%TYPE,
						P_NUM_RETEN   	IN EBANKING.EBANKING_PAGO_TAZ.NUM_RETEN%TYPE,
						P_CUENTA_CARGO  IN EBANKING.EBANKING_PAGO_TAZ.CUENTA_CARGO%TYPE,
						P_FOLIO_ABONO   IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_ABONO%TYPE,
                      	PSCOD           OUT NUMBER,
                      	PSMSG           OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_PAGO_TAZ%ROWTYPE;
BEGIN
  PEREG.NUM_CLIENTE	  := P_NUM_CLIENTE;
  PEREG.NOM_ORIGEN    := P_NOM_ORIGEN;
  PEREG.NUM_TAZ       := P_NUM_TAZ;
  PEREG.NOM_DESTINO	  := P_NOM_DESTINO;
  PEREG.TIPO_PAGO	  := P_TIPO_PAGO;
  PEREG.REFERENCIA	  := P_REFERENCIA;
  PEREG.PAIS		  := P_PAIS;
  PEREG.CANAL		  := P_CANAL;
  PEREG.SUCURSAL	  := P_SUCURSAL;
  PEREG.FOLIO		  := P_FOLIO;
  PEREG.MONTO		  := P_MONTO;
  PEREG.FECHA_PAGO	  := P_FECHA_PAGO;
  PEREG.TIENDA_DES	  := P_TIENDA_DES;
  PEREG.CANAL_DES	  := P_CANAL_DES;
  PEREG.TIENDA_ORI	  := P_TIENDA_ORI;
  PEREG.CANAL_ORI	  := P_CANAL_ORI;
  PEREG.FOLIO_OPE_ORI := P_FOLIO_OPE_ORI;
  PEREG.NUM_RETEN	  := P_NUM_RETEN;
  PEREG.CUENTA_CARGO  := P_CUENTA_CARGO;
  PEREG.FOLIO_ABONO	  := P_FOLIO_ABONO;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_PAGO_TAZ(PEREG,PSCOD,PSMSG);
END; 
 
PROCEDURE MODIFY_PAGO_TAZ(PEREG IN EBANKING.EBANKING_PAGO_TAZ%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_PAGO_TAZ T SET   
	     T.NOM_ORIGEN    = NVL(PEREG.NOM_ORIGEN, T.NOM_ORIGEN),
	  	 T.NUM_TAZ       = NVL(PEREG.NUM_TAZ, T.NUM_TAZ),
	  	 T.NOM_DESTINO	 = NVL(PEREG.NOM_DESTINO, T.NOM_DESTINO),
	  	 T.TIPO_PAGO	 = NVL(PEREG.TIPO_PAGO, T.TIPO_PAGO),
	  	 T.REFERENCIA	 = NVL(PEREG.REFERENCIA, T.REFERENCIA),
	  	 T.PAIS		     = NVL(PEREG.PAIS, T.PAIS),
	  	 T.CANAL		 = NVL(PEREG.CANAL, T.CANAL),
	  	 T.SUCURSAL	     = NVL(PEREG.SUCURSAL, T.SUCURSAL),
	 	 T.FOLIO		 = NVL(PEREG.FOLIO, T.FOLIO),
	  	 T.MONTO		 = NVL(PEREG.MONTO, T.MONTO),
	  	 T.FECHA_PAGO	 = NVL(PEREG.FECHA_PAGO, T.FECHA_PAGO),
	  	 T.TIENDA_DES	 = NVL(PEREG.TIENDA_DES, T.TIENDA_DES),
	  	 T.CANAL_DES	 = NVL(PEREG.CANAL_DES, T.CANAL_DES),
	  	 T.TIENDA_ORI	 = NVL(PEREG.TIENDA_ORI, T.TIENDA_ORI),
	  	 T.CANAL_ORI	 = NVL(PEREG.CANAL_ORI, T.CANAL_ORI),
	  	 T.FOLIO_OPE_ORI = NVL(PEREG.FOLIO_OPE_ORI, T.FOLIO_OPE_ORI),
	  	 T.NUM_RETEN	 = NVL(PEREG.NUM_RETEN, T.NUM_RETEN),
	  	 T.CUENTA_CARGO  = NVL(PEREG.CUENTA_CARGO, T.CUENTA_CARGO),
	  	 T.FOLIO_ABONO	 = NVL(PEREG.FOLIO_ABONO, T.FOLIO_ABONO)  	
     WHERE T.NUM_CLIENTE = PEREG.NUM_CLIENTE;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
        WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_PAGO_TAZ(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_PAGO_TAZ(P_NUM_CLIENTE   IN EBANKING.EBANKING_PAGO_TAZ.NUM_CLIENTE%TYPE, 
                       	  P_NOM_ORIGEN    IN EBANKING.EBANKING_PAGO_TAZ.NOM_ORIGEN%TYPE, 
                      	  P_NUM_TAZ       IN EBANKING.EBANKING_PAGO_TAZ.NUM_TAZ%TYPE,
                      	  P_NOM_DESTINO   IN EBANKING.EBANKING_PAGO_TAZ.NOM_DESTINO%TYPE,
                      	  P_TIPO_PAGO     IN EBANKING.EBANKING_PAGO_TAZ.TIPO_PAGO%TYPE,
						  P_REFERENCIA    IN EBANKING.EBANKING_PAGO_TAZ.REFERENCIA%TYPE,
						  P_PAIS          IN EBANKING.EBANKING_PAGO_TAZ.PAIS%TYPE,
						  P_CANAL         IN EBANKING.EBANKING_PAGO_TAZ.CANAL%TYPE,
						  P_SUCURSAL   	  IN EBANKING.EBANKING_PAGO_TAZ.SUCURSAL%TYPE,
						  P_FOLIO   	  IN EBANKING.EBANKING_PAGO_TAZ.FOLIO%TYPE,
						  P_MONTO   	  IN EBANKING.EBANKING_PAGO_TAZ.MONTO%TYPE,
						  P_FECHA_PAGO    IN EBANKING.EBANKING_PAGO_TAZ.FECHA_PAGO%TYPE,
						  P_TIENDA_DES    IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_DES%TYPE,
						  P_CANAL_DES     IN EBANKING.EBANKING_PAGO_TAZ.CANAL_DES%TYPE,
						  P_TIENDA_ORI    IN EBANKING.EBANKING_PAGO_TAZ.TIENDA_ORI%TYPE,
						  P_CANAL_ORI     IN EBANKING.EBANKING_PAGO_TAZ.CANAL_ORI%TYPE,
						  P_FOLIO_OPE_ORI IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_OPE_ORI%TYPE,
						  P_NUM_RETEN     IN EBANKING.EBANKING_PAGO_TAZ.NUM_RETEN%TYPE,
						  P_CUENTA_CARGO  IN EBANKING.EBANKING_PAGO_TAZ.CUENTA_CARGO%TYPE,
						  P_FOLIO_ABONO   IN EBANKING.EBANKING_PAGO_TAZ.FOLIO_ABONO%TYPE,
                          PSCOD           OUT NUMBER,
                          PSMSG           OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_PAGO_TAZ%ROWTYPE;
BEGIN
  PEREG.NUM_CLIENTE	  := P_NUM_CLIENTE;
  PEREG.NOM_ORIGEN    := P_NOM_ORIGEN;
  PEREG.NUM_TAZ       := P_NUM_TAZ;
  PEREG.NOM_DESTINO	  := P_NOM_DESTINO;
  PEREG.TIPO_PAGO	  := P_TIPO_PAGO;
  PEREG.REFERENCIA	  := P_REFERENCIA;
  PEREG.PAIS		  := P_PAIS;
  PEREG.CANAL		  := P_CANAL;
  PEREG.SUCURSAL	  := P_SUCURSAL;
  PEREG.FOLIO		  := P_FOLIO;
  PEREG.MONTO		  := P_MONTO;
  PEREG.FECHA_PAGO	  := P_FECHA_PAGO;
  PEREG.TIENDA_DES	  := P_TIENDA_DES;
  PEREG.CANAL_DES	  := P_CANAL_DES;
  PEREG.TIENDA_ORI	  := P_TIENDA_ORI;
  PEREG.CANAL_ORI	  := P_CANAL_ORI;
  PEREG.FOLIO_OPE_ORI := P_FOLIO_OPE_ORI;
  PEREG.NUM_RETEN	  := P_NUM_RETEN;
  PEREG.CUENTA_CARGO  := P_CUENTA_CARGO;
  PEREG.FOLIO_ABONO	  := P_FOLIO_ABONO;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_PAGO_TAZ(PEREG,PSCOD,PSMSG);
END;  

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IUPIFRECUENT
******************************************************************************/
PROCEDURE ADD_IUPIFRECUENT (PEREG IN EBANKING.IUPIFRECUENT%ROWTYPE,
                            PSCOD OUT NUMBER,
                        	PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.IUPIFRECUENT(ID,ID_CLIENTE,APODO,FECHA_MODIFICACION,CUENTA_DESTINO,EMAIL_DESTINO,IP_ORIGEN,
	                                  STATUS,CANAL)
                               VALUES(PEREG.ID,PEREG.ID_CLIENTE,PEREG.APODO,PEREG.FECHA_MODIFICACION,
							          PEREG.CUENTA_DESTINO,PEREG.EMAIL_DESTINO,PEREG.IP_ORIGEN,PEREG.STATUS,
									  PEREG.CANAL);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.IUPIFRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_IUPIFRECUENT (P_ID                 IN EBANKING.IUPIFRECUENT.ID%TYPE, 
                       	    P_ID_CLIENTE    	 IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE, 
                      		P_APODO       		 IN EBANKING.IUPIFRECUENT.APODO%TYPE,
                      		P_CUENTA_DESTINO   	 IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE,
                      		P_EMAIL_DESTINO      IN EBANKING.IUPIFRECUENT.EMAIL_DESTINO%TYPE,
							P_IP_ORIGEN    		 IN EBANKING.IUPIFRECUENT.IP_ORIGEN%TYPE,
							P_STATUS          	 IN EBANKING.IUPIFRECUENT.STATUS%TYPE,
							P_CANAL         	 IN EBANKING.IUPIFRECUENT.CANAL%TYPE,
							P_FECHA_MODIFICACION IN EBANKING.IUPIFRECUENT.FECHA_MODIFICACION%TYPE,						
                      		PSCOD           	 OUT NUMBER,
                      		PSMSG           	 OUT VARCHAR2)IS
PEREG EBANKING.IUPIFRECUENT%ROWTYPE;
BEGIN
  PEREG.ID	               := P_ID;
  PEREG.ID_CLIENTE         := P_ID_CLIENTE;
  PEREG.APODO              := P_APODO;
  PEREG.CUENTA_DESTINO	   := P_CUENTA_DESTINO;
  PEREG.EMAIL_DESTINO	   := P_EMAIL_DESTINO;
  PEREG.IP_ORIGEN	       := P_IP_ORIGEN;
  PEREG.STATUS		       := P_STATUS;
  PEREG.CANAL		       := P_CANAL;
  PEREG.FECHA_MODIFICACION := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_IUPIFRECUENT(PEREG,PSCOD,PSMSG);
END; 
 
PROCEDURE MODIFY_IUPIFRECUENT(PEREG IN EBANKING.IUPIFRECUENT%ROWTYPE,
                              PSCOD OUT NUMBER,
                          	  PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.IUPIFRECUENT I SET   
	     I.ID_CLIENTE         = NVL(PEREG.ID_CLIENTE, I.ID_CLIENTE),
	  	 I.APODO              = NVL(PEREG.APODO, I.APODO),
	  	 I.CUENTA_DESTINO	  = NVL(PEREG.CUENTA_DESTINO, I.CUENTA_DESTINO),
	  	 I.EMAIL_DESTINO	  = NVL(PEREG.EMAIL_DESTINO, I.EMAIL_DESTINO),
	  	 I.IP_ORIGEN		  = NVL(PEREG.IP_ORIGEN, I.IP_ORIGEN),
	  	 I.STATUS		      = NVL(PEREG.STATUS, I.STATUS),
		 I.CANAL		      = NVL(PEREG.CANAL, I.CANAL),
	  	 I.FECHA_MODIFICACION = NVL(PEREG.FECHA_MODIFICACION, I.FECHA_MODIFICACION)
     WHERE I.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
        WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_IUPIFRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_IUPIFRECUENT(P_ID                 IN EBANKING.IUPIFRECUENT.ID%TYPE, 
                       	      P_ID_CLIENTE    	   IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE, 
                      	  	  P_APODO       	   IN EBANKING.IUPIFRECUENT.APODO%TYPE,
                      	  	  P_CUENTA_DESTINO     IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE,
                      	  	  P_EMAIL_DESTINO      IN EBANKING.IUPIFRECUENT.EMAIL_DESTINO%TYPE,
						  	  P_IP_ORIGEN    	   IN EBANKING.IUPIFRECUENT.IP_ORIGEN%TYPE,
						  	  P_STATUS             IN EBANKING.IUPIFRECUENT.STATUS%TYPE,
						  	  P_CANAL         	   IN EBANKING.IUPIFRECUENT.CANAL%TYPE,
						  	  P_FECHA_MODIFICACION IN EBANKING.IUPIFRECUENT.FECHA_MODIFICACION%TYPE,		
                          	  PSCOD           	   OUT NUMBER,
                          	  PSMSG           	   OUT VARCHAR2)IS
PEREG EBANKING.IUPIFRECUENT%ROWTYPE;
BEGIN
  PEREG.ID	               := P_ID;
  PEREG.ID_CLIENTE         := P_ID_CLIENTE;
  PEREG.APODO              := P_APODO;
  PEREG.CUENTA_DESTINO	   := P_CUENTA_DESTINO;
  PEREG.EMAIL_DESTINO	   := P_EMAIL_DESTINO;
  PEREG.IP_ORIGEN	       := P_IP_ORIGEN;
  PEREG.STATUS		       := P_STATUS;
  PEREG.CANAL		       := P_CANAL;
  PEREG.FECHA_MODIFICACION := P_FECHA_MODIFICACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_IUPIFRECUENT(PEREG,PSCOD,PSMSG);
END;  

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE COMPRATA_TELEFONOSFRECUENTES
******************************************************************************/
PROCEDURE ADD_BUYTA_TELFRECUEN (PEREG IN EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE,
                                PSCOD OUT NUMBER,
                        	    PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.COMPRATA_TELEFONOSFRECUENTES(CLIENT,CARRIER,TELEPHONE,REFERENCE,ULTIMA_ACTUALIZACION,
	                                                  STATUS,CANAL)
                                               VALUES(PEREG.CLIENT, PEREG.CARRIER, PEREG.TELEPHONE, PEREG.REFERENCE,
											          PEREG.ULTIMA_ACTUALIZACION,PEREG.STATUS,PEREG.CANAL);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_PAY_BUY.ADD_BUYTA_TELFRECUEN(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_BUYTA_TELFRECUEN (P_CLIENT               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CLIENT%TYPE, 
                       	        P_CARRIER    	       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CARRIER%TYPE, 
                      			P_TELEPHONE       	   IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.TELEPHONE%TYPE,
                      			P_REFERENCE   	       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.REFERENCE%TYPE,
                      			P_STATUS               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.STATUS%TYPE,
								P_CANAL    		       IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CANAL%TYPE,
								P_ULTIMA_ACTUALIZACION IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.ULTIMA_ACTUALIZACION%TYPE,					
                      			PSCOD           	   OUT NUMBER,
                      			PSMSG           	   OUT VARCHAR2)IS
PEREG EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE;
BEGIN
  PEREG.CLIENT	             := P_CLIENT;
  PEREG.CARRIER              := P_CARRIER;
  PEREG.TELEPHONE            := P_TELEPHONE;
  PEREG.REFERENCE	         := P_REFERENCE;
  PEREG.STATUS	             := P_STATUS;
  PEREG.CANAL		         := P_CANAL;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.ADD_BUYTA_TELFRECUEN(PEREG,PSCOD,PSMSG);
END; 
 
PROCEDURE MODIFY_BUYTA_TELFRECUEN(PEREG IN EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE,
                                  PSCOD OUT NUMBER,
                          	      PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.COMPRATA_TELEFONOSFRECUENTES T SET   
	     T.CARRIER              = NVL(PEREG.CARRIER, T.CARRIER),
		 T.TELEPHONE            = NVL(PEREG.TELEPHONE, T.TELEPHONE),
		 T.REFERENCE         	= NVL(PEREG.REFERENCE, T.REFERENCE),
		 T.STATUS         		= NVL(PEREG.STATUS, T.STATUS),
		 T.CANAL                = NVL(PEREG.CANAL, T.CANAL),
		 T.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION, T.ULTIMA_ACTUALIZACION)
     WHERE T.CLIENT = PEREG.CLIENT;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
        WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_PAY_BUY.MODIFY_IUPIFRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_BUYTA_TELFRECUEN(P_CLIENT               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CLIENT%TYPE, 
                       	          P_CARRIER    	       	 IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CARRIER%TYPE, 
                      			  P_TELEPHONE       	 IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.TELEPHONE%TYPE,
                      			  P_REFERENCE   	     IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.REFERENCE%TYPE,
                      			  P_STATUS               IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.STATUS%TYPE,
								  P_CANAL    		     IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.CANAL%TYPE,
								  P_ULTIMA_ACTUALIZACION IN EBANKING.COMPRATA_TELEFONOSFRECUENTES.ULTIMA_ACTUALIZACION%TYPE,		
                          	  	  PSCOD           	     OUT NUMBER,
                          	  	  PSMSG           	     OUT VARCHAR2)IS
PEREG EBANKING.COMPRATA_TELEFONOSFRECUENTES%ROWTYPE;
BEGIN
  PEREG.CLIENT	             := P_CLIENT;
  PEREG.CARRIER              := P_CARRIER;
  PEREG.TELEPHONE            := P_TELEPHONE;
  PEREG.REFERENCE	         := P_REFERENCE;
  PEREG.STATUS	             := P_STATUS;
  PEREG.CANAL		         := P_CANAL;
  PEREG.ULTIMA_ACTUALIZACION := P_ULTIMA_ACTUALIZACION;
  EBANKING.PKG_CORE_GEN_PAY_BUY.MODIFY_BUYTA_TELFRECUEN(PEREG,PSCOD,PSMSG);
END; 
							  
END PKG_CORE_GEN_PAY_BUY;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY          PKG_CORE_GEN_RECORDS AS
/******************************************************************************
   NAME:       PPKG_CORE_GEN_RECORDS  //REGISTROS
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_BITACORA_TRAN (PEREG IN EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_BITACORA_TRAN(ID,NUM_CLIENTE,ID_CAT_OPERACION,IP,CTA_ORIGEN,CTA_DESTINO,
                                                FECHA_OPER,MONTO,FOLIO,METODO_CONFIR,DETALLE,NOMBRE_CLIENTE,DETALLE2) 
                                         VALUES(PEREG.ID,PEREG.NUM_CLIENTE,PEREG.ID_CAT_OPERACION,PEREG.IP,
							                    PEREG.CTA_ORIGEN,PEREG.CTA_DESTINO,PEREG.FECHA_OPER,PEREG.MONTO,
							            		PEREG.FOLIO,PEREG.METODO_CONFIR,PEREG.DETALLE,PEREG.NOMBRE_CLIENTE,
							            		PEREG.DETALLE2);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_RECORDS.ADD_BITACORA_TRAN(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_BITACORA_TRAN (P_ID               IN EBANKING.EBANKING_BITACORA_TRAN.ID%TYPE, 
                             P_NUM_CLIENTE      IN EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE, 
                             P_ID_CAT_OPERACION IN EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE,
                             P_IP             	IN EBANKING.EBANKING_BITACORA_TRAN.IP%TYPE,
                       		 P_CTA_ORIGEN    	IN EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE,
                       		 P_CTA_DESTINO      IN EBANKING.EBANKING_BITACORA_TRAN.CTA_DESTINO%TYPE,
                       		 P_FECHA_OPER    	IN EBANKING.EBANKING_BITACORA_TRAN.FECHA_OPER%TYPE,
                       		 P_MONTO       		IN EBANKING.EBANKING_BITACORA_TRAN.MONTO%TYPE,
              				 P_FOLIO       		IN EBANKING.EBANKING_BITACORA_TRAN.FOLIO%TYPE,
              				 P_METODO_CONFIR    IN EBANKING.EBANKING_BITACORA_TRAN.METODO_CONFIR%TYPE,
              				 P_DETALLE      	IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE%TYPE,
              				 P_NOMBRE_CLIENTE   IN EBANKING.EBANKING_BITACORA_TRAN.NOMBRE_CLIENTE%TYPE,
              				 P_DETALLE2      	IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE2%TYPE,
                             PSCOD              OUT NUMBER,
                             PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.NUM_CLIENTE      := P_NUM_CLIENTE;
  PEREG.ID_CAT_OPERACION := P_ID_CAT_OPERACION;
  PEREG.IP      		 := P_IP;
  PEREG.CTA_ORIGEN       := P_CTA_ORIGEN;
  PEREG.CTA_DESTINO      := P_CTA_DESTINO;
  PEREG.FECHA_OPER    	 := P_FECHA_OPER;
  PEREG.MONTO      		 := P_MONTO;
  PEREG.FOLIO      		 := P_FOLIO;
  PEREG.METODO_CONFIR    := P_METODO_CONFIR;
  PEREG.DETALLE     	 := P_DETALLE;
  PEREG.NOMBRE_CLIENTE   := P_NOMBRE_CLIENTE;
  PEREG.DETALLE2         := P_DETALLE2;
  EBANKING.PKG_CORE_GEN_RECORDS.ADD_BITACORA_TRAN(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_BITACORA_TRAN(PEREG IN  EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_BITACORA_TRAN B SET   
         B.NUM_CLIENTE      = NVL(PEREG.NUM_CLIENTE,B.NUM_CLIENTE),
         B.ID_CAT_OPERACION = NVL(PEREG.ID_CAT_OPERACION,B.ID_CAT_OPERACION),
   		 B.IP           	= NVL(PEREG.IP,B.IP),
   		 B.CTA_ORIGEN       = NVL(PEREG.CTA_ORIGEN,B.CTA_ORIGEN),
   		 B.CTA_DESTINO      = NVL(PEREG.CTA_DESTINO,B.CTA_DESTINO),
   		 B.FECHA_OPER       = NVL(PEREG.FECHA_OPER,B.FECHA_OPER),
   		 B.MONTO          	= NVL(PEREG.MONTO,B.MONTO),
   		 B.FOLIO          	= NVL(PEREG.FOLIO,B.FOLIO),
   		 B.METODO_CONFIR    = NVL(PEREG.METODO_CONFIR,B.METODO_CONFIR),
   		 B.DETALLE          = NVL(PEREG.DETALLE,B.DETALLE),
   		 B.NOMBRE_CLIENTE   = NVL(PEREG.NOMBRE_CLIENTE,B.NOMBRE_CLIENTE),
   		 B.DETALLE2       	= NVL(PEREG.DETALLE2,B.DETALLE2)
     WHERE B.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_RECORDS.MODIFY_BITACORA_TRAN(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_BITACORA_TRAN(P_ID               IN EBANKING.EBANKING_BITACORA_TRAN.ID%TYPE, 
                               P_NUM_CLIENTE      IN EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE, 
                               P_ID_CAT_OPERACION IN EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE,
                               P_IP            	  IN EBANKING.EBANKING_BITACORA_TRAN.IP%TYPE,
                       		   P_CTA_ORIGEN    	  IN EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE,
                       		   P_CTA_DESTINO      IN EBANKING.EBANKING_BITACORA_TRAN.CTA_DESTINO%TYPE,
                       		   P_FECHA_OPER    	  IN EBANKING.EBANKING_BITACORA_TRAN.FECHA_OPER%TYPE,
                       		   P_MONTO       	  IN EBANKING.EBANKING_BITACORA_TRAN.MONTO%TYPE,
              				   P_FOLIO            IN EBANKING.EBANKING_BITACORA_TRAN.FOLIO%TYPE,
              				   P_METODO_CONFIR    IN EBANKING.EBANKING_BITACORA_TRAN.METODO_CONFIR%TYPE,
              				   P_DETALLE      	  IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE%TYPE,
              				   P_NOMBRE_CLIENTE   IN EBANKING.EBANKING_BITACORA_TRAN.NOMBRE_CLIENTE%TYPE,
              				   P_DETALLE2      	  IN EBANKING.EBANKING_BITACORA_TRAN.DETALLE2%TYPE,
                               PSCOD              OUT NUMBER,
                               PSMSG              OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_BITACORA_TRAN%ROWTYPE;
BEGIN
  PEREG.ID               := P_ID;
  PEREG.NUM_CLIENTE      := P_NUM_CLIENTE;
  PEREG.ID_CAT_OPERACION := P_ID_CAT_OPERACION;
  PEREG.IP      		 := P_IP;
  PEREG.CTA_ORIGEN       := P_CTA_ORIGEN;
  PEREG.CTA_DESTINO      := P_CTA_DESTINO;
  PEREG.FECHA_OPER    	 := P_FECHA_OPER;
  PEREG.MONTO      		 := P_MONTO;
  PEREG.FOLIO      		 := P_FOLIO;
  PEREG.METODO_CONFIR    := P_METODO_CONFIR;
  PEREG.DETALLE     	 := P_DETALLE;
  PEREG.NOMBRE_CLIENTE   := P_NOMBRE_CLIENTE;
  PEREG.DETALLE2         := P_DETALLE2;
  EBANKING.PKG_CORE_GEN_RECORDS.MODIFY_BITACORA_TRAN(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE OPERACIONES_FRECUENTES
******************************************************************************/
PROCEDURE ADD_OPER_FRECUENT (PEREG IN EBANKING.OPERACIONES_FREC%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.OPERACIONES_FREC(ID_OPERACION,USUARIO,CADENA_DATOS,ALIAS,OPERACION,
	                                            ULTIMA_MODIFICACION,USUARIO_MODIFICO) 
                                         VALUES(PEREG.ID_OPERACION,PEREG.USUARIO,PEREG.CADENA_DATOS,PEREG.ALIAS,
										        PEREG.OPERACION,PEREG.ULTIMA_MODIFICACION,PEREG.USUARIO_MODIFICO);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_RECORDS.ADD_OPER_FRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_OPER_FRECUENT (P_ID_OPERACION        IN EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE, 
                             P_USUARIO      	   IN EBANKING.OPERACIONES_FREC.USUARIO%TYPE, 
                             P_CADENA_DATOS 	   IN EBANKING.OPERACIONES_FREC.CADENA_DATOS%TYPE,
                             P_ALIAS               IN EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
                       		 P_OPERACION    	   IN EBANKING.OPERACIONES_FREC.OPERACION%TYPE,
                       		 P_ULTIMA_MODIFICACION IN EBANKING.OPERACIONES_FREC.ULTIMA_MODIFICACION%TYPE,
                       		 P_USUARIO_MODIFICO    IN EBANKING.OPERACIONES_FREC.USUARIO_MODIFICO%TYPE,
                             PSCOD                 OUT NUMBER,
                             PSMSG                 OUT VARCHAR2)IS
PEREG EBANKING.OPERACIONES_FREC%ROWTYPE;
BEGIN
  PEREG.ID_OPERACION        := P_ID_OPERACION;
  PEREG.USUARIO          	:= P_USUARIO;
  PEREG.CADENA_DATOS     	:= P_CADENA_DATOS;
  PEREG.ALIAS      		 	:= P_ALIAS;
  PEREG.OPERACION           := P_OPERACION;
  PEREG.ULTIMA_MODIFICACION := P_ULTIMA_MODIFICACION;
  PEREG.USUARIO_MODIFICO   	:= P_USUARIO_MODIFICO;
  EBANKING.PKG_CORE_GEN_RECORDS.ADD_OPER_FRECUENT(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_OPER_FRECUENT(PEREG IN  EBANKING.OPERACIONES_FREC%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.OPERACIONES_FREC O SET   
         O.USUARIO             = NVL(PEREG.USUARIO,O.USUARIO),
   		 O.CADENA_DATOS        = NVL(PEREG.CADENA_DATOS,O.CADENA_DATOS),
   		 O.ALIAS          	   = NVL(PEREG.ALIAS,O.ALIAS),
   		 O.OPERACION           = NVL(PEREG.OPERACION,O.OPERACION),
   		 O.ULTIMA_MODIFICACION = NVL(PEREG.ULTIMA_MODIFICACION,O.ULTIMA_MODIFICACION),
   		 O.USUARIO_MODIFICO    = NVL(PEREG.USUARIO_MODIFICO,O.USUARIO_MODIFICO)
     WHERE O.ID_OPERACION      = PEREG.ID_OPERACION;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_RECORDS.MODIFY_OPER_FRECUENT(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_OPER_FRECUENT(P_ID_OPERACION        IN EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE, 
                               P_USUARIO      	   	 IN EBANKING.OPERACIONES_FREC.USUARIO%TYPE, 
                               P_CADENA_DATOS 	     IN EBANKING.OPERACIONES_FREC.CADENA_DATOS%TYPE,
                               P_ALIAS               IN EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
                       		   P_OPERACION    	     IN EBANKING.OPERACIONES_FREC.OPERACION%TYPE,
                       		   P_ULTIMA_MODIFICACION IN EBANKING.OPERACIONES_FREC.ULTIMA_MODIFICACION%TYPE,
                       		   P_USUARIO_MODIFICO    IN EBANKING.OPERACIONES_FREC.USUARIO_MODIFICO%TYPE,
                               PSCOD              	 OUT NUMBER,
                               PSMSG              	 OUT VARCHAR2)IS
PEREG EBANKING.OPERACIONES_FREC%ROWTYPE;
BEGIN
  PEREG.ID_OPERACION        := P_ID_OPERACION;
  PEREG.USUARIO          	:= P_USUARIO;
  PEREG.CADENA_DATOS     	:= P_CADENA_DATOS;
  PEREG.ALIAS      		 	:= P_ALIAS;
  PEREG.OPERACION           := P_OPERACION;
  PEREG.ULTIMA_MODIFICACION := P_ULTIMA_MODIFICACION;
  PEREG.USUARIO_MODIFICO   	:= P_USUARIO_MODIFICO;
  EBANKING.PKG_CORE_GEN_RECORDS.MODIFY_OPER_FRECUENT(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE MON_TRANSACCION
******************************************************************************/
PROCEDURE ADD_MON_TRAN (PEREG IN EBANKINGGUA.MON_TRANSACCION%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKINGGUA.MON_TRANSACCION(ID,CUENTAORIGEN,CUENTADESTINO,MONTO,IP,NOMBREORIGEN,NOMBREDESTINO,
		   		                         TEXTOORIGEN,TEXTODESTINO,FECHARETENCION,RETENCIONREQUEST,RETENCIONRESPONSE,
										 LIBERACIONREQUEST,LIBERACIONRESPONSE,FECHALIBERACION,LOGINORIGEN,
										 IDUSUARIOLIBERACION,IDSTATUS_TRANSACCION,FOLIO ,IDEBANKING,PASWORD,
										 ERROR,EMAIL) 
                                  VALUES(PEREG.ID,PEREG.CUENTAORIGEN,PEREG.CUENTADESTINO,PEREG.MONTO,PEREG.IP,
								         PEREG.NOMBREORIGEN,PEREG.NOMBREDESTINO,PEREG.TEXTOORIGEN,PEREG.TEXTODESTINO,
										 PEREG.FECHARETENCION,PEREG.RETENCIONREQUEST,PEREG.RETENCIONRESPONSE,
										 PEREG.LIBERACIONREQUEST,PEREG.LIBERACIONRESPONSE,PEREG.FECHALIBERACION,
										 PEREG.LOGINORIGEN,PEREG.IDUSUARIOLIBERACION,PEREG.IDSTATUS_TRANSACCION,
										 PEREG.FOLIO,PEREG.IDEBANKING,PEREG.PASWORD,PEREG.ERROR,PEREG.EMAIL);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_RECORDS.ADD_MON_TRAN(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_MON_TRAN (P_ID                   IN EBANKINGGUA.MON_TRANSACCION.ID%TYPE, 
                        P_CUENTAORIGEN         IN EBANKINGGUA.MON_TRANSACCION.CUENTAORIGEN%TYPE, 
                        P_CUENTADESTINO        IN EBANKINGGUA.MON_TRANSACCION.CUENTADESTINO%TYPE,
						P_MONTO                IN EBANKINGGUA.MON_TRANSACCION.MONTO%TYPE,
						P_IP                   IN EBANKINGGUA.MON_TRANSACCION.IP%TYPE,
						P_NOMBREORIGEN         IN EBANKINGGUA.MON_TRANSACCION.NOMBREORIGEN%TYPE,
						P_NOMBREDESTINO        IN EBANKINGGUA.MON_TRANSACCION.NOMBREDESTINO%TYPE,
						P_TEXTOORIGEN          IN EBANKINGGUA.MON_TRANSACCION.TEXTOORIGEN%TYPE,
						P_TEXTODESTINO         IN EBANKINGGUA.MON_TRANSACCION.TEXTODESTINO%TYPE,
						P_FECHARETENCION       IN EBANKINGGUA.MON_TRANSACCION.FECHARETENCION%TYPE,
						P_RETENCIONREQUEST     IN EBANKINGGUA.MON_TRANSACCION.RETENCIONREQUEST%TYPE,
						P_RETENCIONRESPONSE    IN EBANKINGGUA.MON_TRANSACCION.RETENCIONRESPONSE%TYPE,
						P_LIBERACIONREQUEST    IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONREQUEST%TYPE,
						P_LIBERACIONRESPONSE   IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONRESPONSE%TYPE,
						P_FECHALIBERACION      IN EBANKINGGUA.MON_TRANSACCION.FECHALIBERACION%TYPE,
						P_LOGINORIGEN          IN EBANKINGGUA.MON_TRANSACCION.LOGINORIGEN%TYPE,
						P_IDUSUARIOLIBERACION  IN EBANKINGGUA.MON_TRANSACCION.IDUSUARIOLIBERACION%TYPE,
						P_IDSTATUS_TRANSACCION IN EBANKINGGUA.MON_TRANSACCION.IDSTATUS_TRANSACCION%TYPE,
						P_FOLIO     		   IN EBANKINGGUA.MON_TRANSACCION.FOLIO%TYPE,
						P_IDEBANKING     	   IN EBANKINGGUA.MON_TRANSACCION.IDEBANKING%TYPE,
						P_PASWORD     		   IN EBANKINGGUA.MON_TRANSACCION.PASWORD%TYPE,
						P_ERROR     		   IN EBANKINGGUA.MON_TRANSACCION.ERROR%TYPE,
						P_EMAIL     		   IN EBANKINGGUA.MON_TRANSACCION.EMAIL%TYPE,
                        PSCOD              	   OUT NUMBER,
                        PSMSG              	   OUT VARCHAR2)IS
PEREG EBANKINGGUA.MON_TRANSACCION%ROWTYPE;
BEGIN
  PEREG.ID                   := P_ID;
  PEREG.CUENTAORIGEN      	 := P_CUENTAORIGEN;
  PEREG.CUENTADESTINO      	 := P_CUENTADESTINO;
  PEREG.MONTO      		 	 := P_MONTO;
  PEREG.IP      		 	 := P_IP;
  PEREG.NOMBREORIGEN      	 := P_NOMBREORIGEN;
  PEREG.NOMBREDESTINO      	 := P_NOMBREDESTINO;
  PEREG.TEXTOORIGEN      	 := P_TEXTOORIGEN;
  PEREG.TEXTODESTINO         := P_TEXTODESTINO;
  PEREG.FECHARETENCION       := P_FECHARETENCION;
  PEREG.RETENCIONREQUEST     := P_RETENCIONREQUEST;
  PEREG.RETENCIONRESPONSE    := P_RETENCIONRESPONSE;
  PEREG.LIBERACIONREQUEST    := P_LIBERACIONREQUEST;
  PEREG.LIBERACIONRESPONSE   := P_LIBERACIONRESPONSE;
  PEREG.FECHALIBERACION      := P_FECHALIBERACION;
  PEREG.LOGINORIGEN      	 := P_LOGINORIGEN;
  PEREG.IDUSUARIOLIBERACION  := P_IDUSUARIOLIBERACION;
  PEREG.IDSTATUS_TRANSACCION := P_IDSTATUS_TRANSACCION;
  PEREG.FOLIO      		     := P_FOLIO;
  PEREG.IDEBANKING      	 := P_IDEBANKING;
  PEREG.PASWORD      		 := P_PASWORD;
  PEREG.ERROR      		 	 := P_ERROR;
  PEREG.EMAIL      		 	 := P_EMAIL;
  EBANKING.PKG_CORE_GEN_RECORDS.ADD_MON_TRAN(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_MON_TRAN(PEREG IN  EBANKINGGUA.MON_TRANSACCION%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKINGGUA.MON_TRANSACCION M SET  
	     M.CUENTAORIGEN         = NVL(PEREG.CUENTAORIGEN,M.CUENTAORIGEN),
   		 M.CUENTADESTINO        = NVL(PEREG.CUENTADESTINO,M.CUENTADESTINO),
   		 M.MONTO          	    = NVL(PEREG.MONTO,M.MONTO),
   		 M.IP          	        = NVL(PEREG.IP,M.IP),
		 M.NOMBREORIGEN         = NVL(PEREG.NOMBREORIGEN,M.NOMBREORIGEN),
		 M.NOMBREDESTINO        = NVL(PEREG.NOMBREDESTINO,M.NOMBREDESTINO),
		 M.TEXTOORIGEN          = NVL(PEREG.TEXTOORIGEN,M.TEXTOORIGEN),
		 M.TEXTODESTINO         = NVL(PEREG.TEXTODESTINO,M.TEXTODESTINO),
		 M.FECHARETENCION       = NVL(PEREG.FECHARETENCION,M.FECHARETENCION),
		 M.RETENCIONREQUEST     = NVL(PEREG.RETENCIONREQUEST,M.RETENCIONREQUEST),
		 M.RETENCIONRESPONSE    = NVL(PEREG.RETENCIONRESPONSE,M.RETENCIONRESPONSE),
		 M.LIBERACIONREQUEST    = NVL(PEREG.LIBERACIONREQUEST,M.LIBERACIONREQUEST),
		 M.LIBERACIONRESPONSE   = NVL(PEREG.LIBERACIONRESPONSE,M.LIBERACIONRESPONSE),
		 M.FECHALIBERACION      = NVL(PEREG.FECHALIBERACION,M.FECHALIBERACION),
		 M.LOGINORIGEN          = NVL(PEREG.LOGINORIGEN,M.LOGINORIGEN),
		 M.IDUSUARIOLIBERACION  = NVL(PEREG.IDUSUARIOLIBERACION,M.IDUSUARIOLIBERACION),
		 M.IDSTATUS_TRANSACCION = NVL(PEREG.IDSTATUS_TRANSACCION,M.IDSTATUS_TRANSACCION),
		 M.FOLIO          	    = NVL(PEREG.MONTO,M.FOLIO),
		 M.IDEBANKING          	= NVL(PEREG.IDEBANKING,M.IDEBANKING),
		 M.PASWORD          	= NVL(PEREG.PASWORD,M.PASWORD),
		 M.ERROR          	    = NVL(PEREG.ERROR,M.ERROR),
		 M.EMAIL          	    = NVL(PEREG.EMAIL,M.EMAIL)  
     WHERE M.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_RECORDS.MODIFY_MON_TRAN(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_MON_TRAN(P_ID                   IN EBANKINGGUA.MON_TRANSACCION.ID%TYPE, 
                          P_CUENTAORIGEN         IN EBANKINGGUA.MON_TRANSACCION.CUENTAORIGEN%TYPE, 
                          P_CUENTADESTINO        IN EBANKINGGUA.MON_TRANSACCION.CUENTADESTINO%TYPE,
						  P_MONTO                IN EBANKINGGUA.MON_TRANSACCION.MONTO%TYPE,
						  P_IP                   IN EBANKINGGUA.MON_TRANSACCION.IP%TYPE,
						  P_NOMBREORIGEN         IN EBANKINGGUA.MON_TRANSACCION.NOMBREORIGEN%TYPE,
						  P_NOMBREDESTINO        IN EBANKINGGUA.MON_TRANSACCION.NOMBREDESTINO%TYPE,
						  P_TEXTOORIGEN          IN EBANKINGGUA.MON_TRANSACCION.TEXTOORIGEN%TYPE,
						  P_TEXTODESTINO         IN EBANKINGGUA.MON_TRANSACCION.TEXTODESTINO%TYPE,
						  P_FECHARETENCION       IN EBANKINGGUA.MON_TRANSACCION.FECHARETENCION%TYPE,
						  P_RETENCIONREQUEST     IN EBANKINGGUA.MON_TRANSACCION.RETENCIONREQUEST%TYPE,
						  P_RETENCIONRESPONSE    IN EBANKINGGUA.MON_TRANSACCION.RETENCIONRESPONSE%TYPE,
						  P_LIBERACIONREQUEST    IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONREQUEST%TYPE,
						  P_LIBERACIONRESPONSE   IN EBANKINGGUA.MON_TRANSACCION.LIBERACIONRESPONSE%TYPE,
						  P_FECHALIBERACION      IN EBANKINGGUA.MON_TRANSACCION.FECHALIBERACION%TYPE,
						  P_LOGINORIGEN          IN EBANKINGGUA.MON_TRANSACCION.LOGINORIGEN%TYPE,
						  P_IDUSUARIOLIBERACION  IN EBANKINGGUA.MON_TRANSACCION.IDUSUARIOLIBERACION%TYPE,
						  P_IDSTATUS_TRANSACCION IN EBANKINGGUA.MON_TRANSACCION.IDSTATUS_TRANSACCION%TYPE,
						  P_FOLIO     		   	 IN EBANKINGGUA.MON_TRANSACCION.FOLIO%TYPE,
						  P_IDEBANKING     	   	 IN EBANKINGGUA.MON_TRANSACCION.IDEBANKING%TYPE,
						  P_PASWORD     		 IN EBANKINGGUA.MON_TRANSACCION.PASWORD%TYPE,
						  P_ERROR     		   	 IN EBANKINGGUA.MON_TRANSACCION.ERROR%TYPE,
						  P_EMAIL     		   	 IN EBANKINGGUA.MON_TRANSACCION.EMAIL%TYPE,
                          PSCOD              	 OUT NUMBER,
                          PSMSG              	 OUT VARCHAR2)IS
PEREG EBANKINGGUA.MON_TRANSACCION%ROWTYPE;
BEGIN
  PEREG.ID                   := P_ID;
  PEREG.CUENTAORIGEN      	 := P_CUENTAORIGEN;
  PEREG.CUENTADESTINO      	 := P_CUENTADESTINO;
  PEREG.MONTO      		 	 := P_MONTO;
  PEREG.IP      		 	 := P_IP;
  PEREG.NOMBREORIGEN      	 := P_NOMBREORIGEN;
  PEREG.NOMBREDESTINO      	 := P_NOMBREDESTINO;
  PEREG.TEXTOORIGEN      	 := P_TEXTOORIGEN;
  PEREG.TEXTODESTINO         := P_TEXTODESTINO;
  PEREG.FECHARETENCION       := P_FECHARETENCION;
  PEREG.RETENCIONREQUEST     := P_RETENCIONREQUEST;
  PEREG.RETENCIONRESPONSE    := P_RETENCIONRESPONSE;
  PEREG.LIBERACIONREQUEST    := P_LIBERACIONREQUEST;
  PEREG.LIBERACIONRESPONSE   := P_LIBERACIONRESPONSE;
  PEREG.FECHALIBERACION      := P_FECHALIBERACION;
  PEREG.LOGINORIGEN      	 := P_LOGINORIGEN;
  PEREG.IDUSUARIOLIBERACION  := P_IDUSUARIOLIBERACION;
  PEREG.IDSTATUS_TRANSACCION := P_IDSTATUS_TRANSACCION;
  PEREG.FOLIO      		     := P_FOLIO;
  PEREG.IDEBANKING      	 := P_IDEBANKING;
  PEREG.PASWORD      		 := P_PASWORD;
  PEREG.ERROR      		 	 := P_ERROR;
  PEREG.EMAIL      		 	 := P_EMAIL;
  EBANKING.PKG_CORE_GEN_RECORDS.ADD_MON_TRAN(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_TOKEN_PREVENCION
******************************************************************************/
PROCEDURE ADD_TOKEN_PREVEN (PEREG IN EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_TOKEN_PREVENCION(ID,TITULAR,EMAIL,IP,NUM_SERIE_TOKEN,TEL_PARTICULAR,
	                                               TEL_CELULAR,CARRIER_CEL,FEC_HORA_OPERACION,NUM_CLIENTE,
												   ESTATUS,MOTIVO_PREV_FRAUDE,ALIAS,FEC_PREV_FRAU,
												   ID_USER_PREV_FRAU,NUM_INTENTOS,OBSERVACION,FEC_PRI_INTENTO,
												   FEC_ULT_INTENTO,TIPO_OPERACION,SISTEMA,IDPAIS) 
                                            VALUES(PEREG.ID,PEREG.TITULAR,PEREG.EMAIL,PEREG.IP,PEREG.NUM_SERIE_TOKEN,
											       PEREG.TEL_PARTICULAR,PEREG.TEL_CELULAR,PEREG.CARRIER_CEL,
												   PEREG.FEC_HORA_OPERACION,PEREG.NUM_CLIENTE,PEREG.ESTATUS,
												   PEREG.MOTIVO_PREV_FRAUDE,PEREG.ALIAS,PEREG.FEC_PREV_FRAU,
												   PEREG.ID_USER_PREV_FRAU,PEREG.NUM_INTENTOS,PEREG.OBSERVACION,
												   PEREG.FEC_PRI_INTENTO,PEREG.FEC_ULT_INTENTO,PEREG.TIPO_OPERACION,
												   PEREG.SISTEMA,PEREG.IDPAIS);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_RECORDS.ADD_MON_TRAN(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_TOKEN_PREVEN (P_ID                 IN EBANKING.EBANKING_TOKEN_PREVENCION.ID%TYPE, 
                            P_TITULAR         	 IN EBANKING.EBANKING_TOKEN_PREVENCION.TITULAR%TYPE, 
                        	P_EMAIL        		 IN EBANKING.EBANKING_TOKEN_PREVENCION.EMAIL%TYPE,
							P_IP                 IN EBANKING.EBANKING_TOKEN_PREVENCION.IP%TYPE,
							P_NUM_SERIE_TOKEN    IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_SERIE_TOKEN%TYPE,	
							P_TEL_PARTICULAR     IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_PARTICULAR%TYPE,
							P_TEL_CELULAR        IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_CELULAR%TYPE,
							P_CARRIER_CEL        IN EBANKING.EBANKING_TOKEN_PREVENCION.CARRIER_CEL%TYPE,
							P_FEC_HORA_OPERACION IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_HORA_OPERACION%TYPE,
							P_NUM_CLIENTE        IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_CLIENTE%TYPE,
							P_ESTATUS            IN EBANKING.EBANKING_TOKEN_PREVENCION.ESTATUS%TYPE,
							P_MOTIVO_PREV_FRAUDE IN EBANKING.EBANKING_TOKEN_PREVENCION.MOTIVO_PREV_FRAUDE%TYPE,
							P_ALIAS              IN EBANKING.EBANKING_TOKEN_PREVENCION.ALIAS%TYPE,
							P_FEC_PREV_FRAU      IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PREV_FRAU%TYPE,
							P_ID_USER_PREV_FRAU  IN EBANKING.EBANKING_TOKEN_PREVENCION.ID_USER_PREV_FRAU%TYPE,
							P_NUM_INTENTOS       IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_INTENTOS%TYPE,
							P_OBSERVACION        IN EBANKING.EBANKING_TOKEN_PREVENCION.OBSERVACION%TYPE,
							P_FEC_PRI_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PRI_INTENTO%TYPE,
							P_FEC_ULT_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_ULT_INTENTO%TYPE,
							P_TIPO_OPERACION     IN EBANKING.EBANKING_TOKEN_PREVENCION.TIPO_OPERACION%TYPE,
							P_SISTEMA            IN EBANKING.EBANKING_TOKEN_PREVENCION.SISTEMA%TYPE,
							P_IDPAIS             IN EBANKING.EBANKING_TOKEN_PREVENCION.IDPAIS%TYPE,					
                        	PSCOD              	 OUT NUMBER,
                        	PSMSG              	 OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE;
BEGIN
  PEREG.ID                 := P_ID;
  PEREG.TITULAR      	   := P_TITULAR;
  PEREG.EMAIL      	       := P_EMAIL;
  PEREG.IP      	       := P_IP;
  PEREG.NUM_SERIE_TOKEN    := P_NUM_SERIE_TOKEN;
  PEREG.TEL_PARTICULAR     := P_TEL_PARTICULAR;
  PEREG.TEL_CELULAR        := P_TEL_CELULAR;
  PEREG.CARRIER_CEL        := P_CARRIER_CEL;
  PEREG.FEC_HORA_OPERACION := P_FEC_HORA_OPERACION;
  PEREG.NUM_CLIENTE        := P_NUM_CLIENTE;
  PEREG.ESTATUS      	   := P_ESTATUS;
  PEREG.MOTIVO_PREV_FRAUDE := P_MOTIVO_PREV_FRAUDE;
  PEREG.ALIAS      	       := P_ALIAS;
  PEREG.FEC_PREV_FRAU      := P_FEC_PREV_FRAU;
  PEREG.ID_USER_PREV_FRAU  := P_ID_USER_PREV_FRAU;
  PEREG.NUM_INTENTOS       := P_NUM_INTENTOS;
  PEREG.OBSERVACION        := P_OBSERVACION;
  PEREG.FEC_PRI_INTENTO    := P_FEC_PRI_INTENTO;
  PEREG.FEC_ULT_INTENTO    := P_FEC_ULT_INTENTO;
  PEREG.TIPO_OPERACION     := P_TIPO_OPERACION;
  PEREG.SISTEMA      	   := P_SISTEMA;
  PEREG.IDPAIS      	   := P_IDPAIS;
  EBANKING.PKG_CORE_GEN_RECORDS.ADD_TOKEN_PREVEN(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_TOKEN_PREVEN(PEREG IN  EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_TOKEN_PREVENCION T SET  
	     T.TITULAR            = NVL(PEREG.TITULAR,T.TITULAR),
   		 T.EMAIL              = NVL(PEREG.EMAIL,T.EMAIL),
		 T.IP                 = NVL(PEREG.IP,T.IP),
		 T.NUM_SERIE_TOKEN    = NVL(PEREG.NUM_SERIE_TOKEN,T.NUM_SERIE_TOKEN),
		 T.TEL_PARTICULAR     = NVL(PEREG.TEL_PARTICULAR,T.TEL_PARTICULAR),
		 T.TEL_CELULAR        = NVL(PEREG.TEL_CELULAR,T.TEL_CELULAR),
		 T.CARRIER_CEL        = NVL(PEREG.CARRIER_CEL,T.CARRIER_CEL),
		 T.FEC_HORA_OPERACION = NVL(PEREG.FEC_HORA_OPERACION,T.FEC_HORA_OPERACION),
		 T.NUM_CLIENTE        = NVL(PEREG.NUM_CLIENTE,T.NUM_CLIENTE),
		 T.ESTATUS            = NVL(PEREG.ESTATUS,T.ESTATUS),
		 T.MOTIVO_PREV_FRAUDE = NVL(PEREG.MOTIVO_PREV_FRAUDE,T.MOTIVO_PREV_FRAUDE),
		 T.ALIAS              = NVL(PEREG.ALIAS,T.ALIAS),
		 T.FEC_PREV_FRAU      = NVL(PEREG.FEC_PREV_FRAU,T.FEC_PREV_FRAU),
		 T.ID_USER_PREV_FRAU  = NVL(PEREG.ID_USER_PREV_FRAU,T.ID_USER_PREV_FRAU),
		 T.NUM_INTENTOS       = NVL(PEREG.NUM_INTENTOS,T.NUM_INTENTOS),
		 T.OBSERVACION        = NVL(PEREG.OBSERVACION,T.OBSERVACION),
		 T.FEC_PRI_INTENTO    = NVL(PEREG.FEC_PRI_INTENTO,T.FEC_PRI_INTENTO),
		 T.FEC_ULT_INTENTO    = NVL(PEREG.FEC_ULT_INTENTO,T.FEC_ULT_INTENTO),
		 T.TIPO_OPERACION     = NVL(PEREG.TIPO_OPERACION,T.TIPO_OPERACION),
		 T.SISTEMA            = NVL(PEREG.SISTEMA,T.SISTEMA),
		 T.IDPAIS             = NVL(PEREG.IDPAIS,T.IDPAIS) 
     WHERE T.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_RECORDS.MODIFY_TOKEN_PREVEN(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_TOKEN_PREVEN(P_ID                 IN EBANKING.EBANKING_TOKEN_PREVENCION.ID%TYPE, 
                              P_TITULAR            IN EBANKING.EBANKING_TOKEN_PREVENCION.TITULAR%TYPE, 
                        	  P_EMAIL        	   IN EBANKING.EBANKING_TOKEN_PREVENCION.EMAIL%TYPE,
							  P_IP                 IN EBANKING.EBANKING_TOKEN_PREVENCION.IP%TYPE,
							  P_NUM_SERIE_TOKEN    IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_SERIE_TOKEN%TYPE,	
							  P_TEL_PARTICULAR     IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_PARTICULAR%TYPE,
							  P_TEL_CELULAR        IN EBANKING.EBANKING_TOKEN_PREVENCION.TEL_CELULAR%TYPE,
							  P_CARRIER_CEL        IN EBANKING.EBANKING_TOKEN_PREVENCION.CARRIER_CEL%TYPE,
							  P_FEC_HORA_OPERACION IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_HORA_OPERACION%TYPE,
							  P_NUM_CLIENTE        IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_CLIENTE%TYPE,
							  P_ESTATUS            IN EBANKING.EBANKING_TOKEN_PREVENCION.ESTATUS%TYPE,
							  P_MOTIVO_PREV_FRAUDE IN EBANKING.EBANKING_TOKEN_PREVENCION.MOTIVO_PREV_FRAUDE%TYPE,
							  P_ALIAS              IN EBANKING.EBANKING_TOKEN_PREVENCION.ALIAS%TYPE,
							  P_FEC_PREV_FRAU      IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PREV_FRAU%TYPE,
							  P_ID_USER_PREV_FRAU  IN EBANKING.EBANKING_TOKEN_PREVENCION.ID_USER_PREV_FRAU%TYPE,
							  P_NUM_INTENTOS       IN EBANKING.EBANKING_TOKEN_PREVENCION.NUM_INTENTOS%TYPE,
							  P_OBSERVACION        IN EBANKING.EBANKING_TOKEN_PREVENCION.OBSERVACION%TYPE,
							  P_FEC_PRI_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_PRI_INTENTO%TYPE,
							  P_FEC_ULT_INTENTO    IN EBANKING.EBANKING_TOKEN_PREVENCION.FEC_ULT_INTENTO%TYPE,
							  P_TIPO_OPERACION     IN EBANKING.EBANKING_TOKEN_PREVENCION.TIPO_OPERACION%TYPE,
							  P_SISTEMA            IN EBANKING.EBANKING_TOKEN_PREVENCION.SISTEMA%TYPE,
							  P_IDPAIS             IN EBANKING.EBANKING_TOKEN_PREVENCION.IDPAIS%TYPE,		
                          	  PSCOD                OUT NUMBER,
                          	  PSMSG                OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_TOKEN_PREVENCION%ROWTYPE;
BEGIN
  PEREG.ID                 := P_ID;
  PEREG.TITULAR      	   := P_TITULAR;
  PEREG.EMAIL      	       := P_EMAIL;
  PEREG.IP      	       := P_IP;
  PEREG.NUM_SERIE_TOKEN    := P_NUM_SERIE_TOKEN;
  PEREG.TEL_PARTICULAR     := P_TEL_PARTICULAR;
  PEREG.TEL_CELULAR        := P_TEL_CELULAR;
  PEREG.CARRIER_CEL        := P_CARRIER_CEL;
  PEREG.FEC_HORA_OPERACION := P_FEC_HORA_OPERACION;
  PEREG.NUM_CLIENTE        := P_NUM_CLIENTE;
  PEREG.ESTATUS      	   := P_ESTATUS;
  PEREG.MOTIVO_PREV_FRAUDE := P_MOTIVO_PREV_FRAUDE;
  PEREG.ALIAS      	       := P_ALIAS;
  PEREG.FEC_PREV_FRAU      := P_FEC_PREV_FRAU;
  PEREG.ID_USER_PREV_FRAU  := P_ID_USER_PREV_FRAU;
  PEREG.NUM_INTENTOS       := P_NUM_INTENTOS;
  PEREG.OBSERVACION        := P_OBSERVACION;
  PEREG.FEC_PRI_INTENTO    := P_FEC_PRI_INTENTO;
  PEREG.FEC_ULT_INTENTO    := P_FEC_ULT_INTENTO;
  PEREG.TIPO_OPERACION     := P_TIPO_OPERACION;
  PEREG.SISTEMA      	   := P_SISTEMA;
  PEREG.IDPAIS      	   := P_IDPAIS;
  EBANKING.PKG_CORE_GEN_RECORDS.MODIFY_TOKEN_PREVEN(PEREG,PSCOD,PSMSG);
END;

END PKG_CORE_GEN_RECORDS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_SECURIT AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_SECURIT
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_HUELLAS_REG (PEREG IN EBANKING.HUELLAS_REG%ROWTYPE,
                           PSCOD OUT NUMBER,
                           PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.HUELLAS_REG(HUELLA_HASH,ALIAS,FECHA_HORA,CTE_ALNOVA,IP,STATUS) 
                              VALUES(PEREG.HUELLA_HASH, PEREG.ALIAS, PEREG.FECHA_HORA, PEREG.CTE_ALNOVA,
                                     PEREG.IP, PEREG.STATUS);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SECURIT.ADD_HUELLAS_REG(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_HUELLAS_REG (P_HUELLA_HASH IN EBANKING.HUELLAS_REG.HUELLA_HASH%TYPE, 
                           P_ALIAS       IN EBANKING.HUELLAS_REG.ALIAS%TYPE, 
                           P_FECHA_HORA  IN EBANKING.HUELLAS_REG.FECHA_HORA%TYPE,
                		   P_CTE_ALNOVA  IN EBANKING.HUELLAS_REG.CTE_ALNOVA%TYPE,
                		   P_IP          IN EBANKING.HUELLAS_REG.IP%TYPE,
                		   P_STATUS   IN EBANKING.HUELLAS_REG.STATUS%TYPE,
                		   PSCOD    OUT NUMBER,
                           PSMSG    OUT VARCHAR2)IS
PEREG EBANKING.HUELLAS_REG%ROWTYPE;
BEGIN
  PEREG.HUELLA_HASH := P_HUELLA_HASH;
  PEREG.ALIAS       := P_ALIAS;
  PEREG.FECHA_HORA  := P_FECHA_HORA;
  PEREG.CTE_ALNOVA  := P_CTE_ALNOVA;
  PEREG.IP    		:= P_IP;
  PEREG.STATUS   	   := P_STATUS;
  EBANKING.PKG_CORE_GEN_SECURIT.ADD_HUELLAS_REG(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_HUELLAS_REG(PEREG IN EBANKING.HUELLAS_REG%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.HUELLAS_REG H SET   
         H.ALIAS      = NVL(PEREG.ALIAS,H.ALIAS),
       	 H.FECHA_HORA = NVL(PEREG.FECHA_HORA,H.FECHA_HORA),
       	 H.IP         = NVL(PEREG.IP,H.IP),
  		 H.STATUS     = NVL(PEREG.STATUS,H.STATUS)
     WHERE H.HUELLA_HASH = PEREG.HUELLA_HASH AND
           H.CTE_ALNOVA  = PEREG.CTE_ALNOVA;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SECURIT.MODIFY_HUELLAS_REG(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_HUELLAS_REG(P_HUELLA_HASH IN EBANKING.HUELLAS_REG.HUELLA_HASH%TYPE, 
                             P_ALIAS       IN EBANKING.HUELLAS_REG.ALIAS%TYPE, 
                             P_FECHA_HORA  IN EBANKING.HUELLAS_REG.FECHA_HORA%TYPE,
                  			 P_CTE_ALNOVA  IN EBANKING.HUELLAS_REG.CTE_ALNOVA%TYPE,
                  			 P_IP          IN EBANKING.HUELLAS_REG.IP%TYPE,
                  			 P_STATUS      IN EBANKING.HUELLAS_REG.STATUS%TYPE,
                  			 PSCOD         OUT NUMBER,
                             PSMSG         OUT VARCHAR2)IS
PEREG EBANKING.HUELLAS_REG%ROWTYPE;
BEGIN
  PEREG.HUELLA_HASH := P_HUELLA_HASH;
  PEREG.ALIAS       := P_ALIAS;
  PEREG.FECHA_HORA  := P_FECHA_HORA;
  PEREG.CTE_ALNOVA  := P_CTE_ALNOVA;
  PEREG.IP    		:= P_IP;
  PEREG.STATUS   	:= P_STATUS;
  EBANKING.PKG_CORE_GEN_SECURIT.MODIFY_HUELLAS_REG(PEREG,PSCOD,PSMSG);
END; 
        
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_NIVELESSEGURIDAD
******************************************************************************/
PROCEDURE ADD_NIVELSECURITY (PEREG IN EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_NIVELESSEGURIDAD(IDUSER,NIVELMOVIMIENTOS,NIVELTRANSFERENCIAS,NIVELFRECUENTES) 
                                            VALUES(PEREG.IDUSER, PEREG.NIVELMOVIMIENTOS, PEREG.NIVELTRANSFERENCIAS,
											       PEREG.NIVELFRECUENTES);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SECURIT.ADD_NIVELSECURITY(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_NIVELSECURITY (P_IDUSER 		       IN EBANKING.EBANKING_NIVELESSEGURIDAD.IDUSER%TYPE, 
                             P_NIVELMOVIMIENTOS    IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELMOVIMIENTOS%TYPE, 
                           	 P_NIVELTRANSFERENCIAS IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELTRANSFERENCIAS%TYPE,
                		   	 P_NIVELFRECUENTES     IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELFRECUENTES%TYPE,                		  
                		   	 PSCOD    			   OUT NUMBER,
                           	 PSMSG    			   OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE;
BEGIN
  PEREG.IDUSER  		    := P_IDUSER;
  PEREG.NIVELMOVIMIENTOS    := P_NIVELMOVIMIENTOS;
  PEREG.NIVELTRANSFERENCIAS := P_NIVELTRANSFERENCIAS;
  PEREG.NIVELFRECUENTES     := P_NIVELFRECUENTES;
  EBANKING.PKG_CORE_GEN_SECURIT.ADD_NIVELSECURITY(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_NIVELSECURITY(PEREG IN EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_NIVELESSEGURIDAD H SET   
         H.NIVELMOVIMIENTOS    = NVL(PEREG.NIVELMOVIMIENTOS,H.NIVELMOVIMIENTOS),
  		 H.NIVELTRANSFERENCIAS = NVL(PEREG.NIVELTRANSFERENCIAS,H.NIVELTRANSFERENCIAS),
		 H.NIVELFRECUENTES     = NVL(PEREG.NIVELFRECUENTES,H.NIVELFRECUENTES)
     WHERE H.IDUSER = PEREG.IDUSER;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SECURIT.MODIFY_NIVELSECURITY(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_NIVELSECURITY(P_IDUSER 		     IN EBANKING.EBANKING_NIVELESSEGURIDAD.IDUSER%TYPE, 
                               P_NIVELMOVIMIENTOS    IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELMOVIMIENTOS%TYPE, 
                           	   P_NIVELTRANSFERENCIAS IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELTRANSFERENCIAS%TYPE,
                		   	   P_NIVELFRECUENTES     IN EBANKING.EBANKING_NIVELESSEGURIDAD.NIVELFRECUENTES%TYPE, 
                  			   PSCOD         		 OUT NUMBER,
                               PSMSG         		 OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_NIVELESSEGURIDAD%ROWTYPE;
BEGIN
  PEREG.IDUSER  		    := P_IDUSER;
  PEREG.NIVELMOVIMIENTOS    := P_NIVELMOVIMIENTOS;
  PEREG.NIVELTRANSFERENCIAS := P_NIVELTRANSFERENCIAS;
  PEREG.NIVELFRECUENTES     := P_NIVELFRECUENTES;
  EBANKING.PKG_CORE_GEN_SECURIT.MODIFY_NIVELSECURITY(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_SECURITY_MAX_AMOUNT
******************************************************************************/
PROCEDURE ADD_SECURITMAXMON (PEREG IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_SECURITY_MAX_AMOUNT(IDUSER,TERCEROS,INTERBANCARIO,PAGOS,TIEMPOAIRE,DIARIO,
		   		                                      MOV_TERCEROS,MOV_INTER,MOV_PAGOS,MOV_TIEMPOAIRE,
													  MOV_DIARIO,ULTIMO_MOVIMIENTO,INTERNACIONALES,
													  MOV_INTERNACIONALES)                                                
											   VALUES(PEREG.IDUSER,PEREG.TERCEROS,PEREG.INTERBANCARIO,PEREG.PAGOS,
											          PEREG.TIEMPOAIRE,PEREG.DIARIO,PEREG.MOV_TERCEROS,
													  PEREG.MOV_INTER,PEREG.MOV_PAGOS,PEREG.MOV_TIEMPOAIRE,
													  PEREG.MOV_DIARIO,PEREG.ULTIMO_MOVIMIENTO,PEREG.INTERNACIONALES,
													  PEREG.MOV_INTERNACIONALES);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
     RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SECURIT.ADD_SECURITMAXMON(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_SECURITMAXMON (P_IDUSER 		       IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.IDUSER%TYPE, 
                             P_TERCEROS    		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TERCEROS%TYPE, 
                           	 P_INTERBANCARIO 	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERBANCARIO%TYPE,
                		   	 P_PAGOS     		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.PAGOS%TYPE,
							 P_TIEMPOAIRE     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TIEMPOAIRE%TYPE, 
							 P_DIARIO     		   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.DIARIO%TYPE, 
							 P_MOV_TERCEROS        IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TERCEROS%TYPE, 
							 P_MOV_INTER     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTER%TYPE, 
							 P_MOV_PAGOS     	   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_PAGOS%TYPE, 
							 P_MOV_TIEMPOAIRE      IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TIEMPOAIRE%TYPE, 
							 P_MOV_DIARIO          IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_DIARIO%TYPE,    
							 P_ULTIMO_MOVIMIENTO   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.ULTIMO_MOVIMIENTO%TYPE,             		  
                		   	 P_INTERNACIONALES     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERNACIONALES%TYPE, 
							 P_MOV_INTERNACIONALES IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTERNACIONALES%TYPE, 
							 PSCOD    			   OUT NUMBER,
                           	 PSMSG    			   OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE;
BEGIN
  PEREG.IDUSER  		    := P_IDUSER;
  PEREG.TERCEROS    		:= P_TERCEROS;
  PEREG.INTERBANCARIO 		:= P_INTERBANCARIO;
  PEREG.PAGOS     			:= P_PAGOS;
  PEREG.TIEMPOAIRE     		:= P_TIEMPOAIRE;
  PEREG.DIARIO     			:= P_DIARIO;
  PEREG.MOV_TERCEROS     	:= P_MOV_TERCEROS;
  PEREG.MOV_INTER     		:= P_MOV_INTER;
  PEREG.MOV_PAGOS     		:= P_MOV_PAGOS;
  PEREG.MOV_TIEMPOAIRE     	:= P_MOV_TIEMPOAIRE;
  PEREG.MOV_DIARIO     		:= P_MOV_DIARIO;
  PEREG.ULTIMO_MOVIMIENTO   := P_ULTIMO_MOVIMIENTO;
  PEREG.INTERNACIONALES     := P_INTERNACIONALES;
  PEREG.MOV_INTERNACIONALES := P_MOV_INTERNACIONALES;  
  EBANKING.PKG_CORE_GEN_SECURIT.ADD_SECURITMAXMON(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_SECURITMAXMON(PEREG IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_SECURITY_MAX_AMOUNT S SET   
         S.TERCEROS            = NVL(PEREG.TERCEROS,S.TERCEROS),
  		 S.INTERBANCARIO 	   = NVL(PEREG.INTERBANCARIO,S.INTERBANCARIO),
		 S.PAGOS 			   = NVL(PEREG.PAGOS,S.PAGOS),
		 S.TIEMPOAIRE 		   = NVL(PEREG.TIEMPOAIRE,S.TIEMPOAIRE),
		 S.DIARIO 			   = NVL(PEREG.DIARIO,S.DIARIO),
		 S.MOV_TERCEROS 	   = NVL(PEREG.MOV_TERCEROS,S.MOV_TERCEROS),
		 S.MOV_INTER 		   = NVL(PEREG.MOV_INTER,S.MOV_INTER),
		 S.MOV_PAGOS 		   = NVL(PEREG.MOV_PAGOS,S.MOV_PAGOS),
		 S.MOV_TIEMPOAIRE 	   = NVL(PEREG.MOV_TIEMPOAIRE,S.MOV_TIEMPOAIRE),
		 S.MOV_DIARIO          = NVL(PEREG.MOV_DIARIO,S.MOV_DIARIO),
		 S.ULTIMO_MOVIMIENTO   = NVL(PEREG.ULTIMO_MOVIMIENTO,S.ULTIMO_MOVIMIENTO),
		 S.INTERNACIONALES     = NVL(PEREG.INTERNACIONALES,S.INTERNACIONALES),
		 S.MOV_INTERNACIONALES = NVL(PEREG.MOV_INTERNACIONALES,S.MOV_INTERNACIONALES)
     WHERE S.IDUSER = PEREG.IDUSER;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SECURIT.MODIFY_SECURITMAXMON(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_SECURITMAXMON(P_IDUSER 		     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.IDUSER%TYPE, 
                               P_TERCEROS    		 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TERCEROS%TYPE, 
                           	   P_INTERBANCARIO 	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERBANCARIO%TYPE,
                		   	   P_PAGOS     		   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.PAGOS%TYPE,
							   P_TIEMPOAIRE     	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.TIEMPOAIRE%TYPE, 
							   P_DIARIO     		 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.DIARIO%TYPE, 
							   P_MOV_TERCEROS        IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TERCEROS%TYPE, 
							   P_MOV_INTER     	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTER%TYPE, 
							   P_MOV_PAGOS     	   	 IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_PAGOS%TYPE, 
							   P_MOV_TIEMPOAIRE      IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_TIEMPOAIRE%TYPE, 
							   P_MOV_DIARIO          IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_DIARIO%TYPE,    
							   P_ULTIMO_MOVIMIENTO   IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.ULTIMO_MOVIMIENTO%TYPE,             		  
                		   	   P_INTERNACIONALES     IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.INTERNACIONALES%TYPE, 
							   P_MOV_INTERNACIONALES IN EBANKING.EBANKING_SECURITY_MAX_AMOUNT.MOV_INTERNACIONALES%TYPE, 
                  			   PSCOD         		 OUT NUMBER,
                               PSMSG         		 OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_SECURITY_MAX_AMOUNT%ROWTYPE;
BEGIN
  PEREG.IDUSER  		    := P_IDUSER;
  PEREG.TERCEROS    		:= P_TERCEROS;
  PEREG.INTERBANCARIO 		:= P_INTERBANCARIO;
  PEREG.PAGOS     			:= P_PAGOS;
  PEREG.TIEMPOAIRE     		:= P_TIEMPOAIRE;
  PEREG.DIARIO     			:= P_DIARIO;
  PEREG.MOV_TERCEROS     	:= P_MOV_TERCEROS;
  PEREG.MOV_INTER     		:= P_MOV_INTER;
  PEREG.MOV_PAGOS     		:= P_MOV_PAGOS;
  PEREG.MOV_TIEMPOAIRE     	:= P_MOV_TIEMPOAIRE;
  PEREG.MOV_DIARIO     		:= P_MOV_DIARIO;
  PEREG.ULTIMO_MOVIMIENTO   := P_ULTIMO_MOVIMIENTO;
  PEREG.INTERNACIONALES     := P_INTERNACIONALES;
  PEREG.MOV_INTERNACIONALES := P_MOV_INTERNACIONALES;  
  EBANKING.PKG_CORE_GEN_SECURIT.MODIFY_SECURITMAXMON(PEREG,PSCOD,PSMSG);
END;

END PKG_CORE_GEN_SECURIT;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_SESSION AS
/******************************************************************************
   NAME:       PKG_CORE_GEN_SESSION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_EBANKING_LOGIN (PEREG IN EBANKING.EBANKING_LOGIN%ROWTYPE,
                              PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2) IS
BEGIN
 	PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_LOGIN(USER_ID,ATTEMPTS,LOGIN_DATE) VALUES(PEREG.USER_ID, PEREG.ATTEMPTS, PEREG.LOGIN_DATE);
	COMMIT;
	PSMSG:='OPERACION EXITOSA';
	EXCEPTION	    
  		WHEN OTHERS THEN
		PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
    	ROLLBACK;
    	RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SESSION.ADD_EBANKING_LOGIN(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EBANKING_LOGIN (P_USER_ID IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE, 
                              P_ATTEMPTS IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE, 
                              P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN.LOGIN_DATE %TYPE,
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_LOGIN%ROWTYPE;
BEGIN
  	 PEREG.USER_ID:=P_USER_ID; 
  	 PEREG.ATTEMPTS:=P_ATTEMPTS; 
  	 PEREG.LOGIN_DATE:=P_LOGIN_DATE;
  	 EBANKING.PKG_CORE_GEN_SESSION.ADD_EBANKING_LOGIN(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_EBANKING_LOGIN(PEREG IN EBANKING.EBANKING_LOGIN%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2) IS
BEGIN
	 PSCOD:=0;
     UPDATE EBANKING.EBANKING_LOGIN L SET   
     	   L.ATTEMPTS = NVL(PEREG.ATTEMPTS,L.ATTEMPTS),
           L.LOGIN_DATE = NVL(PEREG.LOGIN_DATE,L.LOGIN_DATE)
     WHERE L.USER_ID = PEREG.USER_ID;
     COMMIT;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
     	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SESSION.MODIFY_EBANKING_USER(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
 
PROCEDURE MODIFY_EBANKING_LOGIN(P_USER_ID IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE, 
          					    P_ATTEMPTS IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE, 
          						P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN.LOGIN_DATE%TYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_LOGIN%ROWTYPE;
BEGIN
	 PEREG.USER_ID:=P_USER_ID; 
  	 PEREG.ATTEMPTS:=P_ATTEMPTS; 
  	 PEREG.LOGIN_DATE:=P_LOGIN_DATE;
     EBANKING.PKG_CORE_GEN_SESSION.MODIFY_EBANKING_LOGIN(PEREG,PSCOD,PSMSG);
END;


/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_SESSION
******************************************************************************/
PROCEDURE ADD_EBANKING_SESSION (PEREG IN EBANKING.EBANKING_USER_SESSION%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2)IS
BEGIN
 	PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_USER_SESSION(ID, SESSION_ACTIVA, SESSION_START, IP) VALUES(PEREG.ID, PEREG.SESSION_ACTIVA, PEREG.SESSION_START, PEREG.IP);
	COMMIT;
	PSMSG:='OPERACION EXITOSA';
	EXCEPTION	    
  		WHEN OTHERS THEN
		PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
    	ROLLBACK;
    	RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SESSION.ADD_EBANKING_SESSION(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EBANKING_SESSION(P_ID             IN EBANKING.EBANKING_USER_SESSION.ID%TYPE, 
                                    P_SESSION_ACTIVA IN EBANKING.EBANKING_USER_SESSION.SESSION_ACTIVA%TYPE, 
                                    P_SESSION_START  IN EBANKING.EBANKING_USER_SESSION.SESSION_START%TYPE,
									P_IP             IN EBANKING.EBANKING_USER_SESSION.IP%TYPE,
							        PSCOD          	 OUT NUMBER,
                                    PSMSG 		   	 OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_USER_SESSION%ROWTYPE;
BEGIN
  	 PEREG.ID            :=P_ID; 
  	 PEREG.SESSION_ACTIVA:=P_SESSION_ACTIVA; 
  	 PEREG.SESSION_START :=P_SESSION_START;
	 PEREG.IP 			 :=P_IP;
  	 EBANKING.PKG_CORE_GEN_SESSION.ADD_EBANKING_SESSION(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_EBANKING_SESSION(PEREG IN EBANKING.EBANKING_USER_SESSION%ROWTYPE,
                                       PSCOD OUT NUMBER,
                                       PSMSG OUT VARCHAR2) IS
BEGIN
	 PSCOD:=0;
     UPDATE EBANKING.EBANKING_USER_SESSION U SET   
     	   U.SESSION_ACTIVA = NVL(PEREG.SESSION_ACTIVA,U.SESSION_ACTIVA),
           U.SESSION_START = NVL(PEREG.SESSION_START,U.SESSION_START),
		   U.IP = NVL(PEREG.IP,U.IP)
     WHERE U.ID = PEREG.ID;
     COMMIT;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
     	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SESSION.MODIFY_EBANKING_SESSION(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_EBANKING_SESSION(P_ID 	 	      IN EBANKING.EBANKING_USER_SESSION.ID%TYPE, 
                                       P_SESSION_ACTIVA   IN EBANKING.EBANKING_USER_SESSION.SESSION_ACTIVA%TYPE, 
                                       P_SESSION_START    IN EBANKING.EBANKING_USER_SESSION.SESSION_START%TYPE,
									   P_IP 			  IN EBANKING.EBANKING_USER_SESSION.IP%TYPE,
                                       PSCOD 		      OUT NUMBER,
                                       PSMSG 		      OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_USER_SESSION%ROWTYPE;
BEGIN
  	 PEREG.ID            :=P_ID; 
  	 PEREG.SESSION_ACTIVA:=P_SESSION_ACTIVA; 
  	 PEREG.SESSION_START :=P_SESSION_START;
	 PEREG.IP 			 :=P_IP;
  	 EBANKING.PKG_CORE_GEN_SESSION.MODIFY_EBANKING_SESSION(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_LOGIN_HIST
******************************************************************************/
PROCEDURE ADD_LOGIN_HIST (PEREG IN EBANKING.EBANKING_LOGIN_HIST%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN
 	PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_LOGIN_HIST(ID,USER_ID,LOGIN_DATE,ALIAS,ATTEMPT,IP,VALIDACION) 
	                                  VALUES(PEREG.ID, PEREG.USER_ID, PEREG.LOGIN_DATE, PEREG.ALIAS,
										     PEREG.ATTEMPT, PEREG.IP, PEREG.VALIDACION);
	COMMIT;
	PSMSG:='OPERACION EXITOSA';
	EXCEPTION	    
  		WHEN OTHERS THEN
		PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
    	ROLLBACK;
    	RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_SESSION.ADD_LOGIN_HIST(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_LOGIN_HIST (P_ID         IN EBANKING.EBANKING_LOGIN_HIST.ID%TYPE, 
                          P_USER_ID    IN EBANKING.EBANKING_LOGIN_HIST.USER_ID%TYPE, 
                          P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN_HIST.LOGIN_DATE%TYPE,
						  P_ALIAS      IN EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE,
						  P_ATTEMPT    IN EBANKING.EBANKING_LOGIN_HIST.ATTEMPT%TYPE,							  
						  P_IP         IN EBANKING.EBANKING_LOGIN_HIST.IP%TYPE,
						  P_VALIDACION IN EBANKING.EBANKING_LOGIN_HIST.VALIDACION%TYPE,
						  PSCOD        OUT NUMBER,
                          PSMSG 	   OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_LOGIN_HIST%ROWTYPE;
BEGIN
  	 PEREG.ID         :=P_ID; 
  	 PEREG.USER_ID    :=P_USER_ID; 
  	 PEREG.LOGIN_DATE :=P_LOGIN_DATE;
	 PEREG.ALIAS      :=P_ALIAS;
	 PEREG.ATTEMPT 	  :=P_ATTEMPT;
	 PEREG.VALIDACION :=P_VALIDACION;
	 PEREG.IP 		  :=P_IP;	 
  	 EBANKING.PKG_CORE_GEN_SESSION.ADD_LOGIN_HIST(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_LOGIN_HIST(PEREG IN EBANKING.EBANKING_LOGIN_HIST%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN
	 PSCOD:=0;
     UPDATE EBANKING.EBANKING_LOGIN_HIST L SET   
		   L.LOGIN_DATE = NVL(PEREG.LOGIN_DATE,L.LOGIN_DATE),
		   L.ALIAS = NVL(PEREG.ALIAS,L.ALIAS),
		   L.ATTEMPT = NVL(PEREG.ATTEMPT,L.ATTEMPT),
		   L.VALIDACION = NVL(PEREG.VALIDACION,L.VALIDACION),
		   L.IP = NVL(PEREG.IP,L.IP)
     WHERE L.ID = PEREG.ID AND 
	       L.USER_ID = PEREG.USER_ID ;
     COMMIT;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
     	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_SESSION.MODIFY_LOGIN_HIST(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_LOGIN_HIST(P_ID         IN EBANKING.EBANKING_LOGIN_HIST.ID%TYPE, 
                            P_USER_ID    IN EBANKING.EBANKING_LOGIN_HIST.USER_ID%TYPE, 
                          	P_LOGIN_DATE IN EBANKING.EBANKING_LOGIN_HIST.LOGIN_DATE%TYPE,
						  	P_ALIAS      IN EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE,
						  	P_ATTEMPT    IN EBANKING.EBANKING_LOGIN_HIST.ATTEMPT%TYPE,							  
						  	P_IP         IN EBANKING.EBANKING_LOGIN_HIST.IP%TYPE,
						  	P_VALIDACION IN EBANKING.EBANKING_LOGIN_HIST.VALIDACION%TYPE,
						  	PSCOD        OUT NUMBER,
                          	PSMSG 	     OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_LOGIN_HIST%ROWTYPE;
BEGIN
  	 PEREG.ID         :=P_ID; 
  	 PEREG.USER_ID    :=P_USER_ID; 
  	 PEREG.LOGIN_DATE :=P_LOGIN_DATE;
	 PEREG.ALIAS      :=P_ALIAS;
	 PEREG.ATTEMPT 	  :=P_ATTEMPT;
	 PEREG.VALIDACION :=P_VALIDACION;
	 PEREG.IP 		  :=P_IP;	 
  	 EBANKING.PKG_CORE_GEN_SESSION.MODIFY_LOGIN_HIST(PEREG,PSCOD,PSMSG);
END;
END PKG_CORE_GEN_SESSION;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_TRANS AS
/******************************************************************************
   NAME:       PKG_CORE_ADMIN_TRANSFERS
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_DEST_TEFSPEITERC (PEREG IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE,
                                PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.DESTINOS_TEF_SPEI_TERCEROS(ID,ID_CLIENTE,ID_TIPOTRANSFERENCIA,COD_BANCO,CUENTA_DESTINO,
	                                                NOMBRE_DESTINO,EMAIL_DESTINO,NUM_CELULAR_DESTINO,NUM_TEL_CASA,
													NUM_TEL_OFFNA,IP_ORIGEN,FECHA_MODIFICACION,PLAZA,
													TIPO_CUENTA_DESTINO,CARRIER_NAME,DESCRIPCION_CUENTA,APODO,
													ULTIMA_ACTUALIZACION,STATUS,CANAL,NOTIFICACION) 
                                             VALUES(PEREG.ID,PEREG.ID_CLIENTE,PEREG.ID_TIPOTRANSFERENCIA,
											        PEREG.COD_BANCO,PEREG.CUENTA_DESTINO,
	                                                PEREG.NOMBRE_DESTINO,PEREG.EMAIL_DESTINO,PEREG.NUM_CELULAR_DESTINO,
													PEREG.NUM_TEL_CASA,PEREG.NUM_TEL_OFFNA,PEREG.IP_ORIGEN,
													PEREG.FECHA_MODIFICACION,PEREG.PLAZA,PEREG.TIPO_CUENTA_DESTINO,
													PEREG.CARRIER_NAME,PEREG.DESCRIPCION_CUENTA,PEREG.APODO,
													PEREG.ULTIMA_ACTUALIZACION,PEREG.STATUS,PEREG.CANAL,PEREG.NOTIFICACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_DEST_TEFSPEITERC(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_DEST_TEFSPEITERC (P_ID                   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID%TYPE, 
                                P_ID_CLIENTE           IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE, 
                              	P_ID_TIPOTRANSFERENCIA IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
                           		P_COD_BANCO            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
         						P_CUENTA_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
         						P_NOMBRE_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
         						P_EMAIL_DESTINO        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
         						P_NUM_CELULAR_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
                           		P_NUM_TEL_CASA         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
         						P_NUM_TEL_OFFNA        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
         						P_IP_ORIGEN            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
         						P_FECHA_MODIFICACION   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.FECHA_MODIFICACION%TYPE,
         						P_PLAZA          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
         						P_TIPO_CUENTA_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
         						P_CARRIER_NAME         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
         						P_DESCRIPCION_CUENTA   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
            					P_APODO          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
         						P_ULTIMA_ACTUALIZACION IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ULTIMA_ACTUALIZACION%TYPE,
         						P_STATUS      		   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.STATUS%TYPE,
         						P_CANAL          	   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CANAL%TYPE,
         						P_NOTIFICACION         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOTIFICACION%TYPE,
                           		PSCOD                  OUT NUMBER,
                           		PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE;
BEGIN 
    PEREG.ID  			       :=P_ID;
	PEREG.ID_CLIENTE           :=P_ID_CLIENTE;
	PEREG.ID_TIPOTRANSFERENCIA :=P_ID_TIPOTRANSFERENCIA;
	PEREG.COD_BANCO     	   :=P_COD_BANCO;
	PEREG.CUENTA_DESTINO       :=P_CUENTA_DESTINO;
	PEREG.NOMBRE_DESTINO       :=P_NOMBRE_DESTINO;
	PEREG.EMAIL_DESTINO        :=P_EMAIL_DESTINO;
	PEREG.NUM_CELULAR_DESTINO  :=P_NUM_CELULAR_DESTINO;
	PEREG.NUM_TEL_CASA     	   :=P_NUM_TEL_CASA;
	PEREG.NUM_TEL_OFFNA        :=P_NUM_TEL_OFFNA;
	PEREG.IP_ORIGEN     	   :=P_IP_ORIGEN;
	PEREG.FECHA_MODIFICACION   :=P_FECHA_MODIFICACION;
	PEREG.PLAZA     		   :=P_PLAZA;
	PEREG.TIPO_CUENTA_DESTINO  :=P_TIPO_CUENTA_DESTINO;
	PEREG.CARRIER_NAME     	   :=P_CARRIER_NAME;
	PEREG.DESCRIPCION_CUENTA   :=P_DESCRIPCION_CUENTA;
	PEREG.APODO     		   :=P_APODO;
	PEREG.ULTIMA_ACTUALIZACION :=P_ULTIMA_ACTUALIZACION;
	PEREG.STATUS     		   :=P_STATUS;
	PEREG.CANAL     		   :=P_CANAL;
	PEREG.NOTIFICACION    	   :=P_NOTIFICACION;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_DEST_TEFSPEITERC(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_DEST_TEFSPEIT(PEREG IN  EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS D SET 
		 D.ID_CLIENTE           = NVL(PEREG.ID_CLIENTE,D.ID_CLIENTE),
		 D.ID_TIPOTRANSFERENCIA = NVL(PEREG.ID_TIPOTRANSFERENCIA,D.ID_TIPOTRANSFERENCIA),
		 D.COD_BANCO     	    = NVL(PEREG.COD_BANCO,D.COD_BANCO),
		 D.CUENTA_DESTINO       = NVL(PEREG.CUENTA_DESTINO,D.CUENTA_DESTINO),
		 D.NOMBRE_DESTINO       = NVL(PEREG.NOMBRE_DESTINO,D.NOMBRE_DESTINO),
		 D.EMAIL_DESTINO        = NVL(PEREG.EMAIL_DESTINO,D.EMAIL_DESTINO),
		 D.NUM_CELULAR_DESTINO  = NVL(PEREG.NUM_CELULAR_DESTINO,D.NUM_CELULAR_DESTINO),
		 D.NUM_TEL_CASA     	= NVL(PEREG.NUM_TEL_CASA,D.NUM_TEL_CASA),
		 D.NUM_TEL_OFFNA        = NVL(PEREG.NUM_TEL_OFFNA,D.NUM_TEL_OFFNA),
		 D.IP_ORIGEN     	    = NVL(PEREG.IP_ORIGEN,D.IP_ORIGEN),
		 D.FECHA_MODIFICACION   = NVL(PEREG.FECHA_MODIFICACION,D.FECHA_MODIFICACION),
		 D.PLAZA     		    = NVL(PEREG.PLAZA,D.PLAZA),
		 D.TIPO_CUENTA_DESTINO  = NVL(PEREG.TIPO_CUENTA_DESTINO,D.TIPO_CUENTA_DESTINO),
		 D.CARRIER_NAME     	= NVL(PEREG.CARRIER_NAME,D.CARRIER_NAME),
		 D.DESCRIPCION_CUENTA   = NVL(PEREG.DESCRIPCION_CUENTA,D.DESCRIPCION_CUENTA),
		 D.APODO     		    = NVL(PEREG.APODO,D.APODO),
		 D.ULTIMA_ACTUALIZACION = NVL(PEREG.ULTIMA_ACTUALIZACION,D.ULTIMA_ACTUALIZACION),
		 D.STATUS     		    = NVL(PEREG.STATUS,D.STATUS),
		 D.CANAL     		    = NVL(PEREG.CANAL,D.CANAL),
		 D.NOTIFICACION    	    = NVL(PEREG.NOTIFICACION,D.NOTIFICACION)
     WHERE D.ID = PEREG.ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_DEST_TEFSPEITERC(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_DEST_TEFSPEIT(P_ID                   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID%TYPE, 
                               P_ID_CLIENTE           IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE, 
                               P_ID_TIPOTRANSFERENCIA IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
                           	   P_COD_BANCO            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
         					   P_CUENTA_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
         					   P_NOMBRE_DESTINO       IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
         					   P_EMAIL_DESTINO        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
         					   P_NUM_CELULAR_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
                           	   P_NUM_TEL_CASA         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
         					   P_NUM_TEL_OFFNA        IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
         					   P_IP_ORIGEN            IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
         					   P_FECHA_MODIFICACION   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.FECHA_MODIFICACION%TYPE,
         					   P_PLAZA          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
         					   P_TIPO_CUENTA_DESTINO  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
         					   P_CARRIER_NAME         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
         					   P_DESCRIPCION_CUENTA   IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
            				   P_APODO          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
         					   P_ULTIMA_ACTUALIZACION IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ULTIMA_ACTUALIZACION%TYPE,
         					   P_STATUS      		  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.STATUS%TYPE,
         					   P_CANAL          	  IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CANAL%TYPE,
         					   P_NOTIFICACION         IN EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOTIFICACION%TYPE,
                               PSCOD                  OUT NUMBER,
                               PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.DESTINOS_TEF_SPEI_TERCEROS%ROWTYPE;
BEGIN 
    PEREG.ID  			       :=P_ID;
	PEREG.ID_CLIENTE           :=P_ID_CLIENTE;
	PEREG.ID_TIPOTRANSFERENCIA :=P_ID_TIPOTRANSFERENCIA;
	PEREG.COD_BANCO     	   :=P_COD_BANCO;
	PEREG.CUENTA_DESTINO       :=P_CUENTA_DESTINO;
	PEREG.NOMBRE_DESTINO       :=P_NOMBRE_DESTINO;
	PEREG.EMAIL_DESTINO        :=P_EMAIL_DESTINO;
	PEREG.NUM_CELULAR_DESTINO  :=P_NUM_CELULAR_DESTINO;
	PEREG.NUM_TEL_CASA     	   :=P_NUM_TEL_CASA;
	PEREG.NUM_TEL_OFFNA        :=P_NUM_TEL_OFFNA;
	PEREG.IP_ORIGEN     	   :=P_IP_ORIGEN;
	PEREG.FECHA_MODIFICACION   :=P_FECHA_MODIFICACION;
	PEREG.PLAZA     		   :=P_PLAZA;
	PEREG.TIPO_CUENTA_DESTINO  :=P_TIPO_CUENTA_DESTINO;
	PEREG.CARRIER_NAME     	   :=P_CARRIER_NAME;
	PEREG.DESCRIPCION_CUENTA   :=P_DESCRIPCION_CUENTA;
	PEREG.APODO     		   :=P_APODO;
	PEREG.ULTIMA_ACTUALIZACION :=P_ULTIMA_ACTUALIZACION;
	PEREG.STATUS     		   :=P_STATUS;
	PEREG.CANAL     		   :=P_CANAL;
	PEREG.NOTIFICACION    	   :=P_NOTIFICACION;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_DEST_TEFSPEIT(PEREG,PSCOD,PSMSG);
END; 
     
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE ACTIVACION_DEX
******************************************************************************/
PROCEDURE ADD_ACTIVACIONDEX (PEREG IN EBANKING.ACTIVACION_DEX%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.ACTIVACION_DEX(CTEALNOVA,CTEDEX,U_ID,FECHAACTIVACION,ULTIMA_MODIFICACION,USUARIO_MODIFICO,
	                                    PAIS_IDENTIFICACION,TIPO_IDENTIFICACION,FOLIO_IDENTIFICACION) 
                                 VALUES(PEREG.CTEALNOVA,PEREG.CTEDEX,PEREG.U_ID,PEREG.FECHAACTIVACION,PEREG.ULTIMA_MODIFICACION,
								        PEREG.USUARIO_MODIFICO,PEREG.PAIS_IDENTIFICACION,PEREG.TIPO_IDENTIFICACION,
										PEREG.FOLIO_IDENTIFICACION);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_ACTIVACIONDEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_ACTIVACIONDEX (P_CTEALNOVA            IN EBANKING.ACTIVACION_DEX.CTEALNOVA%TYPE, 
                             P_CTEDEX           	IN EBANKING.ACTIVACION_DEX.CTEDEX%TYPE, 
                             P_U_ID 				IN EBANKING.ACTIVACION_DEX.U_ID%TYPE,
                           	 P_FECHAACTIVACION      IN EBANKING.ACTIVACION_DEX.FECHAACTIVACION%TYPE,
         					 P_ULTIMA_MODIFICACION  IN EBANKING.ACTIVACION_DEX.ULTIMA_MODIFICACION%TYPE,
         					 P_USUARIO_MODIFICO     IN EBANKING.ACTIVACION_DEX.USUARIO_MODIFICO%TYPE,
         					 P_PAIS_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.PAIS_IDENTIFICACION%TYPE,
         					 P_TIPO_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.TIPO_IDENTIFICACION%TYPE,
                           	 P_FOLIO_IDENTIFICACION IN EBANKING.ACTIVACION_DEX.FOLIO_IDENTIFICACION%TYPE,
         					 PSCOD                  OUT NUMBER,
                           	 PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.ACTIVACION_DEX%ROWTYPE;
BEGIN 
    PEREG.CTEALNOVA  		   :=P_CTEALNOVA;
	PEREG.CTEDEX           	   :=P_CTEDEX;
	PEREG.U_ID 				   :=P_U_ID;
	PEREG.FECHAACTIVACION      :=P_FECHAACTIVACION;
	PEREG.ULTIMA_MODIFICACION  :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO     :=P_USUARIO_MODIFICO;
	PEREG.PAIS_IDENTIFICACION  :=P_PAIS_IDENTIFICACION;
	PEREG.TIPO_IDENTIFICACION  :=P_TIPO_IDENTIFICACION;
	PEREG.FOLIO_IDENTIFICACION :=P_FOLIO_IDENTIFICACION;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_ACTIVACIONDEX(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_ACTIVACIONDEX(PEREG IN  EBANKING.ACTIVACION_DEX%ROWTYPE,
                               PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.ACTIVACION_DEX D SET 
		 D.U_ID                 = NVL(PEREG.U_ID,D.U_ID),
		 D.FECHAACTIVACION      = NVL(PEREG.FECHAACTIVACION,D.FECHAACTIVACION),
		 D.ULTIMA_MODIFICACION  = NVL(PEREG.ULTIMA_MODIFICACION,D.ULTIMA_MODIFICACION),
		 D.USUARIO_MODIFICO     = NVL(PEREG.USUARIO_MODIFICO,D.USUARIO_MODIFICO),
		 D.PAIS_IDENTIFICACION  = NVL(PEREG.PAIS_IDENTIFICACION,D.PAIS_IDENTIFICACION),
		 D.TIPO_IDENTIFICACION  = NVL(PEREG.TIPO_IDENTIFICACION,D.TIPO_IDENTIFICACION),
		 D.FOLIO_IDENTIFICACION = NVL(PEREG.FOLIO_IDENTIFICACION,D.FOLIO_IDENTIFICACION)
     WHERE D.CTEALNOVA = PEREG.CTEALNOVA AND
	       D.CTEDEX = PEREG.CTEDEX;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_ACTIVACIONDEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_ACTIVACIONDEX(P_CTEALNOVA            IN EBANKING.ACTIVACION_DEX.CTEALNOVA%TYPE, 
                               P_CTEDEX           	  IN EBANKING.ACTIVACION_DEX.CTEDEX%TYPE, 
                               P_U_ID 				  IN EBANKING.ACTIVACION_DEX.U_ID%TYPE,
                           	   P_FECHAACTIVACION      IN EBANKING.ACTIVACION_DEX.FECHAACTIVACION%TYPE,
         					   P_ULTIMA_MODIFICACION  IN EBANKING.ACTIVACION_DEX.ULTIMA_MODIFICACION%TYPE,
         					   P_USUARIO_MODIFICO     IN EBANKING.ACTIVACION_DEX.USUARIO_MODIFICO%TYPE,
         					   P_PAIS_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.PAIS_IDENTIFICACION%TYPE,
         					   P_TIPO_IDENTIFICACION  IN EBANKING.ACTIVACION_DEX.TIPO_IDENTIFICACION%TYPE,
                           	   P_FOLIO_IDENTIFICACION IN EBANKING.ACTIVACION_DEX.FOLIO_IDENTIFICACION%TYPE,
                               PSCOD                  OUT NUMBER,
                               PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.ACTIVACION_DEX%ROWTYPE;
BEGIN 
    PEREG.CTEALNOVA  		   :=P_CTEALNOVA;
	PEREG.CTEDEX           	   :=P_CTEDEX;
	PEREG.U_ID 				   :=P_U_ID;
	PEREG.FECHAACTIVACION      :=P_FECHAACTIVACION;
	PEREG.ULTIMA_MODIFICACION  :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO     :=P_USUARIO_MODIFICO;
	PEREG.PAIS_IDENTIFICACION  :=P_PAIS_IDENTIFICACION;
	PEREG.TIPO_IDENTIFICACION  :=P_TIPO_IDENTIFICACION;
	PEREG.FOLIO_IDENTIFICACION :=P_FOLIO_IDENTIFICACION;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_ACTIVACIONDEX(PEREG,PSCOD,PSMSG);
END;
   
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE BENEFI_DEX
******************************************************************************/
PROCEDURE ADD_BENEFI_DEX (PEREG IN EBANKING.BENEFI_DEX%ROWTYPE,
                          PSCOD OUT NUMBER,
                          PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.BENEFI_DEX(ID_BENEFICIARIO_DEX,ALIAS_BENEFICIARIO,CTEDEX,FECHAACTIVACION,
	                                ULTIMA_MODIFICACION,USUARIO_MODIFICO) 
                             VALUES(PEREG.ID_BENEFICIARIO_DEX,PEREG.ALIAS_BENEFICIARIO,PEREG.CTEDEX,
							        PEREG.FECHAACTIVACION,PEREG.ULTIMA_MODIFICACION,PEREG.USUARIO_MODIFICO);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_BENEFI_DEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_BENEFI_DEX (P_ID_BENEFICIARIO_DEX  IN EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE, 
                          P_ALIAS_BENEFICIARIO   IN EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE, 
                          P_CTEDEX 				 IN EBANKING.BENEFI_DEX.CTEDEX%TYPE,
                          P_FECHAACTIVACION      IN EBANKING.BENEFI_DEX.FECHAACTIVACION%TYPE,
         				  P_ULTIMA_MODIFICACION  IN EBANKING.BENEFI_DEX.ULTIMA_MODIFICACION%TYPE,
         				  P_USUARIO_MODIFICO     IN EBANKING.BENEFI_DEX.USUARIO_MODIFICO%TYPE,         					
         				  PSCOD                  OUT NUMBER,
                          PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.BENEFI_DEX%ROWTYPE;
BEGIN 
    PEREG.ID_BENEFICIARIO_DEX  :=P_ID_BENEFICIARIO_DEX;
	PEREG.ALIAS_BENEFICIARIO   :=P_ALIAS_BENEFICIARIO;
	PEREG.CTEDEX           	   :=P_CTEDEX;	
	PEREG.FECHAACTIVACION      :=P_FECHAACTIVACION;
	PEREG.ULTIMA_MODIFICACION  :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO     :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_BENEFI_DEX(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_BENEFI_DEX(PEREG IN  EBANKING.BENEFI_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.BENEFI_DEX B SET 
		 B.ALIAS_BENEFICIARIO    = NVL(PEREG.ALIAS_BENEFICIARIO,B.ALIAS_BENEFICIARIO),
		 B.FECHAACTIVACION       = NVL(PEREG.FECHAACTIVACION,B.FECHAACTIVACION),
		 B.ULTIMA_MODIFICACION   = NVL(PEREG.ULTIMA_MODIFICACION,B.ULTIMA_MODIFICACION),
		 B.USUARIO_MODIFICO      = NVL(PEREG.USUARIO_MODIFICO,B.USUARIO_MODIFICO)
     WHERE B.ID_BENEFICIARIO_DEX = PEREG.ID_BENEFICIARIO_DEX AND
	       B.CTEDEX = PEREG.CTEDEX;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_BENEFI_DEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_BENEFI_DEX(P_ID_BENEFICIARIO_DEX  IN EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE, 
                            P_ALIAS_BENEFICIARIO   IN EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE, 
                          	P_CTEDEX 			   IN EBANKING.BENEFI_DEX.CTEDEX%TYPE,
                          	P_FECHAACTIVACION      IN EBANKING.BENEFI_DEX.FECHAACTIVACION%TYPE,
         				  	P_ULTIMA_MODIFICACION  IN EBANKING.BENEFI_DEX.ULTIMA_MODIFICACION%TYPE,
         				  	P_USUARIO_MODIFICO     IN EBANKING.BENEFI_DEX.USUARIO_MODIFICO%TYPE,
                            PSCOD                  OUT NUMBER,
                            PSMSG                  OUT VARCHAR2)IS
PEREG EBANKING.BENEFI_DEX%ROWTYPE;
BEGIN 
    PEREG.ID_BENEFICIARIO_DEX  :=P_ID_BENEFICIARIO_DEX;
	PEREG.ALIAS_BENEFICIARIO   :=P_ALIAS_BENEFICIARIO;
	PEREG.CTEDEX           	   :=P_CTEDEX;	
	PEREG.FECHAACTIVACION      :=P_FECHAACTIVACION;
	PEREG.ULTIMA_MODIFICACION  :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO     :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_BENEFI_DEX(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE TRANSFER_DEX
******************************************************************************/
PROCEDURE ADD_TRANSFER_DEX (PEREG IN EBANKING.TRANSFER_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.TRANSFER_DEX(CLIENTE_ID,MTCN,MONTO_ENVIADO,BENEFICIARIO_ID,TARIFA,NUM_CUENTA,
		   		                      FECHA_ENVIO,FOLIO_RETENCION,PAIS_ID_DESTINO,ESTADO_ID_DESTINO,
									  CIUDAD_ID_DESTINO,ID_MONEDA_ENVIO,ID_MONEDA_DESTINO,ULTIMA_MODIFICACION,
									  USUARIO_MODIFICO) 
                               VALUES(PEREG.CLIENTE_ID,PEREG.MTCN,PEREG.MONTO_ENVIADO,PEREG.BENEFICIARIO_ID,
							          PEREG.TARIFA,PEREG.NUM_CUENTA,PEREG.FECHA_ENVIO,PEREG.FOLIO_RETENCION,
									  PEREG.PAIS_ID_DESTINO,PEREG.ESTADO_ID_DESTINO,PEREG.CIUDAD_ID_DESTINO,
									  PEREG.ID_MONEDA_ENVIO,PEREG.ID_MONEDA_DESTINO,PEREG.ULTIMA_MODIFICACION,
									  PEREG.USUARIO_MODIFICO);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_DEST_TEFSPEITERC(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_TRANSFER_DEX (P_CLIENTE_ID          IN EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE, 
                            P_MTCN                IN EBANKING.TRANSFER_DEX.MTCN%TYPE, 
                            P_MONTO_ENVIADO       IN EBANKING.TRANSFER_DEX.MONTO_ENVIADO%TYPE,
                           	P_BENEFICIARIO_ID     IN EBANKING.TRANSFER_DEX.BENEFICIARIO_ID%TYPE,
         					P_TARIFA              IN EBANKING.TRANSFER_DEX.TARIFA%TYPE,
         					P_NUM_CUENTA          IN EBANKING.TRANSFER_DEX.NUM_CUENTA%TYPE,
         					P_FECHA_ENVIO         IN EBANKING.TRANSFER_DEX.FECHA_ENVIO%TYPE,
         					P_FOLIO_RETENCION     IN EBANKING.TRANSFER_DEX.FOLIO_RETENCION%TYPE,
                           	P_PAIS_ID_DESTINO     IN EBANKING.TRANSFER_DEX.PAIS_ID_DESTINO%TYPE,
         					P_ESTADO_ID_DESTINO   IN EBANKING.TRANSFER_DEX.ESTADO_ID_DESTINO%TYPE,
         					P_CIUDAD_ID_DESTINO   IN EBANKING.TRANSFER_DEX.CIUDAD_ID_DESTINO%TYPE,
         					P_ID_MONEDA_ENVIO     IN EBANKING.TRANSFER_DEX.ID_MONEDA_ENVIO%TYPE,
         					P_ID_MONEDA_DESTINO   IN EBANKING.TRANSFER_DEX.ID_MONEDA_DESTINO%TYPE,
         					P_ULTIMA_MODIFICACION IN EBANKING.TRANSFER_DEX.ULTIMA_MODIFICACION%TYPE,
         					P_USUARIO_MODIFICO    IN EBANKING.TRANSFER_DEX.USUARIO_MODIFICO%TYPE,
                           	PSCOD                 OUT NUMBER,
                           	PSMSG                 OUT VARCHAR2)IS
PEREG EBANKING.TRANSFER_DEX%ROWTYPE;
BEGIN 
    PEREG.CLIENTE_ID  		  :=P_CLIENTE_ID;
	PEREG.MTCN           	  :=P_MTCN;
	PEREG.MONTO_ENVIADO 	  :=P_MONTO_ENVIADO;
	PEREG.BENEFICIARIO_ID     :=P_BENEFICIARIO_ID;
	PEREG.TARIFA       		  :=P_TARIFA;
	PEREG.NUM_CUENTA       	  :=P_NUM_CUENTA;
	PEREG.FECHA_ENVIO         :=P_FECHA_ENVIO;
	PEREG.FOLIO_RETENCION  	  :=P_FOLIO_RETENCION;
	PEREG.PAIS_ID_DESTINO     :=P_PAIS_ID_DESTINO;
	PEREG.ESTADO_ID_DESTINO   :=P_ESTADO_ID_DESTINO;
	PEREG.CIUDAD_ID_DESTINO   :=P_CIUDAD_ID_DESTINO;
	PEREG.ID_MONEDA_ENVIO     :=P_ID_MONEDA_ENVIO;
	PEREG.ID_MONEDA_DESTINO   :=P_ID_MONEDA_DESTINO;
	PEREG.ULTIMA_MODIFICACION :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO    :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_TRANSFER_DEX(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_TRANSFER_DEX(PEREG IN  EBANKING.TRANSFER_DEX%ROWTYPE,                               
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.TRANSFER_DEX D SET 
		 D.CLIENTE_ID          = NVL(PEREG.CLIENTE_ID,D.CLIENTE_ID),
		 D.MONTO_ENVIADO       = NVL(PEREG.MONTO_ENVIADO,D.MONTO_ENVIADO),
		 D.BENEFICIARIO_ID     = NVL(PEREG.BENEFICIARIO_ID,D.BENEFICIARIO_ID),
		 D.TARIFA       	   = NVL(PEREG.TARIFA,D.TARIFA),
		 D.NUM_CUENTA          = NVL(PEREG.NUM_CUENTA,D.NUM_CUENTA),
		 D.FECHA_ENVIO         = NVL(PEREG.FECHA_ENVIO,D.FECHA_ENVIO),
		 D.FOLIO_RETENCION     = NVL(PEREG.FOLIO_RETENCION,D.FOLIO_RETENCION),
		 D.PAIS_ID_DESTINO     = NVL(PEREG.PAIS_ID_DESTINO,D.PAIS_ID_DESTINO),
		 D.ESTADO_ID_DESTINO   = NVL(PEREG.ESTADO_ID_DESTINO,D.ESTADO_ID_DESTINO),
		 D.CIUDAD_ID_DESTINO   = NVL(PEREG.CIUDAD_ID_DESTINO,D.CIUDAD_ID_DESTINO),
		 D.ID_MONEDA_ENVIO     = NVL(PEREG.ID_MONEDA_ENVIO,D.ID_MONEDA_ENVIO),
		 D.ID_MONEDA_DESTINO   = NVL(PEREG.ID_MONEDA_DESTINO,D.ID_MONEDA_DESTINO),		
		 D.ULTIMA_MODIFICACION = NVL(PEREG.ULTIMA_MODIFICACION,D.ULTIMA_MODIFICACION),
		 D.USUARIO_MODIFICO    = NVL(PEREG.USUARIO_MODIFICO,D.USUARIO_MODIFICO)
     WHERE D.MTCN = PEREG.MTCN;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_TRANSFER_DEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_TRANSFER_DEX(P_CLIENTE_ID          IN EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE, 
                              P_MTCN                IN EBANKING.TRANSFER_DEX.MTCN%TYPE, 
                              P_MONTO_ENVIADO       IN EBANKING.TRANSFER_DEX.MONTO_ENVIADO%TYPE,
                           	  P_BENEFICIARIO_ID     IN EBANKING.TRANSFER_DEX.BENEFICIARIO_ID%TYPE,
         					  P_TARIFA              IN EBANKING.TRANSFER_DEX.TARIFA%TYPE,
         					  P_NUM_CUENTA          IN EBANKING.TRANSFER_DEX.NUM_CUENTA%TYPE,
         					  P_FECHA_ENVIO         IN EBANKING.TRANSFER_DEX.FECHA_ENVIO%TYPE,
         					  P_FOLIO_RETENCION     IN EBANKING.TRANSFER_DEX.FOLIO_RETENCION%TYPE,
                           	  P_PAIS_ID_DESTINO     IN EBANKING.TRANSFER_DEX.PAIS_ID_DESTINO%TYPE,
         					  P_ESTADO_ID_DESTINO   IN EBANKING.TRANSFER_DEX.ESTADO_ID_DESTINO%TYPE,
         					  P_CIUDAD_ID_DESTINO   IN EBANKING.TRANSFER_DEX.CIUDAD_ID_DESTINO%TYPE,
         					  P_ID_MONEDA_ENVIO     IN EBANKING.TRANSFER_DEX.ID_MONEDA_ENVIO%TYPE,
         					  P_ID_MONEDA_DESTINO   IN EBANKING.TRANSFER_DEX.ID_MONEDA_DESTINO%TYPE,
         					  P_ULTIMA_MODIFICACION IN EBANKING.TRANSFER_DEX.ULTIMA_MODIFICACION%TYPE,
         					  P_USUARIO_MODIFICO    IN EBANKING.TRANSFER_DEX.USUARIO_MODIFICO%TYPE,
                              PSCOD                 OUT NUMBER,
                              PSMSG                 OUT VARCHAR2)IS
PEREG EBANKING.TRANSFER_DEX%ROWTYPE;
BEGIN 
    PEREG.CLIENTE_ID  		  :=P_CLIENTE_ID;
	PEREG.MTCN           	  :=P_MTCN;
	PEREG.MONTO_ENVIADO 	  :=P_MONTO_ENVIADO;
	PEREG.BENEFICIARIO_ID     :=P_BENEFICIARIO_ID;
	PEREG.TARIFA       		  :=P_TARIFA;
	PEREG.NUM_CUENTA       	  :=P_NUM_CUENTA;
	PEREG.FECHA_ENVIO         :=P_FECHA_ENVIO;
	PEREG.FOLIO_RETENCION  	  :=P_FOLIO_RETENCION;
	PEREG.PAIS_ID_DESTINO     :=P_PAIS_ID_DESTINO;
	PEREG.ESTADO_ID_DESTINO   :=P_ESTADO_ID_DESTINO;
	PEREG.CIUDAD_ID_DESTINO   :=P_CIUDAD_ID_DESTINO;
	PEREG.ID_MONEDA_ENVIO     :=P_ID_MONEDA_ENVIO;
	PEREG.ID_MONEDA_DESTINO   :=P_ID_MONEDA_DESTINO;
	PEREG.ULTIMA_MODIFICACION :=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO    :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_TRANSFER_DEX(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE IMPUESTO_DEX
******************************************************************************/
PROCEDURE ADD_IMPUESTO_DEX (PEREG IN EBANKING.IMPUESTO_DEX%ROWTYPE,
                            PSCOD OUT NUMBER,
                            PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.IMPUESTO_DEX(MTCN,NOMBRE_IMPUESTO,MONTO,ID_IMPUESTO,ID_IMPORTE,NOMBRE_CORTO_IMPUESTO,
	                                  ULTIMA_MODIFICACION,USUARIO_MODIFICO) 
                               VALUES(PEREG.MTCN,PEREG.NOMBRE_IMPUESTO,PEREG.MONTO,PEREG.ID_IMPUESTO,PEREG.ID_IMPORTE,
							          PEREG.NOMBRE_CORTO_IMPUESTO,PEREG.ULTIMA_MODIFICACION,PEREG.USUARIO_MODIFICO);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_IMPUESTO_DEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_IMPUESTO_DEX (P_MTCN                  IN EBANKING.IMPUESTO_DEX.MTCN%TYPE, 
                            P_NOMBRE_IMPUESTO       IN EBANKING.IMPUESTO_DEX.NOMBRE_IMPUESTO%TYPE,
                           	P_MONTO                 IN EBANKING.IMPUESTO_DEX.MONTO%TYPE,
         					P_ID_IMPUESTO           IN EBANKING.IMPUESTO_DEX.ID_IMPUESTO%TYPE,
         					P_ID_IMPORTE            IN EBANKING.IMPUESTO_DEX.ID_IMPORTE%TYPE,
         					P_NOMBRE_CORTO_IMPUESTO IN EBANKING.IMPUESTO_DEX.NOMBRE_CORTO_IMPUESTO%TYPE,
         					P_ULTIMA_MODIFICACION   IN EBANKING.IMPUESTO_DEX.ULTIMA_MODIFICACION%TYPE,
                           	P_USUARIO_MODIFICO      IN EBANKING.IMPUESTO_DEX.USUARIO_MODIFICO%TYPE,
                           	PSCOD                   OUT NUMBER,
                           	PSMSG                   OUT VARCHAR2)IS
PEREG EBANKING.IMPUESTO_DEX%ROWTYPE;
BEGIN 
	PEREG.MTCN           	    :=P_MTCN;
	PEREG.NOMBRE_IMPUESTO 	    :=P_NOMBRE_IMPUESTO;
	PEREG.MONTO                 :=P_MONTO;
	PEREG.ID_IMPUESTO       	:=P_ID_IMPUESTO;
	PEREG.ID_IMPORTE       	    :=P_ID_IMPORTE;
	PEREG.NOMBRE_CORTO_IMPUESTO :=P_NOMBRE_CORTO_IMPUESTO;
	PEREG.ULTIMA_MODIFICACION  	:=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO      :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_IMPUESTO_DEX(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_IMPUESTO_DEX(PEREG IN  EBANKING.IMPUESTO_DEX%ROWTYPE,                               
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.IMPUESTO_DEX D SET 
		 D.NOMBRE_IMPUESTO       = NVL(PEREG.NOMBRE_IMPUESTO,D.NOMBRE_IMPUESTO),
		 D.MONTO                 = NVL(PEREG.MONTO,D.MONTO),
		 D.ID_IMPUESTO       	 = NVL(PEREG.ID_IMPUESTO,D.ID_IMPUESTO),
		 D.ID_IMPORTE            = NVL(PEREG.ID_IMPORTE,D.ID_IMPORTE),
		 D.NOMBRE_CORTO_IMPUESTO = NVL(PEREG.NOMBRE_CORTO_IMPUESTO,D.NOMBRE_CORTO_IMPUESTO),
		 D.ULTIMA_MODIFICACION   = NVL(PEREG.ULTIMA_MODIFICACION,D.ULTIMA_MODIFICACION),
		 D.USUARIO_MODIFICO      = NVL(PEREG.USUARIO_MODIFICO,D.USUARIO_MODIFICO)
     WHERE D.MTCN = PEREG.MTCN;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_IMPUESTO_DEX(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_IMPUESTO_DEX(P_MTCN                  IN EBANKING.IMPUESTO_DEX.MTCN%TYPE, 
                              P_NOMBRE_IMPUESTO       IN EBANKING.IMPUESTO_DEX.NOMBRE_IMPUESTO%TYPE,
                           	  P_MONTO                 IN EBANKING.IMPUESTO_DEX.MONTO%TYPE,
         					  P_ID_IMPUESTO           IN EBANKING.IMPUESTO_DEX.ID_IMPUESTO%TYPE,
         					  P_ID_IMPORTE            IN EBANKING.IMPUESTO_DEX.ID_IMPORTE%TYPE,
         					  P_NOMBRE_CORTO_IMPUESTO IN EBANKING.IMPUESTO_DEX.NOMBRE_CORTO_IMPUESTO%TYPE,
         					  P_ULTIMA_MODIFICACION   IN EBANKING.IMPUESTO_DEX.ULTIMA_MODIFICACION%TYPE,
                           	  P_USUARIO_MODIFICO      IN EBANKING.IMPUESTO_DEX.USUARIO_MODIFICO%TYPE,
                              PSCOD                 OUT NUMBER,
                              PSMSG                 OUT VARCHAR2)IS
PEREG EBANKING.IMPUESTO_DEX%ROWTYPE;
BEGIN 
	PEREG.MTCN           	    :=P_MTCN;
	PEREG.NOMBRE_IMPUESTO 	    :=P_NOMBRE_IMPUESTO;
	PEREG.MONTO                 :=P_MONTO;
	PEREG.ID_IMPUESTO       	:=P_ID_IMPUESTO;
	PEREG.ID_IMPORTE       	    :=P_ID_IMPORTE;
	PEREG.NOMBRE_CORTO_IMPUESTO :=P_NOMBRE_CORTO_IMPUESTO;
	PEREG.ULTIMA_MODIFICACION  	:=P_ULTIMA_MODIFICACION;
	PEREG.USUARIO_MODIFICO      :=P_USUARIO_MODIFICO;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_IMPUESTO_DEX(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_TRACKING
******************************************************************************/
PROCEDURE ADD_USER_TRACKING (PEREG IN EBANKING.EBANKING_USER_TRACKING%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.EBANKING_USER_TRACKING(NUMERO_CLIENTE,FECHA,DESCRIPCION,SISTEMA,ALIAS,ESTATUS,USR_PREV) 
                                         VALUES(PEREG.NUMERO_CLIENTE,PEREG.FECHA,PEREG.DESCRIPCION,PEREG.SISTEMA,
										        PEREG.ALIAS,PEREG.ESTATUS,PEREG.USR_PREV);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_USER_TRACKING(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_USER_TRACKING (P_NUMERO_CLIENTE IN EBANKING.EBANKING_USER_TRACKING.NUMERO_CLIENTE%TYPE, 
                             P_FECHA          IN EBANKING.EBANKING_USER_TRACKING.FECHA%TYPE,
                           	 P_DESCRIPCION    IN EBANKING.EBANKING_USER_TRACKING.DESCRIPCION%TYPE,
         					 P_SISTEMA        IN EBANKING.EBANKING_USER_TRACKING.SISTEMA%TYPE,
         					 P_ALIAS          IN EBANKING.EBANKING_USER_TRACKING.ALIAS%TYPE,
         					 P_ESTATUS 		  IN EBANKING.EBANKING_USER_TRACKING.ESTATUS%TYPE,
         					 P_USR_PREV   	  IN EBANKING.EBANKING_USER_TRACKING.USR_PREV%TYPE,
                           	 PSCOD            OUT NUMBER,
                           	 PSMSG            OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_USER_TRACKING%ROWTYPE;
BEGIN 
	PEREG.NUMERO_CLIENTE        :=P_NUMERO_CLIENTE;
	PEREG.FECHA 	            :=P_FECHA;
	PEREG.DESCRIPCION           :=P_DESCRIPCION;
	PEREG.SISTEMA       	    :=P_SISTEMA;
	PEREG.ALIAS       	        :=P_ALIAS;
	PEREG.ESTATUS               :=P_ESTATUS;
	PEREG.USR_PREV  	        :=P_USR_PREV;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_USER_TRACKING(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_USER_TRACKING(PEREG IN  EBANKING.EBANKING_USER_TRACKING%ROWTYPE,                               
							  PSCOD OUT NUMBER,
                              PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.EBANKING_USER_TRACKING T SET 
		 T.DESCRIPCION = NVL(PEREG.DESCRIPCION,T.DESCRIPCION),
		 T.SISTEMA     = NVL(PEREG.SISTEMA,T.SISTEMA),
		 T.ALIAS       = NVL(PEREG.ALIAS,T.ALIAS),
		 T.ESTATUS     = NVL(PEREG.ESTATUS,T.ESTATUS),
		 T.USR_PREV    = NVL(PEREG.USR_PREV,T.USR_PREV)
     WHERE T.NUMERO_CLIENTE = PEREG.NUMERO_CLIENTE AND 
	       T.FECHA          = PEREG.FECHA;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_USER_TRACKING(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_USER_TRACKING(P_NUMERO_CLIENTE IN EBANKING.EBANKING_USER_TRACKING.NUMERO_CLIENTE%TYPE, 
                               P_FECHA          IN EBANKING.EBANKING_USER_TRACKING.FECHA%TYPE,
                           	   P_DESCRIPCION    IN EBANKING.EBANKING_USER_TRACKING.DESCRIPCION%TYPE,
         					   P_SISTEMA        IN EBANKING.EBANKING_USER_TRACKING.SISTEMA%TYPE,
         					   P_ALIAS          IN EBANKING.EBANKING_USER_TRACKING.ALIAS%TYPE,
         					   P_ESTATUS 		IN EBANKING.EBANKING_USER_TRACKING.ESTATUS%TYPE,
         					   P_USR_PREV   	IN EBANKING.EBANKING_USER_TRACKING.USR_PREV%TYPE,
                               PSCOD            OUT NUMBER,
                               PSMSG            OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_USER_TRACKING%ROWTYPE;
BEGIN 
	PEREG.NUMERO_CLIENTE        :=P_NUMERO_CLIENTE;
	PEREG.FECHA 	            :=P_FECHA;
	PEREG.DESCRIPCION           :=P_DESCRIPCION;
	PEREG.SISTEMA       	    :=P_SISTEMA;
	PEREG.ALIAS       	        :=P_ALIAS;
	PEREG.ESTATUS               :=P_ESTATUS;
	PEREG.USR_PREV  	        :=P_USR_PREV;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_USER_TRACKING(PEREG,PSCOD,PSMSG);
END;


/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE SCHEDULED_PAYMENT
******************************************************************************/
PROCEDURE ADD_SCHEDULED_PAY (PEREG IN EBANKING.SCHEDULED_PAYMENT%ROWTYPE,
                             PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2)IS
BEGIN 
    PSCOD:=0;
    INSERT INTO EBANKING.SCHEDULED_PAYMENT(SCHEDULED_PAYMENT_ID,TX,REQUEST,RESPONSE,STATUS,APPLY_DATE,
	                                       PROGRAM_DATE,TX_NAME,TEXT,FOLIO_PROGRAMADO,FOLIO_ENVIADO,
										   FOLIO_INTERBANCARIO,USER_ID,SCHEDULED_EMAIL_ID)                                          
								    VALUES(PEREG.SCHEDULED_PAYMENT_ID,PEREG.TX,PEREG.REQUEST,PEREG.RESPONSE,
									       PEREG.STATUS,PEREG.APPLY_DATE,PEREG.PROGRAM_DATE,PEREG.TX_NAME,
										   PEREG.TEXT,PEREG.FOLIO_PROGRAMADO,PEREG.FOLIO_ENVIADO,
										   PEREG.FOLIO_INTERBANCARIO,PEREG.USER_ID,PEREG.SCHEDULED_EMAIL_ID);
    COMMIT;
    PSMSG:='OPERACION EXITOSA';
    EXCEPTION     
    WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;     
	    RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_TRANS.ADD_SCHEDULED_PAY(' || SQLCODE || '  ' || SQLERRM || ')');
END;
				

PROCEDURE ADD_SCHEDULED_PAY (P_SCHEDULED_PAYMENT_ID IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_PAYMENT_ID%TYPE, 
                             P_TX                   IN EBANKING.SCHEDULED_PAYMENT.TX%TYPE,
                           	 P_REQUEST    			IN EBANKING.SCHEDULED_PAYMENT.REQUEST%TYPE,
         					 P_RESPONSE        		IN EBANKING.SCHEDULED_PAYMENT.RESPONSE%TYPE,
         					 P_STATUS          		IN EBANKING.SCHEDULED_PAYMENT.STATUS%TYPE,
         					 P_APPLY_DATE 		    IN EBANKING.SCHEDULED_PAYMENT.APPLY_DATE%TYPE,
         					 P_PROGRAM_DATE   	  	IN EBANKING.SCHEDULED_PAYMENT.PROGRAM_DATE%TYPE,
							 P_TX_NAME        		IN EBANKING.SCHEDULED_PAYMENT.TX_NAME%TYPE,
							 P_TEXT               	IN EBANKING.SCHEDULED_PAYMENT.TEXT%TYPE,
							 P_FOLIO_PROGRAMADO     IN EBANKING.SCHEDULED_PAYMENT.FOLIO_PROGRAMADO%TYPE,
							 P_FOLIO_ENVIADO        IN EBANKING.SCHEDULED_PAYMENT.FOLIO_ENVIADO%TYPE,
							 P_FOLIO_INTERBANCARIO  IN EBANKING.SCHEDULED_PAYMENT.FOLIO_INTERBANCARIO%TYPE,
							 P_USER_ID              IN EBANKING.SCHEDULED_PAYMENT.USER_ID%TYPE,
							 P_SCHEDULED_EMAIL_ID   IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_EMAIL_ID%TYPE,
                           	 PSCOD            		OUT NUMBER,
                           	 PSMSG            		OUT VARCHAR2)IS
PEREG EBANKING.SCHEDULED_PAYMENT%ROWTYPE;
BEGIN 
	PEREG.SCHEDULED_PAYMENT_ID :=P_SCHEDULED_PAYMENT_ID;
	PEREG.TX 	               :=P_TX;
	PEREG.REQUEST              :=P_REQUEST;
	PEREG.RESPONSE       	   :=P_RESPONSE;
	PEREG.STATUS       	       :=P_STATUS;
	PEREG.APPLY_DATE           :=P_APPLY_DATE;
	PEREG.PROGRAM_DATE  	   :=P_PROGRAM_DATE;
	PEREG.TX_NAME              :=P_TX_NAME;
	PEREG.TEXT           	   :=P_TEXT;
	PEREG.FOLIO_PROGRAMADO     :=P_FOLIO_PROGRAMADO;
	PEREG.FOLIO_ENVIADO        :=P_FOLIO_ENVIADO;
	PEREG.FOLIO_INTERBANCARIO  :=P_FOLIO_INTERBANCARIO;
	PEREG.USER_ID              :=P_USER_ID;
	PEREG.SCHEDULED_EMAIL_ID   :=P_SCHEDULED_EMAIL_ID;
	EBANKING.PKG_CORE_GEN_TRANS.ADD_SCHEDULED_PAY(PEREG,PSCOD,PSMSG);
END;
 
PROCEDURE MODIFY_SCHEDULED_PAY(PEREG IN  EBANKING.SCHEDULED_PAYMENT%ROWTYPE,                               
							   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2)IS
BEGIN
     PSCOD:=0;
     UPDATE EBANKING.SCHEDULED_PAYMENT S SET 
		 S.TX                  = NVL(PEREG.TX,S.TX),
		 S.REQUEST             = NVL(PEREG.REQUEST,S.REQUEST),
		 S.RESPONSE            = NVL(PEREG.RESPONSE,S.RESPONSE),
		 S.STATUS              = NVL(PEREG.STATUS,S.STATUS),
		 S.APPLY_DATE          = NVL(PEREG.APPLY_DATE,S.APPLY_DATE),
		 S.PROGRAM_DATE        = NVL(PEREG.PROGRAM_DATE,S.PROGRAM_DATE),
		 S.TX_NAME             = NVL(PEREG.TX_NAME,S.TX_NAME),
		 S.TEXT                = NVL(PEREG.TEXT,S.TEXT),
		 S.FOLIO_PROGRAMADO    = NVL(PEREG.FOLIO_PROGRAMADO,S.FOLIO_PROGRAMADO),
		 S.FOLIO_ENVIADO       = NVL(PEREG.FOLIO_ENVIADO,S.FOLIO_ENVIADO),
		 S.FOLIO_INTERBANCARIO = NVL(PEREG.FOLIO_INTERBANCARIO,S.FOLIO_INTERBANCARIO),
		 S.USER_ID             = NVL(PEREG.USER_ID,S.USER_ID),
		 S.SCHEDULED_EMAIL_ID  = NVL(PEREG.SCHEDULED_EMAIL_ID,S.SCHEDULED_EMAIL_ID)		 
     WHERE S.SCHEDULED_PAYMENT_ID = PEREG.SCHEDULED_PAYMENT_ID;
     COMMIT;
     PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      WHEN OTHERS THEN
        PSCOD:=-1;
        PSMSG:=SQLCODE || '  ' || SQLERRM;
		ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_TRANS.MODIFY_SCHEDULED_PAY(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
PROCEDURE MODIFY_SCHEDULED_PAY(P_SCHEDULED_PAYMENT_ID IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_PAYMENT_ID%TYPE, 
                               P_TX                   IN EBANKING.SCHEDULED_PAYMENT.TX%TYPE,
                           	   P_REQUEST    		  IN EBANKING.SCHEDULED_PAYMENT.REQUEST%TYPE,
         					   P_RESPONSE        	  IN EBANKING.SCHEDULED_PAYMENT.RESPONSE%TYPE,
         					   P_STATUS          	  IN EBANKING.SCHEDULED_PAYMENT.STATUS%TYPE,
         					   P_APPLY_DATE 		  IN EBANKING.SCHEDULED_PAYMENT.APPLY_DATE%TYPE,
         					   P_PROGRAM_DATE   	  IN EBANKING.SCHEDULED_PAYMENT.PROGRAM_DATE%TYPE,
							   P_TX_NAME        	  IN EBANKING.SCHEDULED_PAYMENT.TX_NAME%TYPE,
							   P_TEXT                 IN EBANKING.SCHEDULED_PAYMENT.TEXT%TYPE,
							   P_FOLIO_PROGRAMADO     IN EBANKING.SCHEDULED_PAYMENT.FOLIO_PROGRAMADO%TYPE,
							   P_FOLIO_ENVIADO        IN EBANKING.SCHEDULED_PAYMENT.FOLIO_ENVIADO%TYPE,
							   P_FOLIO_INTERBANCARIO  IN EBANKING.SCHEDULED_PAYMENT.FOLIO_INTERBANCARIO%TYPE,
							   P_USER_ID              IN EBANKING.SCHEDULED_PAYMENT.USER_ID%TYPE,
							   P_SCHEDULED_EMAIL_ID   IN EBANKING.SCHEDULED_PAYMENT.SCHEDULED_EMAIL_ID%TYPE,
                               PSCOD            	  OUT NUMBER,
                               PSMSG            	  OUT VARCHAR2)IS
PEREG EBANKING.SCHEDULED_PAYMENT%ROWTYPE;
BEGIN 
	PEREG.SCHEDULED_PAYMENT_ID :=P_SCHEDULED_PAYMENT_ID;
	PEREG.TX 	               :=P_TX;
	PEREG.REQUEST              :=P_REQUEST;
	PEREG.RESPONSE       	   :=P_RESPONSE;
	PEREG.STATUS       	       :=P_STATUS;
	PEREG.APPLY_DATE           :=P_APPLY_DATE;
	PEREG.PROGRAM_DATE  	   :=P_PROGRAM_DATE;
	PEREG.TX_NAME              :=P_TX_NAME;
	PEREG.TEXT           	   :=P_TEXT;
	PEREG.FOLIO_PROGRAMADO     :=P_FOLIO_PROGRAMADO;
	PEREG.FOLIO_ENVIADO        :=P_FOLIO_ENVIADO;
	PEREG.FOLIO_INTERBANCARIO  :=P_FOLIO_INTERBANCARIO;
	PEREG.USER_ID              :=P_USER_ID;
	PEREG.SCHEDULED_EMAIL_ID   :=P_SCHEDULED_EMAIL_ID;
	EBANKING.PKG_CORE_GEN_TRANS.MODIFY_SCHEDULED_PAY(PEREG,PSCOD,PSMSG);
END;




END PKG_CORE_GEN_TRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_GEN_USER AS
/******************************************************************************
   NAME:       PKG_CORE_AUTENTICATION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE ADD_EBANKING_USER (PEREG IN EBANKING.EBANKING_USER%ROWTYPE,
		  					 PSCOD OUT NUMBER,
                             PSMSG OUT VARCHAR2) IS
BEGIN
	 INSERT INTO EBANKING.EBANKING_USER
        (ID, ACTIVATION, ACTIVE, ANSWER, CELLULAR, EMAIL, QUESTION, USER2CELLCOMPANY, ADVANCEDSERVICE, SECUREDATA,
         ACTIVATIONTYPE, SECURITY_LEVEL, STATUSNS, CODIGONS, CONFIRMNS, STATUS_CONT_TRAN, MAIL_RECEIVE, TRACKING, 
         PWD_CONFIRM, PWD_BANCA_TEL, PWD_CHANGE_DATE, PWD_STATUS, PWD_CONFIRM_CHANGE_DATE, BIOMETRICO, TELEFONO_OFICINA,
         OLD_ADVANCEDSERVICE, ULT_ACCESO, ULT_IP, BAN_MAIL, TOKEN, FECHA_CAMBIO_STATUS_BAJA, STATUS_BAJA, USER_STATUS, 
         FECHA_CAMBIO_STATUS, RFC_CLIENTE, NIP_RED_MOVIL)
     VALUES(PEREG.ID, PEREG.ACTIVATION, PEREG.ACTIVE, PEREG.ANSWER, PEREG.CELLULAR, PEREG.EMAIL, PEREG.QUESTION,
            PEREG.USER2CELLCOMPANY, PEREG.ADVANCEDSERVICE, PEREG.SECUREDATA,PEREG.ACTIVATIONTYPE, PEREG.SECURITY_LEVEL, 
            PEREG.STATUSNS, PEREG.CODIGONS, PEREG.CONFIRMNS, PEREG.STATUS_CONT_TRAN, PEREG.MAIL_RECEIVE, PEREG.TRACKING, 
            PEREG.PWD_CONFIRM, PEREG.PWD_BANCA_TEL, PEREG.PWD_CHANGE_DATE, PEREG.PWD_STATUS, PEREG.PWD_CONFIRM_CHANGE_DATE, PEREG.BIOMETRICO, PEREG.TELEFONO_OFICINA, PEREG.OLD_ADVANCEDSERVICE, PEREG.ULT_ACCESO, PEREG.ULT_IP, PEREG.BAN_MAIL, PEREG.TOKEN, PEREG.FECHA_CAMBIO_STATUS_BAJA, PEREG.STATUS_BAJA, PEREG.USER_STATUS, PEREG.FECHA_CAMBIO_STATUS, PEREG.RFC_CLIENTE, PEREG.NIP_RED_MOVIL);
     COMMIT;
	 PSCOD:=0;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      	WHEN OTHERS THEN
		PSCOD:=-1;
	    PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_GEN_USER.ADD_EBANKING_USER(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EBANKING_USER (P_ID 		 				IN EBANKING.EBANKING_USER.ID%TYPE, 
				        	 P_ACTIVATION 		   		IN EBANKING.EBANKING_USER.ACTIVATION%TYPE, 
					         P_ACTIVE 			   		IN EBANKING.EBANKING_USER.ACTIVE%TYPE, 
					         P_ANSWER 			   		IN EBANKING.EBANKING_USER.ANSWER%TYPE, 
					         P_CELLULAR 		   		IN EBANKING.EBANKING_USER.CELLULAR%TYPE, 
					         P_EMAIL 			   	    IN EBANKING.EBANKING_USER.EMAIL%TYPE, 
					         P_QUESTION 				IN EBANKING.EBANKING_USER.QUESTION%TYPE, 
					         P_USER2CELLCOMPANY 		IN EBANKING.EBANKING_USER.USER2CELLCOMPANY%TYPE, 
					         P_ADVANCEDSERVICE 	        IN EBANKING.EBANKING_USER.ADVANCEDSERVICE%TYPE, 
					         P_SECUREDATA 	   	  		IN EBANKING.EBANKING_USER.SECUREDATA%TYPE,
					         P_ACTIVATIONTYPE 			IN EBANKING.EBANKING_USER.ACTIVATIONTYPE%TYPE, 
					         P_SECURITY_LEVEL 	 	    IN EBANKING.EBANKING_USER.SECURITY_LEVEL%TYPE, 
					         P_STATUSNS 	  	 		IN EBANKING.EBANKING_USER.STATUSNS%TYPE, 
					         P_CODIGONS    				IN EBANKING.EBANKING_USER.CODIGONS%TYPE, 
					         P_CONFIRMNS   				IN EBANKING.EBANKING_USER.CONFIRMNS%TYPE, 
					         P_STATUS_CONT_TRAN 		IN EBANKING.EBANKING_USER.STATUS_CONT_TRAN%TYPE, 
					         P_MAIL_RECEIVE 	   		IN EBANKING.EBANKING_USER.MAIL_RECEIVE%TYPE, 
					         P_TRACKING 	   			IN EBANKING.EBANKING_USER.TRACKING%TYPE, 
					         P_PWD_CONFIRM 				IN EBANKING.EBANKING_USER.PWD_CONFIRM%TYPE, 
					         P_PWD_BANCA_TEL  			IN EBANKING.EBANKING_USER.PWD_BANCA_TEL%TYPE, 
					         P_PWD_CHANGE_DATE 			IN EBANKING.EBANKING_USER.PWD_CHANGE_DATE%TYPE, 
					         P_PWD_STATUS 	   	  		IN EBANKING.EBANKING_USER.PWD_STATUS%TYPE, 
					         P_PWD_CONFIRM_CHANGE_DATE  IN EBANKING.EBANKING_USER.PWD_CONFIRM_CHANGE_DATE%TYPE, 
					         P_BIOMETRICO 			    IN EBANKING.EBANKING_USER.BIOMETRICO%TYPE, 
					         P_TELEFONO_OFICINA 		IN EBANKING.EBANKING_USER.TELEFONO_OFICINA%TYPE, 
					         P_OLD_ADVANCEDSERVICE 		IN EBANKING.EBANKING_USER.OLD_ADVANCEDSERVICE%TYPE, 
					         P_ULT_ACCESO 		   	    IN EBANKING.EBANKING_USER.ULT_ACCESO%TYPE, 
					         P_ULT_IP 	  	 			IN EBANKING.EBANKING_USER.ULT_IP%TYPE, 
					         P_BAN_MAIL  				IN EBANKING.EBANKING_USER.BAN_MAIL%TYPE, 
					         P_TOKEN 	   			    IN EBANKING.EBANKING_USER.TOKEN%TYPE, 
					         P_FECHA_CAMBIO_STATUS_BAJA IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS_BAJA%TYPE, 
					         P_STATUS_BAJA 				IN EBANKING.EBANKING_USER.STATUS_BAJA%TYPE, 
					         P_USER_STATUS 				IN EBANKING.EBANKING_USER.USER_STATUS%TYPE, 
					         P_FECHA_CAMBIO_STATUS 		IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS%TYPE, 
					         P_RFC_CLIENTE 				IN EBANKING.EBANKING_USER.RFC_CLIENTE%TYPE, 
					         P_NIP_RED_MOVIL  			IN EBANKING.EBANKING_USER.NIP_RED_MOVIL%TYPE,
		  					 PSCOD 						OUT NUMBER,
                             PSMSG 						OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_USER%ROWTYPE;
BEGIN
	 PEREG.ID:=P_ID; 
  	 PEREG.ACTIVATION:=P_ACTIVATION; 
  	 PEREG.ACTIVE:=P_ACTIVE; 
  	 PEREG.ANSWER:=P_ANSWER; 
  	 PEREG.CELLULAR:=P_CELLULAR; 
  	 PEREG.EMAIL:=P_EMAIL; 
  	 PEREG.QUESTION:=P_QUESTION;
  	 PEREG.USER2CELLCOMPANY:=P_USER2CELLCOMPANY; 
  	 PEREG.ADVANCEDSERVICE:=P_ADVANCEDSERVICE; 
  	 PEREG.SECUREDATA:=P_SECUREDATA;
  	 PEREG.ACTIVATIONTYPE:=P_ACTIVATIONTYPE; 
  	 PEREG.SECURITY_LEVEL:=P_SECURITY_LEVEL; 
  	 PEREG.STATUSNS:=P_STATUSNS; 
  	 PEREG.CODIGONS:=P_CODIGONS; 
  	 PEREG.CONFIRMNS:=P_CONFIRMNS; 
  	 PEREG.STATUS_CONT_TRAN:=P_STATUS_CONT_TRAN; 
  	 PEREG.MAIL_RECEIVE:=P_MAIL_RECEIVE; 
  	 PEREG.TRACKING:=P_TRACKING; 
  	 PEREG.PWD_CONFIRM:=P_PWD_CONFIRM; 
  	 PEREG.PWD_BANCA_TEL:=P_PWD_BANCA_TEL; 
  	 PEREG.PWD_CHANGE_DATE:=P_PWD_CHANGE_DATE; 
  	 PEREG.PWD_STATUS:=P_PWD_STATUS; 
  	 PEREG.PWD_CONFIRM_CHANGE_DATE:=P_PWD_CONFIRM_CHANGE_DATE; 
  	 PEREG.BIOMETRICO:=P_BIOMETRICO; 
  	 PEREG.TELEFONO_OFICINA:=P_TELEFONO_OFICINA; 
  	 PEREG.OLD_ADVANCEDSERVICE:=P_OLD_ADVANCEDSERVICE; 
  	 PEREG.ULT_ACCESO:=P_ULT_ACCESO; 
  	 PEREG.ULT_IP:=P_ULT_IP; 
  	 PEREG.BAN_MAIL:=P_BAN_MAIL; 
  	 PEREG.TOKEN:=P_TOKEN; 
  	 PEREG.FECHA_CAMBIO_STATUS_BAJA:=P_FECHA_CAMBIO_STATUS_BAJA; 
  	 PEREG.STATUS_BAJA:=P_STATUS_BAJA; 
  	 PEREG.USER_STATUS:=P_USER_STATUS; 
  	 PEREG.FECHA_CAMBIO_STATUS:=P_FECHA_CAMBIO_STATUS; 
  	 PEREG.RFC_CLIENTE:=P_RFC_CLIENTE; 
  	 PEREG.NIP_RED_MOVIL:=P_NIP_RED_MOVIL;
  	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_USER(PEREG,PSCOD,PSMSG);
END;
 
 
PROCEDURE MODIFY_EBANKING_USER(PEREG IN EBANKING.EBANKING_USER%ROWTYPE,
		  					   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2) IS
BEGIN     
     UPDATE EBANKING.EBANKING_USER U SET  
     		U.ACTIVATION               = NVL(PEREG.ACTIVATION,U.ACTIVATION), 
            U.ACTIVE 	   			   = NVL(PEREG.ACTIVE,U.ACTIVE),
            U.ANSWER 				   = NVL(PEREG.ANSWER,U.ANSWER),
     		U.CELLULAR 				   = NVL(PEREG.CELLULAR,U.CELLULAR),
            U.EMAIL 				   = NVL(PEREG.EMAIL,U.EMAIL), 
     		U.QUESTION 				   = NVL(PEREG.QUESTION,U.QUESTION),
            U.USER2CELLCOMPANY 		   = NVL(PEREG.USER2CELLCOMPANY,U.USER2CELLCOMPANY),
     		U.ADVANCEDSERVICE 		   = NVL(PEREG.ADVANCEDSERVICE,U.ADVANCEDSERVICE),
            U.SECUREDATA 			   = NVL(PEREG.SECUREDATA,U.SECUREDATA),
     		U.ACTIVATIONTYPE 		   = NVL(PEREG.ACTIVATIONTYPE,U.ACTIVATIONTYPE),
     		U.SECURITY_LEVEL 		   = NVL(PEREG.SECURITY_LEVEL,U.SECURITY_LEVEL),
            U.STATUSNS 				   = NVL(PEREG.STATUSNS,U.STATUSNS),
            U.CODIGONS 				   = NVL(PEREG.CODIGONS,U.CODIGONS), 
     		U.CONFIRMNS 			   = NVL(PEREG.CONFIRMNS,U.CONFIRMNS),
            U.STATUS_CONT_TRAN 		   = NVL(PEREG.STATUS_CONT_TRAN,U.STATUS_CONT_TRAN),
            U.MAIL_RECEIVE 			   = NVL(PEREG.MAIL_RECEIVE,U.MAIL_RECEIVE), 
     		U.TRACKING 				   = NVL(PEREG.TRACKING,U.TRACKING),
            U.PWD_CONFIRM 			   = NVL(PEREG.PWD_CONFIRM,U.PWD_CONFIRM),
            U.PWD_BANCA_TEL 		   = NVL(PEREG.PWD_BANCA_TEL,U.PWD_BANCA_TEL),
     		U.PWD_CHANGE_DATE 		   = NVL(PEREG.PWD_CHANGE_DATE,U.PWD_CHANGE_DATE),
            U.PWD_STATUS 			   = NVL(PEREG.PWD_STATUS,U.PWD_STATUS),
            U.PWD_CONFIRM_CHANGE_DATE  = NVL(PEREG.PWD_CONFIRM_CHANGE_DATE,U.PWD_CONFIRM_CHANGE_DATE),
     		U.BIOMETRICO 			   = NVL(PEREG.BIOMETRICO, U.BIOMETRICO),
            U.TELEFONO_OFICINA 		   = NVL(PEREG.TELEFONO_OFICINA, U.TELEFONO_OFICINA), 
     		U.OLD_ADVANCEDSERVICE 	   = NVL(PEREG.OLD_ADVANCEDSERVICE, U.OLD_ADVANCEDSERVICE),
     		U.ULT_ACCESO 			   = NVL(PEREG.ULT_ACCESO, U.ULT_ACCESO),
     		U.ULT_IP 	   			   = NVL(PEREG.ULT_IP, U.ULT_IP),
     		U.BAN_MAIL 				   = NVL(PEREG.BAN_MAIL, U.BAN_MAIL),
     		U.TOKEN    	 			   = NVL(PEREG.TOKEN, U.TOKEN),
     		U.FECHA_CAMBIO_STATUS_BAJA = NVL(PEREG.FECHA_CAMBIO_STATUS_BAJA, U.FECHA_CAMBIO_STATUS_BAJA),
     		U.STATUS_BAJA 			   = NVL(PEREG.STATUS_BAJA, U.STATUS_BAJA),
     		U.USER_STATUS 			   = NVL(PEREG.USER_STATUS, U.USER_STATUS),
     		U.FECHA_CAMBIO_STATUS 	   = NVL(PEREG.FECHA_CAMBIO_STATUS, U.FECHA_CAMBIO_STATUS),
     		U.RFC_CLIENTE 			   = NVL(PEREG.RFC_CLIENTE, U.RFC_CLIENTE),
     		U.NIP_RED_MOVIL 		   = NVL(PEREG.NIP_RED_MOVIL, U.NIP_RED_MOVIL)
      WHERE U.ID = PEREG.ID;
      COMMIT;
	  PSCOD:=0;
	  PSMSG:='OPERACION EXITOSA';
	  EXCEPTION
	  	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_GEN_USER.MODIFY_EBANKING_USER(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
 
PROCEDURE MODIFY_EBANKING_USER(P_ID 		 		      IN EBANKING.EBANKING_USER.ID%TYPE, 
				        	   P_ACTIVATION 		   	  IN EBANKING.EBANKING_USER.ACTIVATION%TYPE, 
					           P_ACTIVE 			   	  IN EBANKING.EBANKING_USER.ACTIVE%TYPE, 
					           P_ANSWER 			   	  IN EBANKING.EBANKING_USER.ANSWER%TYPE, 
					           P_CELLULAR 		   		  IN EBANKING.EBANKING_USER.CELLULAR%TYPE, 
					           P_EMAIL 			   	      IN EBANKING.EBANKING_USER.EMAIL%TYPE, 
					           P_QUESTION 				  IN EBANKING.EBANKING_USER.QUESTION%TYPE, 
					           P_USER2CELLCOMPANY 		  IN EBANKING.EBANKING_USER.USER2CELLCOMPANY%TYPE, 
					           P_ADVANCEDSERVICE 	      IN EBANKING.EBANKING_USER.ADVANCEDSERVICE%TYPE, 
					           P_SECUREDATA 	   	  	  IN EBANKING.EBANKING_USER.SECUREDATA%TYPE,
					           P_ACTIVATIONTYPE 		  IN EBANKING.EBANKING_USER.ACTIVATIONTYPE%TYPE, 
					           P_SECURITY_LEVEL 	 	  IN EBANKING.EBANKING_USER.SECURITY_LEVEL%TYPE, 
					           P_STATUSNS 	  	 		  IN EBANKING.EBANKING_USER.STATUSNS%TYPE, 
					           P_CODIGONS    			  IN EBANKING.EBANKING_USER.CODIGONS%TYPE, 
					           P_CONFIRMNS   			  IN EBANKING.EBANKING_USER.CONFIRMNS%TYPE, 
					           P_STATUS_CONT_TRAN 		  IN EBANKING.EBANKING_USER.STATUS_CONT_TRAN%TYPE, 
					           P_MAIL_RECEIVE 	   		  IN EBANKING.EBANKING_USER.MAIL_RECEIVE%TYPE, 
					           P_TRACKING 	   			  IN EBANKING.EBANKING_USER.TRACKING%TYPE, 
					           P_PWD_CONFIRM 			  IN EBANKING.EBANKING_USER.PWD_CONFIRM%TYPE, 
					           P_PWD_BANCA_TEL  		  IN EBANKING.EBANKING_USER.PWD_BANCA_TEL%TYPE, 
					           P_PWD_CHANGE_DATE 		  IN EBANKING.EBANKING_USER.PWD_CHANGE_DATE%TYPE, 
					           P_PWD_STATUS 	   	  	  IN EBANKING.EBANKING_USER.PWD_STATUS%TYPE, 
					           P_PWD_CONFIRM_CHANGE_DATE  IN EBANKING.EBANKING_USER.PWD_CONFIRM_CHANGE_DATE%TYPE, 
					           P_BIOMETRICO 			  IN EBANKING.EBANKING_USER.BIOMETRICO%TYPE, 
					           P_TELEFONO_OFICINA 		  IN EBANKING.EBANKING_USER.TELEFONO_OFICINA%TYPE, 
					           P_OLD_ADVANCEDSERVICE 	  IN EBANKING.EBANKING_USER.OLD_ADVANCEDSERVICE%TYPE, 
					           P_ULT_ACCESO 		   	  IN EBANKING.EBANKING_USER.ULT_ACCESO%TYPE, 
					           P_ULT_IP 	  	 		  IN EBANKING.EBANKING_USER.ULT_IP%TYPE, 
					           P_BAN_MAIL  				  IN EBANKING.EBANKING_USER.BAN_MAIL%TYPE, 
					           P_TOKEN 	   			      IN EBANKING.EBANKING_USER.TOKEN%TYPE, 
					           P_FECHA_CAMBIO_STATUS_BAJA IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS_BAJA%TYPE, 
					           P_STATUS_BAJA 			  IN EBANKING.EBANKING_USER.STATUS_BAJA%TYPE, 
					           P_USER_STATUS 			  IN EBANKING.EBANKING_USER.USER_STATUS%TYPE, 
					           P_FECHA_CAMBIO_STATUS 	  IN EBANKING.EBANKING_USER.FECHA_CAMBIO_STATUS%TYPE, 
					           P_RFC_CLIENTE 			  IN EBANKING.EBANKING_USER.RFC_CLIENTE%TYPE, 
					           P_NIP_RED_MOVIL  		  IN EBANKING.EBANKING_USER.NIP_RED_MOVIL%TYPE,
		  					   PSCOD 					  OUT NUMBER,
                               PSMSG 					  OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_USER%ROWTYPE;
BEGIN
	 PEREG.ID					   := P_ID;
	 PEREG.ACTIVATION              := P_ACTIVATION;
     PEREG.ACTIVE 				   := P_ACTIVE;
     PEREG.ANSWER 				   := P_ANSWER;
     PEREG.CELLULAR 			   := P_CELLULAR;
     PEREG.EMAIL 				   := P_EMAIL; 
     PEREG.QUESTION 			   := P_QUESTION;
     PEREG.USER2CELLCOMPANY 	   := P_USER2CELLCOMPANY;
     PEREG.ADVANCEDSERVICE 		   := P_ADVANCEDSERVICE;
     PEREG.SECUREDATA 			   := P_SECUREDATA;
     PEREG.ACTIVATIONTYPE 		   := P_ACTIVATIONTYPE;
     PEREG.SECURITY_LEVEL 		   := P_SECURITY_LEVEL;
     PEREG.STATUSNS 			   := P_STATUSNS;
     PEREG.CODIGONS 			   := P_CODIGONS;
     PEREG.CONFIRMNS 			   := P_CONFIRMNS;
     PEREG.STATUS_CONT_TRAN 	   := P_STATUS_CONT_TRAN;
     PEREG.MAIL_RECEIVE 		   := P_MAIL_RECEIVE;
     PEREG.TRACKING 			   := P_TRACKING;
     PEREG.PWD_CONFIRM 			   := P_PWD_CONFIRM;
     PEREG.PWD_BANCA_TEL 		   := P_PWD_BANCA_TEL;
     PEREG.PWD_CHANGE_DATE 		   := P_PWD_CHANGE_DATE;
     PEREG.PWD_STATUS 			   := P_PWD_STATUS;
     PEREG.PWD_CONFIRM_CHANGE_DATE := P_PWD_CONFIRM_CHANGE_DATE;
     PEREG.BIOMETRICO 			   := P_BIOMETRICO;
     PEREG.TELEFONO_OFICINA 	   := P_TELEFONO_OFICINA; 
     PEREG.OLD_ADVANCEDSERVICE 	   := P_OLD_ADVANCEDSERVICE;
     PEREG.ULT_ACCESO 			   := P_ULT_ACCESO;
     PEREG.ULT_IP 				   := P_ULT_IP;
     PEREG.BAN_MAIL 			   := P_BAN_MAIL;
     PEREG.TOKEN 				   := P_TOKEN;
     PEREG.FECHA_CAMBIO_STATUS_BAJA:=P_FECHA_CAMBIO_STATUS_BAJA;
     PEREG.STATUS_BAJA 			   := P_STATUS_BAJA;
     PEREG.USER_STATUS 			   := P_USER_STATUS;
     PEREG.FECHA_CAMBIO_STATUS 	   := P_FECHA_CAMBIO_STATUS;
     PEREG.RFC_CLIENTE 			   := P_RFC_CLIENTE;
     PEREG.NIP_RED_MOVIL 		   := P_NIP_RED_MOVIL;
     EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_USER(PEREG,PSCOD,PSMSG);
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_OLD
******************************************************************************/
PROCEDURE ADD_EBANKING_USEROLD (PEREG IN EBANKING.EBANKING_USER_OLD%ROWTYPE,
		  					    PSCOD OUT NUMBER,
                                PSMSG OUT VARCHAR2) IS
BEGIN
	 INSERT INTO EBANKING.EBANKING_USER_OLD
        (USER_ID, CELLULAR_OLD, CELLULAR_CHANGE_DATE, TELEFONO_ALTERNO_OLD, ALTERNO_CHANGE_DATE, EMAIL_OLD,
  		 EMAIL_CHANGE_DATE, QUESTION_CHANGE_DATE, ANSWER_CHANGE_DATE, IP)
    
	 VALUES(PEREG.USER_ID, PEREG.CELLULAR_OLD, PEREG.CELLULAR_CHANGE_DATE, PEREG.TELEFONO_ALTERNO_OLD, 
	        PEREG.ALTERNO_CHANGE_DATE, PEREG.EMAIL_OLD, PEREG.EMAIL_CHANGE_DATE, PEREG.QUESTION_CHANGE_DATE, 
			PEREG.ANSWER_CHANGE_DATE, PEREG.IP);
     COMMIT;
	 PSCOD:=0;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      	WHEN OTHERS THEN
		PSCOD:=-1;
	    PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_ADMIN_USER.ADD_EBANKING_USEROLD(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EBANKING_USEROLD (P_USER_ID 	   	   	  	IN EBANKING.EBANKING_USER_OLD.USER_ID%TYPE, 
						        P_CELLULAR_OLD    	  	IN EBANKING.EBANKING_USER_OLD.CELLULAR_OLD%TYPE, 
						        P_CELLULAR_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.CELLULAR_CHANGE_DATE%TYPE, 
						        P_TELEFONO_ALTERNO_OLD  IN EBANKING.EBANKING_USER_OLD.TELEFONO_ALTERNO_OLD%TYPE, 
						        P_ALTERNO_CHANGE_DATE 	IN EBANKING.EBANKING_USER_OLD.ALTERNO_CHANGE_DATE%TYPE, 
						        P_EMAIL_OLD  		   	IN EBANKING.EBANKING_USER_OLD.EMAIL_OLD%TYPE, 
						        P_EMAIL_CHANGE_DATE 	IN EBANKING.EBANKING_USER_OLD.EMAIL_CHANGE_DATE%TYPE, 
						        P_QUESTION_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.QUESTION_CHANGE_DATE%TYPE, 
						        P_ANSWER_CHANGE_DATE  	IN EBANKING.EBANKING_USER_OLD.ANSWER_CHANGE_DATE%TYPE, 
						        P_IP 	  				IN EBANKING.EBANKING_USER_OLD.IP%TYPE,						        				       
								PSCOD 				    OUT NUMBER,
	                            PSMSG 				    OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_USER_OLD%ROWTYPE;
BEGIN
	 PEREG.USER_ID			    := P_USER_ID;
	 PEREG.CELLULAR_OLD			:= P_CELLULAR_OLD;
	 PEREG.CELLULAR_CHANGE_DATE	:= P_CELLULAR_CHANGE_DATE; 
	 PEREG.TELEFONO_ALTERNO_OLD	:= P_TELEFONO_ALTERNO_OLD; 
	 PEREG.ALTERNO_CHANGE_DATE	:= P_ALTERNO_CHANGE_DATE; 
	 PEREG.EMAIL_OLD			:= P_EMAIL_OLD; 
	 PEREG.EMAIL_CHANGE_DATE    := P_EMAIL_CHANGE_DATE; 
	 PEREG.QUESTION_CHANGE_DATE := P_QUESTION_CHANGE_DATE;
	 PEREG.ANSWER_CHANGE_DATE	:= P_ANSWER_CHANGE_DATE; 
 	 PEREG.IP			        := P_IP;
	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_USEROLD(PEREG,PSCOD,PSMSG);
END;
 
 
PROCEDURE MODIFY_EBANKING_USEROLD(PEREG IN EBANKING.EBANKING_USER_OLD%ROWTYPE,
                                   PSCOD OUT NUMBER,
                                   PSMSG OUT VARCHAR2)IS
BEGIN     
UPDATE EBANKING.EBANKING_USER_OLD U SET   
			 	U.CELLULAR_OLD			  = NVL(PEREG.CELLULAR_OLD,U.CELLULAR_OLD),
			 	U.CELLULAR_CHANGE_DATE	  = NVL(PEREG.CELLULAR_CHANGE_DATE,U.CELLULAR_CHANGE_DATE), 
			 	U.TELEFONO_ALTERNO_OLD	  = NVL(PEREG.TELEFONO_ALTERNO_OLD,U.TELEFONO_ALTERNO_OLD),
			 	U.ALTERNO_CHANGE_DATE	  = U.ALTERNO_CHANGE_DATE, 
			 	U.EMAIL_OLD		   	 	  = NVL(PEREG.EMAIL_OLD,U.EMAIL_OLD), 
			 	U.EMAIL_CHANGE_DATE		  = NVL(PEREG.EMAIL_CHANGE_DATE,U.EMAIL_CHANGE_DATE),
			 	U.QUESTION_CHANGE_DATE	  = NVL(PEREG.QUESTION_CHANGE_DATE,U.QUESTION_CHANGE_DATE), 
		 	 	U.ANSWER_CHANGE_DATE	  = NVL(PEREG.ANSWER_CHANGE_DATE,U.ANSWER_CHANGE_DATE),
			 	U.IP		  			  = NVL(PEREG.IP,U.IP)			 	        
	  WHERE U.USER_ID = PEREG.USER_ID;
	 
      COMMIT;
	  PSCOD:=0;
	  PSMSG:='OPERACION EXITOSA';
	  EXCEPTION
	  	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_ADMIN_USER.MODIFY_EBANKING_USEROLD(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
 
PROCEDURE MODIFY_EBANKING_USEROLD(P_USER_ID 	   	   	  IN EBANKING.EBANKING_USER_OLD.USER_ID%TYPE, 
						           P_CELLULAR_OLD    	  IN EBANKING.EBANKING_USER_OLD.CELLULAR_OLD%TYPE, 
						           P_CELLULAR_CHANGE_DATE IN EBANKING.EBANKING_USER_OLD.CELLULAR_CHANGE_DATE%TYPE, 
						           P_TELEFONO_ALTERNO_OLD IN EBANKING.EBANKING_USER_OLD.TELEFONO_ALTERNO_OLD%TYPE, 
						           P_ALTERNO_CHANGE_DATE  IN EBANKING.EBANKING_USER_OLD.ALTERNO_CHANGE_DATE%TYPE, 
						           P_EMAIL_OLD  		  IN EBANKING.EBANKING_USER_OLD.EMAIL_OLD%TYPE, 
						           P_EMAIL_CHANGE_DATE 	  IN EBANKING.EBANKING_USER_OLD.EMAIL_CHANGE_DATE%TYPE, 
						           P_QUESTION_CHANGE_DATE IN EBANKING.EBANKING_USER_OLD.QUESTION_CHANGE_DATE%TYPE, 
						           P_ANSWER_CHANGE_DATE   IN EBANKING.EBANKING_USER_OLD.ANSWER_CHANGE_DATE%TYPE, 
						           P_IP 	  			  IN EBANKING.EBANKING_USER_OLD.IP%TYPE,
                             	   PSCOD 				  OUT NUMBER,
                             	   PSMSG 				  OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_USER_OLD%ROWTYPE;
BEGIN
	 PEREG.USER_ID			    := P_USER_ID;
	 PEREG.CELLULAR_OLD			:= P_CELLULAR_OLD;
	 PEREG.CELLULAR_CHANGE_DATE	:= P_CELLULAR_CHANGE_DATE; 
	 PEREG.TELEFONO_ALTERNO_OLD	:= P_TELEFONO_ALTERNO_OLD; 
	 PEREG.ALTERNO_CHANGE_DATE	:= P_ALTERNO_CHANGE_DATE; 
	 PEREG.EMAIL_OLD		   	:= P_EMAIL_OLD; 
	 PEREG.EMAIL_CHANGE_DATE	:= P_EMAIL_CHANGE_DATE; 
	 PEREG.QUESTION_CHANGE_DATE	:= P_QUESTION_CHANGE_DATE; 	 
	 PEREG.ANSWER_CHANGE_DATE	:= P_ANSWER_CHANGE_DATE; 
	 PEREG.IP		   			:= P_IP; 	 
	 EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_USEROLD(PEREG,PSCOD,PSMSG);
END;


/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_ACTIVATION
******************************************************************************/
  
PROCEDURE ADD_EBANKING_ACTIVA (PEREG IN EBANKING.EBANKING_ACTIVATION%ROWTYPE,
		  					   PSCOD OUT NUMBER,
                               PSMSG OUT VARCHAR2) IS
BEGIN
	 INSERT INTO EBANKING.EBANKING_ACTIVATION
        (ALIAS, CLIENTE, EMAIL, CUENTAOTARJ, QUESTION, ANSWER, CEL_PHONE, COMPANY, OFFICE_PHONE, STATUS, ACTIVACION,
         CODE, CUENTA, IP, TARJETA, TIPO, MONITOR, COMENTARIO, INTENTOS_LOCALIZAR, NAME, TIPOPROD, FIRSTINTENTO,
         LASTINTENTO, CONFIRMACION)
    
	 VALUES(PEREG.ALIAS, PEREG.CLIENTE, PEREG.EMAIL, PEREG.CUENTAOTARJ, PEREG.QUESTION, PEREG.ANSWER, 
	        PEREG.CEL_PHONE, PEREG.COMPANY, PEREG.OFFICE_PHONE, PEREG.STATUS, PEREG.ACTIVACION, PEREG.CODE, 
			PEREG.CUENTA, PEREG.IP, PEREG.TARJETA, PEREG.TIPO, PEREG.MONITOR, PEREG.COMENTARIO, 
			PEREG.INTENTOS_LOCALIZAR, PEREG.NAME, PEREG.TIPOPROD, PEREG.FIRSTINTENTO,PEREG.LASTINTENTO, 
			PEREG.CONFIRMACION);
     COMMIT;
	 PSCOD:=0;
	 PSMSG:='OPERACION EXITOSA';
     EXCEPTION
      	WHEN OTHERS THEN
		PSCOD:=-1;
	    PSMSG:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20120, 'Error ocurrido al PKG_CORE_ADMIN_USER.ADD_EBANKING_ACTIVA(' || SQLCODE || '  ' || SQLERRM || ')');
END;

PROCEDURE ADD_EBANKING_ACTIVA (P_ALIAS 	   	   	  	IN EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE, 
						       P_CLIENTE    	  	IN EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE, 
						       P_EMAIL 	   	  		IN EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE, 
						       P_CUENTAOTARJ 	   	IN EBANKING.EBANKING_ACTIVATION.CUENTAOTARJ%TYPE, 
						       P_QUESTION 	   	  	IN EBANKING.EBANKING_ACTIVATION.QUESTION%TYPE, 
						       P_ANSWER 		   	IN EBANKING.EBANKING_ACTIVATION.ANSWER%TYPE, 
						       P_CEL_PHONE 	   	  	IN EBANKING.EBANKING_ACTIVATION.CEL_PHONE%TYPE, 
						       P_COMPANY 	    	IN EBANKING.EBANKING_ACTIVATION.COMPANY%TYPE, 
						       P_OFFICE_PHONE  	    IN EBANKING.EBANKING_ACTIVATION.OFFICE_PHONE%TYPE, 
						       P_STATUS 	  		IN EBANKING.EBANKING_ACTIVATION.STATUS%TYPE,
						       P_ACTIVACION   	    IN EBANKING.EBANKING_ACTIVATION.ACTIVACION%TYPE, 
						       P_CODE   	    	IN EBANKING.EBANKING_ACTIVATION.CODE%TYPE, 
						       P_CUENTA 		  	IN EBANKING.EBANKING_ACTIVATION.CUENTA%TYPE, 
						       P_IP 		  		IN EBANKING.EBANKING_ACTIVATION.IP%TYPE, 
						       P_TARJETA	  		IN EBANKING.EBANKING_ACTIVATION.TARJETA%TYPE, 
						       P_TIPO 				IN EBANKING.EBANKING_ACTIVATION.TIPO%TYPE, 
						       P_MONITOR 	  		IN EBANKING.EBANKING_ACTIVATION.MONITOR%TYPE, 
						       P_COMENTARIO 		IN EBANKING.EBANKING_ACTIVATION.COMENTARIO%TYPE, 
						       P_INTENTOS_LOCALIZAR	IN EBANKING.EBANKING_ACTIVATION.INTENTOS_LOCALIZAR%TYPE, 
						       P_NAME 	  			IN EBANKING.EBANKING_ACTIVATION.NAME%TYPE, 
						       P_TIPOPROD 	 		IN EBANKING.EBANKING_ACTIVATION.TIPOPROD%TYPE, 
						       P_FIRSTINTENTO 	  	IN EBANKING.EBANKING_ACTIVATION.FIRSTINTENTO%TYPE, 
						       P_LASTINTENTO  		IN EBANKING.EBANKING_ACTIVATION.LASTINTENTO%TYPE, 
						       P_CONFIRMACION		IN EBANKING.EBANKING_ACTIVATION.CONFIRMACION%TYPE, 					       
							   PSCOD 				OUT NUMBER,
	                           PSMSG 				OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_ACTIVATION%ROWTYPE;
BEGIN
	 PEREG.ALIAS			   := P_ALIAS;
	 PEREG.CLIENTE			   := P_CLIENTE;
	 PEREG.EMAIL			   := P_EMAIL; 
	 PEREG.CUENTAOTARJ		   := P_CUENTAOTARJ; 
	 PEREG.QUESTION			   := P_QUESTION; 
	 PEREG.ANSWER			   := P_ANSWER; 
	 PEREG.CEL_PHONE		   := P_CEL_PHONE; 
	 PEREG.COMPANY			   := P_COMPANY;
	 PEREG.OFFICE_PHONE		   := P_OFFICE_PHONE; 
 	 PEREG.STATUS			   := P_STATUS;
	 PEREG.ACTIVACION		   := P_ACTIVACION; 
	 PEREG.CODE				   := P_CODE; 
	 PEREG.CUENTA			   := P_CUENTA; 
	 PEREG.IP				   := P_IP;
	 PEREG.TARJETA			   := P_TARJETA;
	 PEREG.TIPO				   := P_TIPO;
	 PEREG.MONITOR			   := P_MONITOR;
	 PEREG.COMENTARIO		   := P_COMENTARIO; 
	 PEREG.INTENTOS_LOCALIZAR  := P_INTENTOS_LOCALIZAR; 
	 PEREG.NAME		           := P_NAME;
	 PEREG.TIPOPROD			   := P_TIPOPROD;
	 PEREG.FIRSTINTENTO		   := P_FIRSTINTENTO;
	 PEREG.LASTINTENTO		   := P_LASTINTENTO; 
	 PEREG.CONFIRMACION	       := P_CONFIRMACION;
	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_ACTIVA(PEREG,PSCOD,PSMSG);
END;
 
 
PROCEDURE MODIFY_EBANKING_ACTIVA(PEREG IN EBANKING.EBANKING_ACTIVATION%ROWTYPE,
                                 PSCOD OUT NUMBER,
                                 PSMSG OUT VARCHAR2)IS
BEGIN     
	 IF PEREG.CLIENTE IS NOT NULL THEN
	     UPDATE EBANKING.EBANKING_ACTIVATION A SET   
				A.ALIAS			   	  = NVL(PEREG.ALIAS,A.ALIAS),
			 	A.EMAIL			   	  = NVL(PEREG.EMAIL,A.EMAIL),
			 	A.CUENTAOTARJ	   	  = NVL(PEREG.CUENTAOTARJ,A.CUENTAOTARJ), 
			 	A.QUESTION		   	  = NVL(PEREG.QUESTION,A.QUESTION),
			 	A.ANSWER		   	  = NVL(PEREG.ANSWER,A.ANSWER), 
			 	A.CEL_PHONE		   	  = NVL(PEREG.CEL_PHONE,A.CEL_PHONE), 
			 	A.COMPANY		   	  = NVL(PEREG.COMPANY,A.COMPANY),
			 	A.OFFICE_PHONE		  = NVL(PEREG.OFFICE_PHONE,A.OFFICE_PHONE), 
		 	 	A.STATUS			  = NVL(PEREG.STATUS,A.STATUS),
			 	A.ACTIVACION		  = NVL(PEREG.ACTIVACION,A.ACTIVACION), 
			 	A.CODE				  = NVL(PEREG.CODE,A.CODE),
			 	A.CUENTA			  = NVL(PEREG.CUENTA,A.CUENTA), 
			 	A.IP				  = NVL(PEREG.IP,A.IP),
			 	A.TARJETA			  = NVL(PEREG.TARJETA,A.TARJETA),
			 	A.TIPO				  = NVL(PEREG.TIPO,A.TIPO),
				A.MONITOR			  = NVL(PEREG.MONITOR,A.MONITOR),		 							   
				A.COMENTARIO		  = NVL(PEREG.COMENTARIO,A.COMENTARIO), 
			 	A.INTENTOS_LOCALIZAR  = NVL(PEREG.INTENTOS_LOCALIZAR,A.INTENTOS_LOCALIZAR), 
			 	A.NAME		       	  = NVL(PEREG.NAME,A.NAME),
			 	A.TIPOPROD			  = NVL(PEREG.TIPOPROD,A.TIPOPROD),
			 	A.FIRSTINTENTO		  = PEREG.FIRSTINTENTO,
			 	A.LASTINTENTO		  = PEREG.LASTINTENTO, 
			 	A.CONFIRMACION	  	  = NVL(PEREG.CONFIRMACION,A.CONFIRMACION)            
	      WHERE A.CLIENTE = PEREG.CLIENTE;
	  ELSE 
	  	  UPDATE EBANKING.EBANKING_ACTIVATION A SET   
			 	A.EMAIL			   	  = NVL(PEREG.EMAIL,A.EMAIL),
			 	A.CUENTAOTARJ	   	  = NVL(PEREG.CUENTAOTARJ,A.CUENTAOTARJ), 
			 	A.QUESTION		   	  = NVL(PEREG.QUESTION,A.QUESTION),
			 	A.ANSWER		   	  = NVL(PEREG.ANSWER,A.ANSWER), 
			 	A.CEL_PHONE		   	  = NVL(PEREG.CEL_PHONE,A.CEL_PHONE), 
			 	A.COMPANY		   	  = NVL(PEREG.COMPANY,A.COMPANY),
			 	A.OFFICE_PHONE		  = NVL(PEREG.OFFICE_PHONE,A.OFFICE_PHONE), 
		 	 	A.STATUS			  = NVL(PEREG.STATUS,A.STATUS),
			 	A.ACTIVACION		  = NVL(PEREG.ACTIVACION,A.ACTIVACION), 
			 	A.CODE				  = NVL(PEREG.CODE,A.CODE),
			 	A.CUENTA			  = NVL(PEREG.CUENTA,A.CUENTA), 
			 	A.IP				  = NVL(PEREG.IP,A.IP),
			 	A.TARJETA			  = NVL(PEREG.TARJETA,A.TARJETA),
			 	A.TIPO				  = NVL(PEREG.TIPO,A.TIPO),
				A.MONITOR			  = NVL(PEREG.MONITOR,A.MONITOR),		 							   
				A.COMENTARIO		  = NVL(PEREG.COMENTARIO,A.COMENTARIO), 
			 	A.INTENTOS_LOCALIZAR  = NVL(PEREG.INTENTOS_LOCALIZAR,A.INTENTOS_LOCALIZAR), 
			 	A.NAME		       	  = NVL(PEREG.NAME,A.NAME),
			 	A.TIPOPROD			  = NVL(PEREG.TIPOPROD,A.TIPOPROD),
			 	A.FIRSTINTENTO		  = PEREG.FIRSTINTENTO,
			 	A.LASTINTENTO		  = PEREG.LASTINTENTO, 
			 	A.CONFIRMACION	  	  = NVL(PEREG.CONFIRMACION,A.CONFIRMACION)            
	      WHERE A.ALIAS = PEREG.ALIAS;
	  END IF;
      COMMIT;
	  PSCOD:=0;
	  PSMSG:='OPERACION EXITOSA';
	  EXCEPTION
	  	WHEN OTHERS THEN
  		PSCOD:=-1;
  		PSMSG:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en PKG_CORE_ADMIN_USER.MODIFY_EBANKING_ACTIVA(' || SQLCODE || '  ' || SQLERRM || ')');
END;
 
 
PROCEDURE MODIFY_EBANKING_ACTIVA(P_ALIAS 	   	   	  	IN EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE, 
					             P_CLIENTE    	  	    IN EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE, 
					             P_EMAIL 	   	  		IN EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE, 
					             P_CUENTAOTARJ 	   	  	IN EBANKING.EBANKING_ACTIVATION.CUENTAOTARJ%TYPE, 
					             P_QUESTION 	   	  	IN EBANKING.EBANKING_ACTIVATION.QUESTION%TYPE, 
					         	 P_ANSWER 		   	  	IN EBANKING.EBANKING_ACTIVATION.ANSWER%TYPE, 
					         	 P_CEL_PHONE 	   	  	IN EBANKING.EBANKING_ACTIVATION.CEL_PHONE%TYPE, 
					         	 P_COMPANY 	    		IN EBANKING.EBANKING_ACTIVATION.COMPANY%TYPE, 
					         	 P_OFFICE_PHONE  	    IN EBANKING.EBANKING_ACTIVATION.OFFICE_PHONE%TYPE, 
					         	 P_STATUS 	  		    IN EBANKING.EBANKING_ACTIVATION.STATUS%TYPE,
					         	 P_ACTIVACION   	    IN EBANKING.EBANKING_ACTIVATION.ACTIVACION%TYPE, 
					         	 P_CODE   	    		IN EBANKING.EBANKING_ACTIVATION.CODE%TYPE, 
					         	 P_CUENTA 		  	    IN EBANKING.EBANKING_ACTIVATION.CUENTA%TYPE, 
					         	 P_IP 		  			IN EBANKING.EBANKING_ACTIVATION.IP%TYPE, 
					         	 P_TARJETA	  			IN EBANKING.EBANKING_ACTIVATION.TARJETA%TYPE, 
					         	 P_TIPO 				IN EBANKING.EBANKING_ACTIVATION.TIPO%TYPE, 
					         	 P_MONITOR 	  			IN EBANKING.EBANKING_ACTIVATION.MONITOR%TYPE, 
					         	 P_COMENTARIO 		  	IN EBANKING.EBANKING_ACTIVATION.COMENTARIO%TYPE, 
					         	 P_INTENTOS_LOCALIZAR	IN EBANKING.EBANKING_ACTIVATION.INTENTOS_LOCALIZAR%TYPE, 
					         	 P_NAME 	  			IN EBANKING.EBANKING_ACTIVATION.NAME%TYPE, 
					         	 P_TIPOPROD 	 		IN EBANKING.EBANKING_ACTIVATION.TIPOPROD%TYPE, 
					         	 P_FIRSTINTENTO 	  	IN EBANKING.EBANKING_ACTIVATION.FIRSTINTENTO%TYPE, 
					         	 P_LASTINTENTO  		IN EBANKING.EBANKING_ACTIVATION.LASTINTENTO%TYPE, 
					         	 P_CONFIRMACION			IN EBANKING.EBANKING_ACTIVATION.CONFIRMACION%TYPE,
                             	 PSCOD 				    OUT NUMBER,
                             	 PSMSG 				    OUT VARCHAR2)IS
PEREG EBANKING.EBANKING_ACTIVATION%ROWTYPE;
BEGIN
	 PEREG.ALIAS			   := P_ALIAS;
	 PEREG.CLIENTE			   := P_CLIENTE;
	 PEREG.EMAIL			   := P_EMAIL; 
	 PEREG.CUENTAOTARJ		   := P_CUENTAOTARJ; 
	 PEREG.QUESTION			   := P_QUESTION; 
	 PEREG.ANSWER			   := P_ANSWER; 
	 PEREG.CEL_PHONE		   := P_CEL_PHONE; 
	 PEREG.COMPANY			   := P_COMPANY;
	 PEREG.OFFICE_PHONE		   := P_OFFICE_PHONE; 
 	 PEREG.STATUS			   := P_STATUS;
	 PEREG.ACTIVACION		   := P_ACTIVACION; 
	 PEREG.CODE				   := P_CODE; 
	 PEREG.CUENTA			   := P_CUENTA; 
	 PEREG.IP				   := P_IP;
	 PEREG.TARJETA			   := P_TARJETA;
	 PEREG.TIPO				   := P_TIPO;
	 PEREG.MONITOR			   := P_MONITOR;
	 PEREG.COMENTARIO		   := P_COMENTARIO; 
	 PEREG.INTENTOS_LOCALIZAR  := P_INTENTOS_LOCALIZAR; 
	 PEREG.NAME		           := P_NAME;
	 PEREG.TIPOPROD			   := P_TIPOPROD;
	 PEREG.FIRSTINTENTO		   := P_FIRSTINTENTO;
	 PEREG.LASTINTENTO		   := P_LASTINTENTO; 
	 PEREG.CONFIRMACION	       := P_CONFIRMACION;
	 EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_ACTIVA(PEREG,PSCOD,PSMSG);
END;

END PKG_CORE_GEN_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_PAR_DATOS AS
     
FUNCTION GETEBAKINGCORE(PECADENA IN VARCHAR2)RETURN SYS_REFCURSOR IS
TYPE CUR_TYP IS REF CURSOR;
C_CURSOR CUR_TYP;
BEGIN
  OPEN C_CURSOR FOR PECADENA;
  RETURN C_CURSOR;
EXCEPTION
 WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20121, 'Error ocurrido al EBANKING.PKG_CORE_DATOS.GETEBAKINGCORE(' || SQLCODE || '  ' || SQLERRM || ')');
     CLOSE C_CURSOR;
END;
END PKG_CORE_PAR_DATOS;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_PAR_SESSION AS
/******************************************************************************
   NAME:       PKG_CORE_PAR_SESSION
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE EBANKING_LOGIN (P_USER_ID    IN EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
		  				  P_ATTEMPTS   IN EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE,
		  				  P_ACCION     IN NUMBER,
                          PSCOD 	   OUT NUMBER,
                          PSMSG 	   OUT VARCHAR2) IS
PEREG EBANKING.EBANKING_LOGIN%ROWTYPE;
P_LOGIN_DATE_TMP EBANKING.EBANKING_LOGIN.LOGIN_DATE%TYPE;
P_ATTEMPTS_TMP   EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE;
CURSOR_CONSULTA TYPES.REFCURSOR;
BEGIN
	 PEREG.USER_ID    :=P_USER_ID;
	 PEREG.ATTEMPTS   :=P_ATTEMPTS;
	 PEREG.LOGIN_DATE :=SYSDATE;
	 IF P_ACCION = 1 THEN
	 	 EBANKING.PKG_CORE_GEN_SESSION.ADD_EBANKING_LOGIN(PEREG,PSCOD,PSMSG);	   
     END IF; 
	 
	 IF P_ACCION = 2 THEN
	 	 EBANKING.PKG_CORE_GEN_SESSION.MODIFY_EBANKING_LOGIN(PEREG,PSCOD,PSMSG);	   
     END IF; 
	 
	 IF P_ACCION = 3 THEN
	 	 OPEN CURSOR_CONSULTA 
		     FOR SELECT L.LOGIN_DATE,L.ATTEMPTS
		         FROM EBANKING.EBANKING_LOGIN L
		         WHERE L.USER_ID = PEREG.USER_ID;
		     LOOP    
		       FETCH CURSOR_CONSULTA INTO P_LOGIN_DATE_TMP,P_ATTEMPTS_TMP;
		       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
		     END LOOP; 
	     CLOSE CURSOR_CONSULTA;
		 
		 IF (TRUNC(P_LOGIN_DATE_TMP)-TRUNC(SYSDATE)<>0 AND P_ATTEMPTS_TMP<P_ATTEMPTS) THEN 
		 	PEREG.ATTEMPTS:=1;
		 ELSE 
		 	PEREG.ATTEMPTS:=PEREG.ATTEMPTS+1;
		 END IF;
		 
	 	 EBANKING.PKG_CORE_GEN_SESSION.MODIFY_EBANKING_LOGIN(PEREG,PSCOD,PSMSG);	   
     END IF;
	 
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_SESSION
******************************************************************************/
PROCEDURE EBANKING_SESSION (PEREG    USERSESSIONBEAN,
                            P_ACCION IN NUMBER,
                            PSCOD    OUT NUMBER,
                            PSMSG    OUT VARCHAR2)IS
PEREG_TMP EBANKING.EBANKING_USER_SESSION%ROWTYPE;
BEGIN
	 PEREG_TMP.ID               :=PEREG.ID;
	 PEREG_TMP.SESSION_ACTIVA   :=PEREG.SESSION_ACTIVA; 
	 
	 IF PEREG.SESSION_START IS NOT NULL THEN
	 	PEREG_TMP.SESSION_START := SYSDATE;
  	 ELSE
	 	PEREG_TMP.SESSION_START := PEREG.SESSION_START;
	 END IF;
	 
	 PEREG_TMP.IP               :=PEREG.IP;
	 
	 IF P_ACCION = 1 THEN
	 	 EBANKING.PKG_CORE_GEN_SESSION.ADD_EBANKING_SESSION(PEREG_TMP,PSCOD,PSMSG);	   
     END IF; 
	 
	 IF P_ACCION = 2 THEN
	 	 EBANKING.PKG_CORE_GEN_SESSION.MODIFY_EBANKING_SESSION(PEREG_TMP,PSCOD,PSMSG);	   
     END IF; 
	 
END;

 
END PKG_CORE_PAR_SESSION;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_PAR_USER AS
/******************************************************************************
   NAME:       PKG_CORE_PAR_USER
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/01/2013             1. Created this package.
******************************************************************************/
PROCEDURE EBANKING_USER (PEREG USERBEAN,
		  			     P_ACCION IN NUMBER,
		  				 PSCOD OUT NUMBER,
                         PSMSG OUT VARCHAR2) IS
PEREG_TMP EBANKING.EBANKING_USER%ROWTYPE;
BEGIN
	 PEREG_TMP.ACTIVATION			   := PEREG.ACTIVATION;
  	 PEREG_TMP.ACTIVE                  := PEREG.ACTIVE;
  	 PEREG_TMP.ADVANCEDSERVICE 	   	   := PEREG.ADVANCEDSERVICE;
  	 PEREG_TMP.ANSWER			   	   := PEREG.ANSWER;
  	 PEREG_TMP.CELLULAR			   	   := PEREG.CELLULAR;
  	 PEREG_TMP.EMAIL			   	   := PEREG.EMAIL;
  	 PEREG_TMP.ID				   	   := PEREG.ID;
  	 PEREG_TMP.QUESTION			   	   := PEREG.QUESTION;
  	 PEREG_TMP.MAIL_RECEIVE		   	   := PEREG.MAIL_RECEIVE;
  	 PEREG_TMP.OLD_ADVANCEDSERVICE 	   := PEREG.OLD_ADVANCEDSERVICE;
  	 PEREG_TMP.PWD_BANCA_TEL	   	   := PEREG.PWD_BANCA_TEL;
	 
	 IF PEREG.PWD_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.PWD_CHANGE_DATE	   := SYSDATE;
  	 ELSE
	 	PEREG_TMP.PWD_CHANGE_DATE      := PEREG.PWD_CHANGE_DATE;
	 END IF;
  	 
  	 PEREG_TMP.PWD_CONFIRM		       := PEREG.PWD_CONFIRM;
	 
	 IF PEREG.PWD_CONFIRM_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.PWD_CONFIRM_CHANGE_DATE := SYSDATE;
  	 ELSE
	 	PEREG_TMP.PWD_CONFIRM_CHANGE_DATE := PEREG.PWD_CONFIRM_CHANGE_DATE;
	 END IF;
	 
  	 PEREG_TMP.PWD_STATUS			   := PEREG.PWD_STATUS;
  	 PEREG_TMP.SECUREDATA			   := PEREG.SECUREDATA;
  	 PEREG_TMP.SECURITY_LEVEL		   := PEREG.SECURITY_LEVEL;
  	 PEREG_TMP.TELEFONO_OFICINA		   := PEREG.TELEFONO_OFICINA;
  	 PEREG_TMP.TRACKING				   := PEREG.TRACKING;
  	 PEREG_TMP.TOKEN				   := PEREG.TOKEN;
  	 PEREG_TMP.USER2CELLCOMPANY		   := PEREG.USER2CELLCOMPANY;
	 
	 IF P_ACCION = 1 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_USER(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
	 IF P_ACCION = 2 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_USER(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
	 
END;
							 
/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_ACTIVATION
******************************************************************************/

PROCEDURE EBANKING_ACTIVATION (PEREG 	ACTIVATIONBEAN,
		  			           P_ACCION IN NUMBER,
		  				       PSCOD 	OUT NUMBER,
                         	   PSMSG 	OUT VARCHAR2) IS
PEREG_TMP EBANKING.EBANKING_ACTIVATION%ROWTYPE;
BEGIN
	 PEREG_TMP.ALIAS			   := PEREG.ALIAS;
	 PEREG_TMP.CLIENTE			   := PEREG.CLIENTE;
	 PEREG_TMP.EMAIL			   := PEREG.EMAIL; 
	 PEREG_TMP.CUENTAOTARJ		   := PEREG.CUENTAOTARJ; 
	 PEREG_TMP.QUESTION			   := PEREG.QUESTION; 
	 PEREG_TMP.ANSWER			   := PEREG.ANSWER; 
	 PEREG_TMP.CEL_PHONE		   := PEREG.CEL_PHONE; 
	 PEREG_TMP.COMPANY			   := PEREG.COMPANY;
	 PEREG_TMP.OFFICE_PHONE		   := PEREG.OFFICE_PHONE; 
 	 PEREG_TMP.STATUS			   := PEREG.STATUS;
	 
	 IF PEREG.ACTIVACION IS NOT NULL THEN
	 	PEREG_TMP.ACTIVACION	   := SYSDATE;
  	 ELSE
	 	PEREG_TMP.ACTIVACION       := PEREG.ACTIVACION;
	 END IF;
	 
	 PEREG_TMP.CODE				   := PEREG.CODE; 
	 PEREG_TMP.CUENTA			   := PEREG.CUENTA; 
	 PEREG_TMP.IP				   := PEREG.IP;
	 PEREG_TMP.TARJETA			   := PEREG.TARJETA;
	 PEREG_TMP.INTENTOS_LOCALIZAR  := PEREG.INTENTOS_LOCALIZAR; 
	 PEREG_TMP.NAME		           := PEREG.NAME;
	 PEREG_TMP.TIPOPROD			   := PEREG.TIPOPROD;
	 PEREG_TMP.FIRSTINTENTO		   := PEREG.FIRSTINTENTO;
	 PEREG_TMP.LASTINTENTO		   := PEREG.LASTINTENTO; 
	 
	 IF P_ACCION = 1 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_ACTIVA(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
	 IF P_ACCION = 2 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_ACTIVA(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
	 
END;

/******************************************************************************
   METODOS DE AGREGAR Y MODIFICAR DE LA TABLA DE EBANKING_USER_OLD
******************************************************************************/

PROCEDURE EBANKING_USER_OLD (PEREG    USEROLDBEAN,
		  				 	 P_ACCION IN NUMBER,
		  				 	 PSCOD    OUT NUMBER,
                         	 PSMSG    OUT VARCHAR2)IS
PEREG_TMP EBANKING.EBANKING_USER_OLD%ROWTYPE;
BEGIN 
	 PEREG_TMP.USER_ID			       := PEREG.USER_ID;
	 PEREG_TMP.CELLULAR_OLD			   := PEREG.CELLULAR_OLD;
	 
	 IF PEREG.CELLULAR_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.CELLULAR_CHANGE_DATE := SYSDATE;
  	 ELSE
	 	PEREG_TMP.CELLULAR_CHANGE_DATE := PEREG.CELLULAR_CHANGE_DATE;
	 END IF;
	 
	 PEREG_TMP.TELEFONO_ALTERNO_OLD	   := PEREG.TELEFONO_ALTERNO_OLD;
	 PEREG_TMP.ALTERNO_CHANGE_DATE	   := PEREG.ALTERNO_CHANGE_DATE; 
	 PEREG_TMP.EMAIL_OLD		   	   := PEREG.EMAIL_OLD; 
	 
	 IF PEREG.EMAIL_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.EMAIL_CHANGE_DATE	   := SYSDATE;
  	 ELSE
	 	PEREG_TMP.EMAIL_CHANGE_DATE    := PEREG.EMAIL_CHANGE_DATE;
	 END IF;
	 
	 IF PEREG.QUESTION_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.QUESTION_CHANGE_DATE  := SYSDATE;
  	 ELSE
	 	PEREG_TMP.QUESTION_CHANGE_DATE  := PEREG.QUESTION_CHANGE_DATE;
	 END IF;
	 
	 IF PEREG.ANSWER_CHANGE_DATE IS NOT NULL THEN
	 	PEREG_TMP.ANSWER_CHANGE_DATE	:= SYSDATE;
  	 ELSE
	 	PEREG_TMP.ANSWER_CHANGE_DATE    := PEREG.ANSWER_CHANGE_DATE;
	 END IF;
	 	 
	 IF P_ACCION = 1 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.ADD_EBANKING_USEROLD(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
	 IF P_ACCION = 2 THEN
	 	 EBANKING.PKG_CORE_GEN_USER.MODIFY_EBANKING_USEROLD(PEREG_TMP,PSCOD,PSMSG);
	 END IF;
END;

END PKG_CORE_PAR_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY PKG_CORE_SERVICES IS
/******************************************************************************
   NAME:       PKG_CORE_SERVICES
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        13/06/2012             1. Created this package.
******************************************************************************/
    
  PROCEDURE CAT_ROL (P_IDROL              IN EBANKING.CORE_ROL.IDROL%TYPE,
                     P_NOMBRE_ROL         IN EBANKING.CORE_ROL.NOMBRE_ROL%TYPE,
                     P_STATUS             IN EBANKING.CORE_ROL.STATUS%TYPE,
                     P_USUARIO_MODIFICO   IN EBANKING.CORE_ROL.USUARIO_MODIFICO%TYPE,
                     P_ACCION             IN NUMBER,
                     P_RESULTADO          OUT NUMBER,
                     P_RESULTADODES       OUT VARCHAR2) IS
  P_EXISTE     NUMBER;
  P_IDROLTEMP  EBANKING.CORE_ROL.IDROL%TYPE;
  CURSOR_CONSULTA TYPES.refcursor;
  
  BEGIN 
        
	IF P_ACCION != 1 THEN
	   OPEN CURSOR_CONSULTA 
	     FOR SELECT COUNT(1) 
	         FROM EBANKING.CORE_ROL R
	         WHERE R.IDROL = P_IDROL;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;
   
    ELSE
  	   OPEN CURSOR_CONSULTA 
	     FOR  SELECT COUNT(1) ,R.IDROL
	         FROM EBANKING.CORE_ROL R
	         WHERE R.NOMBRE_ROL = P_NOMBRE_ROL
			 GROUP BY R.IDROL;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE,P_IDROLTEMP;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;
  
    END IF;
  
  
    IF P_ACCION = 1 AND (P_EXISTE = 0 OR P_EXISTE IS NULL)  THEN
      INSERT INTO EBANKING.CORE_ROL
        (IDROL,
         NOMBRE_ROL,
         STATUS,
         USUARIO_MODIFICO,
         ULTIMA_MODIFICACION)
      VALUES
        ((SELECT (NVL(MAX(IDROL), 0) ) + 1 FROM EBANKING.CORE_ROL),
         P_NOMBRE_ROL,
         P_STATUS,
         P_USUARIO_MODIFICO,
         SYSDATE);
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de rol.';
    ELSIF P_ACCION = 1 AND P_EXISTE != 0 THEN	
	  UPDATE EBANKING.CORE_ROL R
         SET R.STATUS              = P_STATUS,
             R.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             R.ULTIMA_MODIFICACION = SYSDATE
      WHERE R.IDROL = P_IDROLTEMP;
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de rol.';
	
    
    ELSIF P_ACCION = 2 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_ROL R
         SET R.IDROL               = NVL(P_IDROL, R.IDROL),
             R.NOMBRE_ROL          = NVL(P_NOMBRE_ROL, R.NOMBRE_ROL),
             R.STATUS              = NVL(P_STATUS,R.STATUS),
             R.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             R.ULTIMA_MODIFICACION = SYSDATE
      WHERE R.IDROL = P_IDROL;
      P_RESULTADO    := 2;
      P_RESULTADODES := 'Exito en la operación se actualizó el elemento en el catalogo de rol.';
    
    ELSIF P_ACCION = 3 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_ROL R
         SET R.STATUS              = NVL(P_STATUS,R.STATUS),
             R.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             R.ULTIMA_MODIFICACION = SYSDATE
      WHERE R.IDROL = P_IDROL;
      P_RESULTADO    := 3;
      P_RESULTADODES := 'Exito en la operación se eliminó el elemento en el catalogo de rol.';
    ELSE
      P_RESULTADO    := 4;
      P_RESULTADODES := 'No se efectuo la acción.';
    
    END IF;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      P_RESULTADO    := 0;
      P_RESULTADODES := SQLCODE || '  ' || SQLERRM;
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20120,'Error ocurrido en PKG_CORE_SERVICES.CAT_ROL(' ||SQLCODE || '' || SQLERRM || ')');
  END;
  
  
  PROCEDURE CAT_EJBS(P_IDEJB              IN EBANKING.CORE_EJBS.IDEJB%TYPE,
                     P_NOMBRE_EJB         IN EBANKING.CORE_EJBS.NOMBRE_EJB%TYPE,                             
                     P_STATUS             IN EBANKING.CORE_EJBS.STATUS%TYPE,
                     P_USUARIO_MODIFICO   IN EBANKING.CORE_EJBS.USUARIO_MODIFICO%TYPE,
                     P_ACCION             IN NUMBER,
                     P_RESULTADO          OUT NUMBER,
                     P_RESULTADODES       OUT VARCHAR2) IS
  P_EXISTE    NUMBER;
  P_IDEJBTEMP EBANKING.CORE_EJBS.IDEJB%TYPE;
  CURSOR_CONSULTA  TYPES.refcursor;
  
  BEGIN 
        
    IF P_ACCION != 1 THEN
	   OPEN CURSOR_CONSULTA 
	     FOR SELECT COUNT(1) 
	        FROM EBANKING.CORE_EJBS E
	        WHERE E.IDEJB = P_IDEJB;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;   
    ELSE
  	   OPEN CURSOR_CONSULTA 
	     FOR  SELECT COUNT(1) ,E.IDEJB
	         FROM EBANKING.CORE_EJBS E
	         WHERE E.NOMBRE_EJB = P_NOMBRE_EJB
			 GROUP BY E.IDEJB;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE,P_IDEJBTEMP;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;  
    END IF;
   
  
    IF P_ACCION = 1 and (P_EXISTE = 0 OR P_EXISTE IS NULL) THEN
      INSERT INTO EBANKING.CORE_EJBS
        (IDEJB,
         NOMBRE_EJB,
         STATUS,
         USUARIO_MODIFICO,
         ULTIMA_MODIFICACION)
      VALUES
        ((SELECT (NVL(MAX(IDEJB), 0) ) + 1 FROM EBANKING.CORE_EJBS),
         P_NOMBRE_EJB,
         P_STATUS,
         P_USUARIO_MODIFICO,
         SYSDATE);
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de ejbs.';
	  
	ELSIF P_ACCION = 1 AND P_EXISTE != 0 THEN	
	  UPDATE EBANKING.CORE_EJBS E
         SET E.STATUS              = P_STATUS,
             E.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             E.ULTIMA_MODIFICACION = SYSDATE
      WHERE E.IDEJB = P_IDEJBTEMP;
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de ejbs.';
    
    ELSIF P_ACCION = 2 and P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_EJBS E
         SET E.IDEJB               = NVL(P_IDEJB, E.IDEJB),
             E.NOMBRE_EJB          = NVL(P_NOMBRE_EJB, E.NOMBRE_EJB),
             E.STATUS              = NVL(P_STATUS,E.STATUS),
             E.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             E.ULTIMA_MODIFICACION = SYSDATE
      WHERE  E.IDEJB = P_IDEJB;
      P_RESULTADO    := 2;
      P_RESULTADODES := 'Exito en la operación se actualizó el elemento en el catalogo de ejbs.';
    
    ELSIF P_ACCION = 3 and P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_EJBS E
         SET E.STATUS              = NVL(P_STATUS,E.STATUS),
             E.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             E.ULTIMA_MODIFICACION = SYSDATE
      WHERE E.IDEJB= P_IDEJB;
      P_RESULTADO    := 3;
      P_RESULTADODES := 'Exito en la operación se eliminó el elemento en el catalogo de ejbs.';
    ELSE
      P_RESULTADO    := 4;
      P_RESULTADODES := 'No se efectuo la acción.';
    
    END IF;
   COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      P_RESULTADO    := 0;
      P_RESULTADODES := SQLCODE || '  ' || SQLERRM;
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20120,'Error ocurrido en PKG_CORE_SERVICES.CAT_EJBS(' ||SQLCODE || '' || SQLERRM || ')');
  END;
  
  
  PROCEDURE CAT_METODOS(P_IDMETODO            IN EBANKING.CORE_METODS.IDMETODO%TYPE,
                        P_IDEJB               IN EBANKING.CORE_METODS.IDEJB%TYPE,                             
                        P_NOMBRE_METODO       IN EBANKING.CORE_METODS.NOMBRE_METODO%TYPE,
						P_DESCRIPCION_FUNCION IN EBANKING.CORE_METODS.DESCRIPCION_FUNCION%TYPE,
                        P_STATUS              IN EBANKING.CORE_METODS.STATUS%TYPE,
                        P_USUARIO_MODIFICO    IN EBANKING.CORE_METODS.USUARIO_MODIFICO%TYPE,
                        P_ACCION              IN NUMBER,
                        P_RESULTADO           OUT NUMBER,
                        P_RESULTADODES        OUT VARCHAR2) IS
  P_EXISTE 			NUMBER;
  P_IDMETODOTEMP	EBANKING.CORE_METODS.IDMETODO%TYPE;
  CURSOR_CONSULTA  TYPES.refcursor;
  
  BEGIN 
   IF P_ACCION != 1 THEN     
	   OPEN CURSOR_CONSULTA 
	     FOR SELECT COUNT(1) 
	        FROM EBANKING.CORE_METODS ME
	        WHERE ME.IDMETODO = P_IDMETODO;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;
    ELSE
  	   OPEN CURSOR_CONSULTA 
	     FOR SELECT COUNT(1), ME.IDMETODO
	         FROM EBANKING.CORE_METODS ME
	         WHERE ME.NOMBRE_METODO = P_NOMBRE_METODO AND
			       ME.IDEJB = P_IDEJB
			 GROUP BY ME.IDMETODO;
	     LOOP    
	       FETCH CURSOR_CONSULTA INTO P_EXISTE,P_IDMETODOTEMP;
	       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	     END LOOP; 
	   CLOSE CURSOR_CONSULTA;  
    END IF;
  
    IF P_ACCION = 1 and (P_EXISTE = 0 OR P_EXISTE IS NULL) THEN
      INSERT INTO EBANKING.CORE_METODS
        (IDMETODO,
         IDEJB,
         NOMBRE_METODO,
         STATUS,
		 DESCRIPCION_FUNCION,
         USUARIO_MODIFICO,
         ULTIMA_MODIFICACION)
      VALUES
        ((SELECT (NVL(MAX(IDMETODO), 0) ) + 1 FROM EBANKING.CORE_METODS),
         P_IDEJB,
         P_NOMBRE_METODO,
         P_STATUS,
		 P_DESCRIPCION_FUNCION,
         P_USUARIO_MODIFICO,
         SYSDATE);
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de metodos.';
	
	ELSIF P_ACCION = 1 AND P_EXISTE != 0 THEN
		  UPDATE EBANKING.CORE_METODS ME
	         SET ME.STATUS              = NVL(P_STATUS,ME.STATUS),
	             ME.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
	             ME.ULTIMA_MODIFICACION = SYSDATE
	      WHERE ME.IDMETODO = P_IDMETODOTEMP;
	      P_RESULTADO    := 1;
	      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de metodos.';
    
    ELSIF P_ACCION = 2 and P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_METODS ME
         SET ME.IDMETODO            = NVL(P_IDMETODO, ME.IDMETODO),
             ME.IDEJB               = NVL(P_IDEJB, ME.IDEJB),
             ME.NOMBRE_METODO       = NVL(P_NOMBRE_METODO,ME.NOMBRE_METODO),
             ME.STATUS              = NVL(P_STATUS,ME.STATUS),
			 ME.DESCRIPCION_FUNCION = NVL(P_DESCRIPCION_FUNCION,ME.DESCRIPCION_FUNCION),
             ME.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             ME.ULTIMA_MODIFICACION = SYSDATE
      WHERE ME.IDMETODO = P_IDMETODO;
      P_RESULTADO    := 2;
      P_RESULTADODES := 'Exito en la operación se actualizó el elemento en el catalogo de metodos.';
    
    ELSIF P_ACCION = 3 and P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_METODS ME
         SET ME.STATUS              = NVL(P_STATUS,ME.STATUS),
             ME.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             ME.ULTIMA_MODIFICACION = SYSDATE
      WHERE ME.IDMETODO = P_IDMETODO;
      P_RESULTADO    := 3;
      P_RESULTADODES := 'Exito en la operación se eliminó el elemento en el catalogo de metodos.';
    ELSE
      P_RESULTADO    := 4;
      P_RESULTADODES := 'No se efectuo la acción.';
    
    END IF;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      P_RESULTADO    := 0;
      P_RESULTADODES := SQLCODE || '  ' || SQLERRM;
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20120,'Error ocurrido en PKG_CORE_SERVICES.CAT_METODOS(' ||SQLCODE || '' || SQLERRM || ')');
  END;
  
  
  PROCEDURE CAT_ROL_METODO(P_IDROL_METODO       IN EBANKING.CORE_ROL_METODS.IDROL_METODO%TYPE,
                           P_IDMETODO           IN EBANKING.CORE_ROL_METODS.IDMETODO%TYPE,   
                           P_IDROL              IN EBANKING.CORE_ROL_METODS.IDROL%TYPE,     
                           P_STATUS             IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           P_USUARIO_MODIFICO   IN EBANKING.CORE_ROL_METODS.USUARIO_MODIFICO%TYPE,
                           P_ACCION             IN NUMBER,
                           P_RESULTADO          OUT NUMBER,
                           P_RESULTADODES       OUT VARCHAR2) IS
  P_EXISTE          NUMBER;
  P_IDROL_METODOTMP EBANKING.CORE_ROL_METODS.IDROL_METODO%TYPE;
  CURSOR_CONSULTA   TYPES.refcursor;
  
  BEGIN 

   OPEN CURSOR_CONSULTA 
     FOR SELECT COUNT(1),RM.IDROL_METODO
         FROM EBANKING.CORE_ROL_METODS RM
         WHERE RM.IDROL=P_IDROL AND
			   RM.IDMETODO=P_IDMETODO
	     GROUP BY RM.IDROL_METODO;
     LOOP    
       FETCH CURSOR_CONSULTA INTO P_EXISTE,P_IDROL_METODOTMP;
       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
     END LOOP; 
   CLOSE CURSOR_CONSULTA;
   
  
    IF P_ACCION = 1 AND (P_EXISTE = 0 OR P_EXISTE IS NULL) THEN
      INSERT INTO EBANKING.CORE_ROL_METODS
        (IDROL_METODO,
         IDMETODO,
         IDROL,
         STATUS,
         USUARIO_MODIFICO,
         ULTIMA_MODIFICACION)
      VALUES
        ((SELECT (NVL(MAX(IDROL_METODO), 0) ) + 1 FROM EBANKING.CORE_ROL_METODS),
         P_IDMETODO,
         P_IDROL,
         P_STATUS,
         P_USUARIO_MODIFICO,
         SYSDATE);
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de rol_metodo.';
	  
    ELSIF P_ACCION = 1 AND P_EXISTE != 0 THEN
	  UPDATE EBANKING.CORE_ROL_METODS RM
         SET RM.STATUS              = NVL(P_STATUS,RM.STATUS),
             RM.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             RM.ULTIMA_MODIFICACION = SYSDATE
      WHERE RM.IDROL_METODO =P_IDROL_METODOTMP;
	  P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de rol_metodo.';
	
    ELSIF P_ACCION = 2 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_ROL_METODS RM
         SET RM.IDROL_METODO        = NVL(P_IDROL_METODO, RM.IDROL_METODO),
             RM.IDMETODO            = NVL(P_IDMETODO,RM.IDMETODO),
             RM.IDROL               = NVL(P_IDROL, RM.IDROL),           
             RM.STATUS              = NVL(P_STATUS,RM.STATUS),
             RM.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             RM.ULTIMA_MODIFICACION = SYSDATE
      WHERE RM.IDROL_METODO = P_IDROL_METODO;
      P_RESULTADO    := 2;
      P_RESULTADODES := 'Exito en la operación se actualizó el elemento en el catalogo de rol_metodo.';
    
    ELSIF P_ACCION = 3 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_ROL_METODS RM
         SET RM.STATUS              = NVL(P_STATUS,RM.STATUS),
             RM.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             RM.ULTIMA_MODIFICACION = SYSDATE
      WHERE RM.IDROL=P_IDROL AND
			RM.IDMETODO=P_IDMETODO;
      P_RESULTADO    := 3;
      P_RESULTADODES := 'Exito en la operación se eliminó el elemento en el catalogo de rol_metodo.';
    ELSE
      P_RESULTADO    := 4;
      P_RESULTADODES := 'No se efectuo la acción.';
    
    END IF;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      P_RESULTADO    := 0;
      P_RESULTADODES := SQLCODE || '  ' || SQLERRM;
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20120,'Error ocurrido en PKG_CORE_SERVICES.CAT_ROL_METODO(' ||SQLCODE || '' || SQLERRM || ')');
  END;
  
  
  
  PROCEDURE CAT_MACS(P_MAC                 IN EBANKING.CORE_MACS.MAC%TYPE,
  					 P_MAC_M               IN EBANKING.CORE_MACS.MAC%TYPE,
                     P_IDROL               IN EBANKING.CORE_MACS.IDROL%TYPE,                             
                     P_NOMBRE_APLICACION   IN EBANKING.CORE_MACS.NOMBRE_APLICACION%TYPE,
					 P_NOMBRE_APLICACION_M IN EBANKING.CORE_MACS.NOMBRE_APLICACION%TYPE,
                     P_STATUS              IN EBANKING.CORE_MACS.STATUS%TYPE,
                     P_USUARIO_MODIFICO    IN EBANKING.CORE_MACS.USUARIO_MODIFICO%TYPE,
                     P_ACCION              IN NUMBER,
                     P_RESULTADO           OUT NUMBER,
                     P_RESULTADODES        OUT VARCHAR2) IS
  P_EXISTE NUMBER;
  CURSOR_CONSULTA  TYPES.refcursor;
  
  BEGIN 
        
   OPEN CURSOR_CONSULTA 
     FOR SELECT COUNT(1) 
        FROM EBANKING.CORE_MACS M
        WHERE M.MAC = P_MAC AND
		      M.NOMBRE_APLICACION=P_NOMBRE_APLICACION;
     LOOP    
       FETCH CURSOR_CONSULTA INTO P_EXISTE;
       EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
     END LOOP; 
   CLOSE CURSOR_CONSULTA;
   
  
    IF P_ACCION = 1 AND (P_EXISTE = 0 OR P_EXISTE IS NULL) THEN
      INSERT INTO EBANKING.CORE_MACS
        (MAC,
         IDROL,
         NOMBRE_APLICACION,
         STATUS,
         USUARIO_MODIFICO,
         ULTIMA_MODIFICACION)
      VALUES
        (P_MAC,
         P_IDROL,
         P_NOMBRE_APLICACION,
         P_STATUS,
         P_USUARIO_MODIFICO,
         SYSDATE);
      P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de macs.';
    ELSIF P_ACCION = 1 AND P_EXISTE != 0 THEN
	  UPDATE EBANKING.CORE_MACS M
         SET M.STATUS              = NVL(P_STATUS,M.STATUS),
             M.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             M.ULTIMA_MODIFICACION = SYSDATE
      WHERE M.MAC = P_MAC AND
	  		M.NOMBRE_APLICACION=P_NOMBRE_APLICACION;	
	  P_RESULTADO    := 1;
      P_RESULTADODES := 'Exito en la operación se insertó el elemento en el catalogo de macs.';
	
    ELSIF P_ACCION = 2 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_MACS M
         SET M.MAC                 = NVL(P_MAC_M, M.MAC),
             M.IDROL               = NVL(P_IDROL, M.IDROL),
             M.NOMBRE_APLICACION   = NVL(P_NOMBRE_APLICACION_M,M.NOMBRE_APLICACION),
             M.STATUS              = NVL(P_STATUS,M.STATUS),
             M.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             M.ULTIMA_MODIFICACION = SYSDATE
      WHERE M.MAC = P_MAC AND
	  		M.NOMBRE_APLICACION=P_NOMBRE_APLICACION;
      P_RESULTADO    := 2;
      P_RESULTADODES := 'Exito en la operación se actualizó el elemento en el catalogo de macs.';
    
    ELSIF P_ACCION = 3 AND P_EXISTE != 0 THEN
      UPDATE EBANKING.CORE_MACS M
         SET M.STATUS              = NVL(P_STATUS,M.STATUS),
             M.USUARIO_MODIFICO    = P_USUARIO_MODIFICO,
             M.ULTIMA_MODIFICACION = SYSDATE
      WHERE M.MAC = P_MAC AND
	  		M.NOMBRE_APLICACION=P_NOMBRE_APLICACION;	
      P_RESULTADO    := 3;
      P_RESULTADODES := 'Exito en la operación se eliminó el elemento en el catalogo de macs.';
    ELSE
      P_RESULTADO    := 4;
      P_RESULTADODES := 'No se efectuo la acción.';
    
    END IF;
  
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      P_RESULTADO    := 0;
      P_RESULTADODES := SQLCODE || '  ' || SQLERRM;
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20120,'Error ocurrido en PKG_CORE_SERVICES.CAT_MACS(' ||SQLCODE || '' || SQLERRM || ')');
  END;
  
  FUNCTION GET_CAT_ROL(P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
					   P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE)  RETURN SYS_REFCURSOR IS   
    CURSOR_CONSULTA  SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT R.IDROL, R.NOMBRE_ROL, R.STATUS, R.USUARIO_MODIFICO, R.ULTIMA_MODIFICACION
		   	   FROM EBANKING.CORE_ROL R
			   WHERE R.STATUS BETWEEN P_STATUSROL_INI AND P_STATUSROL_FIN
			   ORDER BY R.NOMBRE_ROL;
      RETURN CURSOR_CONSULTA;   
	CLOSE CURSOR_CONSULTA;  
  END;
  
  FUNCTION GET_CAT_EJBS(P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE) RETURN SYS_REFCURSOR IS   	
    CURSOR_CONSULTA  SYS_REFCURSOR;
    BEGIN
     	OPEN CURSOR_CONSULTA
		FOR SELECT E.IDEJB, E.NOMBRE_EJB, E.STATUS, E.USUARIO_MODIFICO, E.ULTIMA_MODIFICACION
		   	FROM EBANKING.CORE_EJBS E
			WHERE E.STATUS  BETWEEN P_STATUSEJB_INI AND  P_STATUSEJB_FIN
			ORDER BY E.NOMBRE_EJB;		 
		RETURN CURSOR_CONSULTA; 
	CLOSE CURSOR_CONSULTA;
  END;
  
  FUNCTION GET_CAT_METODOS(P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                           P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						   P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						   P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE) RETURN SYS_REFCURSOR IS  
    CURSOR_CONSULTA   SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT ME.IDMETODO, ME.IDEJB, ME.NOMBRE_METODO, ME.DESCRIPCION_FUNCION,
		              ME.STATUS, ME.ULTIMA_MODIFICACION, ME.USUARIO_MODIFICO,
		              E.NOMBRE_EJB, E.STATUS STATUS_EJB,
		              E.NOMBRE_EJB||'.'|| ME.NOMBRE_METODO LLAVEMETODO
		   FROM EBANKING.CORE_METODS ME INNER JOIN EBANKING.CORE_EJBS E ON ME.IDEJB = E.IDEJB
		   WHERE (ME.STATUS BETWEEN P_STATUSME_INI AND P_STATUSME_FIN ) AND
		         (E.STATUS  BETWEEN P_STATUSEJB_INI AND  P_STATUSEJB_FIN)
		   ORDER BY E.NOMBRE_EJB,ME.NOMBRE_METODO;      
      RETURN CURSOR_CONSULTA; 
	  CLOSE CURSOR_CONSULTA;    
  END;
  
 
  FUNCTION GET_CAT_ROL_METODOS(P_STATUSRM_INI  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           	   P_STATUSRM_FIN  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
							   P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                           	   P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						   	   P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						   	   P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE,
							   P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
						   	   P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE) RETURN SYS_REFCURSOR IS
    CURSOR_CONSULTA   SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT RM.IDROL_METODO, RM.IDMETODO, RM.IDROL, RM.STATUS, RM.ULTIMA_MODIFICACION, 
		   	   		  RM.USUARIO_MODIFICO, R.NOMBRE_ROL, R.STATUS STATUS_ROL,ME.NOMBRE_METODO,
					  ME.DESCRIPCION_FUNCION, E.NOMBRE_EJB, 
					  E.NOMBRE_EJB||'.'|| ME.NOMBRE_METODO  ||'_'||RM.IDROL LLAVE
			   FROM EBANKING.CORE_ROL_METODS RM INNER JOIN EBANKING.CORE_METODS ME ON ME.IDMETODO = RM.IDMETODO
					 						  	INNER JOIN EBANKING.CORE_ROL R ON R.IDROL = RM.IDROL												
												INNER JOIN EBANKING.CORE_EJBS E ON E.IDEJB = ME.IDEJB
			   WHERE (E.STATUS  BETWEEN P_STATUSEJB_INI AND P_STATUSEJB_FIN) AND
			   		 (ME.STATUS BETWEEN P_STATUSME_INI  AND P_STATUSME_FIN)  AND
					 (R.STATUS  BETWEEN P_STATUSROL_INI AND P_STATUSROL_FIN) AND
					 (RM.STATUS BETWEEN P_STATUSRM_INI  AND P_STATUSRM_FIN)
			   ORDER BY E.NOMBRE_EJB, ME.NOMBRE_METODO;
	  RETURN CURSOR_CONSULTA; 
	  CLOSE CURSOR_CONSULTA;     
  END;
  
  FUNCTION GET_ID_ROL_METODOS(P_STATUSRM_INI  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
                           	  P_STATUSRM_FIN  IN EBANKING.CORE_ROL_METODS.STATUS%TYPE,
							  P_STATUSME_INI  IN EBANKING.CORE_METODS.STATUS%TYPE,
                           	  P_STATUSME_FIN  IN EBANKING.CORE_METODS.STATUS%TYPE,
						   	  P_STATUSEJB_INI IN EBANKING.CORE_EJBS.STATUS%TYPE,
						   	  P_STATUSEJB_FIN IN EBANKING.CORE_EJBS.STATUS%TYPE,
							  P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
						   	  P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE,
							  P_IDROL IN EBANKING.CORE_ROL_METODS.IDROL%TYPE) RETURN SYS_REFCURSOR IS
    CURSOR_CONSULTA   SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT RM.IDROL_METODO, RM.IDMETODO, RM.IDROL, RM.STATUS, RM.ULTIMA_MODIFICACION, 
		              RM.USUARIO_MODIFICO, R.NOMBRE_ROL ,R.STATUS STATUS_ROL, ME.NOMBRE_METODO, 
					  E.NOMBRE_EJB, E.IDEJB,ME.DESCRIPCION_FUNCION,
					  E.NOMBRE_EJB||'.'|| ME.NOMBRE_METODO  ||'_'||RM.IDROL LLAVE
			   FROM EBANKING.CORE_ROL_METODS RM INNER JOIN EBANKING.CORE_METODS ME ON ME.IDMETODO = RM.IDMETODO
					 						  	INNER JOIN EBANKING.CORE_ROL R ON R.IDROL = RM.IDROL												
												INNER JOIN EBANKING.CORE_EJBS E ON E.IDEJB = ME.IDEJB
			   WHERE (E.STATUS  BETWEEN P_STATUSEJB_INI AND P_STATUSEJB_FIN) AND
			   		 (ME.STATUS BETWEEN P_STATUSME_INI  AND P_STATUSME_FIN)  AND
					 (R.STATUS  BETWEEN P_STATUSROL_INI AND P_STATUSROL_FIN) AND
					 (RM.STATUS BETWEEN P_STATUSRM_INI  AND P_STATUSRM_FIN) AND
			         RM.IDROL=P_IDROL
			   ORDER BY RM.IDMETODO;	
	  RETURN CURSOR_CONSULTA; 
	  CLOSE CURSOR_CONSULTA;     
  END;
    
  FUNCTION GET_CAT_MACS(P_STATUSMAC_INI  IN EBANKING.CORE_MACS.STATUS%TYPE,
                        P_STATUSMAC_FIN  IN EBANKING.CORE_MACS.STATUS%TYPE,
						P_STATUSROL_INI  IN EBANKING.CORE_ROL.STATUS%TYPE,
						P_STATUSROL_FIN  IN EBANKING.CORE_ROL.STATUS%TYPE) RETURN SYS_REFCURSOR IS
    CURSOR_CONSULTA   SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT M.MAC, M.NOMBRE_APLICACION, M.IDROL, M.STATUS , M.ULTIMA_MODIFICACION,
		              M.USUARIO_MODIFICO , R.NOMBRE_ROL
		   	   FROM EBANKING.CORE_MACS M INNER JOIN EBANKING.CORE_ROL R ON R.IDROL = M.IDROL
			   WHERE (M.STATUS BETWEEN P_STATUSMAC_INI AND P_STATUSMAC_FIN) AND
			         (R.STATUS BETWEEN P_STATUSROL_INI AND P_STATUSROL_FIN)
			   ORDER BY R.NOMBRE_ROL, M.NOMBRE_APLICACION;	
	  RETURN CURSOR_CONSULTA; 
	  CLOSE CURSOR_CONSULTA;  
  END; 
  
    
  FUNCTION GET_ID_MAC (P_STATUSMAC_INI  IN EBANKING.CORE_MACS.STATUS%TYPE,
                       P_STATUSMAC_FIN  IN EBANKING.CORE_MACS.STATUS%TYPE,
					   P_STATUSROL_INI IN EBANKING.CORE_ROL.STATUS%TYPE,
					   P_STATUSROL_FIN IN EBANKING.CORE_ROL.STATUS%TYPE,
					   P_MAC IN EBANKING.CORE_MACS.MAC%TYPE) RETURN SYS_REFCURSOR IS
    CURSOR_CONSULTA   SYS_REFCURSOR;
    BEGIN
      OPEN CURSOR_CONSULTA 
	  	   FOR SELECT M.MAC, M.NOMBRE_APLICACION, M.IDROL, M.STATUS, M.ULTIMA_MODIFICACION,
		              M.USUARIO_MODIFICO, R.NOMBRE_ROL
		   	   FROM EBANKING.CORE_MACS M INNER JOIN EBANKING.CORE_ROL R ON R.IDROL = M.IDROL
			   WHERE (M.STATUS BETWEEN P_STATUSMAC_INI AND P_STATUSMAC_FIN) AND
			         (R.STATUS BETWEEN P_STATUSROL_INI AND P_STATUSROL_FIN) AND
					 M.MAC=P_MAC 
			   ORDER BY M.MAC, M.NOMBRE_APLICACION;	
	  RETURN CURSOR_CONSULTA; 
	  CLOSE CURSOR_CONSULTA;  
  END; 
  
  
END PKG_CORE_SERVICES;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY pkg_dinero_express
IS
   FUNCTION get_cliente (cl_cliente_alnova VARCHAR2)
      RETURN TYPES.refcursor
   IS
      cursorcliente   TYPES.refcursor;
   BEGIN
      OPEN cursorcliente FOR
         SELECT cli.cliente_alnova, cli.cliente_id, cli.nombre,
                cli.apellido_paterno, cli.apellido_materno,
                cli.fecha_nacimiento
           FROM ebanking.dexcliente cli
          WHERE cli.cliente_alnova = cl_cliente_alnova;

      RETURN cursorcliente;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error obtener cliente ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error obtener cliente ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
   END get_cliente;

   FUNCTION get_transferencia (
      tr_num_cuenta     VARCHAR2,
      tr_fecha_inicio   DATE,
      tr_fecha_fin      DATE
   )
      RETURN TYPES.refcursor
   IS
      cursortransferencia   TYPES.refcursor;
   BEGIN
      IF (tr_fecha_fin IS NOT NULL AND tr_fecha_inicio IS NOT NULL)
      THEN
         OPEN cursortransferencia FOR
            SELECT tran.cliente_id, tran.mtcn, tran.monto_enviado,
                   tran.beneficiario_id, tran.tarifa, tran.num_cuenta,
                   tran.fecha_envio, NVL (imp.monto, 0) impuestos,
                   NVL (des.monto, 0) descuentos
              FROM ebanking.dextransferencia tran
                   LEFT JOIN
                   (SELECT   mtcn, SUM (monto) monto
                        FROM ebanking.deximpuesto
                    GROUP BY mtcn) imp ON imp.mtcn = tran.mtcn
                   LEFT JOIN
                   (SELECT   mtcn, SUM (monto) monto
                        FROM ebanking.dexdescuento
                    GROUP BY mtcn) des ON des.mtcn = tran.mtcn
             WHERE tran.num_cuenta = tr_num_cuenta
               AND TRUNC (tran.fecha_envio) BETWEEN TRUNC (tr_fecha_inicio)
                                                AND TRUNC (tr_fecha_fin);

         RETURN cursortransferencia;
      ELSE
         IF (tr_fecha_inicio IS NOT NULL)
         THEN
            OPEN cursortransferencia FOR
               SELECT tran.cliente_id, tran.mtcn, tran.monto_enviado,
                      tran.beneficiario_id, tran.tarifa, tran.num_cuenta,
                      tran.fecha_envio, NVL (imp.monto, 0) impuestos,
                      NVL (des.monto, 0) descuentos
                 FROM ebanking.dextransferencia tran
                      LEFT JOIN
                      (SELECT   mtcn, SUM (monto) monto
                           FROM ebanking.deximpuesto
                       GROUP BY mtcn) imp ON imp.mtcn = tran.mtcn
                      LEFT JOIN
                      (SELECT   mtcn, SUM (monto) monto
                           FROM ebanking.dexdescuento
                       GROUP BY mtcn) des ON des.mtcn = tran.mtcn
                WHERE tran.num_cuenta = tr_num_cuenta
                  AND TRUNC (tran.fecha_envio) >= TRUNC (tr_fecha_inicio);

            RETURN cursortransferencia;
         ELSE
            IF (tr_fecha_fin IS NOT NULL)
            THEN
               OPEN cursortransferencia FOR
                  SELECT tran.cliente_id, tran.mtcn, tran.monto_enviado,
                         tran.beneficiario_id, tran.tarifa, tran.num_cuenta,
                         tran.fecha_envio, NVL (imp.monto, 0) impuestos,
                         NVL (des.monto, 0) descuentos
                    FROM ebanking.dextransferencia tran
                         LEFT JOIN
                         (SELECT   mtcn, SUM (monto) monto
                              FROM ebanking.deximpuesto
                          GROUP BY mtcn) imp ON imp.mtcn = tran.mtcn
                         LEFT JOIN
                         (SELECT   mtcn, SUM (monto) monto
                              FROM ebanking.dexdescuento
                          GROUP BY mtcn) des ON des.mtcn = tran.mtcn
                   WHERE tran.num_cuenta = tr_num_cuenta
                     AND TRUNC (tran.fecha_envio) <= TRUNC (tr_fecha_fin);

               RETURN cursortransferencia;
            ELSE
               OPEN cursortransferencia FOR
                  SELECT tran.cliente_id, tran.mtcn, tran.monto_enviado,
                         tran.beneficiario_id, tran.tarifa, tran.num_cuenta,
                         tran.fecha_envio, NVL (imp.monto, 0) impuestos,
                         NVL (des.monto, 0) descuentos
                    FROM ebanking.dextransferencia tran
                         LEFT JOIN
                         (SELECT   mtcn, SUM (monto) monto
                              FROM ebanking.deximpuesto
                          GROUP BY mtcn) imp ON imp.mtcn = tran.mtcn
                         LEFT JOIN
                         (SELECT   mtcn, SUM (monto) monto
                              FROM ebanking.dexdescuento
                          GROUP BY mtcn) des ON des.mtcn = tran.mtcn
                   WHERE tran.num_cuenta = tr_num_cuenta;

               RETURN cursortransferencia;
            END IF;
         END IF;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error obtener transferencia ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error obtener transferencia ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
   END get_transferencia;

   FUNCTION get_descuento (des_mtcn VARCHAR2)
      RETURN TYPES.refcursor
   IS
      cursordescuento   TYPES.refcursor;
   BEGIN
      OPEN cursordescuento FOR
         SELECT des.mtcn, des.descripcion, des.monto
           FROM ebanking.dexdescuento des
          WHERE des.mtcn = des_mtcn;

      RETURN cursordescuento;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error obtener descuento ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error obtener descuento ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
   END get_descuento;

   FUNCTION get_impuesto (imp_mtcn VARCHAR2)
      RETURN TYPES.refcursor
   IS
      cursorimpuesto   TYPES.refcursor;
   BEGIN
      OPEN cursorimpuesto FOR
         SELECT imp.mtcn, imp.NOMBRE_IMPUESTO , imp.monto
           FROM ebanking.deximpuesto imp
          WHERE imp.mtcn = imp_mtcn;

      RETURN cursorimpuesto;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error obtener impuesto ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error obtener impuesto ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
   END get_impuesto;


 /***********************Funciones de Inserción para modulo de DineroExpress********************************/



   PROCEDURE add_cliente (
      cl_cliente_alnova        VARCHAR2,
      cl_cliente_id        	   NUMBER,
      cl_nombre            	   VARCHAR2,
      cl_apellido_paterno      VARCHAR2,
      cl_apellido_materno      VARCHAR2,
      cl_fecha_nacimiento  	   DATE,
	  cl_pais_identificacion   NUMBER,
	  cl_tipo_identificacion   NUMBER,
	  cl_folio_identificacion  VARCHAR2,
	  cl_usuario_modifico 	   VARCHAR2
   )
   AS
   BEGIN
      INSERT INTO ebanking.dexcliente cli
                  (cli.cliente_alnova, cli.cliente_id, cli.nombre,
                   cli.apellido_paterno, cli.apellido_materno,
                   cli.fecha_nacimiento,
				   cli.pais_identificacion,
				   cli.tipo_identificacion,
				   cli.folio_identificacion,
				   cli.usuario_modifico
                  )
           VALUES (cl_cliente_alnova, cl_cliente_id, cl_nombre,
                   cl_apellido_paterno, cl_apellido_materno,
                   cl_fecha_nacimiento,
				   cl_pais_identificacion,
				   cl_tipo_identificacion,
				   cl_folio_identificacion,
				   cl_usuario_modifico
                  );

      COMMIT;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error al insertar el cliente ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error al insertar el cliente ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
	ROLLBACK;
   END add_cliente;

   PROCEDURE add_transferencias (
      tr_cliente_id        NUMBER,
      tr_mtcn              VARCHAR2,
      tr_monto_enviado     NUMBER,
      tr_beneficiario_id   NUMBER,
      tr_tarifa            NUMBER,
      tr_num_cuenta        VARCHAR2,
	  tr_folio_retencion   VARCHAR2,
      tr_fecha_envio	   DATE,
	  tr_pais_id_destino   NUMBER,
	  tr_estado_id_destino NUMBER,
	  tr_ciudad_id_destino NUMBER,
	  tr_id_moneda_envio   NUMBER,
	  tr_id_moneda_destino NUMBER,
	  tr_usuario_modifico  VARCHAR2
   )
   AS
   BEGIN
      INSERT INTO ebanking.dextransferencia tran
                  (
				   tran.cliente_id, tran.mtcn, tran.monto_enviado,
                   tran.beneficiario_id, tran.tarifa, tran.num_cuenta, tran.folio_retencion,
				   tran.fecha_envio,
				   tran.pais_id_destino,
				   tran.estado_id_destino,
				   tran.ciudad_id_destino,
				   tran.id_moneda_envio,
				   tran.id_moneda_destino,
				   tran.usuario_modifico
                  )
           VALUES
		   		  (
				   tr_cliente_id, tr_mtcn, tr_monto_enviado,
                   tr_beneficiario_id, tr_tarifa, tr_num_cuenta, tr_folio_retencion,
				   tr_fecha_envio,
				   tr_pais_id_destino,
				   tr_estado_id_destino,
				   tr_ciudad_id_destino,
				   tr_id_moneda_envio,
				   tr_id_moneda_destino,
				   tr_usuario_modifico
                  );

      COMMIT;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error al insertar la transferencia ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error
                                (-20100,
                                    'Error al insertar la transferencia ( * '
                                 || SQLCODE
                                 || '  '
                                 || SQLERRM
                                 || '   *)'
                                );
   ROLLBACK;
   END add_transferencias;

   PROCEDURE add_descuento (
      des_mtcn             	   VARCHAR2,
      des_descripcion   	   VARCHAR2,
      des_monto         	   NUMBER,
	  des_id_descuento		   NUMBER,
	  des_usuario_modifico	   VARCHAR2
   )
   AS
   BEGIN
      INSERT INTO ebanking.dexdescuento des
                  (des.mtcn, des.descripcion, des.monto, des.id, des.usuario_modifico)
           VALUES (des_mtcn, des_descripcion, des_monto, EBANKING.SEQ_DE_DESCUENTO.NEXTVAL, des_usuario_modifico);

      COMMIT;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error al insertar los descuentos ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error al insertar los descuentos ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
   ROLLBACK;
   END add_descuento;

   PROCEDURE add_impuesto (
      imp_mtcn          VARCHAR2,
      imp_nombre_impuesto   VARCHAR2,
      imp_monto         	   NUMBER,
	  imp_id_impuesto 		   NUMBER,
	  imp_id_importe			   NUMBER,
	  imp_nombre_corto_imp	   VARCHAR2,
	  imp_usuario_modifico	   VARCHAR2
   )
   AS
   BEGIN
      INSERT INTO ebanking.deximpuesto imp
                  (imp.mtcn, imp.NOMBRE_IMPUESTO, imp.monto,
				   imp.id_impuesto,
				   imp.ID_IMPORTE,
				   imp.NOMBRE_CORTO_IMPUESTO,
				   imp.USUARIO_MODIFICO,
				   imp.ID
                  )
           VALUES (imp_mtcn, imp_nombre_impuesto, imp_monto,
		   		   imp_id_impuesto,
				   imp_id_importe,
				   imp_nombre_corto_imp,
				   imp_usuario_modifico,
				   EBANKING.SEQ_DE_IMPUESTO.NEXTVAL
                  );

      COMMIT;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         raise_application_error (-20100,
                                     'Error al insertar los impuestos ('
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || ')'
                                 );
      WHEN OTHERS
      THEN
         raise_application_error (-20100,
                                     'Error al insertar los impuestos ( * '
                                  || SQLCODE
                                  || '  '
                                  || SQLERRM
                                  || '   *)'
                                 );
	ROLLBACK;
   END add_impuesto;
END pkg_dinero_express;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY          types AS
--24/03/2011
TYPE REFCURSOR IS REF CURSOR;
--24/03/2011
END;
/

SHOW ERRORS;


CREATE OR REPLACE procedure actualiza
(
p_nombre in ebanking.usuario.nombre %type,
p_contrasena in ebanking.usuario.contrasena %type,
p_telefono in ebanking.usuario.telefono %type,
p_usuario in ebanking.usuario.usuario %type,
p_id in ebanking.usuario.id_usuario %type
)
as
begin
UPDATE Usuario SET nombre=p_nombre, contrasena=p_contrasena, telefono=p_telefono, usuario = p_usuario WHERE id_usuario=p_id;
commit;
end;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ACTUALIZA_BENEFICIARIOS( numCteAlnova  VARCHAR2,  
nombre1New VARCHAR2, 
nombre2New VARCHAR2, 
paternoNew VARCHAR2, 
maternoNew VARCHAR2, 
parentescoNew VARCHAR2, 
edadNew VARCHAR2, 
porcentajeNew VARCHAR2,
operacion  NUMBER )

AS 
BEGIN
if operacion = 0
then
	DELETE FROM EBANKING.FI_BENEFICIARIO FD WHERE FD.FI_CTE_ALNOVA = numCteAlnova;
	INSERT INTO EBANKING.FI_BENEFICIARIO FD (FD.FI_CTE_ALNOVA, FD.FI_NOMBRE1, FD.FI_NOMBRE2, FD.FI_APATERNO, FD.FI_AMATERNO, FD.FI_PARENTESCO, FD.FI_EDAD, FD.FI_PORC_PART)
	VALUES (numCteAlnova, nombre1New, nombre2New, paternoNew, maternoNew, parentescoNew, edadNew, porcentajeNew);
else
	INSERT INTO EBANKING.FI_BENEFICIARIO FD (FD.FI_CTE_ALNOVA, FD.FI_NOMBRE1, FD.FI_NOMBRE2, FD.FI_APATERNO, FD.FI_AMATERNO, FD.FI_PARENTESCO, FD.FI_EDAD, FD.FI_PORC_PART)
	VALUES (numCteAlnova, nombre1New, nombre2New, paternoNew, maternoNew, parentescoNew, edadNew, porcentajeNew);
end if;

EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al actualizar beneficiario (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al actualizar beneficiario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ACTUALIZA_BENEFICIARIOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ACTUALIZA_DESTINOS_FRECUENTES( clienteAlnova NUMBER, ide NUMBER, fecha VARCHAR2, pEstatus VARCHAR2, pCanal VARCHAR2 )

AS
BEGIN

UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS
SET STATUS                = pEstatus,
    CANAL                 = pCanal,
    ULTIMA_ACTUALIZACION  = TO_DATE( fecha , 'dd/mm/yyyy hh24:mi:ss' )
WHERE ID = ide  AND ID_CLIENTE = clienteAlnova ;
COMMIT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de traspasos  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de traspasos  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END ACTUALIZA_DESTINOS_FRECUENTES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ACTUALIZA_TA_FRECUENTES( clienteAlnova NUMBER, tel VARCHAR2, fecha VARCHAR2, pEstatus VARCHAR2, pCanal VARCHAR2 )

AS
BEGIN

UPDATE EBANKING.COMPRATA_TELEFONOSFRECUENTES
SET ULTIMA_ACTUALIZACION  = TO_DATE( fecha , 'dd/mm/yyyy hh24:mi:ss' ),
    STATUS                = pEstatus,
    CANAL                 = pCanal
WHERE TELEPHONE = tel  AND CLIENT = clienteAlnova ;
COMMIT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de tiempo aire  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de tiempo aire  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END ACTUALIZA_TA_FRECUENTES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ACTUALIZA_TELMEX_FRECUENTES( clienteAlnova NUMBER, tel VARCHAR2, fecha VARCHAR2, pEstatus VARCHAR2, pCanal VARCHAR2 )

AS
BEGIN

UPDATE EBANKING.TELMEX
SET STATUS                = pEstatus,
    CANAL                 = pCanal,
    ULTIMA_ACTUALIZACION  = TO_DATE( fecha , 'dd/mm/yyyy hh24:mi:ss' )
WHERE TELEFONO = tel  AND USER_ID = clienteAlnova ;
COMMIT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de telmex  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar los frecuentes de telmex  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END ACTUALIZA_TELMEX_FRECUENTES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          "ADDACCION"
     ( op_in IN varchar2 )
AS
     numero number;
  BEGIN
     select count(*)  INTO numero
     from ebanking.acciones
     where operacion=op_in
     and fecha like sysdate;
IF numero>=1 THEN
     update ebanking.acciones set movimiento=movimiento +1
     where operacion=op_in and fecha like sysdate;
     commit;
ELSE
     insert into ebanking.acciones (operacion,movimiento,fecha)
     values ( op_in, 1, sysdate );
     commit;
END IF;
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END AddAccion;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure          ADDACCION1
     ( op_in IN varchar2, cli number )
AS
     numero number;
	 v_cliente varchar2(80);
  BEGIN
     select count(*)  INTO numero
     from ebanking.acciones
     where operacion=op_in
     and fecha like sysdate;
IF numero>=1 THEN
     update ebanking.acciones set movimiento=movimiento +1
     where operacion=op_in and fecha like sysdate;
     commit;
ELSE
     insert into ebanking.acciones (operacion,movimiento,fecha)
     values ( op_in, 1, sysdate );
     commit;
END IF;

  BEGIN
    select cliente INTO V_CLIENTE
    from   operaciones_cli
    where  cliente                  = cli
    and    TO_CHAR(fecha,'MM/YYYY') = TO_CHAR(SYSDATE,'MM/YYYY')
    and    operacion                = op_in;

    IF SQL%FOUND THEN
       NULL;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         insert into ebanking.operaciones_cli
                (cliente, fecha  , operacion)
         values (cli    , sysdate, op_in);
         commit;
    WHEN OTHERS THEN
         raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
  END;

EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END ADDACCION1;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADDACCIONtest
     ( op_in IN varchar2 )
AS
     numero number:=0;
  BEGIN

IF numero>=1 THEN
     commit;
END IF;
END ADDACCIONtest;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure          AddEstadistica
     ( op_in IN varchar2, signed IN number )

AS
     numero number;


  BEGIN
     select /*+ INDEX(I_AUTENTICADO ) */ count(autenticado)  INTO numero
     from estadisticas
     where autenticado = signed
     and to_char(fecha, 'DDMMYYYY') = to_char(sysdate, 'DDMMYYYY')
     and pagina=op_in;


IF numero>=1 THEN
 update estadisticas set conteo=conteo +1 where autenticado=signed and pagina=op_in
 and to_char(fecha, 'DDMMYYYY') = to_char(sysdate, 'DDMMYYYY');
     commit;
ELSE
     insert into estadisticas (pagina,conteo,fecha,autenticado)
     values ( op_in, 1, sysdate, signed );
     commit;
END IF;
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);


END AddEstadistica;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure AddEstadistica_Afore
     ( op_in IN varchar2, signed IN number )
AS
     numero number;
  BEGIN
     select /*+ INDEX(I_AUTENTICADO ) */ count(autenticado)  INTO numero
     from estadisticas_afore
     where autenticado = signed
     and to_char(fecha, 'DDMMYYYY') = to_char(sysdate, 'DDMMYYYY')
     and pagina=op_in;
IF numero>=1 THEN
		 update estadisticas_afore set conteo=conteo +1 where autenticado=signed and
		 pagina=op_in
		 and to_char(fecha, 'DDMMYYYY') = to_char(sysdate, 'DDMMYYYY');
     commit;
ELSE
     insert into estadisticas_afore (pagina,conteo,fecha,autenticado)
     values ( op_in, 1, sysdate, signed );
     commit;
END IF;
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado -
'||SQLCODE||' -ERROR- '||SQLERRM);
END AddEstadistica_Afore;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            "ADDMONETXCTA"
    ( operacion_in IN varchar, producto_in varchar, subproducto_in varchar, canal_in int, monto_in float )
AS
    numero number;
BEGIN
    select COUNT(*)  into numero
        from EBANKING.MONETXCTA
        where operacion = operacion_in
           and producto = producto_in
           and subproducto = subproducto_in
           and canal = canal_in
           and fecha like sysdate;

    IF numero>=1 THEN
        update EBANKING.MONETXCTA
        set contador = contador + 1,  monto = monto + monto_in
        where operacion = operacion_in
            and producto = producto_in
            and subproducto = subproducto_in
            and canal = canal_in
            and fecha like sysdate;
        commit;
    ELSE
        insert into EBANKING.MONETXCTA (fecha,operacion,producto,subproducto,canal,contador,monto)
            values ( sysdate, operacion_in, producto_in, subproducto_in, canal_in, 1, monto_in );
        commit;
    END IF;

    EXCEPTION
    WHEN OTHERS THEN
          raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure AddMovimiento
     ( imp_in IN float, op_in IN varchar2 )
AS
     v_importe number;
     v_movimiento number;
     numero number;
  BEGIN
     select count(*)  INTO numero
     from ebanking.movimientos
     where operacion=op_in
     and fecha like sysdate;
IF numero>=1 THEN
     update ebanking.movimientos set importe=importe+imp_in ,movimiento=movimiento +1
     where operacion=op_in and fecha like sysdate;
     commit;
ELSE
     insert into ebanking.movimientos (importe,operacion,movimiento,fecha)
     values ( imp_in, op_in, 1, sysdate);
     commit;
END IF;
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END AddMovimiento;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure          AddMovimiento1 ( imp_in IN float, op_in IN varchar2, cli number )
AS
   v_importe number;
   v_movimiento number;
   numero number;
   v_num_cliente number;
   v_cliente varchar2(80);
BEGIN
   SELECT COUNT(operacion) INTO numero
   FROM EBANKING.movimientos
   WHERE operacion=op_in
   AND TO_CHAR(fecha, 'DD/MM/YYYY') = TO_CHAR(SYSDATE, 'DD/MM/YYYY');
 IF numero >= 1 THEN
   update EBANKING.movimientos 
   set importe = (importe + imp_in), movimiento = (movimiento + 1)
   where operacion = op_in 
   and TO_DATE(fecha, 'DD/MM/YYYY') = TO_DATE(SYSDATE, 'DD/MM/YYYY');
   commit;
 ELSE
   insert into EBANKING.movimientos (importe,operacion,movimiento,fecha) values ( imp_in, op_in, 1, sysdate);
   commit;
 END IF;
 BEGIN
      SELECT DISTINCT cliente INTO v_num_cliente	  FROM EBANKING.operaciones_cli
      WHERE cliente = cli      AND TO_DATE(fecha, 'DD/MM/YYYY') = TO_DATE(SYSDATE, 'DD/MM/YYYY')
      AND operacion = op_in;
 IF SQL%FOUND THEN
 NULL;
 END IF;
 EXCEPTION
 WHEN NO_DATA_FOUND THEN
   insert into EBANKING.operaciones_cli(cliente, fecha , operacion) values (cli , sysdate, op_in);
   commit;
 WHEN OTHERS THEN
 raise_application_error(-20001,'Un error fue encontrado1 - '||SQLCODE||' -ERROR- '||SQLERRM);
 END;
EXCEPTION
WHEN OTHERS THEN
 raise_application_error(-20001,'Un error fue encontrado2 - '||SQLCODE||' -ERROR- '||SQLERRM);
END AddMovimiento1;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            "ADDMOVSADMIN"
    ( operacion_in IN varchar, canal_in int)
AS
    numero number;
BEGIN
    select COUNT(*)  into numero
        from EBANKING.MOVSADMIN
        where operacion = operacion_in
           and canal = canal_in
           and fecha like sysdate;

    IF numero>=1 THEN
        update EBANKING.MOVSADMIN set contador = contador + 1
        where operacion = operacion_in
            and canal = canal_in
            and fecha like sysdate;
        commit;
    ELSE
        insert into EBANKING.MOVSADMIN (fecha,operacion,canal,contador)
            values ( sysdate, operacion_in, canal_in, 1 );
        commit;
    END IF;

    EXCEPTION
    WHEN OTHERS THEN
          raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            "ADDMOVSXCTA"
    ( operacion_in IN varchar, producto_in varchar, subproducto_in varchar, canal_in int, contador_in number )
AS
    numero number;
BEGIN
    select COUNT(*)  into numero
        from EBANKING.MOVSXCTA
        where operacion = operacion_in
           and producto = producto_in
           and subproducto = subproducto_in
           and canal = canal_in
           and fecha like sysdate;

    IF numero>=1 THEN
        update EBANKING.MOVSXCTA set contador = contador + contador_in
        where operacion = operacion_in
            and producto = producto_in
            and subproducto = subproducto_in
            and canal = canal_in
            and fecha like sysdate;
        commit;
    ELSE
        insert into EBANKING.MOVSXCTA (fecha,operacion,producto,subproducto,canal,contador)
            values ( sysdate, operacion_in, producto_in, subproducto_in, canal_in, contador_in );
        commit;
    END IF;

    EXCEPTION
    WHEN OTHERS THEN
          raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                   ADD_ACTIVA_SMS ( V_NUM_CLIENTE VARCHAR2) AS

V_ID             EBANKING.ACTIVACION_SMS.ID%TYPE;

PSCod_Error      NUMBER;
PSMsg_Error      VARCHAR2(1000);

BEGIN

  SELECT EBANKING.SEQ_ACTIVACION_SMS_ID.nextval INTO V_ID FROM DUAL;
  
  
INSERT
INTO EBANKING.ACTIVACION_SMS  (ID, ID_CLIENTE, FECHA_ACTIVACION, FECHA_MODIFICACION, USUARIO_MODIFICO )
 VALUES (   V_ID,   V_NUM_CLIENTE,   sysdate, sysdate,'NETNET'  );
 COMMIT;
  
  PSCod_Error := 0;
  PSMsg_Error := 'Agrego registro en ADD_ACTIVA_SMS correctamente';

EXCEPTION WHEN OTHERS THEN
  PSCod_Error:=1;
  PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
  RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_ACTIVA_SMS(' || SQLCODE || '  ' || SQLERRM || ')');

END  ADD_ACTIVA_SMS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_AIRTIME_FRECUENT (
V_CLIENT                    IN      EBANKING.CompraTA_TelefonosFrecuentes.CLIENT%TYPE, 
V_CARRIER                   IN      EBANKING.CompraTA_TelefonosFrecuentes.CARRIER%TYPE,
V_TELEPHONE                 IN      EBANKING.CompraTA_TelefonosFrecuentes.TELEPHONE%TYPE,
V_REFERENCE                 IN      EBANKING.CompraTA_TelefonosFrecuentes.REFERENCE%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
BEGIN

   SELECT COUNT (CLIENT) INTO NUMERO
   FROM  EBANKING.CompraTA_TelefonosFrecuentes 
   WHERE CLIENT = V_CLIENT AND STATUS = INACTIVO AND CARRIER = V_CARRIER AND TELEPHONE = V_TELEPHONE;
   
   
   IF NUMERO = 0 THEN
        INSERT INTO EBANKING.CompraTA_TelefonosFrecuentes(CLIENT, CARRIER, TELEPHONE, REFERENCE, ULTIMA_ACTUALIZACION, STATUS, CANAL)
        VALUES(V_CLIENT, V_CARRIER, V_TELEPHONE, V_REFERENCE,SYSDATE,ACTIVO,V_CANAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_AIRTIME_FRECUENTS correctamente';
   ELSE
        UPDATE EBANKING.CompraTA_TelefonosFrecuentes SET REFERENCE = V_REFERENCE,
                                     ULTIMA_ACTUALIZACION = SYSDATE,
                                                   STATUS = ACTIVO,
                                                   CANAL  = V_CANAL
        WHERE CLIENT = V_CLIENT AND CARRIER = V_CARRIER AND STATUS = INACTIVO AND TELEPHONE = V_TELEPHONE;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se actualizo el registro en ADD_AIRTIME_FRECUENTS correctamente';
   END IF;        
   
   
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_AIRTIME_FRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
END ADD_AIRTIME_FRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_CATWS_FUNC (operacion NUMBER, indice NUMBER)
IS

BEGIN
	 IF(operacion = 0)
	 	 THEN
		 	 INSERT INTO EBANKING.PORTAL_CAT PC (PC.ID, PC.STATUS) VALUES (indice, 0);--NO SIRVE WEB SERVICE 
	 END IF;
	 IF(operacion = 1)
	     THEN
		 	 INSERT INTO EBANKING.PORTAL_CAT PC (PC.ID, PC.STATUS) VALUES (indice, 1);--SI SIRVE WEB SERVICE
     END IF;
	 COMMIT;			 		 	 			   
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error en ADD_CATWS (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error en ADD_CATWS ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_CATWS_FUNC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_CLIENTE_EXPRESS( cl_cliente_alnova VARCHAR2,  
cl_cliente_id NUMBER, 
cl_nombre VARCHAR2,
cl_apellido_paterno VARCHAR2, 
cl_apellido_materno VARCHAR2,
cl_fecha_nacimiento DATE)
AS 
BEGIN
	INSERT INTO EBANKING.DINERO_EXPRESS_CLIENTE CLI (CLI.CLIENTE_ALNOVA, CLI.CLIENTE_ID, CLI.NOMBRE,
		   		CLI.APELLIDO_PATERNO, CLI.APELLIDO_MATERNO, CLI.FECHA_NACIMIENTO)
	VALUES (cl_cliente_alnova, cl_cliente_id, cl_nombre, cl_apellido_paterno, cl_apellido_materno,
		   	cl_fecha_nacimiento);
	COMMIT;
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar el cliente (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar el cliente ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_CLIENTE_EXPRESS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_DESCUENTO (des_mtcn VARCHAR2,  
des_descripcion VARCHAR2, 
des_monto NUMBER)
AS 
BEGIN
	INSERT INTO EBANKING.DINERO_EXPRESS_DESCUENTO DES (DES.MTCN, DES.DESCRIPCION, DES.MONTO)
	VALUES (des_mtcn, des_descripcion, des_monto);
	COMMIT;
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar los descuentos (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar los descuentos ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_DESCUENTO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_FIRMA( contrato VARCHAR2,  
cuenta VARCHAR2, 
firma VARCHAR2, 
folio_alnova VARCHAR2)

AS 
BEGIN
	INSERT INTO EBANKING_FIRMA FI (FI.FOLIO_ALNOVA, FI.CUENTA, FI.CONTRATO, FI.FIRMA)
	VALUES (folio_alnova, cuenta, contrato, firma);
	COMMIT;
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar la firma (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar la firma ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_FIRMA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          add_fixfoto (
   pfixname   VARCHAR2,
   pid        NUMBER,
   pidalbum   NUMBER,
   pfixdate   DATE
)
AS
BEGIN
   UPDATE photos
      SET fix_name = pfixname,
          fixfotoupdate = pfixdate
    WHERE ID = pid AND idalbum = pidalbum;
	commit;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      raise_application_error
                       (-20100,
                           'Error ocurrido al actualizar foto en el album  ('
                        || SQLCODE
                        || '  '
                        || SQLERRM
                        || ')'
                       );
   WHEN OTHERS
   THEN
      raise_application_error
                       (-20100,
                           'Error ocurrido al actualizar foto en el album  ('
                        || SQLCODE
                        || '  '
                        || SQLERRM
                        || ')'
                       );
END add_fixfoto;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_FREC_INTER (
V_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
V_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
V_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
V_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
V_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
BEGIN

        SELECT COUNT(1) INTO NUMERO  FROM EBANKING.TRANSFINTERNALFRECUENT
        WHERE CLAVE_SWIFT = V_CLAVE_SWIFT 
          AND CLIENT = V_CLIENT 
          AND DESTINO = V_DESTINO;   
    
     IF NUMERO = 0 THEN
        
        INSERT INTO EBANKING.TRANSFINTERNALFRECUENT(CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, IP_ORIGEN, CLAVE_SWIFT, CANAL)
        VALUES (V_CLIENT, V_DESTINO, V_NAME, ACTIVO, SYSDATE, V_IP_ORIGEN, V_CLAVE_SWIFT, V_CANAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_FREC_INTER correctamente';
        
    ELSE
        UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO, 
                                                     NAME = V_NAME, 
                                                IP_ORIGEN = V_IP_ORIGEN, 
                                                    CANAL = 'NET', 
                                       FECHA_MODIFICACION = SYSDATE
        WHERE CLIENT = V_CLIENT AND DESTINO = V_DESTINO AND CLAVE_SWIFT = V_CLAVE_SWIFT;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_FREC_INTER correctamente';
        
    END IF;

    

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_INTER (' || SQLCODE || '  ' || SQLERRM || ')');
    
END ADD_FREC_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_FREC_INTER_MORAL_PERSON (
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
P_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
P_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
P_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
P_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
P_APELLIDO_PATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_PATERNO%TYPE,
P_APELLIDO_MATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_MATERNO%TYPE,
P_LUGAR_NACIMIENTO      IN      EBANKING.TRANSFINTERNALFRECUENT.LUGAR_NACIMIENTO%TYPE,
P_RAZON_SOCIAL          IN      EBANKING.TRANSFINTERNALFRECUENT.RFC%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
PERSONA NUMBER := 2;
BEGIN

        SELECT COUNT(1) INTO NUMERO  FROM EBANKING.TRANSFINTERNALFRECUENT
        WHERE CLAVE_SWIFT = P_CLAVE_SWIFT 
          AND CLIENT = P_CLIENT 
          AND DESTINO = P_DESTINO
          AND TIPO_PERSONA = PERSONA;   
    
     IF NUMERO = 0 THEN
        
        INSERT INTO EBANKING.TRANSFINTERNALFRECUENT(CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, IP_ORIGEN, CLAVE_SWIFT, CANAL, APELLIDO_PATERNO, APELLIDO_MATERNO, LUGAR_NACIMIENTO, TIPO_PERSONA, RFC )
        VALUES (P_CLIENT, P_DESTINO, P_NAME, ACTIVO, SYSDATE, P_IP_ORIGEN, P_CLAVE_SWIFT, CANAL, P_APELLIDO_PATERNO, P_APELLIDO_MATERNO, P_LUGAR_NACIMIENTO, PERSONA , P_RAZON_SOCIAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_FREC_INTER_MORAL_PERSON correctamente';
        
    ELSE
        UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO, 
                                                     NAME = P_NAME, 
                                                IP_ORIGEN = P_IP_ORIGEN, 
                                                    CANAL = 'NET', 
                                       FECHA_MODIFICACION = SYSDATE,
                                         APELLIDO_PATERNO = P_APELLIDO_PATERNO,
                                         APELLIDO_MATERNO = P_APELLIDO_MATERNO,
                                         LUGAR_NACIMIENTO = P_LUGAR_NACIMIENTO,
                                                      RFC = P_RAZON_SOCIAL
        WHERE CLIENT = P_CLIENT AND DESTINO = P_DESTINO AND CLAVE_SWIFT = P_CLAVE_SWIFT AND TIPO_PERSONA = PERSONA;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_FREC_INTER_MORAL_PERSON correctamente';
        
    END IF;

    

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=-1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_INTER_MORAL_PERSON (' || SQLCODE || '  ' || SQLERRM || ')');
    
END ADD_FREC_INTER_MORAL_PERSON;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_FREC_SERVICE (      
V_USER_ID                   IN      number, 
V_REFERENCIA                IN      varchar2,
SERVICIO                    IN      number,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
V_USUARIOMODIFICO VARCHAR(7):= 'NETNET';
BEGIN

   CASE SERVICIO

        WHEN 17 THEN
                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.EDCULTURALES WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
                IF NUMERO = 0 THEN
                    INSERT INTO EBANKING.EDCULTURALES(USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL) 
                                      VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
                    COMMIT;
                    PSCod_Error := 3;
                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                ELSE
                    UPDATE EBANKING.EDCULTURALES SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
                                      WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA AND STATUS = INACTIVO;
                    PSCod_Error := 2;
                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                END IF;

--        WHEN 5  THEN 
--                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.INTERBUS WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
--                IF NUMERO = 0 THEN
--                    INSERT INTO  EBANKING.INTERBUS(USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL ) 
--                                   VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
--                    COMMIT;
--                    PSCod_Error := 3;
--                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
--                ELSE
--                    UPDATE EBANKING.INTERBUS SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
--                                        WHERE  USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA AND STATUS = INACTIVO;
--                    PSCod_Error := 2;
--                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';  
--                END IF;

--        WHEN 27 THEN
--                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.IUSACELL WHERE USER_ID = V_USER_ID AND CUENTA = V_REFERENCIA;
--                IF NUMERO = 0 THEN
--                    INSERT INTO EBANKING.IUSACELL(USER_ID, CUENTA, ULTIMA_ACTUALIZACION, STATUS, CANAL)
--                                  VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
--                    COMMIT;
--                    PSCod_Error := 3;
--                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
--                ELSE
--                    UPDATE EBANKING.IUSACELL SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
--                                        WHERE USER_ID = V_USER_ID AND CUENTA = V_REFERENCIA AND STATUS = INACTIVO;
--                    PSCod_Error := 2;
--                   PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
--                END IF;
                
        
--        WHEN 8  THEN
--                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.MOVISTAR WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
--                IF NUMERO = 0 THEN
--                    INSERT INTO EBANKING.MOVISTAR(USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL) 
--                                 VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
--                    COMMIT;
--                    PSCod_Error := 3;
--                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
--                ELSE
--                    UPDATE EBANKING.MOVISTAR SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
--                                        WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA AND STATUS = INACTIVO;
--                    PSCod_Error := 2;
--                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
--                END IF;
        
        WHEN 4  THEN
                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.SKYACCOUNTS WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
                IF NUMERO = 0 THEN
                    INSERT INTO EBANKING.SKYACCOUNTS(USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL) 
                    VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
                    COMMIT;
                    PSCod_Error := 3;
                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                ELSE
                    UPDATE EBANKING.SKYACCOUNTS SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
                    WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA AND STATUS = INACTIVO;
                    PSCod_Error := 2;
                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                END IF; 
        
        WHEN 1  THEN
                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.TELMEX WHERE USER_ID = V_USER_ID AND TELEFONO = V_REFERENCIA;
                IF NUMERO = 0 THEN
                    INSERT INTO EBANKING.TELMEX(USER_ID, TELEFONO, ULTIMA_ACTUALIZACION, STATUS, CANAL) 
                    VALUES(V_USER_ID, V_REFERENCIA,SYSDATE,ACTIVO,V_CANAL);
                    COMMIT;
                    PSCod_Error := 3;
                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                ELSE
                    UPDATE EBANKING.TELMEX SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL 
                    WHERE USER_ID = V_USER_ID AND TELEFONO = V_REFERENCIA AND STATUS = INACTIVO;
                    PSCod_Error := 2;
                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                END IF; 
        ELSE 
                SELECT COUNT(STATUS) INTO NUMERO FROM EBANKING.ALL_FRECUENTES WHERE USER_ID = V_USER_ID AND ID_SERVICIO = TO_CHAR(SERVICIO) AND FRECUENTE = V_REFERENCIA;
                IF NUMERO = 0 THEN
                    INSERT INTO EBANKING.ALL_FRECUENTES(USER_ID, FRECUENTE,STATUS,CANAL,ID_SERVICIO,ULTIMA_ACTUALIZACION,USUARIO_MODIFICO)
                                        VALUES(V_USER_ID, V_REFERENCIA,ACTIVO,V_CANAL,TO_CHAR(SERVICIO),SYSDATE,V_USUARIOMODIFICO);
                    COMMIT;
                    PSCod_Error := 3;
                    PSMsg_Error := 'Se inserto el registro en ADD_FREC_PAYMENT_SERVICE correctamente';
                ELSE
                    UPDATE EBANKING.ALL_FRECUENTES SET ULTIMA_ACTUALIZACION= SYSDATE, STATUS = ACTIVO, CANAL=V_CANAL 
                    WHERE USER_ID=V_USER_ID AND ID_SERVICIO=TO_CHAR(SERVICIO) AND FRECUENTE=V_REFERENCIA AND STATUS = INACTIVO;
                    PSCod_Error := 2;
                    PSMsg_Error := 'Se actualizo el registro en ADD_FREC_PAYMENT_SERVICE correctamente';  
                END IF;

    END CASE;

   IF SQL%NOTFOUND THEN
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente ya existe.';
   END IF;
   
   COMMIT;
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=4;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
END ADD_FREC_SERVICE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_FREC_TEFSPEITER(
V_ID_CLIENTE                IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE,
V_ID_TIPOTRANSFERENCIA      IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
V_CUENTA_DESTINO            IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
V_NOMBRE_DESTINO            IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
V_EMAIL_DESTINO             IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
V_TIPO_CUENTA_DESTINO       IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
V_COD_BANCO                 IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
V_IP_ORIGEN                 IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
V_APODO                     IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
V_NUM_CELULAR_DESTINO       IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
V_NUM_TEL_CASA              IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
V_NUM_TEL_OFFNA             IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
V_CARRIER_NAME              IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
V_DESCRIPCION_CUENTA        IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
V_PLAZA                     IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
NUMERO NUMBER;
SPEI NUMBER := 2;
TEF NUMBER := 4;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
BEGIN

    IF V_ID_TIPOTRANSFERENCIA = SPEI or V_ID_TIPOTRANSFERENCIA = TEF THEN
        SELECT COUNT(ID) INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE 
          AND (ID_TIPOTRANSFERENCIA = SPEI OR ID_TIPOTRANSFERENCIA = TEF);   
    ELSE
        SELECT COUNT(ID) INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE
          AND ID_TIPOTRANSFERENCIA = V_ID_TIPOTRANSFERENCIA;
    END IF;
    
     IF NUMERO = 0 THEN
        
        INSERT INTO EBANKING.DESTINOS_TEF_SPEI_TERCEROS 
        (ID, ID_CLIENTE, ID_TIPOTRANSFERENCIA, CUENTA_DESTINO, NOMBRE_DESTINO, EMAIL_DESTINO, TIPO_CUENTA_DESTINO, COD_BANCO, 
        IP_ORIGEN,APODO ,NUM_CELULAR_DESTINO ,NUM_TEL_CASA, NUM_TEL_OFFNA, CARRIER_NAME, DESCRIPCION_CUENTA, PLAZA ,FECHA_MODIFICACION,ULTIMA_ACTUALIZACION,STATUS,CANAL )
        VALUES (EBANKING.SEQ_DESTINOS_TEF_SPEI_TER_ID.NEXTVAL,V_ID_CLIENTE, V_ID_TIPOTRANSFERENCIA, V_CUENTA_DESTINO, V_NOMBRE_DESTINO,V_EMAIL_DESTINO, 
        V_TIPO_CUENTA_DESTINO, V_COD_BANCO,V_IP_ORIGEN,V_APODO ,V_NUM_CELULAR_DESTINO ,V_NUM_TEL_CASA, V_NUM_TEL_OFFNA, V_CARRIER_NAME, V_DESCRIPCION_CUENTA, V_PLAZA,FECHA,FECHA,ACTIVO,V_CANAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_FRECUENTE_TEF_SPEI_TERCEROS correctamente';
        
    ELSE
        UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS SET ULTIMA_ACTUALIZACION = FECHA,
                                                         FECHA_MODIFICACION = FECHA,
                                                                     STATUS = ACTIVO,
                                                             NOMBRE_DESTINO = V_NOMBRE_DESTINO,
                                                             EMAIL_DESTINO = V_EMAIL_DESTINO,
                                                       ID_TIPOTRANSFERENCIA = V_ID_TIPOTRANSFERENCIA,
                                                       TIPO_CUENTA_DESTINO  = V_TIPO_CUENTA_DESTINO,
                                                                  COD_BANCO = V_COD_BANCO,
                                                                  IP_ORIGEN = V_IP_ORIGEN,
                                                                      APODO = V_APODO,
                                                        NUM_CELULAR_DESTINO = V_NUM_CELULAR_DESTINO,
                                                               NUM_TEL_CASA = V_NUM_TEL_CASA,
                                                              NUM_TEL_OFFNA = V_NUM_TEL_OFFNA,
                                                               CARRIER_NAME = V_CARRIER_NAME,
                                                         DESCRIPCION_CUENTA = V_DESCRIPCION_CUENTA,
                                                                      PLAZA = V_PLAZA
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO AND ID_CLIENTE = V_ID_CLIENTE;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_FRECUENTE_TEF_SPEI_TERCEROS correctamente';
        
    END IF;

    

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FRECUENTE_TEF_SPEI_TERCEROS (' || SQLCODE || '  ' || SQLERRM || ')');
    
END ADD_FREC_TEFSPEITER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_FREQ_EXTCRED(
V_CLIENT                IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CLIENTE%TYPE,
V_BANK                  IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BANCO%TYPE,
V_TYPE_CREDIT           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.TIPOCREDITO%TYPE,
V_DESTINO               IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CUENTACREDITO%TYPE,
V_BENEFICIARY           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BENEFICIARIO%TYPE,
V_IP_ORIGEN             IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.IP_ORIGEN%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
V_NUMERO NUMBER;
V_ACTIVATE NUMBER:=1;
V_INACTIVE NUMBER:= 0;
V_CANAL VARCHAR(4):= 'NET';
V_FECHA DATE := SYSDATE;
BEGIN

        SELECT 
            COUNT(1) INTO V_NUMERO
        FROM EBANKING.CREDITOSOTROSBANCOSFRECUENT
        WHERE CLIENTE       = V_CLIENT 
          AND CUENTACREDITO = V_DESTINO
          AND STATUS        = V_INACTIVE
          AND BANCO         = V_BANK;   
    
     IF V_NUMERO = 0 THEN
        
        INSERT INTO EBANKING.CREDITOSOTROSBANCOSFRECUENT(CLIENTE
                                                        , BANCO
                                                        , TIPOCREDITO
                                                        , CUENTACREDITO
                                                        , BENEFICIARIO
                                                        , STATUS
                                                        , FECHA_MODIFICACION
                                                        , IP_ORIGEN
                                                        , CANAL)
                                                VALUES (V_CLIENT
                                                        , V_BANK
                                                        , V_TYPE_CREDIT
                                                        , V_DESTINO
                                                        , V_BENEFICIARY
                                                        , V_ACTIVATE
                                                        , V_FECHA
                                                        , V_IP_ORIGEN
                                                        , V_CANAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_FREQ_EXTCRED correctamente';
        
    ELSE
        UPDATE EBANKING.CREDITOSOTROSBANCOSFRECUENT SET BENEFICIARIO            = V_BENEFICIARY 
                                                        , STATUS                = V_ACTIVATE
                                                        , FECHA_MODIFICACION    = V_FECHA
                                                        , IP_ORIGEN             = V_IP_ORIGEN
                                                        , CANAL                 = V_CANAL
                                                    WHERE CLIENTE               = V_CLIENT 
                                                        AND CUENTACREDITO       = V_DESTINO 
                                                        AND BANCO               = V_BANK
                                                        AND STATUS              = V_INACTIVE;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_FREQ_EXTCRED correctamente';
        
    END IF;

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREQ_EXTCRED (' || SQLCODE || '  ' || SQLERRM || ')');

END ADD_FREQ_EXTCRED;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            ADD_HISTORI_RSA (
V_ID                          OUT    TOKENADMINPRU.HIST_RSA.ID%TYPE,
V_NUM_CLIENTE                 IN     TOKENADMINPRU.HIST_RSA.NUM_CLIENTE%TYPE,
V_NUM_SERIE_TOKEN             IN     TOKENADMINPRU.HIST_RSA.NUM_SERIE_TOKEN%TYPE,
V_TIPO                        IN     TOKENADMINPRU.HIST_RSA.TIPO%TYPE,
V_FECHA_APLICACION            IN     TOKENADMINPRU.HIST_RSA.FECHA_APLICACION%TYPE,
V_IP_SUCURSAL_TERMINAL        IN     TOKENADMINPRU.HIST_RSA.IP_SUCURSAL_TERMINAL%TYPE,
V_OPERADOR                    IN     TOKENADMINPRU.HIST_RSA.OPERADOR%TYPE,
V_SUCURSAL                    IN     TOKENADMINPRU.HIST_RSA.SUCURSAL%TYPE,
V_OPERACION                   IN     TOKENADMINPRU.HIST_RSA.OPERACION%TYPE,
V_SISTEMA                     IN     TOKENADMINPRU.HIST_RSA.SISTEMA%TYPE,
V_IDPAIS                      IN     TOKENADMINPRU.HIST_RSA.IDPAIS%TYPE,
V_ULTIMA_MODIFICACION         IN     TOKENADMINPRU.HIST_RSA.ULTIMA_MODIFICACION%TYPE,
V_USUARIO_MODIFICO            IN     TOKENADMINPRU.HIST_RSA.USUARIO_MODIFICO%TYPE,
PSCod_Error                   OUT    number,
PSMsg_Error                   OUT    varchar2
)
IS

BEGIN

     SELECT TOKENADMINPRU.SEQ_ID_HIST_RSA.nextval
     INTO V_ID   FROM DUAL;

     INSERT INTO TOKENADMINPRU.HIST_RSA(     
            ID, NUM_CLIENTE, NUM_SERIE_TOKEN, TIPO, FECHA_APLICACION, IP_SUCURSAL_TERMINAL, OPERADOR, SUCURSAL, OPERACION, SISTEMA, IDPAIS,
           ULTIMA_MODIFICACION, USUARIO_MODIFICO, ULTIMO_STATUS
     )
     VALUES( 
            V_ID, V_NUM_CLIENTE, V_NUM_SERIE_TOKEN, V_TIPO, SYSDATE, V_IP_SUCURSAL_TERMINAL, V_OPERADOR, V_SUCURSAL, V_OPERACION, V_SISTEMA, V_IDPAIS,
            SYSDATE, V_USUARIO_MODIFICO, SYSDATE
     );
     
    PSCod_Error := 0;
    PSMsg_Error := 'Agrego registro en ADD_HISTORI_RSA correctamente';

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_HISTORI_RSA (' || SQLCODE || '  ' || SQLERRM || ')');

END  ADD_HISTORI_RSA ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                   ADD_HIST_CUENTA_SMS ( 
   V_ID_CLIENTE VARCHAR2,
    V_CUENTA VARCHAR2,
    V_CELULAR VARCHAR2,
    V_STATUS VARCHAR2,
    V_IDCARRIER VARCHAR2
    
    ) AS

V_ID             EBANKING.HIST_CUENTA_SMS.ID%TYPE;

PSCod_Error      NUMBER;
PSMsg_Error      VARCHAR2(1000);

BEGIN

  SELECT EBANKING.SEQ_HIST_CUENTA_SMS_ID.nextval INTO V_ID FROM DUAL;
  
  INSERT
INTO EBANKING.HIST_CUENTA_SMS
  (
    ID,
    ID_CLIENTE,
    NUMERO_CUENTA,
    NUMERO_CELULAR,
    STATUS,
    ID_CARRIER,
    FECHA_MOVIMIENTO,
    USUARIO,
    ULTIMA_MODIFICACION,
    USUARIO_MODIFICO
  )
  VALUES
  (
    V_ID,
    V_ID_CLIENTE,
    V_CUENTA,
    V_CELULAR,
    V_STATUS,
    V_IDCARRIER,
    SYSDATE,
    'NETNET',
    SYSDATE,
    'NETNET'
  );
COMMIT;
  
  PSCod_Error := 0;
  PSMsg_Error := 'Agrego registro en ADD_HIST_CUENTA_SMS correctamente';

EXCEPTION WHEN OTHERS THEN
  PSCod_Error:=1;
  PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
  RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_HIST_CUENTA_SMS(' || SQLCODE || '  ' || SQLERRM || ')');

END  ADD_HIST_CUENTA_SMS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_HIST_LOGIN ( V_NUM_CLIENTE VARCHAR2,V_INSTANCIA VARCHAR2) AS

V_ID             EBANKING.HIST_LOGIN.ID%TYPE;
PSCod_Error      NUMBER;
PSMsg_Error      VARCHAR2(1000);

BEGIN

  SELECT EBANKING.SEQ_HIST_LOGIN.nextval INTO V_ID FROM DUAL;
  
  INSERT INTO EBANKING.HIST_LOGIN( ID, ID_CLIENTE, FECHA_ACCESO,INSTANCIA, USUARIO_MODIFICO, SISTEMA, PAIS)
  VALUES( V_ID, V_NUM_CLIENTE, SYSDATE, V_INSTANCIA, 'NETNET', 'NETNET', 'MX');
  
  PSCod_Error := 0;
  PSMsg_Error := 'Agrego registro en ADD_HIST_LOGIN correctamente';

EXCEPTION WHEN OTHERS THEN
  PSCod_Error:=1;
  PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
  RAISE_APPLICATION_ERROR (-20100, 'Incidencia al insertar HIST_LOGIN_ACCESO(' || SQLCODE || '  ' || SQLERRM || ')');

END  ADD_HIST_LOGIN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_HIST_LOGIN_ACCESO ( V_NUM_CLIENTE VARCHAR2,V_INSTANCIA VARCHAR2,V_PAIS VARCHAR2,V_NAVEGADOR VARCHAR2,V_IP VARCHAR2, V_ALIAS VARCHAR2) AS

V_ID             EBANKING.HIST_LOGIN_ACCESO.ID%TYPE;

PSCod_Error      NUMBER;
PSMsg_Error      VARCHAR2(1000);

BEGIN

  SELECT EBANKING.SEQ_HIST_LOGIN_ID.nextval INTO V_ID FROM DUAL;
  
  
  INSERT INTO EBANKING.HIST_LOGIN_ACCESO( ID, ID_CLIENTE, FECHA_ACCESO,  FECHA_MODIFICACION, USUARIO_MODIFICO, SISTEMA, PAIS,INSTANCIA,IP,NAVEGADOR,ALIAS)
  VALUES( V_ID, V_NUM_CLIENTE, SYSDATE, SYSDATE, 'NETNET', 'NETNET', V_PAIS, V_INSTANCIA,V_IP,V_NAVEGADOR,V_ALIAS);
  
  PSCod_Error := 0;
  PSMsg_Error := 'Agrego registro en ADD_HIST_LOGIN_ACCESO correctamente';

EXCEPTION WHEN OTHERS THEN
  PSCod_Error:=1;
  PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
  ROLLBACK;
  RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar HIST_LOGIN_ACCESO(' || SQLCODE || '  ' || SQLERRM || ')');

END  ADD_HIST_LOGIN_ACCESO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_IMPUESTO (imp_mtcn VARCHAR2,  
imp_descripcion VARCHAR2, 
imp_monto NUMBER)
AS 
BEGIN
	INSERT INTO EBANKING.DINERO_EXPRESS_IMPUESTO IMP (IMP.MTCN, IMP.DESCRIPCION, IMP.MONTO)
	VALUES (imp_mtcn, imp_descripcion, imp_monto);
	COMMIT;
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar los impuestos (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar los impuestos ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_IMPUESTO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_MAIL(
    pSubject varchar2,
	pMail_to varchar2,
	pMail_cc varchar2,
	pMail_bcc varchar2,
	pContenido varchar2
	--pAdjunto EBANKING.EBANKING_MAIL.ADJUNTO%TYPE
  )
  IS
  BEGIN
		INSERT INTO EBANKING_MAIL (SUBJECT, MAIL_TO, MAIL_CC, MAIL_BCC, CONTENIDO)--, ADJUNTO)
		VALUES (pSubject, pMail_to, pMail_cc, pMail_bcc, pContenido);--, pAdjunto);
		COMMIT;
		EXCEPTION
				 WHEN OTHERS THEN
				 ROLLBACK;
				 raise_application_error(-20001, 'NO SE PUDO INSERTAR EL MAIL EN LA BASE DE DATOS - '||SQLCODE||' -ERROR- '||SQLERRM );
  END ADD_MAIL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_MAIL2(
    pSubject varchar2,
	pMail_to varchar2,
	pMail_cc varchar2,
	pMail_bcc varchar2,
	pContenido EBANKING.EBANKING_MAIL.CONTENIDO%TYPE
	--pAdjunto EBANKING.EBANKING_MAIL.ADJUNTO%TYPE
  )
  IS
  BEGIN
		INSERT INTO EBANKING_MAIL (SUBJECT, MAIL_TO, MAIL_CC, MAIL_BCC, CONTENIDO)--, ADJUNTO)
		VALUES (pSubject, pMail_to, pMail_cc, pMail_bcc, pContenido);--, pAdjunto);
		COMMIT;
		EXCEPTION
				 WHEN OTHERS THEN
				 ROLLBACK;
				 raise_application_error(-20001, 'NO SE PUDO INSERTAR EL MAIL EN LA BASE DE DATOS - '||SQLCODE||' -ERROR- '||SQLERRM );
  END ADD_MAIL2;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_MEX_BIT_TRA (
 V_ID_TRANSACCION              OUT    EBANKING.BIT_MEX_TRANS.ID_TRANSACCION%TYPE,                  
 V_NUM_CLIENTE                 IN     EBANKING.BIT_MEX_TRANS.NUM_CLIENTE%TYPE,         
 V_DISPOSITIVO                 IN     EBANKING.BIT_MEX_TRANS.DISPOSITIVO%TYPE,  
 V_RESULTADO_AUTH              IN     EBANKING.BIT_MEX_TRANS.RESULTADO_AUTH%TYPE,  
 V_OPERACION                    IN      EBANKING.BIT_MEX_TRANS.OPERACION%TYPE,
 V_TIEMPO_TARJETAS                IN      EBANKING.BIT_MEX_TRANS.TIEMPO_TARJETAS%TYPE,
 V_TIEMPO_BD                    IN      EBANKING.BIT_MEX_TRANS.TIEMPO_BD%TYPE,
 V_TIEMPO_RSA                    IN      EBANKING.BIT_MEX_TRANS.TIEMPO_RSA%TYPE,
 V_TIEMPO_TOTAL                   IN      EBANKING.BIT_MEX_TRANS.TIEMPO_TOTAL%TYPE,
 V_IP_CLIENTE                  IN     EBANKING.BIT_MEX_TRANS.IP_CLIENTE%TYPE,
 V_IP_INSTANCIA                IN     EBANKING.BIT_MEX_TRANS.IP_INSTANCIA%TYPE,
 V_SISTEMA                     IN     EBANKING.BIT_MEX_TRANS.IP_INSTANCIA%TYPE,
 V_USUARIO_MODIFICO            IN     EBANKING.BIT_MEX_TRANS.USUARIO_MODIFICO%TYPE,      
 PSCod_Error                   OUT    number,
 PSMsg_Error                   OUT    varchar2
)
IS
BEGIN
     SELECT EBANKING.SEQ_ID_MEX_BIT.nextval
     INTO V_ID_TRANSACCION   FROM DUAL;
     INSERT INTO EBANKING.BIT_MEX_TRANS(     
            ID_TRANSACCION, 
            NUM_CLIENTE, 
            DISPOSITIVO, 
            RESULTADO_AUTH,
            OPERACION,
            TIEMPO_TARJETAS,
            TIEMPO_BD,
            TIEMPO_RSA,
            TIEMPO_TOTAL,
            IP_CLIENTE, 
            IP_INSTANCIA, 
            SISTEMA, 
            FECHA_AUTH, 
            USUARIO_MODIFICO, 
            ULTIMA_MODIFICACION
     )VALUES( 
            V_ID_TRANSACCION, 
            V_NUM_CLIENTE, 
            V_DISPOSITIVO, 
            V_RESULTADO_AUTH, 
            V_OPERACION,
            V_TIEMPO_TARJETAS,
            V_TIEMPO_BD,
            V_TIEMPO_RSA,
            V_TIEMPO_TOTAL,
            V_IP_CLIENTE, 
            V_IP_INSTANCIA, 
            V_SISTEMA, 
            SYSDATE, 
            V_USUARIO_MODIFICO, 
            SYSDATE
     );
    COMMIT;
    PSCod_Error := 0;
    PSMsg_Error := 'Agrego registro en ADD_MEX_BIT_TRA correctamente';
EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            V_ID_TRANSACCION:=0;
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_MEX_BIT_TRA (' || SQLCODE || '  ' || SQLERRM || ')');
END  ADD_MEX_BIT_TRA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_MONTOS_PERMITIDO (
  V_NUMCLIENTE                 EBANKING.MONTOS_USER.ID_USER%TYPE,
  V_MONTO_COM                 EBANKING.MONTOS_USER.MONTO_COM%TYPE,
  V_MONTO_MX                 EBANKING.MONTOS_USER.MONTO_MX%TYPE
 )
IS
BEGIN

	 INSERT INTO EBANKING.MONTOS_USER(ID_MONTO_USER, ID_USER,MONTO_COM,MONTO_MX)
	 VALUES (EBANKING.SEQ_MONTOSUSER.nextval, V_NUMCLIENTE, V_MONTO_COM, V_MONTO_MX);
	 COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
		ROLLBACK;
		raise_application_error(-20001,'Ocurrio un error al intentar obtener Montos - '||SQLCODE||' -ERROR- '||SQLERRM);

 END ADD_MONTOS_PERMITIDO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_MORAL_PER(
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
P_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
P_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
P_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
P_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
P_APELLIDO_PATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_PATERNO%TYPE,
P_APELLIDO_MATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_MATERNO%TYPE,
P_LUGAR_NACIMIENTO      IN      EBANKING.TRANSFINTERNALFRECUENT.LUGAR_NACIMIENTO%TYPE,
P_RAZON_SOCIAL          IN      EBANKING.TRANSFINTERNALFRECUENT.RFC%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
PERSONA NUMBER := 2;
BEGIN

        SELECT COUNT(1) INTO NUMERO  FROM EBANKING.TRANSFINTERNALFRECUENT
        WHERE CLAVE_SWIFT = P_CLAVE_SWIFT 
          AND CLIENT = P_CLIENT 
          AND DESTINO = P_DESTINO
          AND TIPO_PERSONA = PERSONA;   
    
     IF NUMERO = 0 THEN
        
        INSERT INTO EBANKING.TRANSFINTERNALFRECUENT(CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, IP_ORIGEN, CLAVE_SWIFT, CANAL, APELLIDO_PATERNO, APELLIDO_MATERNO, LUGAR_NACIMIENTO, TIPO_PERSONA, RFC )
        VALUES (P_CLIENT, P_DESTINO, P_NAME, ACTIVO, SYSDATE, P_IP_ORIGEN, P_CLAVE_SWIFT, CANAL, P_APELLIDO_PATERNO, P_APELLIDO_MATERNO, P_LUGAR_NACIMIENTO, PERSONA , P_RAZON_SOCIAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_MORAL_PER correctamente';
        
    ELSE
        UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO, 
                                                     NAME = P_NAME, 
                                                IP_ORIGEN = P_IP_ORIGEN, 
                                       FECHA_MODIFICACION = SYSDATE,
                                         APELLIDO_PATERNO = P_APELLIDO_PATERNO,
                                         APELLIDO_MATERNO = P_APELLIDO_MATERNO,
                                         LUGAR_NACIMIENTO = P_LUGAR_NACIMIENTO,
                                                      RFC = P_RAZON_SOCIAL,
                                              CLAVE_SWIFT = P_CLAVE_SWIFT,
                                           STATUS_BLOQUEO = 2
        WHERE CLIENT = P_CLIENT AND DESTINO = P_DESTINO AND CLAVE_SWIFT = P_CLAVE_SWIFT AND TIPO_PERSONA = PERSONA;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_MORAL_PER correctamente';
        
    END IF;

    

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=-1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_MORAL_PER (' || SQLCODE || '  ' || SQLERRM || ')');
    
END ADD_MORAL_PER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_MORAL_PERSON (
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
P_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
P_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
P_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
P_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
P_APELLIDO_PATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_PATERNO%TYPE,
P_APELLIDO_MATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_MATERNO%TYPE,
P_LUGAR_NACIMIENTO      IN      EBANKING.TRANSFINTERNALFRECUENT.LUGAR_NACIMIENTO%TYPE,
P_RAZON_SOCIAL          IN      EBANKING.TRANSFINTERNALFRECUENT.RFC%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
PERSONA NUMBER := 2;
BEGIN

        SELECT COUNT(1) INTO NUMERO  FROM EBANKING.TRANSFINTERNALFRECUENT
        WHERE CLAVE_SWIFT = P_CLAVE_SWIFT 
          AND CLIENT = P_CLIENT 
          AND DESTINO = P_DESTINO
          AND TIPO_PERSONA = PERSONA;   
    
     IF NUMERO = 0 THEN
        
        INSERT INTO EBANKING.TRANSFINTERNALFRECUENT(CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, IP_ORIGEN, CLAVE_SWIFT, CANAL, APELLIDO_PATERNO, APELLIDO_MATERNO, LUGAR_NACIMIENTO, TIPO_PERSONA, RFC )
        VALUES (P_CLIENT, P_DESTINO, P_NAME, ACTIVO, SYSDATE, P_IP_ORIGEN, P_CLAVE_SWIFT, CANAL, P_APELLIDO_PATERNO, P_APELLIDO_MATERNO, P_LUGAR_NACIMIENTO, PERSONA , P_RAZON_SOCIAL);
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_FREC_INTER_MORAL_PERSON correctamente';
        
    ELSE
        UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO, 
                                                     NAME = P_NAME, 
                                                IP_ORIGEN = P_IP_ORIGEN, 
                                                    CANAL = 'NET', 
                                       FECHA_MODIFICACION = SYSDATE,
                                         APELLIDO_PATERNO = P_APELLIDO_PATERNO,
                                         APELLIDO_MATERNO = P_APELLIDO_MATERNO,
                                         LUGAR_NACIMIENTO = P_LUGAR_NACIMIENTO,
                                                      RFC = P_RAZON_SOCIAL
        WHERE CLIENT = P_CLIENT AND DESTINO = P_DESTINO AND CLAVE_SWIFT = P_CLAVE_SWIFT AND TIPO_PERSONA = PERSONA;
        COMMIT;
        PSCod_Error := 0;
        PSMsg_Error := 'Se Actualizo registro en ADD_FREC_INTER_MORAL_PERSON correctamente';
        
    END IF;

    

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=-1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_INTER_MORAL_PERSON (' || SQLCODE || '  ' || SQLERRM || ')');
    
END ADD_MORAL_PERSON;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_OPFRECUENT(
V_USUARIO                   IN      EBANKING.OPERACIONES_FREC.USUARIO%TYPE, 
V_CADENA_DATOS              IN      EBANKING.OPERACIONES_FREC.CADENA_DATOS%TYPE,
V_ALIAS                     IN      EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
V_OPERACION                 IN      EBANKING.OPERACIONES_FREC.OPERACION%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
)IS
NUMERO NUMBER;
BEGIN
   SELECT COUNT(USUARIO) INTO NUMERO FROM EBANKING.OPERACIONES_FREC WHERE USUARIO = V_USUARIO;
   
   IF NUMERO <= 0 THEN  
        INSERT INTO EBANKING.OPERACIONES_FREC(ID_OPERACION,USUARIO,CADENA_DATOS,ALIAS,OPERACION,ULTIMA_MODIFICACION,USUARIO_MODIFICO)
					VALUES(EBANKING.SEQUENCE_OPER_FREC.NEXTVAL,V_USUARIO,V_CADENA_DATOS,V_ALIAS,V_OPERACION,SYSDATE,'EBANKING');
        PSCod_Error := 0;
        PSMsg_Error := 'Agrego registro en ADD_AIRTIME_FRECUENTS correctamente';
   ELSE
        PSCod_Error := 1;
        PSMsg_Error := 'Excede el numero de operaciones frecuentes';
   END IF;        
   
   
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_OPFRECUENT (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_OPFRECUENT (' || SQLCODE || '  ' || SQLERRM || ')');
END ADD_OPFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_PAGOMAZ
(
  
   PA_SUCURSAL       IN    EBANKING.TAPAGOMICRONEG.FNSUCURSAL%TYPE  
  ,PA_IMPORTE           IN    EBANKING.TAPAGOMICRONEG.FNIMPORTE%TYPE                     
  ,PA_GRUPO        IN   EBANKING.TAPAGOMICRONEG.FCGRUPO%TYPE
  ,PA_REFERENCIA        IN   EBANKING.TAPAGOMICRONEG.FCREFERENCIA%TYPE
  ,PA_REFEREN_CAJA IN   EBANKING.TAPAGOMICRONEG.FCREFEREN_CAJA%TYPE
  ,PA_USUARIO       IN   EBANKING.TAPAGOMICRONEG.FNUSUARIO%TYPE
  ,PA_TIENDA        IN   EBANKING.TAPAGOMICRONEG.FCTIENDA%TYPE
  ,PA_CAJERO     IN   EBANKING.TAPAGOMICRONEG.FCCAJERO%TYPE
  ,PA_CUENTA_CARGO        IN   EBANKING.TAPAGOMICRONEG.FCCUENTA_CARGO%TYPE
  ,PA_NOM_INTEGRANTE     IN   EBANKING.TAPAGOMICRONEG.FCNOM_INTEGRAN%TYPE
  ,PA_FECHA_PAGO IN   EBANKING.TAPAGOMICRONEG.FDFECHA_PAGO%TYPE
  ,PA_SISTEMA IN   EBANKING.TAPAGOMICRONEG.FCSISTEMA%TYPE
  ,PA_CANAL IN   EBANKING.TAPAGOMICRONEG.CANAL%TYPE
  ,PA_CREDITO IN   EBANKING.TAPAGOMICRONEG.CREDITO%TYPE
  ,PA_NUM_OPER IN   EBANKING.TAPAGOMICRONEG.NUM_OPER%TYPE
  
  ,PA_FECHA_MOD             IN    DATE
  ,PA_USUARIO_MOD      IN    VARCHAR2
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
BEGIN

    INSERT INTO EBANKING.TAPAGOMICRONEG (
       FNSUCURSAL, 
       FNIMPORTE, 
       FCGRUPO, 
       FCREFERENCIA, 
       FCREFEREN_CAJA, 
       FNUSUARIO, 
       FCTIENDA, 
       FCCAJERO,    
       FCCUENTA_CARGO,
       FCNOM_INTEGRAN, 
       FDFECHA_PAGO, 
       FCSISTEMA,
       CANAL,
       CREDITO,
       NUM_OPER,
       FDFECHA_MOD, 
       FCUSUARIO_MOD) 
    VALUES ( 
    PA_SUCURSAL, 
    PA_IMPORTE, 
    PA_GRUPO,
    PA_REFERENCIA, 
    PA_REFEREN_CAJA, 
    PA_USUARIO,
    PA_TIENDA, 
    PA_CAJERO,
    PA_CUENTA_CARGO, 
    PA_NOM_INTEGRANTE, 
    PA_FECHA_PAGO,
    PA_SISTEMA,
    PA_CANAL,
    PA_CREDITO,
    PA_NUM_OPER,
    PA_FECHA_MOD, 
    PA_USUARIO_MOD
    );       
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END ADD_PAGOMAZ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_PAGO_GOB_PDF (
   V_ID_CLIENTE                EBANKING.DATOS_GOBIERNOS_PDF.ID_CLIENTE%TYPE
  ,V_TITULO_PAGO               EBANKING.DATOS_GOBIERNOS_PDF.TITULO_PAGO%TYPE
  ,V_NOMBRE_CLIENTE            EBANKING.DATOS_GOBIERNOS_PDF.NOMBRE_CLIENTE%TYPE
  ,V_DIRECCION                 EBANKING.DATOS_GOBIERNOS_PDF.DIRECCION%TYPE
  ,V_COLONIA                   EBANKING.DATOS_GOBIERNOS_PDF.COLONIA%TYPE
  ,V_CODIGO_POSTAL             EBANKING.DATOS_GOBIERNOS_PDF.CODIGO_POSTAL%TYPE
  ,V_MUNICIPIO                 EBANKING.DATOS_GOBIERNOS_PDF.MUNICIPIO%TYPE
  ,V_ESTADO                    EBANKING.DATOS_GOBIERNOS_PDF.ESTADO%TYPE
  ,V_CONCEPTO                  EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO%TYPE
  ,V_CONCEPTO1                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO1%TYPE
  ,V_CONCEPTO2                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO2%TYPE
  ,V_CONCEPTO3                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO3%TYPE
  ,V_BANCO                     EBANKING.DATOS_GOBIERNOS_PDF.BANCO%TYPE
  ,V_NUM_AUTORIZACION          EBANKING.DATOS_GOBIERNOS_PDF.NUM_AUTORIZACION%TYPE
  ,V_FECHA_PAGO                EBANKING.DATOS_GOBIERNOS_PDF.FECHA_PAGO%TYPE
  ,V_LINEA_CAPTURA             EBANKING.DATOS_GOBIERNOS_PDF.LINEA_CAPTURA%TYPE
  ,V_CERT_DIGITAL              EBANKING.DATOS_GOBIERNOS_PDF.CERT_DIGITAL%TYPE
  ,V_TOTAL                     EBANKING.DATOS_GOBIERNOS_PDF.TOTAL%TYPE
  ,V_ID_SERVICIO               EBANKING.DATOS_GOBIERNOS_PDF.ID_SERVICIO%TYPE
  ,V_CONCEPTO4                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO4%TYPE
  ,V_CONCEPTO5                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO5%TYPE
  ,V_CONCEPTO6                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO6%TYPE
  ,V_CONCEPTO7                 EBANKING.DATOS_GOBIERNOS_PDF.CONCEPTO7%TYPE
  ,V_RFC                       EBANKING.DATOS_GOBIERNOS_PDF.RFC%TYPE
  ,V_CUENTACARGO               EBANKING.DATOS_GOBIERNOS_PDF.CUENTACARGO%TYPE
  ,V_IVACOMISION                  EBANKING.DATOS_GOBIERNOS_PDF.IVACOMISION%TYPE
  ,V_IVA                       EBANKING.DATOS_GOBIERNOS_PDF.IVA%TYPE
  ,V_IMPORTE                   EBANKING.DATOS_GOBIERNOS_PDF.IMPORTE%TYPE
)
IS
BEGIN
  INSERT INTO EBANKING.DATOS_GOBIERNOS_PDF(ID_CLIENTE,TITULO_PAGO,NOMBRE_CLIENTE,DIRECCION,COLONIA,CODIGO_POSTAL,MUNICIPIO,ESTADO,CONCEPTO,CONCEPTO1,CONCEPTO2,CONCEPTO3,BANCO,NUM_AUTORIZACION,FECHA_PAGO,LINEA_CAPTURA,CERT_DIGITAL,TOTAL,ID_SERVICIO,CONCEPTO4,CONCEPTO5,CONCEPTO6,CONCEPTO7,RFC,CUENTACARGO,IVACOMISION,IVA,IMPORTE)
            VALUES(V_ID_CLIENTE,V_TITULO_PAGO,V_NOMBRE_CLIENTE,V_DIRECCION,V_COLONIA,V_CODIGO_POSTAL,V_MUNICIPIO,V_ESTADO,V_CONCEPTO,V_CONCEPTO1,V_CONCEPTO2,V_CONCEPTO3,V_BANCO,V_NUM_AUTORIZACION,V_FECHA_PAGO,V_LINEA_CAPTURA,V_CERT_DIGITAL,V_TOTAL,V_ID_SERVICIO,V_CONCEPTO4,V_CONCEPTO5,V_CONCEPTO6,V_CONCEPTO7,V_RFC,V_CUENTACARGO,V_IVACOMISION,V_IVA,V_IMPORTE);
commit;
  EXCEPTION
    WHEN OTHERS THEN
ROLLBACK;
          raise_application_error(-20001,'Ocurrio un error al intentar agregar los datos del PDF de pago a gobiernos - '||SQLCODE||' -ERROR- '||SQLERRM);
END ADD_PAGO_GOB_PDF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_PAGO_IMSS_PDF (
   V_LINEA_CAPTURA                  IN EBANKING.DATOS_IMSS_PDF.LINEA_CAPTURA%TYPE
  ,V_NUM_AUTORIZACION               IN EBANKING.DATOS_IMSS_PDF.NUM_AUTORIZACION%TYPE
  ,V_OPCION                         IN EBANKING.DATOS_IMSS_PDF.OPCION%TYPE
  ,V_FOLIOSUA                       IN EBANKING.DATOS_IMSS_PDF.FOLIOSUA%TYPE
  ,V_PERIODOPAGO                    IN EBANKING.DATOS_IMSS_PDF.PERIODOPAGO%TYPE
  ,V_IMPORTETOTAL                   IN EBANKING.DATOS_IMSS_PDF.IMPORTETOTAL%TYPE
  ,V_IMPORTERCV                     IN EBANKING.DATOS_IMSS_PDF.IMPORTERCV%TYPE
  ,V_IMPORTEIMSS                    IN EBANKING.DATOS_IMSS_PDF.IMPORTEIMSS%TYPE         
  ,V_IMPORTEINFONAVIT               IN EBANKING.DATOS_IMSS_PDF.IMPORTEINFONAVIT%TYPE    
  ,V_IMPORTESEGUROSIMSS             IN EBANKING.DATOS_IMSS_PDF.IMPORTESEGUROSIMSS%TYPE
  ,V_IMPORTEACTUALIZACIONIMSS       IN EBANKING.DATOS_IMSS_PDF.IMPORTEACTUALIZACIONIMSS%TYPE
  ,V_IMPORTERECARGOSIMSS            IN EBANKING.DATOS_IMSS_PDF.IMPORTERECARGOSIMSS%TYPE
  ,V_IMPORTERETIROCESAFORE          IN EBANKING.DATOS_IMSS_PDF.IMPORTERETIROCESAFORE%TYPE
  ,V_IMPORTEACTUALIZACIONAFORE      IN EBANKING.DATOS_IMSS_PDF.IMPORTEACTUALIZACIONAFORE%TYPE
  ,V_IMPORTERECARGOSAFORE           IN EBANKING.DATOS_IMSS_PDF.IMPORTERECARGOSAFORE%TYPE
  ,V_IMPORTEAPORTACIONVOLAFORE      IN EBANKING.DATOS_IMSS_PDF.IMPORTEAPORTACIONVOLAFORE%TYPE
  ,V_IMPORTEAPORTACIONCOMAFORE      IN EBANKING.DATOS_IMSS_PDF.IMPORTEAPORTACIONCOMAFORE%TYPE
  ,V_IMPORTECUENTAINDINFONAVIT      IN EBANKING.DATOS_IMSS_PDF.IMPORTECUENTAINDINFONAVIT%TYPE   
  ,V_IMPORTEAMORTIZACIONINFONAVIT   IN EBANKING.DATOS_IMSS_PDF.IMPORTEAMORTIZACIONINFONAVIT%TYPE
  ,V_IMPORTEAPORPATRONALINFONAVIT   IN EBANKING.DATOS_IMSS_PDF.IMPORTEAPORPATRONALINFONAVIT%TYPE
  ,V_IMPORTEACTUALZAINFONAVIT       IN EBANKING.DATOS_IMSS_PDF.IMPORTEACTUALIZACIONINFONAVIT%TYPE
  ,V_IMPORTERECARGOSINFONAVIT       IN EBANKING.DATOS_IMSS_PDF.IMPORTERECARGOSINFONAVIT%TYPE
  ,V_IMPORTEMULTASINFONAVIT         IN EBANKING.DATOS_IMSS_PDF.IMPORTEMULTASINFONAVIT%TYPE
  ,V_IMPORTEFUNDEMEXINFONAVIT       IN EBANKING.DATOS_IMSS_PDF.IMPORTEFUNDEMEXINFONAVIT%TYPE      
  ,V_VERSIONSUA                     IN EBANKING.DATOS_IMSS_PDF.VERSIONSUA%TYPE 
  ,V_FECHA_CARGO                    IN EBANKING.DATOS_IMSS_PDF.FECHA_CARGO%TYPE 
  ,V_FECHA_PAGO                     IN EBANKING.DATOS_IMSS_PDF.FECHA_PAGO%TYPE
  ,V_NUM_TRABAJADORES               IN EBANKING.DATOS_IMSS_PDF.NUM_TRABAJADORES%TYPE 
  ,V_RAZONSOCIAL                    IN EBANKING.DATOS_IMSS_PDF.RAZONSOCIAL%TYPE
  ,V_DOMICILIO                      IN EBANKING.DATOS_IMSS_PDF.DOMICILIO%TYPE
  ,V_RFCPATRONAL                    IN EBANKING.DATOS_IMSS_PDF.RFCPATRONAL%TYPE  
  ,V_IMPORTEACV                     IN EBANKING.DATOS_IMSS_PDF.IMPORTEACV%TYPE 
  ,V_IMPORTEVIVIENDA                IN EBANKING.DATOS_IMSS_PDF.IMPORTEVIVIENDA%TYPE 
  ,V_FECHA_VENCIMIENTO              IN VARCHAR2
  ,V_ORIGENARCHIVO                  IN EBANKING.DATOS_IMSS_PDF.ORIGENARCHIVO%TYPE 
  ,V_REGPATRONAL                    IN EBANKING.DATOS_IMSS_PDF.REGPATRONAL%TYPE
  ,V_ID_CLIENTE                     IN EBANKING.DATOS_IMSS_PDF.ID_CLIENTE%TYPE
  ,V_CUENTACARGO                    IN EBANKING.DATOS_IMSS_PDF.CUENTACARGO%TYPE
  ,V_SELLO_DIGITAL                  IN EBANKING.DATOS_IMSS_PDF.SELLO_DIGITAL%TYPE
  ,V_COMISION                       IN EBANKING.DATOS_IMSS_PDF.COMISION%TYPE
  ,V_SISTEMA                        IN EBANKING.DATOS_IMSS_PDF.SISTEMA%TYPE
  ,V_RESULTADO                      OUT NUMBER
  ,V_MENSAJE                        OUT VARCHAR2
)
IS
BEGIN
  INSERT INTO EBANKING.DATOS_IMSS_PDF(LINEA_CAPTURA
                                     ,NUM_AUTORIZACION
                                     ,OPCION
                                     ,FOLIOSUA
                                     ,PERIODOPAGO
                                     ,IMPORTETOTAL
                                     ,IMPORTERCV
                                     ,IMPORTEIMSS
                                     ,IMPORTEACV
                                     ,IMPORTEVIVIENDA
                                     ,IMPORTEINFONAVIT
                                     ,IMPORTESEGUROSIMSS
                                     ,IMPORTEACTUALIZACIONIMSS
                                     ,IMPORTERECARGOSIMSS
                                     ,IMPORTERETIROCESAFORE
                                     ,IMPORTEACTUALIZACIONAFORE
                                     ,IMPORTERECARGOSAFORE
                                     ,IMPORTEAPORTACIONVOLAFORE
                                     ,IMPORTEAPORTACIONCOMAFORE
                                     ,IMPORTECUENTAINDINFONAVIT
                                     ,IMPORTEAPORPATRONALINFONAVIT
                                     ,IMPORTEAMORTIZACIONINFONAVIT
                                     ,IMPORTEACTUALIZACIONINFONAVIT
                                     ,IMPORTERECARGOSINFONAVIT
                                     ,IMPORTEMULTASINFONAVIT
                                     ,IMPORTEFUNDEMEXINFONAVIT
                                     ,ORIGENARCHIVO
                                     ,REGPATRONAL
                                     ,VERSIONSUA
                                     ,FECHA_VENCIMIENTO
                                     ,FECHA_CARGO
                                     ,FECHA_PAGO
                                     ,NUM_TRABAJADORES
                                     ,RAZONSOCIAL
                                     ,DOMICILIO
                                     ,RFCPATRONAL
                                     ,ID_CLIENTE
                                     ,CUENTACARGO
                                     ,SELLO_DIGITAL
                                     ,COMISION
                                     ,ULTIMA_MODIFICACION
                                     ,USUARIO_MODIFICO
                                     ,SISTEMA
                                     ,PAIS)
                               VALUES(V_LINEA_CAPTURA                  
                                     ,V_NUM_AUTORIZACION               
                                     ,V_OPCION   
                                     ,V_FOLIOSUA                       
                                     ,V_PERIODOPAGO                    
                                     ,V_IMPORTETOTAL                   
                                     ,V_IMPORTERCV                     
                                     ,V_IMPORTEIMSS                         
                                     ,NVL(V_IMPORTEACV,0)                      
                                     ,NVL(V_IMPORTEVIVIENDA,0)                
                                     ,NVL(V_IMPORTEINFONAVIT,0)               
                                     ,NVL(V_IMPORTESEGUROSIMSS,0)             
                                     ,NVL(V_IMPORTEACTUALIZACIONIMSS,0)       
                                     ,NVL(V_IMPORTERECARGOSIMSS,0)            
                                     ,NVL(V_IMPORTERETIROCESAFORE,0)          
                                     ,NVL(V_IMPORTEACTUALIZACIONAFORE,0)      
                                     ,NVL(V_IMPORTERECARGOSAFORE,0)           
                                     ,NVL(V_IMPORTEAPORTACIONVOLAFORE,0)      
                                     ,NVL(V_IMPORTEAPORTACIONCOMAFORE,0)      
                                     ,NVL(V_IMPORTECUENTAINDINFONAVIT,0)       
                                     ,NVL(V_IMPORTEAPORPATRONALINFONAVIT,0)   
                                     ,NVL(V_IMPORTEAMORTIZACIONINFONAVIT,0)   
                                     ,NVL(V_IMPORTEACTUALZAINFONAVIT,0) 
                                     ,NVL(V_IMPORTERECARGOSINFONAVIT,0)       
                                     ,NVL(V_IMPORTEMULTASINFONAVIT,0)         
                                     ,NVL(V_IMPORTEFUNDEMEXINFONAVIT,0)         
                                     ,NVL(V_ORIGENARCHIVO,0)                  
                                     ,NVL(V_REGPATRONAL,' ')                    
                                     ,NVL(V_VERSIONSUA,' ')                     
                                     ,TO_DATE(V_FECHA_VENCIMIENTO,'YYYYMMDD')
                                     ,NVL(V_FECHA_CARGO,SYSDATE)
                                     ,NVL(V_FECHA_PAGO,SYSDATE)                                                                                                                             
                                     ,NVL(V_NUM_TRABAJADORES,0)               
                                     ,NVL(V_RAZONSOCIAL,' ')                    
                                     ,NVL(V_DOMICILIO,' ')                      
                                     ,NVL(V_RFCPATRONAL,' ')
                                     ,V_ID_CLIENTE
                                     ,V_CUENTACARGO 
                                     ,V_SELLO_DIGITAL
                                     ,V_COMISION
                                     ,SYSDATE
                                     ,'NETNET'
                                     ,V_SISTEMA
                                     ,'MX');
 
     V_RESULTADO := 1;
     V_MENSAJE := 'Se inserto la información del IMSS';	
     COMMIT;
  EXCEPTION
     WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        V_RESULTADO := 1;
        V_MENSAJE := 'La información ya se encuentra registrada correctamente';
     WHEN OTHERS THEN
        ROLLBACK;
        V_RESULTADO  := 0;	
        V_MENSAJE :='Ocurrio un error al intentar agregar los datos del PDF - '|| SQLCODE||' -ERROR- '||SQLERRM;
END ADD_PAGO_IMSS_PDF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_PAGO_SERV_PDF (
  V_REFERENCIA                 EBANKING.DATOS_SERVICIO_PDF.REFERENCIA%TYPE,
  V_NUMERO_OPERACION           EBANKING.DATOS_SERVICIO_PDF.NUMERO_OPERACION%TYPE,
  V_FECHA_APLICACION           EBANKING.DATOS_SERVICIO_PDF.FECHA_APLICACION%TYPE,
  V_FECHA_PAGO                 EBANKING.DATOS_SERVICIO_PDF.FECHA_PAGO%TYPE,
  V_ID_SERVICIO                EBANKING.DATOS_SERVICIO_PDF.ID_SERVICIO%TYPE,
  V_CUENTA_CARGO               EBANKING.DATOS_SERVICIO_PDF.CUENTA_CARGO%TYPE,
  V_IMPORTE                    EBANKING.DATOS_SERVICIO_PDF.IMPORTE%TYPE,
  V_COMISION                   EBANKING.DATOS_SERVICIO_PDF.COMISION%TYPE,
  V_IVA                        EBANKING.DATOS_SERVICIO_PDF.IVA%TYPE,
  V_TOTAL                      EBANKING.DATOS_SERVICIO_PDF.TOTAL%TYPE,
  V_SELLO_DIGITAL              EBANKING.DATOS_SERVICIO_PDF.SELLO_DIGITAL%TYPE,
  V_NOMBRE_COMPLETO            EBANKING.DATOS_SERVICIO_PDF.NOMBRE_COMPLETO%TYPE,
  V_ACTIVIDAD                  EBANKING.DATOS_SERVICIO_PDF.ACTIVIDAD%TYPE,
  V_NUMERO_CLIENTE             EBANKING.DATOS_SERVICIO_PDF.NUMERO_CLIENTE%TYPE,
  V_ADICIONAL                  EBANKING.DATOS_SERVICIO_PDF.ADICIONAL%TYPE
)
IS
BEGIN
  INSERT INTO EBANKING.DATOS_SERVICIO_PDF(REFERENCIA, NUMERO_OPERACION, FECHA_APLICACION, FECHA_PAGO, ID_SERVICIO, CUENTA_CARGO, IMPORTE, COMISION, IVA, TOTAL, SELLO_DIGITAL, NOMBRE_COMPLETO, ACTIVIDAD, NUMERO_CLIENTE, ADICIONAL)
            VALUES(V_REFERENCIA, V_NUMERO_OPERACION, SYSDATE, SYSDATE, V_ID_SERVICIO, V_CUENTA_CARGO, V_IMPORTE, V_COMISION, V_IVA, V_TOTAL, V_SELLO_DIGITAL, V_NOMBRE_COMPLETO, V_ACTIVIDAD, V_NUMERO_CLIENTE, V_ADICIONAL);
   COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
          raise_application_error(-20001,'Ocurrio un error al intentar agerndar los datos del PDF de servios - '||SQLCODE||' -ERROR- '||SQLERRM);
END ADD_PAGO_SERV_PDF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE add_postit (
   pidalbum      NUMBER,
   pidfoto       NUMBER,
   pcomentario   VARCHAR2,
   px            FLOAT,
   py            FLOAT,
   puser         VARCHAR2
)
AS
   idpostit   NUMBER;
BEGIN
   SELECT photos_seq.NEXTVAL
     INTO idpostit
     FROM DUAL;

   INSERT INTO postit
               (ID, idalbum, idfoto, comentario, x, y, usuario
               )
        VALUES (idpostit, pidalbum, pidfoto, pcomentario, px, py, puser
               );
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END add_postit;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_RFC (
  V_NUMCLIENTE                 EBANKING.EBANKING_RFC.USER_ID%TYPE,
  V_MONTO_COM                 EBANKING.EBANKING_RFC.RFC%TYPE
  )
IS
BEGIN

	 INSERT INTO EBANKING.EBANKING_RFC RF (RF.ID_EBANKING_RFC,RF.USER_ID ,RF.RFC)
	 VALUES (EBANKING.SEQ_EBANKING_RFC.nextval, V_NUMCLIENTE,V_MONTO_COM);
	 COMMIT;

  EXCEPTION
    WHEN OTHERS THEN
		ROLLBACK;
		raise_application_error(-20001,'Ocurrio un error al INSERTAR NUEVO RFC - '||SQLCODE||' -ERROR- '||SQLERRM);

 END ADD_RFC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_SMS_TKN_ACR (
 V_ID_SMS                         OUT    EBANKING.TOKEN_ENV_SMS.ID_SMS%TYPE,      
 V_ID_ALNOVA                   IN      EBANKING.TOKEN_ENV_SMS.ID_ALNOVA%TYPE,
 V_NUM_CEL                        IN     EBANKING.TOKEN_ENV_SMS.NUM_CEL%TYPE,         
 V_CARRIER                        IN     EBANKING.TOKEN_ENV_SMS.CARRIER%TYPE,  
 V_STATUS                         IN     EBANKING.TOKEN_ENV_SMS.STATUS%TYPE,   
 V_TIEMPO_ENVIO                IN     varchar2,
 V_USUARIO_MODIFICO            IN     EBANKING.TOKEN_ENV_SMS.USUARIO_MODIFICO%TYPE,      
 PSCod_Error                   OUT    number,
 PSMsg_Error                   OUT    varchar2
)
IS
BEGIN
     SELECT EBANKING.SEQ_ID_ENV_SMS.nextval
     INTO V_ID_SMS FROM DUAL;
     INSERT INTO EBANKING.TOKEN_ENV_SMS(     
            ID_SMS, 
            ID_ALNOVA, 
            NUM_CEL, 
            CARRIER, 
            STATUS, 
            TIEMPO_ENVIO, 
            ULTIMA_MODIFICACION, 
            USUARIO_MODIFICO
     )VALUES( 
            V_ID_SMS, 
            V_ID_ALNOVA, 
            V_NUM_CEL, 
            V_CARRIER, 
            V_STATUS, 
            TO_DATE(V_TIEMPO_ENVIO,'YYYY-MM-DD HH24:MI:SS'), 
            SYSDATE, 
            V_USUARIO_MODIFICO
     );
    COMMIT;
    PSCod_Error := 0;
    PSMsg_Error := 'Agrego registro en ADD_SMS_TKN_ACR correctamente';
EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_SMS_TKN_ACR (' || SQLCODE || '  ' || SQLERRM || ')');
END  ADD_SMS_TKN_ACR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          ADD_TDCFRECUENT (
V_CLIENT                    IN      EBANKING.TDCFRECUENT.CLIENT%TYPE,
V_DESTINO                   IN      EBANKING.TDCFRECUENT.DESTINO%TYPE,
V_IP_ORIGEN                 IN      EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
V_ALIAS                     IN      EBANKING.TDCFRECUENT.ALIAS%TYPE,
V_CARD_NUMBER               IN      varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
V_PREFIJO VARCHAR2(8);
V_BANCO   VARCHAR2(30);
V_NOMBRE  VARCHAR2(100);
V_CLASE   VARCHAR2(15);
NUM       NUMBER;
FLAG      BOOLEAN := FALSE;
CONSULTA  SYS_REFCURSOR;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
TARJETA VARCHAR(30):= 'TARJETA CREDITO AZTECA';
BEGIN
    OPEN CONSULTA FOR
            SELECT PREFIJO, BANCO, NOMBRE INTO V_PREFIJO, V_BANCO, V_NOMBRE  FROM EBANKING.EBANKING_BINES
            WHERE PREFIJO LIKE SUBSTR(V_CARD_NUMBER, 0, 6)||'%' ORDER BY PREFIJO DESC;
        LOOP
            FETCH CONSULTA INTO V_PREFIJO, V_BANCO, V_NOMBRE;
            IF CONSULTA%FOUND THEN
                IF V_PREFIJO  = SUBSTR(V_CARD_NUMBER, 0,LENGTH(V_PREFIJO)) THEN
                    FLAG:=TRUE;
                    EXIT WHEN FLAG;
                END IF;
            ELSE
                EXIT;
            END IF;
        END LOOP;
    
    IF FLAG THEN
    
        SELECT COUNT(DESTINO) INTO NUM FROM EBANKING.TDCFRECUENT
        WHERE (CLIENT=V_CLIENT AND NOMBRE<>TARJETA AND status=ACTIVO) and DESTINO = V_DESTINO;    
        
        IF NUM = 0 THEN
            DELETE EBANKING.TDCFRECUENT WHERE DESTINO = V_DESTINO and CLIENT = V_CLIENT and STATUS = INACTIVO;
            COMMIT;
            INSERT INTO EBANKING.TDCFRECUENT(CLIENT, DESTINO, BANCO, NOMBRE, STATUS, FECHA_MODIFICACION, IP_ORIGEN, ALIAS, CANAL)
            VALUES (V_CLIENT, V_DESTINO, V_BANCO, V_NOMBRE, ACTIVO, sysdate, V_IP_ORIGEN, V_ALIAS, V_CANAL);
            COMMIT;
            PSCod_Error := 0;
            PSMsg_Error := 'Se inserto el registro en ADD_FREC_ANOTHER_BANK correctamente';
        ELSE
            PSCod_Error := 2;
            PSMsg_Error := 'La frecuente ya existe en  ADD_FREC_ANOTHER_BANK ';
            
        END IF;
        
    ELSE
        PSCod_Error := 4;
        PSMsg_Error := 'La tarjeta es Invalida ';
    
    END IF;
    


   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
END ADD_TDCFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ADD_TRANSFERENCIAS (tr_cliente_id NUMBER,  
tr_mtcn VARCHAR2, 
tr_monto_enviado NUMBER, 
tr_beneficiario_id NUMBER,
tr_tarifa NUMBER,
tr_num_cuenta VARCHAR2)
AS 
BEGIN
	INSERT INTO EBANKING.DINERO_EXPRESS_TRANSFERENCIA TRAN (TRAN.CLIENTE_ID, TRAN.MTCN, TRAN.MONTO_ENVIADO,
		   		TRAN.BENEFICIARIO_ID, TRAN.TARIFA, TRAN.NUM_CUENTA)
	VALUES (tr_cliente_id, tr_mtcn, tr_monto_enviado, tr_beneficiario_id, tr_tarifa, tr_num_cuenta);
	COMMIT;
EXCEPTION

WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar la transferencia (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar la transferencia ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END ADD_TRANSFERENCIAS;
/

SHOW ERRORS;


CREATE OR REPLACE procedure consulta
(
P_USUARIO in ebanking.usuario.usuario %type,
S_CURSOR OUT EBANKING.TYPES.REFCURSOR
)
as
begin
OPEN S_CURSOR FOR SELECT NOMBRE,USUARIO,CONTRASENA,TELEFONO FROM EBANKING.USUARIO
    WHERE LTRIM(RTRIM(USUARIO))= LTRIM(RTRIM(P_USUARIO));
commit;
end;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          CREA_VISTA_VWOPERMONTO (fechaInicio IN VARCHAR2 ,fechaFinal IN VARCHAR2) IS 
BEGIN 
IF(fechaInicio IS NULL )THEN
    RAISE_APPLICATION_ERROR (-20120, 'La Fecha Inicial es Obligatoria');
  END IF;
  
  IF(fechaFinal IS NULL )THEN
    RAISE_APPLICATION_ERROR (-20121, 'La Fecha Final es Obligatoria');
  END IF;

  IF(TO_DATE(fechaInicio,'dd/MM/yyyy') > TO_DATE(fechaFinal,'dd/MM/yyyy') )THEN
    RAISE_APPLICATION_ERROR (-20122, 'La Fecha Inicial no Puede Ser Mayor a la Final');
  END IF;
  
 EXECUTE IMMEDIATE 
'CREATE OR REPLACE VIEW EBANKING.VWOPERMONTO (usralnova,'||
                                     'aplicacion,'||
                                    'nombrecompleto,'||
                                    'operacion,'||
                                    'monto,'||
                                    'fecha_operacion'||
                                   ') '||
'AS '||
   'SELECT u.usralnova, u.aplicacion, u.nombrecompleto, op.operacion, '||
          'td.valor AS monto, op.fecha_operacion '||
     'FROM ebanking.m_usuarios u, '||
          'ebanking.m_usuarios_operaciones op, '||
          'ebanking.m_tracking t, '||
          'ebanking.m_tracking_detalle td '||
    'WHERE u.idusuario = op.idusuario '||
      'AND t.id_usuario_operacion = op.id_usuario_operacion '||
      'AND td.idtracking = t.idtracking '||
      'AND td.id_tracking_detalle '||
             'BETWEEN (SELECT MIN (id_tracking_detalle) '||
                        'FROM ebanking.m_tracking_detalle '||
                       'WHERE (campo = ''importe'' OR campo = ''monto'') '||
                         'AND fecha_operacion BETWEEN TO_DATE (SYSDATE - 7, '||
                                                             ' ''dd/MM/yyyy'' '||
                                                             ') '||
                                                 'AND TO_DATE (SYSDATE, '||
                                                             ' ''dd/MM/yyyy''  '||
                                                             ')) '||
                 'AND (SELECT MAX (id_tracking_detalle) '||
                        'FROM ebanking.m_tracking_detalle '||
                       'WHERE (campo = ''importe'' OR campo = ''monto'') '||
                         'AND fecha_operacion BETWEEN TO_DATE (SYSDATE - 7, '||
                                                             ' ''dd/MM/yyyy'' '||
                                                             ') '||
                                                 'AND TO_DATE (SYSDATE, '||
                                                              ' ''dd/MM/yyyy'' '||
                                                             ')) '||
      'AND (td.campo = ''importe'' OR td.campo = ''monto'') '||
      'AND op.operacion != ''login''  '||
   'and op.fecha_operacion between TO_DATE('''||fechaInicio||''',''dd/MM/yyyy'') and TO_DATE( '''||fechaFinal||''',''dd/MM/yyyy'')+1 '; 

 EXECUTE IMMEDIATE 
 'GRANT SELECT ON EBANKING.VWOPERMONTO TO USRINWAPEDES'; 
  
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE deleteFoto(pid number, pidalbum number) AS
BEGIN
   DELETE FROM PHOTOS WHERE ID = pid AND IDALBUM = pidalbum;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END deleteFoto;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE deleteInteresado(idinteresado number) AS
BEGIN
   DELETE INTERESADOS WHERE ID=idinteresado;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END deleteInteresado;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_AIRTIME_FREC (
V_CLIENT                    IN      EBANKING.CompraTA_TelefonosFrecuentes.CLIENT%TYPE, 
V_CARRIER                   IN      EBANKING.CompraTA_TelefonosFrecuentes.CARRIER%TYPE,
V_TELEPHONE                 IN      EBANKING.CompraTA_TelefonosFrecuentes.TELEPHONE%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
BEGIN

   UPDATE EBANKING.CompraTA_TelefonosFrecuentes SET ULTIMA_ACTUALIZACION = SYSDATE,
                                                         STATUS = INACTIVO,
                                                          CANAL = V_CANAL
                      WHERE CLIENT = V_CLIENT AND CARRIER = V_CARRIER AND TELEPHONE = V_TELEPHONE;
   
   IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se Actualizo el registro en DELETE_AIRTIME_FRECUENTS correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;                          
   COMMIT; 
   
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar DELETE_AIRTIME_FRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_AIRTIME_FREC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_FRCTEFSPEITER (
V_ID_CLIENTE                IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE,
V_ID_TIPOTRANSFERENCIA      IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
V_CUENTA_DESTINO            IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
NUMERO NUMBER;
SPEI   NUMBER :=2;
TEF    NUMBER :=4;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;

BEGIN

    IF V_ID_TIPOTRANSFERENCIA = SPEI or V_ID_TIPOTRANSFERENCIA = TEF THEN
        SELECT ID INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE 
          AND (ID_TIPOTRANSFERENCIA = SPEI OR ID_TIPOTRANSFERENCIA = TEF);   
    ELSE
        SELECT ID INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE
          AND ID_TIPOTRANSFERENCIA = V_ID_TIPOTRANSFERENCIA;
    END IF;
    
    
    UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS SET STATUS = INACTIVO, 
                            ULTIMA_ACTUALIZACION = FECHA,
                              FECHA_MODIFICACION = FECHA,
                                           CANAL = V_CANAL 
                                        WHERE ID = NUMERO;

   IF SQL%FOUND THEN
      PSCod_Error := 0;
    PSMsg_Error := 'Se elimino registro en DELETE_FREC_TEF_SPEI_TERCERO correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;    
      
   EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DELETE_FREC_TEF_SPEI_TERCERO (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_FRCTEFSPEITER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_FREC_INTER(
V_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
V_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
V_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
V_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
V_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
INACTIVO NUMBER:=0;
ACTIVO NUMBER:=1;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;

BEGIN
    
    UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = INACTIVO,
                                                CANAL = V_CANAL, 
                                   FECHA_MODIFICACION = FECHA
    WHERE CLIENT = V_CLIENT AND DESTINO = V_DESTINO AND CLAVE_SWIFT = V_CLAVE_SWIFT AND NAME = V_NAME AND STATUS = ACTIVO AND TIPO_PERSONA = 1;

   IF SQL%FOUND THEN
      PSCod_Error := 0;
    PSMsg_Error := 'Se elimino registro en DELETE_FREC_INTER correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;    
      
   EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DELETE_FREC_INTER (' || SQLCODE || '  ' || SQLERRM || ')');

END DELETE_FREC_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_FREC_SERVICE (      
V_USER_ID                   IN      number, 
V_REFERENCIA                IN      varchar2,
V_ID_SERVICIO               IN      number,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS

INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';

BEGIN

   CASE V_ID_SERVICIO

        WHEN 17 THEN
                    UPDATE EBANKING.EDCULTURALES SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
                                      WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;

--        WHEN 5  THEN 
--                    UPDATE EBANKING.INTERBUS SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
--                                        WHERE  USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;

--        WHEN 27 THEN
--                    UPDATE EBANKING.IUSACELL SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL 
--                                        WHERE USER_ID = V_USER_ID AND CUENTA = V_REFERENCIA;
        
--        WHEN 8  THEN
--                    UPDATE EBANKING.MOVISTAR SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
--                                        WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
        
        WHEN 4  THEN
                    UPDATE EBANKING.SKYACCOUNTS SET ULTIMA_ACTUALIZACION= SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
                    WHERE USER_ID = V_USER_ID AND REFERENCIA = V_REFERENCIA;
       WHEN -500  THEN
                    UPDATE EBANKING.IUPIFRECUENT SET FECHA_MODIFICACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
                    WHERE ID_CLIENTE = V_USER_ID AND CUENTA_DESTINO = V_REFERENCIA;            
        
        WHEN 1  THEN
                    UPDATE EBANKING.TELMEX SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = INACTIVO, CANAL = V_CANAL
                    WHERE USER_ID = V_USER_ID AND TELEFONO = V_REFERENCIA;
        ELSE 
                    UPDATE EBANKING.ALL_FRECUENTES SET ULTIMA_ACTUALIZACION= SYSDATE, STATUS = INACTIVO, CANAL=V_CANAL
                    WHERE USER_ID=V_USER_ID AND ID_SERVICIO=TO_CHAR(V_ID_SERVICIO) AND FRECUENTE=V_REFERENCIA;

    END CASE;

    IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se elimino el registro en DELETE_FREC_PAYMENT_SERVICE correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   COMMIT;   
   
   EXCEPTION

     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DELETE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_FREC_SERVICE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_FREC_TDC (
V_CLIENT                    IN      EBANKING.TDCFRECUENT.CLIENT%TYPE,
V_DESTINO                   IN      EBANKING.TDCFRECUENT.DESTINO%TYPE,
V_IP_ORIGEN                 IN      EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
INACTIVO NUMBER:=0;
BEGIN
   
   UPDATE EBANKING.TDCFRECUENT SET STATUS=INACTIVO, IP_ORIGEN = V_IP_ORIGEN WHERE CLIENT = V_CLIENT AND DESTINO =V_DESTINO;
    
    IF (SQL%NOTFOUND) THEN
            PSCod_Error:=1;
            PSMsg_Error:='La frecuente a eliminar no existe';
    ELSE
            PSCod_Error:=0;
            PSMsg_Error:= 'La Frecuente se elimino correctamente';        
    END IF;
    
    COMMIT;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar DELETE_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar DELETE_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_FREC_TDC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_FREQ_EXTCRED(
V_CLIENT                IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CLIENTE%TYPE,
V_BANK                  IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BANCO%TYPE,
V_TYPE_CREDIT           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.TIPOCREDITO%TYPE,
V_DESTINO               IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CUENTACREDITO%TYPE,
V_IP_ORIGEN             IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.IP_ORIGEN%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
V_INACTIVE NUMBER:= 0;
V_CANAL VARCHAR(4):= 'NET';
V_FECHA DATE := SYSDATE;
BEGIN
    UPDATE EBANKING.CREDITOSOTROSBANCOSFRECUENT SET STATUS                      = V_INACTIVE    
                                                        , FECHA_MODIFICACION    = V_FECHA
                                                        , IP_ORIGEN             = V_IP_ORIGEN
                                                        , CANAL                 = V_CANAL
                                                    WHERE CLIENTE               = V_CLIENT 
                                                        AND CUENTACREDITO       = V_DESTINO
                                                        AND TIPOCREDITO         = V_TYPE_CREDIT 
                                                        AND BANCO               = V_BANK;
    COMMIT;
    PSCod_Error := 0;
    PSMsg_Error := 'Se Elimino registro en DELETE_FREQ_EXTCRED correctamente';
    EXCEPTION
    WHEN OTHERS THEN
        PSCod_Error:=2;
        PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;

            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar DELETE_FREQ_EXTCRED (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_FREQ_EXTCRED;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELETE_OPFRECUENTS(
V_ID_OPERACION              IN      EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
)IS
NUMERO NUMBER;
BEGIN
      DELETE FROM EBANKING.OPERACIONES_FREC WHERE ID_OPERACION =V_ID_OPERACION;
   
   
   IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se elimino el registro en DELETE_OPFRECUENTS correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;        
   
   
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DELETE_OPFRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DELETE_OPFRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
END DELETE_OPFRECUENTS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DELTOKENHIST IS
BEGIN
     DELETE FROM EBANKING.TOKEN_HIST WHERE TO_DATE( ULTIMA_MODIFICACION, 'DD/MM/YYYY' ) <= TO_DATE( (SYSDATE-3), 'DD/MM/YYYY'  );
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'No se eliminaron los registros de la tabla - '||SQLCODE||' -ERROR- '||SQLERRM);
END DELTOKENHIST;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DEL_MORAL_PER (
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
P_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
INACTIVO NUMBER:=0;
ACTIVO NUMBER:=1;
P_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;
PERSONA NUMBER := 2;
BEGIN

     UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = INACTIVO,
                                                 CANAL = P_CANAL, 
                                        STATUS_BLOQUEO = 2,
                                    FECHA_MODIFICACION = FECHA
    WHERE CLIENT = P_CLIENT AND CLAVE_SWIFT = P_CLAVE_SWIFT AND STATUS = ACTIVO AND TIPO_PERSONA = PERSONA;   
    
        IF SQL%FOUND THEN
          PSCod_Error := 0;
        PSMsg_Error := 'Se elimino registro en DEL_MORAL_PER correctamente';
       ELSE
          PSCod_Error := -1;
          PSMsg_Error := 'El frecuente no existe.';
       END IF;
   
   COMMIT;    
      
   EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=-2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al eliminar DEL_MORAL_PER (' || SQLCODE || '  ' || SQLERRM || ')');

END DEL_MORAL_PER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          DESBLOQUEA_TARJETA( numTarjeta  EBANKING_LOGIN_TA_HIS.NUM_TARJETA%TYPE )
AS
BEGIN
 UPDATE ebanking.EBANKING_LOGIN_TA_HIS SET ATTEMPTS=0 WHERE NUM_TARJETA = numTarjeta;
 COMMIT;
EXCEPTION
 WHEN OTHERS THEN
   ROLLBACK;
   RAISE_APPLICATION_ERROR (-20100, 'Error al desbloquear la tarjeta ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END DESBLOQUEA_TARJETA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE ELIMINACOLUMNAS IS
tmpVar NUMBER;
/******************************************************************************
   NAME:       ELIMINACOLUMNAS
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        10/08/2006          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     ELIMINACOLUMNAS
      Sysdate:         10/08/2006
      Date and Time:   10/08/2006, 05:36:19 p.m., and 10/08/2006 05:36:19 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/

CURSOR CUENTASREP IS
  SELECT ID_CLIENTE,
  		 COD_BANCO,
		 CUENTA_DESTINO,
		 Count(*)
  FROM DESTINOS_TEF_SPEI_TERCEROS
  GROUP BY ID_CLIENTE,
  		   COD_BANCO,
  		   CUENTA_DESTINO
  HAVING Count(*) > 1;
BEGIN
	 FOR registro IN  CUENTASREP LOOP
		 DELETE FROM DESTINOS_TEF_SPEI_TERCEROS SD
		 WHERE SD.ID_CLIENTE = registro.ID_CLIENTE
		 AND SD.COD_BANCO = registro.COD_BANCO
		 AND SD.CUENTA_DESTINO = registro.CUENTA_DESTINO
		 AND SD.ID_TIPOTRANSFERENCIA = 2;
	 END LOOP;
END ELIMINACOLUMNAS;
/

SHOW ERRORS;


CREATE OR REPLACE procedure eliminar
(
p_id_usuario in ebanking.usuario.id_usuario %type
)
as
begin
delete from usuario where id_usuario = p_id_usuario;
commit;
end;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FALTAN_DEX(idBeneficiarioDex IN number, 
                                 aliasBeneficiario IN varchar2, 
                                 cte_Dex IN number, usuarioModifico IN varchar2, 
                                 nombreCompleto IN varchar2,
                                 tipoBeneficiario IN number, activoSt IN number)
AS existBenef NUMBER;
  PSCod_Error NUMBER := 0;
  PSMsg_Error VARCHAR2( 1000 );

BEGIN

	IF (tipoBeneficiario = 1) THEN
		SELECT COUNT(CTEDEX) INTO existBenef FROM EBANKING.BENEFI_DEX 
    WHERE CTEDEX = cte_Dex AND tip_benefi = tipoBeneficiario 
    AND UPPER(ALIAS_BENEFICIARIO) = UPPER(aliasBeneficiario) AND estatus = activoSt;
	END IF;
  IF (existBenef = 0) THEN
    INSERT INTO EBANKING.BENEFI_DEX(ID_BENEFICIARIO_DEX, ALIAS_BENEFICIARIO, CTEDEX, FECHAACTIVACION, ULTIMA_MODIFICACION, USUARIO_MODIFICO, NOMBRE_COMPLETO, TIP_BENEFI, ESTATUS) 
    VALUES( idBeneficiarioDex, aliasBeneficiario, cte_Dex, SYSDATE, SYSDATE, usuarioModifico, nombreCompleto, tipoBeneficiario, activoSt);
    COMMIT;
    PSCod_Error := 0;
    PSMsg_Error := 'Se agrego el registro de Persona en BENEFI_DEX correctamente';
  END IF;

EXCEPTION

  WHEN OTHERS THEN
    PSCod_Error:=1;
    PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
    ROLLBACK;
    raise_application_error(-20001, 'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);

END FALTAN_DEX;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE FIAR_ACTUALIZA_CLIENTES AS 
BEGIN
  
  UPDATE EBANKING.FIAR_CLIENTES
    SET EBANKING.FECHA_INGRESO=DATE('14/12/10','dd/mm/yy'),
        EBANKING.MODULO_FIAR=1
  WHERE EBANKING.CTE_ALNOVA IN ('1895751',	'1205854',	'3426051',	'1356454',	'3426094',	'3426100',	'1212370',	'3426159',	'3426166',	'3426255',	
'3426285',	'3426348',	'3426498',	'3426595',	'3426612',	'3426631',	'3426645',	'1392010',	'3426748',	'1353240',	
'3426887',	'3426889',	'3426901',	'3426905',	'3426918',	'3427021',	'3427106',	'3845755',	'3886913',	'3886931',	
'3887251',	'3887319',	'3887348',	'3887378',	'3887409',	'3887410',	'4412128',	'4612928',	'4999811',	'5086608',	
'5146861',	'16453914',	'5358071',	'5691758',	'5778903',	'6016365',	'6132926',	'5038260',	'6411370',	'6247368',	
'9368805',	'9422219',	'10431757',	'11357851',	'23446410',	'5766002',	'3593924',	'3670891',	'3671785',	'11666192',	
'11544645',	'3521620',	'4021389',	'4021415',	'3671704',	'3671804',	'3905482',	'5522222',	'3838155',	'4021410',	
'9291194',	'5513697',	'11062396',	'5657161',	'3219194',	'3425855',	'3218938',	'5357909',	'3426463',	'3426922',	
'3427004',	'3218874',	'4678100',	'6420936',	'6426441',	'8488015',	'8744441',	'9155916',	'9342724',	'9498412',	
'10063974',	'10072904',	'10087555',	'10296013',	'10511083',	'10831593',	'15872713',	'3556302',	'3556308',	'3556313',	
'3556464',	'3556465',	'3556467',	'3556470',	'3556475',	'3556482',	'3556484',	'3556485',	'3556486',	'3556487',	
'3556488',	'3556511',	'3556578',	'3556600',	'3556622',	'3556630',	'3556638',	'4923703',	'3556645',	'3556702',	
'3556717',	'3556734',	'3556763',	'3556797',	'3556896',	'3556912',	'3556921',	'3556934',	'3045585',	'3557023',	
'3557130',	'3557131',	'1140043',	'3557172',	'3557180',	'3557243',	'3557292',	'3557303',	'3557328',	'3557335',	
'3557367',	'3557447',	'3557449',	'3557595',	'3557610',	'3557618',	'3557753',	'3557769',	'3557935',	'3557969',	
'3558039',	'3558043',	'3558144',	'3558268',	'3558373',	'3558398',	'3558495',	'3558526',	'3558606',	'3558796',	
'3558832',	'4122998',	'3559118',	'3695691',	'3695696',	'3696171',	'3696199',	'3696758',	'3696781',	'3696833',	
'3739317',	'4689194',	'4998136',	'5478782',	'5977200',	'6051285',	'3218818',	'3218825',	'3218831',	'3218832',	
'4225903',	'3218842',	'3218844',	'3218853',	'3218856',	'3218857',	'3218861',	'3218881',	'3218886',	'1760386',	
'1359599',	'3218903',	'3218927',	'3218929',	'3218974',	'2701546',	'2760322',	'3219007',	'3219008',	'3219010',	
'2220208',	'3219027',	'3219037',	'3219061',	'3219079',	'3219080',	'3219090',	'3219096',	'3219124',	'3219127',	
'3219155',	'5139348',	'3219165',	'3219171',	'3219175',	'3219177',	'1416830',	'3219180',	'3219181',	'4764824',	
'3219188',	'3668655',	'3425817',	'3425848',	'3425863',	'3426072',	'3887376',	'20266383',	'21225022',	'18804379',	
'3427010',	'23873519',	'3558595',	'16632210',	'16850447',	'16951093',	'17026330',	'14153247',	'3219044',	'3219064',	
'9135949',	'21566451',	'23059959',	'3427016',	'9414616',	'9388701',	'8630529',	'6152168',	'5990145',	'5982080',	
'5618109',	'4916436',	'4827753',	'3557502',	'3558232',	'3558625',	'9365629',	'3986593',	'3557184',	'6474358',	
'3426288',	'9519394',	'3557638',	'3426736',	'20137388',	'4395324',	'4039656',	'22859915',	'13956362',	'3887392',	
'17425071',	'3887364',	'3887350',	'3887062',	'17020387',	'3696284',	'24545313',	'3671174',	'3671122',	'3670929',	
'3426157',	'3427136',	'3427051',	'3426878',	'3426864',	'3426819',	'3426671',	'3426666',	'3426507',	'3426464',	
'3426456',	'3426441',	'3426430',	'3426280',	'3695712',	'16752664',	'22348255',	'4265567',	'3556999',	'3558717',	
'3426124',	'3426071',	'3426000',	'3425847',	'3425783',	'3219185',	'3219172',	'3219170',	'3219160',	'3219119',	
'3219109',	'3219107',	'3219033',	'3219030',	'3219015',	'3218966',	'3218964',	'3218956',	'3218944',	'3218930',	
'3218925',	'3218913',	'3218909',	'3218865',	'3218864',	'2846544',	'14267003',	'3557104',	'3426767',	'3556637',	
'3219198',	'3218819',	'3556605',	'10147304',	'3559195',	'3558376',	'3426449',	'4691758',	'2524101',	'2357667',	
'4449586',	'3219168',	'3558439',	'3556937',	'3218823',	'16826832',	'3558845',	'26401282',	'6513922',	'3558515',	
'3219017',	'3218982',	'3556468',	'3557193',	'3556501',	'3558811',	'16886066',	'16945345',	'3557102',	'3695683',	
'3558780',	'3695705',	'3557349',	'3556509',	'23486205',	'3426738',	'3219126',	'1524559',	'3218989',	'3426541',	
'3219035',	'29986261',	'28333350',	'22415234',	'21373768',	'21235473',	'20622601',	'20239453',	'20126261',	'14729309',	
'14171238',	'14048202',	'13984488',	'13774917',	'13717495',	'11839476',	'11508746',	'11354492',	'10701517',	'10609730',	
'10439712',	'10080751',	'9882158',	'9619031')
  
END FIAR_ACTUALIZA_CLIENTES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FNADDCUFREC(paFcId_Alnova     IN EBANKING.CU_FRECUENTES.ID_ALNOVA%TYPE
                                                ,paFcCliente_Unico IN EBANKING.CU_FRECUENTES.CLIENTE_UNICO%TYPE 
                                                ,paFcAlias         IN EBANKING.CU_FRECUENTES.ALIAS%TYPE 
                                                ,paFcNombre        IN EBANKING.CU_FRECUENTES.NOMBRE%TYPE
                                                ,paFnStatus        IN EBANKING.CU_FRECUENTES.STATUS%TYPE
                                                ,paFcSistema       IN EBANKING.CU_FRECUENTES.SISTEMA%TYPE
                                                ,paFcPais          IN EBANKING.CU_FRECUENTES.PAIS%TYPE
                                                ,paFcUsuario_modi  IN EBANKING.CU_FRECUENTES.USUARIO_MODIFICO%TYPE
                                                ,fnPsCod OUT NUMBER
                                                ,fcPsMsg OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para actualizar una frecuente
   Parametros de entrada:  pcFcId_Alnova     - Identificador del cliente alnova
                           paFcCliente_Unico - Identifiador del cliente unico 
                           paFcAlias         - Alias del cliente
                           paFcNombre        - Nombre del cliente
                           paFnStatus        - Estatus de la frecuente del cliente
                           paFcSistema       - Sistema
                           paFcPais          - Pais
                           paFcUsuario_modi  - Usuario que modifica
   Parametros de salida:   fnPsCod           - Codigo de retorno del procedimiento
                           fcPsMsg           - Mensaje de retoro del procedimiento
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  16/04/2013
****************************************************************************/   
   BEGIN
   FCPSMSG := 'OPERACION EXITOSA';
   FNPSCOD := 0;
      INSERT INTO EBANKING.CU_FRECUENTES (ID
                                         ,ID_ALNOVA
                                         ,CLIENTE_UNICO
                                         ,ALIAS
                                         ,NOMBRE
                                         ,FECHA_MODIFICACION
                                         ,ULTIMA_MODIFICACION
                                         ,STATUS
                                         ,SISTEMA
                                         ,PAIS
                                         ,USUARIO_MODIFICO)
                                  VALUES (EBANKING.SEQ_CU_FREC.NEXTVAL
                                         ,paFcId_Alnova
                                         ,paFcCliente_Unico
                                         ,paFcAlias
                                         ,paFcNombre
                                         ,SYSDATE
                                         ,SYSDATE
                                         ,paFnStatus 
                                         ,paFcSistema
                                         ,paFcPais
                                         ,paFcUsuario_modi);
      COMMIT;       
EXCEPTION
  WHEN OTHERS THEN
      ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EN LA TABLA DE FRECUENTES CREDIMAX';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al actualizar la tabla de frecuentes de credimax ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END FNADDCUFREC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FNUPDATE_CUFREC(paFcId_Alnova     IN EBANKING.CU_FRECUENTES.ID_ALNOVA%TYPE
                                                    ,paFcCliente_Unico IN EBANKING.CU_FRECUENTES.CLIENTE_UNICO%TYPE 
                                                    ,paFcAlias         IN EBANKING.CU_FRECUENTES.ALIAS%TYPE 
                                                    ,paFcNombre        IN EBANKING.CU_FRECUENTES.NOMBRE%TYPE
                                                    ,paFnStatus        IN EBANKING.CU_FRECUENTES.STATUS%TYPE
                                                    ,paFcSistema       IN EBANKING.CU_FRECUENTES.SISTEMA%TYPE
                                                    ,paFcPais          IN EBANKING.CU_FRECUENTES.PAIS%TYPE
                                                    ,paFcUsuario_modi  IN EBANKING.CU_FRECUENTES.USUARIO_MODIFICO%TYPE
                                                    ,fnPsCod OUT NUMBER
                                                    ,fcPsMsg OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para actualizar una frecuente
   Parametros de entrada:  pcFcId_Alnova     - Identificador del cliente alnova
                           paFcCliente_Unico - Identifiador del cliente unico 
                           paFcAlias         - Alias del cliente
                           paFcNombre        - Nombre del cliente
                           paFnStatus        - Estatus de la frecuente del cliente
                           paFcSistema       - Sistema
                           paFcPais          - Pais
                           paFcUsuario_modi  - Usuario que modifica
   Parametros de salida:   fnPsCod           - Codigo de retorno del procedimiento
                           fcPsMsg           - Mensaje de retoro del procedimiento
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  16/04/2013
****************************************************************************/
   CSLCERO NUMBER := 0;
   BEGIN
   FCPSMSG := 'OPERACION EXITOSA';
   FNPSCOD := 0;
      UPDATE EBANKING.CU_FRECUENTES
            SET ALIAS              = NVL(paFcAlias,ALIAS)
            ,NOMBRE                = NVL(paFcNombre,NOMBRE)
            ,ULTIMA_MODIFICACION   = SYSDATE
            ,STATUS                = NVL(paFnStatus,STATUS)
            ,SISTEMA               = NVL(paFcSistema,SISTEMA)
            ,PAIS                  = NVL(paFcPais,PAIS)
            ,USUARIO_MODIFICO      = NVL(paFcUsuario_modi,USUARIO_MODIFICO)
       WHERE ID > CSLCERO
         AND CLIENTE_UNICO         = paFcCliente_Unico
         AND ID_ALNOVA             = paFcId_Alnova
   RETURNING ID
        INTO fnPsCod;     
        COMMIT;    
        IF fnPsCod = CSLCERO THEN
          FCPSMSG := 'NO EXISTE REGISTRO A ACTUALIZAR.';
        END IF;
EXCEPTION
  WHEN OTHERS THEN
      ROLLBACK;
      FCPSMSG := 'ERROR AL ACTUALIZAR EN LA TABLA DE FRECUENTES CREDIMAX';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al actualizar la tabla de frecuentes de credimax ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END FNUPDATE_CUFREC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_BSQUSUARIO
/*************************************************************
Proyecto: Monitoreo de retenciones
Descripción: Sp Busqueda de usuarios de eBanking
Parámetros de entrada: 
    - opcion (Tipo de busqueda)
    - nocliente (numero de cliente)
    - nombreusuario (nombre de usuario buscado)
    - appaterno (apellido paterno de usuario buscado)
    - apmaterno (apellido materno de usuario buscado)
    - nocuenta (numero de cuenta buscada)
    - notarjeta (numero de tarjeta buscada)
Parámetros de salida: 
    -RESULTADO (resultado de la consulta para utilización en el sistema de monitoreo)
Valor de retorno: No aplica
Parámetros de entrada-salida: No aplica
Precondiciones: No aplica
Creador: Erick Ochoa C.
Fecha de creación: Agosto 2014
*************************************************************/
( 
           opcion           IN  VARCHAR
           ,nocliente       IN  NUMBER 
           ,nombreusuario   IN  VARCHAR2
           ,appaterno       IN  VARCHAR2
           ,apmaterno       IN  VARCHAR2 
           ,nocuenta        IN  VARCHAR2
           ,notarjeta       IN  VARCHAR2 
          ,PSCod_Error      OUT NUMBER
          ,PSMsg_Error      OUT VARCHAR2 
          ,RESULTADO        OUT SYS_REFCURSOR
) 
 
AS 

VAR_NOMBRE VARCHAR2(50) :='';
VAR_APPAT VARCHAR2(50) :='';
VAR_APMAT VARCHAR2(50) :='';
NOMBRECOMPLETO1 varchar2(50) := '';
NOMBRECOMPLETO2 varchar2(50) := '';

FICERO  NUMBER := 0;    -- NUMERO 0
FIUNO   NUMBER := 1;    -- NUMERO 1
FCNULO  VARCHAR(4):= 'NULO';
FCESP   VARCHAR(1):= ' ';



BEGIN
  
VAR_NOMBRE := NVL(nombreusuario,FCNULO);
VAR_APPAT := NVL(appaterno,FCNULO);
VAR_APMAT := NVL(apmaterno,FCNULO);


    IF opcion = 'bsqXId' -- Busqueda por ID de cliente 
    THEN
        OPEN RESULTADO FOR
            /* 
            SELECT ALIAS
                   ,CLIENTE
                   ,EMAIL
                   ,CUENTAOTARJ
                   ,QUESTION
                   ,ANSWER
                   ,CEL_PHONE
                   ,COMPANY
                   ,OFFICE_PHONE
                   ,STATUS
                   ,ACTIVACION
                   ,CODE
                   ,CUENTA
                   ,IP
                   ,TARJETA
                   ,TIPO
                   ,MONITOR
                   ,COMENTARIO
                   ,INTENTOS_LOCALIZAR
                   ,NAME
                   ,TIPOPROD
                   ,FIRSTINTENTO
                   ,LASTINTENTO
                   ,CONFIRMACION
            */
            SELECT CLIENTE
                   ,NAME
              FROM EBANKING.EBANKING_ACTIVATION 
             WHERE CLIENTE = nocliente;
         
        PSCod_Error := FICERO;
        PSMsg_Error := 'buscar usuario OK CLIENTE[' || nocliente || ']';

    END IF;
    
    IF opcion = 'bsqXNombre' -- Busqueda por nombre
    THEN

        IF VAR_APPAT != FCNULO and VAR_APMAT != FCNULO -- Existen ambos apellidos
        THEN 
            NOMBRECOMPLETO1 := NOMBRECOMPLETO1 || nombreusuario || FCESP || appaterno || FCESP || apmaterno;
            NOMBRECOMPLETO2 := NOMBRECOMPLETO2 || appaterno || FCESP || apmaterno || FCESP || nombreusuario;
            
            OPEN RESULTADO FOR 
                SELECT CLIENTE
                       ,NAME
                  FROM EBANKING.EBANKING_ACTIVATION 
                 WHERE ltrim(rtrim(replace(replace(replace(NAME,' ',' @@') ,'@@ ','') ,' @@',' ') )) LIKE  '%' || NOMBRECOMPLETO1 || '%' 
                    OR ltrim(rtrim(replace(replace(replace(NAME,' ',' @@') ,'@@ ','') ,' @@',' ') )) LIKE  '%' || NOMBRECOMPLETO2 || '%' ;
        END IF;
        
        IF  VAR_APMAT = FCNULO and VAR_APPAT != FCNULO --   Existe solo Apellido paterno
        THEN
            NOMBRECOMPLETO1 := NOMBRECOMPLETO1 || nombreusuario || FCESP || appaterno ;
            NOMBRECOMPLETO2 := NOMBRECOMPLETO2 || appaterno || FCESP || nombreusuario;
            
            OPEN RESULTADO FOR 
                SELECT CLIENTE
                       ,NAME 
                  FROM EBANKING.EBANKING_ACTIVATION 
                 WHERE ltrim(rtrim(replace(replace(replace(NAME,' ',' @@') ,'@@ ','') ,' @@',' ') )) LIKE  '%' || NOMBRECOMPLETO1 || '%' 
                    OR ltrim(rtrim(replace(replace(replace(NAME,' ',' @@') ,'@@ ','') ,' @@',' ') )) LIKE  '%' || NOMBRECOMPLETO2 || '%' ;
        END IF;

    
        IF  VAR_APMAT = FCNULO and VAR_APPAT = FCNULO -- Existe solo nombre 
        THEN
            NOMBRECOMPLETO1 := nombreusuario;

            OPEN RESULTADO FOR 
                SELECT CLIENTE
                       ,NAME 
                  FROM EBANKING.EBANKING_ACTIVATION 
                 WHERE ltrim(rtrim(replace(replace(replace(NAME,' ',' @@') ,'@@ ','') ,' @@',' ') )) LIKE  '%' || NOMBRECOMPLETO1 || '%'; 
        END IF;
        
        PSCod_Error := FICERO;
        PSMsg_Error := 'buscar usuario OK NOMBRECOMPLETO1[' || NOMBRECOMPLETO1 || '] NOMBRECOMPLETO2[' || NOMBRECOMPLETO2 || ']';

    end if;
    
    IF opcion = 'bsqXCtaTar' -- Busquea por cuenta / tarjeta
    THEN

        OPEN RESULTADO FOR 
            /* 
            SELECT ALIAS
                   ,CLIENTE
                   ,EMAIL
                   ,CUENTAOTARJ
                   ,QUESTION
                   ,ANSWER
                   ,CEL_PHONE
                   ,COMPANY
                   ,OFFICE_PHONE
                   ,STATUS
                   ,ACTIVACION
                   ,CODE
                   ,CUENTA
                   ,IP
                   ,TARJETA
                   ,TIPO
                   ,MONITOR
                   ,COMENTARIO
                   ,INTENTOS_LOCALIZAR
                   ,NAME
                   ,TIPOPROD
                   ,FIRSTINTENTO
                   ,LASTINTENTO
                   ,CONFIRMACION
            */
            SELECT CLIENTE
                   ,NAME
              FROM EBANKING.EBANKING_ACTIVATION
             WHERE CUENTA = nocuenta 
                OR TARJETA = notarjeta;
         
        PSCod_Error := FICERO;
        PSMsg_Error := 'buscar usuario OK CUENTA/TARJ[' || nocuenta || '] o [' || notarjeta || ']';

    END IF;


    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=FIUNO;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar usuario  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END FRA_BSQUSUARIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_CONSULTBLKS
( 
           opcion IN VARCHAR

          , usuarioid  IN  VARCHAR2
          , notarjeta IN  VARCHAR2 

          , blkFallidos OUT     NUMBER
          , blkMaxfallidos OUT     NUMBER
          , blkPrevfraudes OUT     NUMBER
          , blkInactividad OUT     NUMBER
          , blkMaxFallcexpress OUT     NUMBER
          , blkPorrecpassword OUT     NUMBER
          
           
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          
          -- para ejemplo devolviendo consulta para un datatable 
          /*
          ,xxxxxxxx  IN  NUMBER 
          ,RESULTADO OUT SYS_REFCURSOR
          */
) 


 
AS 
var_prueba varchar(1) :='';
v_existe varchar2(1) := 'N';

BEGIN
    
    --if opcion = 'consBloqueos' then
    
    
        begin
            -- 1.- Bloqueo intentos fallidos diarios (3) 
            SELECT ATTEMPTS into blkFallidos FROM EBANKING.EBANKING_LOGIN WHERE USER_ID = usuarioid AND ATTEMPTS > 2;
            -- blkFallidos := 100;  
            exception
            when TOO_MANY_ROWS then blkFallidos := 0;
            when NO_DATA_FOUND then blkFallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;
       
       
        begin  
            -- 2.- bloqueo por mÃ¡ximos de intentos fallidos (10) 
            SELECT ATTEMPTS into blkMaxfallidos FROM EBANKING.EBANKING_LOGIN WHERE USER_ID = usuarioid AND ATTEMPTS > 9;
            -- blkMaxfallidos := 200;
            exception
            when TOO_MANY_ROWS then blkMaxfallidos := 0;
            when NO_DATA_FOUND then blkMaxfallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;
        
        
        begin
            -- 3.- bloqueo por prevenciÃ³n de fraudes 
            SELECT TRACKING into blkPrevfraudes FROM EBANKING.EBANKING_USER WHERE ID = usuarioid; -- Si es 2 estÃ¡ bloqueado  0 -> activo
            -- blkPrevfraudes := 300;
            exception
            when TOO_MANY_ROWS then blkMaxfallidos := 0;
            when NO_DATA_FOUND then blkMaxfallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;
        
        begin
            -- 4.- bloqueo por inactividad 11 meses 
            SELECT ACTIVE into blkInactividad FROM EBANKING.EBANKING_USER WHERE ID = usuarioid; -- Si es 0 estÃ¡ bloqueado	1 -> Activo
            -- blkInactividad := 400;
            exception
            when TOO_MANY_ROWS then blkMaxfallidos := 1;  -- Utilizamos 1 en este caso puesto que el cero significa que si hay bloqueo 
            when NO_DATA_FOUND then blkMaxfallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;

        begin
            -- 5.- bloqueo por mÃ¡ximos intentos de consulta expres  
            SELECT COUNT(*) INTO blkMaxFallcexpress FROM ebanking.EBANKING_LOGIN_TA_HIS WHERE NUM_TARJETA = To_Number(notarjeta) AND ATTEMPTS<>0;
            -- blkMaxFallcexpress := 500;
            exception
            when TOO_MANY_ROWS then blkMaxfallidos := 0;
            when NO_DATA_FOUND then blkMaxfallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;

        begin
            -- 6.- bloqueo por recuperaciÃ³n de contraseÃ±a  
            SELECT COUNT(*) into blkPorrecpassword FROM ebanking.EBANKING_ACTIVATION_FAILURE_H WHERE USER_ID = To_Number(usuarioid) AND ATTEMPT<>0;
            -- blkPorrecpassword := 600;
            exception
            when TOO_MANY_ROWS then blkMaxfallidos := 0;
            when NO_DATA_FOUND then blkMaxfallidos := -1;
            WHEN OTHERS THEN
                ROLLBACK;
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al verificar bloqueos  (' || SQLCODE || '  ' || SQLERRM || ')');

        end;
        
    
         
        PSCod_Error := 0;
        PSMsg_Error := 'consulta bloqueos OK';

    --end if;    
    
    
        
END FRA_CONSULTBLKS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_CONSULTUSER
/*************************************************************
Proyecto: Monitoreo de retenciones
Descripción: Sp Consulta de datos de usuario
Parámetros de entrada: 
    - opcion (Tipo de consulta)
    - idusuario (id del usuario a buscar)
Parámetros de salida: 
    -RESULTADO (resultado de la consulta para utilización en el sistema de monitoreo)
Valor de retorno: No aplica
Parámetros de entrada-salida: No aplica
Precondiciones: No aplica
Creador: Erick Ochoa C.
Fecha de creación: Agosto 2014
*************************************************************/
( 
           opcion       IN VARCHAR
          ,idusuario    IN  NUMBER
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error  OUT     VARCHAR2 
          ,RESULTADO    OUT SYS_REFCURSOR
) 
 
AS 

FICERO  NUMBER := 0;    -- NUMERO 0
FIUNO   NUMBER := 1;    -- NUMERO 1

BEGIN

    IF opcion = 'consSingle' -- Consulta un solo usuario
    THEN
    
        OPEN RESULTADO FOR 
            SELECT ID
                   ,ACTIVATION
                   ,ACTIVE
                   ,ANSWER
                   ,CELLULAR
                   ,EMAIL
                   ,QUESTION
                   ,USER2CELLCOMPANY
                   ,ADVANCEDSERVICE
                   ,SECUREDATA
                   ,ACTIVATIONTYPE
                   ,SECURITY_LEVEL
                   ,STATUSNS
                   ,CODIGONS
                   ,CONFIRMNS
                   ,STATUS_CONT_TRAN
                   ,MAIL_RECEIVE
                   ,TRACKING
                   ,PWD_CONFIRM	
                   ,PWD_BANCA_TEL
                   ,PWD_CHANGE_DATE	
                   ,PWD_STATUS
                   ,PWD_CONFIRM_CHANGE_DATE
                   ,BIOMETRICO
                   ,TELEFONO_OFICINA
                   ,OLD_ADVANCEDSERVICE
                   ,ULT_ACCESO
                   ,ULT_IP
                   ,BAN_MAIL
                   ,TOKEN
                   ,FECHA_CAMBIO_STATUS_BAJA
                   ,STATUS_BAJA	
                   ,USER_STATUS	
                   ,FECHA_CAMBIO_STATUS	
                   ,RFC_CLIENTE
                   ,NIP_RED_MOVIL
                   ,FECHA_MODIFICACION
                   ,USUARIO_MODIFICA
                   ,OBSERVACIONES
              FROM EBANKING.EBANKING_USER
             WHERE ID = idusuario;

        PSCod_Error := FICERO;
        PSMsg_Error := 'consulta usuario EBANKING_USER OK';
    END IF;

    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=FIUNO;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar usuario en EBANKING_USER (' || SQLCODE || '  ' || SQLERRM || ')');
              
END FRA_CONSULTUSER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_CONSUSRACTV
/*************************************************************
Proyecto: Monitoreo de retenciones
Descripción: Sp Consulta datos activacion de usuario)
Parámetros de entrada: 
    - opcion (Tipo de consulta)
    - idusuario (id del usuario a consultar)
Parámetros de salida: 
    -RESULTADO (resultado de la consulta para utilización en el sistema de monitoreo)
Valor de retorno: No aplica
Parámetros de entrada-salida: No aplica
Precondiciones: No aplica
Creador: Erick Ochoa C.
Fecha de creación: Agosto 2014
*************************************************************/
( 
           opcion       IN  VARCHAR
          ,idusuario    IN  NUMBER
          ,PSCod_Error  OUT NUMBER
          ,PSMsg_Error  OUT VARCHAR2 
          ,RESULTADO    OUT SYS_REFCURSOR
) 

 
AS 

FICERO  NUMBER := 0;    -- NUMERO 0
FIUNO   NUMBER := 1;    -- NUMERO 1

BEGIN
    
    IF opcion = 'consSingle' -- Un solo usuario 
    THEN
    
        OPEN RESULTADO FOR 
            SELECT ALIAS
                   ,CLIENTE
                   ,EMAIL
                   ,CUENTAOTARJ
                   ,QUESTION
                   ,ANSWER
                   ,CEL_PHONE
                   ,COMPANY
                   ,OFFICE_PHONE
                   ,STATUS
                   ,ACTIVACION
                   ,CODE
                   ,CUENTA
                   ,IP
                   ,TARJETA
                   ,TIPO
                   ,MONITOR
                   ,COMENTARIO
                   ,INTENTOS_LOCALIZAR
                   ,NAME
                   ,TIPOPROD
                   ,FIRSTINTENTO
                   ,LASTINTENTO
                   ,CONFIRMACION
          FROM EBANKING.EBANKING_ACTIVATION 
         WHERE CLIENTE = idusuario;

        PSCod_Error := FICERO;
        PSMsg_Error := 'consulta usuario EBANKING_ACTIVACION OK';

    END IF;

    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=FIUNO;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar usuario en EBANKING_ACTIVACION   (' || SQLCODE || '  ' || SQLERRM || ')');
              
END FRA_CONSUSRACTV;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_DESBLOQUEOS
( 
           opcion IN VARCHAR

          , usuarioid  IN  VARCHAR2
          , notarjeta IN  VARCHAR2
          
          , tipodesbloqueo IN  VARCHAR2  

          , desblkFallidos OUT     NUMBER
          , desblkMaxfallidos OUT     NUMBER
          , desblkPrevfraudes OUT     NUMBER
          , desblkInactividad OUT     NUMBER
          , desblkMaxFallcexpress OUT     NUMBER
          , desblkPorrecpassword OUT     NUMBER
          
           
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          

 
AS 
var_prueba varchar(1) :='';
v_existe varchar2(1) := 'N';

BEGIN
    
    
        begin
            -- 1.- Bloqueo intentos fallidos diarios (3) 
            -- SELECT ATTEMPTS into blkFallidos FROM EBANKING.EBANKING_LOGIN WHERE USER_ID = usuarioid AND ATTEMPTS > 2;
             desblkFallidos := 100;  

        end;
       
       
        begin  
            -- 2.- bloqueo por mÃ¡ximos de intentos fallidos (10) 
            -- SELECT ATTEMPTS into blkMaxfallidos FROM EBANKING.EBANKING_LOGIN WHERE USER_ID = usuarioid AND ATTEMPTS > 9;
             desblkMaxfallidos := 200;

        end;
        
        
        begin
            -- 3.- bloqueo por prevenciÃ³n de fraudes 
            -- SELECT TRACKING into blkPrevfraudes FROM EBANKING.EBANKING_USER WHERE ID = usuarioid; -- Si es 2 estÃ¡ bloqueado  0 -> activo
             desblkPrevfraudes := 300;

        end;
        
        begin
            -- 4.- bloqueo por inactividad 11 meses 
            -- SELECT ACTIVE into blkInactividad FROM EBANKING.EBANKING_USER WHERE ID = usuarioid; -- Si es 0 estÃ¡ bloqueado    1 -> Activo
             desblkInactividad := 400;

        end;

        begin
            -- 5.- bloqueo por mÃ¡ximos intentos de consulta expres  
            -- SELECT COUNT(*) INTO blkMaxFallcexpress FROM ebanking.EBANKING_LOGIN_TA_HIS WHERE NUM_TARJETA = To_Number(notarjeta) AND ATTEMPTS<>0;
             desblkMaxFallcexpress := 500;

        end;

        begin
            
            -- 6.- bloqueo por recuperaciÃ³n de contraseÃ±a  
            -- SELECT COUNT(*) into blkPorrecpassword FROM ebanking.EBANKING_ACTIVATION_FAILURE_H WHERE USER_ID = To_Number(usuarioid) AND ATTEMPT<>0;
             desblkPorrecpassword := 600;

        end;
         
        PSCod_Error := 0;
        PSMsg_Error := 'Desbloqueo de usuario OK';

    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al aplicar desblqueos (' || SQLCODE || '  ' || SQLERRM || ')');
          
        
END FRA_DESBLOQUEOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          FRA_STATUSUARIO
/*************************************************************
Proyecto: Monitoreo de retenciones
Descripción: Sp aplicacion de status de usuario ebanking)
Parámetros de entrada: 
    - opcion (Tipo de consulta)
    - idusuario (id del usuario a consultar)
    - usr_modifica (operador que aplica status)
    - observ (Observaciones de aplicacion de status)
Parámetros de salida: No Aplica.
Valor de retorno: No aplica
Parámetros de entrada-salida: No aplica
Precondiciones: No aplica
Creador: Erick Ochoa C.
Fecha de creación: Agosto 2014
*************************************************************/
( 
          opcion        IN  VARCHAR2 
          ,id_usuario   IN  NUMBER
          ,usr_modifica IN  VARCHAR2
          ,observ       IN  VARCHAR2
          ,PSCod_Error  OUT NUMBER
          ,PSMsg_Error  OUT VARCHAR2 
) 
 
AS 

FICERO  NUMBER := 0;            -- NUMERO 0
FIUNO   NUMBER := 1;            -- NUMERO 1
FIDOS   NUMBER := 2;            -- NUMERO 2
FCOK    VARCHAR2(2) := 'OK';    -- PALABRA OK

BEGIN

    IF opcion = 'blkUsuario' -- BLOQUEO DE USUARIO 
    THEN
        UPDATE EBANKING.EBANKING_USER 
           SET TRACKING=FIDOS
               ,Fecha_Modificacion = SYSDATE
               ,Usuario_Modifica = usr_modifica
               ,Observaciones = observ
         WHERE ID = id_usuario;
        
        COMMIT;
        PSCod_Error := FICERO;
        PSMsg_Error := FCOK;
    end if;
    
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=FIUNO;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar status de usuario  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END FRA_STATUSUARIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          Fra_UpdateUsuariosBloqueados
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,opcion IN NUMBER
          ,valor IN NUMBER
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,p_intentos OUT SYS_REFCURSOR
) 
AS 
BEGIN
    
    IF (opcion = 1) THEN
        OPEN p_intentos FOR
        Select ATTEMPTS FROM EBANKING.EBANKING_LOGIN WHERE USER_ID = p_usuario; 
    END IF;
    
    IF (opcion = 2) THEN /*Desbloqueo de max intentos*/
        UPDATE EBANKING.EBANKING_LOGIN SET ATTEMPTS =0 WHERE USER_ID= p_usuario;
        COMMIT;
        --OPEN p_intentos FOR
        --*SELECT 1 AS RESUL
    END IF;
    
    IF (opcion = 3) THEN /*Desbloqueo inactividad*/
        UPDATE EBANKING.EBANKING_USER SET ACTIVE = 1 WHERE ID= p_usuario;
        COMMIT;
        --OPEN p_intentos FOR
        --SELECT 1 AS RESUL
    END IF;
    
   
  PSCod_Error := 0;
   PSMsg_Error := 'Exito en la operacion';
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
            ROLLBACK;
            IF (Opcion = 1) THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar transaccion  (' || SQLCODE || '  ' || SQLERRM || ')');
            END IF;
            IF (Opcion > 1) THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar iformacion  (' || SQLCODE || '  ' || SQLERRM || ')');
            END IF;
END Fra_UpdateUsuariosBloqueados;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          getIdTracking(IDUSUARIOOPERACION IN NUMBER,cursor_salida out Types.REFCURSOR)
AS
BEGIN
   OPEN cursor_salida FOR
       SELECT  idTRACKING  
       FROM EBANKING.M_TRACKING 
       WHERE ID_USUARIO_OPERACION = IDUSUARIOOPERACION;

   
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
               RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getIdTracking;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GETIDUSUARIO(USERNAME IN VARCHAR, NOMBREAPLICACION IN VARCHAR, cursor_salida out Types.REFCURSOR)
AS

BEGIN

 
	 OPEN cursor_salida FOR
       SELECT MUSR.IDUSUARIO 
       FROM EBANKING.M_USUARIOS MUSR
       WHERE MUSR.USER_NAME =USERNAME AND 
	         MUSR.APLICACION = NOMBREAPLICACION;


EXCEPTION
       WHEN NO_DATA_FOUND THEN
               RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
      
END GETIDUSUARIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GETIDUSUARIOOPER(USERNAME IN VARCHAR,NOMBREAPLICACION IN VARCHAR,cursor_salida out Types.REFCURSOR)
AS

BEGIN
    OPEN cursor_salida FOR
     SELECT MAX(up.ID_Usuario_Operacion) as IDUSUARIOOPERACION 
     FROM EBANKING.M_USUARIOS_OPERACIONES up, EBANKING.M_USUARIOS u
     WHERE u.IDUSUARIO=up.IDUSUARIO AND 
	       u.USER_NAME=USERNAME AND 
		   u.APLICACION=NOMBREAPLICACION;
  
EXCEPTION
    WHEN NO_DATA_FOUND THEN
               RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GETIDUSUARIOOPER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE GETMAILUSER(
    IDUSER IN VARCHAR,
    cursor_salida OUT Types.REFCURSOR)
AS
BEGIN
  OPEN cursor_salida FOR SELECT ID,EMAIL FROM EBANKING_USER WHERE ID=IDUSER;
EXCEPTION
WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)');
WHEN OTHERS THEN
  RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)');
END GETMAILUSER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE getRejectedReasons
  ( queryDinamico IN VARCHAR2,
    p_cursor IN OUT SYS_REFCURSOR )
    As
BEGIN
  dbms_output.put_line('INICIA');
  dbms_output.put_line(queryDinamico);
  OPEN p_cursor FOR 
      queryDinamico ;
 
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE GETUSRALNOVA(USERNAME IN VARCHAR, NOMBREAPLICACION IN VARCHAR, USR_ALNOVA OUT VARCHAR)
AS
CURSOR_CONSULTA  TYPES.refcursor;
BEGIN
     OPEN CURSOR_CONSULTA 
	 	  FOR  SELECT U.USRALNOVA   
      	  	   FROM EBANKING.M_USUARIOS U
      	  	   WHERE U.USER_NAME = USERNAME AND 
	        		 U.APLICACION = NOMBREAPLICACION;
		  LOOP	   
	 	    FETCH CURSOR_CONSULTA INTO USR_ALNOVA;
	  	  	EXIT WHEN CURSOR_CONSULTA%NOTFOUND;
	  	  END LOOP; 
     CLOSE CURSOR_CONSULTA;
EXCEPTION
       WHEN NO_DATA_FOUND THEN
        USR_ALNOVA := '';
      
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_ACTIVE_USER (    
 V_ID_ALNOVA                IN     EBANKING.ebanking_user.id%TYPE,
 V_ACTIVE                    OUT    EBANKING.ebanking_user.active%TYPE
)
IS
ERROR NUMBER;      
BEGIN
    ERROR:=0;
    BEGIN
        SELECT ID, ACTIVE INTO V_ID_ALNOVA, V_ACTIVE
            FROM EBANKING.EBANKING_USER
            WHERE ID=V_ID_ALNOVA;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                V_ID_ALNOVA := '-1';
                ERROR:=1;
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_ACTIVE_USER (' || SQLCODE || '  ' || SQLERRM || ')');
        END;
END GET_ACTIVE_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_CELL_COMPANIES (      
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
CELL_COMPANIES              OUT     sys_refcursor
) IS

BEGIN
        
    OPEN CELL_COMPANIES FOR
    SELECT ID, DESCRIPTION 
    FROM EBANKING.EBANKING_CELLCOMPANY 
    ORDER BY ID ASC;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_CELLCOMPANY correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_CELL_COMPANIES (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_CELL_COMPANIES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_CTAS_OCULTAS
    (P_ID_ALNOVA IN EBANKING.CTAS_OCULTAS.ID_CLI_ALNOVA%TYPE , cursor_salida OUT SYS_REFCURSOR )
  IS

BEGIN
  OPEN cursor_salida FOR
  SELECT ID_CONSECUTIVO, ID_CLI_ALNOVA, TIPO_CUENTA,CUENTA,ESTATUS,ULTIMA_MODIFICACION,USUARIO_MODIFICO,SISTEMA,PAIS
    FROM EBANKING.CTAS_OCULTAS
    WHERE ID_CLI_ALNOVA=P_ID_ALNOVA and ESTATUS='1';
END GET_CTAS_OCULTAS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_FREC_DATA_WU_SP (
V_CU                        IN        EBANKING.BENEFICIARIOS_WU.CU%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_FRECS                   OUT    SYS_REFCURSOR
)
IS

BEGIN
    OPEN CURSOR_FRECS FOR   
    SELECT NOMBRE,AP_PATERNO,AP_MATERNO,PAIS,CIUDAD,ESTADO,ID_BENEFICIARIO_WU,ESTATUS,FECHA_ACTIVACION FROM EBANKING.BENEFICIARIOS_WU 
    WHERE CU=V_CU;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_FREC_DATA_WU_SP correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_FREC_DATA_WU_SP (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_FREC_DATA_WU_SP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_FREC_INTER_MORAL_PERSON (
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE
)
RETURN TYPES.REFCURSOR
AS
type T_CURSOR IS REF CURSOR RETURN TRANSFINTERNALFRECUENT%ROWTYPE;
CURSOR_SALIDA T_CURSOR;
V_REG EBANKING.TRANSFINTERNALFRECUENT%ROWTYPE;
PERSONA NUMBER := 2;
BEGIN
   OPEN CURSOR_SALIDA 
    FOR
      SELECT 
          CLIENT,
          DESTINO,
          NAME,
          STATUS,
          FECHA_MODIFICACION,
          /*IP_ORIGEN,*/
          CLAVE_SWIFT,
          /*CANAL,*/
          APELLIDO_PATERNO,
          APELLIDO_MATERNO,
          LUGAR_NACIMIENTO,
          /*DOMICILIO,*/
          STATUS_BLOQUEO,
         /* FECHA_NACIMIENTO,*/
          FECHA_ACTIVACION,
          TIPO_PERSONA,
          RFC
      FROM EBANKING.TRANSFINTERNALFRECUENT
      WHERE CLIENT = P_CLIENT AND  TIPO_PERSONA = PERSONA;
      
RETURN CURSOR_SALIDA;

EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_FREC_INTER_MORAL_PERSON ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_FREC_SERVICE (      
V_USER_ID                   IN      number,
V_ID_SERVICIO               IN      number,
CURSOR_FRECUENTES           OUT     sys_refcursor,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS

ACTIVO NUMBER:=1;
NUM_LENGTH NUMBER := 10;
BEGIN

   CASE V_ID_SERVICIO

        WHEN 17 THEN
        
                    OPEN CURSOR_FRECUENTES FOR
                    SELECT USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL 
                    FROM EBANKING.EDCULTURALES WHERE USER_ID = V_USER_ID AND STATUS = ACTIVO
                    ORDER BY USER_ID;
                    PSCod_Error := 0;
                    PSMsg_Error := 'consulta en GET_MODELOS correctamente';

        WHEN 4  THEN
                    OPEN CURSOR_FRECUENTES FOR
                    SELECT USER_ID, REFERENCIA, ULTIMA_ACTUALIZACION, STATUS, CANAL 
                    FROM EBANKING.SKYACCOUNTS WHERE USER_ID = V_USER_ID AND STATUS = ACTIVO
                    ORDER BY USER_ID;
                    PSCod_Error := 0;
                    PSMsg_Error := 'consulta en GET_FREC_SERVICE correctamente';

        WHEN 1  THEN
                    OPEN CURSOR_FRECUENTES FOR
                    SELECT USER_ID, TELEFONO, ULTIMA_ACTUALIZACION, STATUS, CANAL 
                    FROM EBANKING.TELMEX WHERE USER_ID = V_USER_ID AND STATUS = ACTIVO AND LENGTH(TELEFONO)=NUM_LENGTH
                    ORDER BY USER_ID;
                    PSCod_Error := 0;
                    PSMsg_Error := 'consulta en GET_FREC_SERVICE correctamente';
        ELSE 
                    OPEN CURSOR_FRECUENTES FOR
                    SELECT USER_ID, FRECUENTE,ULTIMA_ACTUALIZACION,STATUS,CANAL,ID_SERVICIO 
                    FROM EBANKING.ALL_FRECUENTES WHERE USER_ID = V_USER_ID AND STATUS = ACTIVO AND ID_SERVICIO = V_ID_SERVICIO;
                    PSCod_Error := 0;
                    PSMsg_Error := 'consulta en GET_FREC_SERVICE correctamente';
                    

    END CASE;
    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_FREC_SERVICE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_FREC_WUSP (
V_CU                        IN        EBANKING.BENEFICIARIOWU.CU%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_FRECS                   OUT    SYS_REFCURSOR
)
IS

BEGIN
    OPEN CURSOR_FRECS FOR   
    SELECT NOMBRE,AP_PATERNO,AP_MATERNO,PAIS,CIUDAD,ESTADO,ID_BENEFICIARIO_WU,ESTATUS,FECHA_ACTIVACION 
    FROM EBANKING.BENEFICIARIOWU 
    WHERE CU=V_CU;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_FREC_WUSP correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_FREC_WUSP (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_FREC_WUSP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_INTER_FRECS (
V_CLIENT                        IN    EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_INTER_FRECS             OUT    sys_refcursor
)
IS
ACTIVO NUMBER:=1;
BEGIN
    OPEN CURSOR_INTER_FRECS FOR   
    SELECT CLIENT,DESTINO,NAME,CLAVE_SWIFT, STATUS ,FECHA_MODIFICACION,CANAL  FROM EBANKING.TRANSFINTERNALFRECUENT 
    WHERE CLIENT=V_CLIENT AND STATUS=ACTIVO order by NAME;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_INTER_FRECS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_INTER_FRECS (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_INTER_FRECS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_IUPI_ACCOUNT(
P_ID_CLIENTE IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE,
P_CUENTA_DESTINO IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE ,
cursor_salida OUT SYS_REFCURSOR)
IS

BEGIN
OPEN cursor_salida for
SELECT ID FROM EBANKING.IUPIFRECUENT WHERE CUENTA_DESTINO=P_CUENTA_DESTINO AND ID_CLIENTE=P_ID_CLIENTE;

EXCEPTION
     WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR (-20000, 'Error al obtener usuario en  EBANKING.GET_IUPI_ACCOUNT  (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20000, 'Error al obtener usuario en  EBANKING.GET_IUPI_ACCOUNT  (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_IUPI_ACCOUNT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_IUPI_REF_FREQ ( 
    P_ID_USUARIO IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE , 
    cursor_salida  OUT SYS_REFCURSOR)

IS

BEGIN 

OPEN cursor_salida for
SELECT ID , APODO, FECHA_MODIFICACION, CUENTA_DESTINO , IP_ORIGEN, STATUS, CANAL, EMAIL_DESTINO from EBANKING.IUPIFRECUENT where id_cliente = P_ID_USUARIO  AND status=1 ;
END GET_IUPI_REF_FREQ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_MODELOS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_MODELOS                OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_MODELOS FOR
        SELECT ID, NUM_MODELO, SISTEMA_OPERATIVO, DESCRIPCION
            FROM TOKENADMINPRU.CAT_VER_FAM
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_MODELOS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO MODELOS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_MODELOS (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_MODELOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_MONITOR_USER_DETAILS (
V_USERNAME               IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,
V_PASSWORD               OUT    TOKENADMINPRU.USUARIOS_TOKEN.PASSWORD%TYPE,
V_ENABLED                OUT    TOKENADMINPRU.USUARIOS_TOKEN.ENABLED%TYPE,
CURSOR_AUTHORITIES       OUT    sys_refcursor,
PSCod_Error              OUT    number,
PSMsg_Error              OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_AUTHORITIES FOR
    SELECT AUTHORITY
    FROM TOKENADMINPRU.AUTHORITIES
    WHERE USERNAME = V_USERNAME;
    SELECT PASSWORD, ENABLED 
    INTO V_PASSWORD, V_ENABLED
    FROM TOKENADMINPRU.USUARIOS_TOKEN
    WHERE USERNAME = V_USERNAME;
    PSCod_Error := 0;
    PSMsg_Error := 'Se obtuvieron correctamente los datos del usuario monitor';
EXCEPTION
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'Cliente no existe';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Cliente no existe';
            RAISE_APPLICATION_ERROR (-20100, 'No se encontro usuario al consultar GET_MONITOR_USER_DETAILS (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_MONITOR_USER_DETAILS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_MONITOR_USUARIOS_TOKEN(
CURSOR_USUARIOS_TOKEN           OUT    sys_refcursor,
PSCod_Error            OUT    number,
PSMsg_Error            OUT    varchar2
)
IS
BEGIN

    OPEN CURSOR_USUARIOS_TOKEN FOR
    SELECT USERNAME
    FROM TOKENADMINPRU.USUARIOS_TOKEN;
    
    PSCod_Error := 0;
    PSMsg_Error := 'Se obtuvieron correctamente los usuarios';
    
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Ocurrio un error al tratar de recuperar los usuarios';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar USUARIOS_TOKEN (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_MONITOR_USUARIOS_TOKEN ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_MORAL_PER(
P_CLIENT                         IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
PSCod_Error                      OUT    number,
PSMsg_Error                      OUT    varchar2,
CURSOR_MORAL_PERSON              OUT    sys_refcursor
)
IS
ACTIVO NUMBER:=1;
PERSONA NUMBER := 2;
BEGIN
    OPEN CURSOR_MORAL_PERSON FOR  
        SELECT CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, CLAVE_SWIFT, APELLIDO_PATERNO,APELLIDO_MATERNO,
          LUGAR_NACIMIENTO, STATUS_BLOQUEO, FECHA_ACTIVACION, TIPO_PERSONA, RFC
      FROM EBANKING.TRANSFINTERNALFRECUENT
      WHERE CLIENT = P_CLIENT AND  TIPO_PERSONA = PERSONA AND STATUS=ACTIVO order by NAME;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_MORAL_PER correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar los frecuentes del cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_MORAL_PER (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_MORAL_PER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_MORAL_PERSON(
P_CLIENT                         IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
PSCod_Error                      OUT    number,
PSMsg_Error                      OUT    varchar2,
CURSOR_MORAL_PERSON              OUT    sys_refcursor
)
IS
ACTIVO NUMBER:=1;
PERSONA NUMBER := 2;
BEGIN
    OPEN CURSOR_MORAL_PERSON FOR  
        SELECT CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION,/*IP_ORIGEN,*/ CLAVE_SWIFT,/*CANAL,*/APELLIDO_PATERNO,APELLIDO_MATERNO,
          LUGAR_NACIMIENTO,/*DOMICILIO,*/ STATUS_BLOQUEO,/* FECHA_NACIMIENTO,*/ FECHA_ACTIVACION, TIPO_PERSONA, RFC
      FROM EBANKING.TRANSFINTERNALFRECUENT
      WHERE CLIENT = P_CLIENT AND  TIPO_PERSONA = PERSONA AND STATUS=ACTIVO order by NAME;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_INTER_FRECS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar los frecuentes del cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_INTER_FRECS (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_MORAL_PERSON;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_MUNICIPALITIES (    
STATENUM                    IN      varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
MUNICIPALITIES              OUT     sys_refcursor
) IS


BEGIN
            
    OPEN MUNICIPALITIES FOR
    SELECT CITY_CODE, DESCRIPCION 
    FROM EBANKING.EBANKING_MUNICIPIOS 
    WHERE CITY_CODE LIKE STATENUM || '%';
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_MUNICIPIOS correcta';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_MUNICIPALITIES (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_MUNICIPALITIES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_NOTIFICA( NUM_ALNOVA IN VARCHAR, BANDERA OUT NUMBER)
AS

    DATE_NOTIFICATION DATE;

BEGIN

    SELECT FECHA_NOTIFICACION INTO DATE_NOTIFICATION FROM EBANKING.RMA_NOTIFICA
        WHERE TRUNC(FECHA_NOTIFICACION) <= TRUNC(SYSDATE)        
        AND CTE_ALNOVA = NUM_ALNOVA;


IF  DATE_NOTIFICATION IS NOT NULL THEN

    IF TRUNC(DATE_NOTIFICATION) < TRUNC(SYSDATE) THEN
        UPDATE  EBANKING.RMA_NOTIFICA
            SET NUMERO_NOTIFICACIONES   = NUMERO_NOTIFICACIONES + 1,
            FECHA_NOTIFICACION = SYSDATE,
            ULTIMA_MODIFICACION = SYSDATE
            WHERE CTE_ALNOVA = NUM_ALNOVA;
            BANDERA := 1;
            COMMIT;
     ELSE
          BANDERA := 0;

     END IF;

END IF;

  EXCEPTION
        WHEN NO_DATA_FOUND THEN
                INSERT INTO EBANKING.RMA_NOTIFICA FD(FD.CTE_ALNOVA,FD.FECHA_NOTIFICACION,FD.NUMERO_NOTIFICACIONES,FD.ULTIMA_MODIFICACION, FD.USUARIO_MODIFICO)
                     VALUES(NUM_ALNOVA, SYSDATE, 1, SYSDATE,'USRMNTR');
                     COMMIT;
                BANDERA:= 1;

         WHEN OTHERS THEN
                BANDERA:= -1;
                RAISE_APPLICATION_ERROR (-20100, 'Error en SP de notificaciones RMA ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
                ROLLBACK;
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_NUM_ACC_CRED_FREC(
V_CLIENT                IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CLIENTE%TYPE,
V_BANK                  IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BANCO%TYPE,
V_DESTINO               IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CUENTACREDITO%TYPE,
V_TYPE_CREDIT           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.TIPOCREDITO%TYPE,
PSNum_Accounts          OUT     number,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
V_NUMERO NUMBER;
V_ACTIVE NUMBER:=1;
                
BEGIN
    SELECT 
            COUNT(1) INTO V_NUMERO
            FROM EBANKING.CREDITOSOTROSBANCOSFRECUENT
            WHERE CLIENTE       = V_CLIENT 
              AND BANCO         = V_BANK
              AND CUENTACREDITO = V_DESTINO
              AND TIPOCREDITO   = V_TYPE_CREDIT
              AND STATUS        = V_ACTIVE;   
              
             COMMIT;
            PSNum_Accounts := V_NUMERO;
            PSCod_Error := 0;
            PSMsg_Error := 'Se obtuvo el numero de registros correctamente';

                    
    EXCEPTION
            WHEN OTHERS THEN
                PSCod_Error:=2;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;

                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar ADD_FREQ_EXTCRED (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_NUM_ACC_CRED_FREC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_OFFICES (    
CITY_ZIP_CODE               IN      varchar2,
BY_ZIP_CODE                 IN      number, 
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
OFFICES_ADRESS              OUT     sys_refcursor
) IS

BEGIN
    IF (BY_ZIP_CODE = 1) THEN
        OPEN OFFICES_ADRESS FOR
        SELECT SUCURSAL, NOMBRE, DIRECCION 
        FROM EBANKING.EBANKING_SUCURSALES 
        WHERE CP = CITY_ZIP_CODE;
    ELSE
        OPEN OFFICES_ADRESS FOR
        SELECT SUCURSAL, NOMBRE, DIRECCION 
        FROM EBANKING.EBANKING_SUCURSALES 
        WHERE CITY_CODE = TO_NUMBER(CITY_ZIP_CODE);
    END IF;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_SUCURSALES correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_OFFICES (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_OFFICES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_OFFICE_ADRESS (    
OFFICE                       IN     varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
OFFICE_ADRESS               OUT     sys_refcursor
) IS

BEGIN
        
    OPEN OFFICE_ADRESS FOR
    SELECT SUCURSAL, NOMBRE, DIRECCION 
    FROM EBANKING.EBANKING_SUCURSALES 
    WHERE SUCURSAL = TO_NUMBER(OFFICE);
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_SUCURSALES correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_OFFICE_ADRESS (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_OFFICE_ADRESS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_PAGOSMAZ(
                                                    PA_CURSOR OUT SYS_REFCURSOR) IS
BEGIN

    OPEN PA_CURSOR FOR SELECT FCSISTEMA, FDFECHA_PAGO, FCGRUPO, 
                               FNUSUARIO, FCCUENTA_CARGO, FCNOM_INTEGRAN, 
                               FNIMPORTE, FCREFEREN_CAJA, FNSUCURSAL, 
                               FCREFERENCIA, FCTIENDA, FCCAJERO, 
                               FDFECHA_MOD, FCUSUARIO_MOD, CANAL, CREDITO, NUM_OPER FROM EBANKING.TAPAGOMICRONEG 
        WHERE TO_CHAR(FDFECHA_PAGO, 'yyyy-mm-dd') = TO_CHAR(SYSDATE-1, 'yyyy-mm-dd');

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_PASSPORT (
V_ALIAS                     IN     TOKENADMINPRU.PASSPORT.ALIAS%TYPE,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_PASS                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_PASS FOR   
    SELECT PA.ID_PASSPORT, PA.ALIAS, PA.PASSPORT, PA.ULTIMA_MODIFICACION, PA.USUARIO_MODIFICO
    FROM TOKENADMINPRU.PASSPORT PA 
    WHERE PA.ALIAS = V_ALIAS;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_PASSPORT correctamente';
    
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar passport';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_PASSPORT (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_PASSPORT ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_PENDING_TOKENS (    
ID_USER                      IN     varchar2,
OPER_TYPE                    IN     varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
PENDING_TOKENS              OUT     number
) IS

PENDING_TOKENS1 NUMBER;

BEGIN
        
    SELECT (COUNT(*)) INTO PENDING_TOKENS1
    FROM EBANKING_TOKEN_PREVENCION ETP 
    WHERE ETP.NUM_CLIENTE=ID_USER 
    AND ETP.ESTATUS=1 
    AND ETP.TIPO_OPERACION=OPER_TYPE;
    
    PENDING_TOKENS := PENDING_TOKENS1;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_TOKEN_PREVENCION correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_PENDING_TOKENS (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_PENDING_TOKENS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_QUEMADO_DIS (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.QUEMADO_TKN_DIS.ID_ALNOVA%TYPE,
V_NUM_TOKEN_IN                 IN     TOKENADMINPRU.QUEMADO_TKN_DIS.TOKEN%TYPE,
V_TIPO                         IN     TOKENADMINPRU.QUEMADO_TKN_DIS.TIPO %TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
V_NUM_REGISTROS                OUT    number
)
IS

BEGIN
    
    SELECT count(ID_ALNOVA) into V_NUM_REGISTROS
    FROM TOKENADMINPRU.QUEMADO_TKN_DIS 
    WHERE ID_ALNOVA = V_NUM_CLIENTE_IN
    AND TOKEN =  V_NUM_TOKEN_IN
    AND TIPO = V_TIPO;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_QUEMADO_DIS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar los tokens quemados';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_QUEMADO_DIS (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_QUEMADO_DIS ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_QUEMADO_TAR (
V_ID_ALNOVA             IN     TOKENADMINPRU.QUEMADO_TKN_TAR.ID_ALNOVA%TYPE,
V_ID_TARJETA            IN     TOKENADMINPRU.QUEMADO_TKN_TAR.ID_TARJETA%TYPE,
V_TOKEN                 IN     TOKENADMINPRU.QUEMADO_TKN_TAR.TOKEN%TYPE,
V_NUM_REGISTROS         OUT    number,
PSCod_Error             OUT    number,
PSMsg_Error             OUT    varchar2

)
IS

BEGIN
    
    SELECT COUNT(1) INTO V_NUM_REGISTROS
        FROM TOKENADMINPRU.QUEMADO_TKN_TAR 
        WHERE ID_ALNOVA = V_ID_ALNOVA
            AND ID_TARJETA = V_ID_TARJETA
            AND TOKEN =  V_TOKEN;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_QUEMADO_TAR correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar los tokens quemados de las tarjetas';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_QUEMADO_TAR (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_QUEMADO_TAR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_REF_MAZ(
                                                    PA_REF OUT NUMBER) IS
BEGIN

    SELECT EBANKING.SEQ_MICNEG_PAG.NextVal INTO PA_REF FROM DUAL;

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_SEM_AC_US (
V_ALNOVA_IN                       IN     EBANKING.TOKEN_DISP.ID_ALNOVA%TYPE,
V_SEMILLA                         OUT    EBANKING.TOKEN_DISP.SEMILLA%TYPE
)
IS

BEGIN

     SELECT S.SEMILLA INTO V_SEMILLA FROM EBANKING.TOKEN_DISP S
     WHERE S.ID_ALNOVA = V_ALNOVA_IN
     AND S.ESTADO = 1;

EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_SEMILLA:= '';
        WHEN OTHERS THEN
            V_SEMILLA:= '';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_SEM_AC_US (' || SQLCODE || '  ' || SQLERRM || ')');

END GET_SEM_AC_US;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_SEM_TOK (
V_SEM                         IN     EBANKING.TOKEN_DISP.SEM_ENCRIPTADA%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_SEMILLAS                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_SEMILLAS FOR
        SELECT T.ID_ACT_DISPOSITIVO, T.SEMILLA FROM EBANKING.TOKEN_DISP T
        WHERE T.SEM_ENCRIPTADA = V_SEM
        ORDER BY T.ID_ACT_DISPOSITIVO ASC;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_SEM_TOK correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar semillas';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_SEM_TOK (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_SEM_TOK;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_SISTEMAS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_SISTEMAS                OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_SISTEMAS FOR
        SELECT ID, ID_SISTEMA, DESCRIPCION
            FROM TOKENADMINPRU.CAT_SISTEMA
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_SISTEMAS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO SISTEMAS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_SISTEMAS (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_SISTEMAS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_SIST_OPE (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_SISOP                   OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_SISOP FOR
        SELECT ID_SISTEMA, NOMBRE, DESCRIPCION
            FROM TOKENADMINPRU.CAT_VER_SOPERAT
            ORDER BY ID_SISTEMA;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_SIST_OPE correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO SIST OPE';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_SIST_OPE (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_SIST_OPE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_TAR_AL_ACTI (
 V_ID_ALNOVA                    IN     TOKENADMINPRU.STATUS_TARJETA.ID_ALNOVA%TYPE,
 CURSOR_CLIENTE                 OUT    sys_refcursor,
 PSCod_Error                    OUT    number,
 PSMsg_Error                    OUT    varchar2
)
IS    
BEGIN
    OPEN CURSOR_CLIENTE FOR
        SELECT ST.ID_TARJETA, ST.DESFASE, ST.SINCRONIZACIONES, ST.FECHA_ACTIVACION
            FROM TOKENADMINPRU.STATUS_TARJETA ST
            WHERE STATUS=1 
                AND ID_ALNOVA=V_ID_ALNOVA;
    PSCod_Error := 0;
    PSMsg_Error:='consulta en GET_TAR_AL_ACTI correctamente';
EXCEPTION
        WHEN NO_DATA_FOUND THEN
            PSCod_Error := 1;
            PSMsg_Error:='No existen tarjetas para el usuario alnova: '|| V_ID_ALNOVA;
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TAR_AL_ACTI (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_TAR_AL_ACTI ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_TIPOS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_TIPOS                   OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_TIPOS FOR
        SELECT ID, NOMBRE, DESCRIPCION
            FROM TOKENADMINPRU.CAT_TIPO_FAM
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_TIPOS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO TIPOS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TIPOS (' || SQLCODE || '  ' || SQLERRM || ')');
END  GET_TIPOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_TOKENS_STATUSONE (    
ID_USER                      IN     varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
TOKENS_NUMBER               OUT     number
) IS

TOKENS_NUMBER1 NUMBER;

BEGIN
        
    SELECT (COUNT(*)) INTO TOKENS_NUMBER1
    FROM EBANKING_TOKEN_STATUS ETS
    WHERE ETS.NUM_CLIENTE=ID_USER 
    AND ETS.STATUS=1;
    
    TOKENS_NUMBER := TOKENS_NUMBER1;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_TOKEN_STATUS correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TOKENS_STATUSONE (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_TOKENS_STATUSONE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_TOKENUNL_DATA (    
ID_USER                      IN     varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2,
USER_DATA                   OUT     sys_refcursor
) IS

BEGIN
        
    OPEN USER_DATA FOR
    SELECT CELLULAR, USER2CELLCOMPANY, EMAIL, TELEFONO_OFICINA
    FROM EBANKING.EBANKING_USER
    WHERE ID = ID_USER;
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en EBANKING_USER correctamente';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TOKENUNL_DATA (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_TOKENUNL_DATA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_TOTAL_TOKEN (
                                       
V_NUM_CLIENTE_IN               IN     EBANKING.EBANKING_TOKEN_STATUS.NUM_CLIENTE%TYPE,
TOTAL_RSA                       out   number,
TOTAL_DISP                       out   number,
TOTAL_TAR                       out   number,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2
)
IS
BEGIN
   
SELECT COUNT(1) into TOTAL_RSA   FROM EBANKING.EBANKING_TOKEN_STATUS
        WHERE  NUM_CLIENTE = V_NUM_CLIENTE_IN
            AND STATUS = 1;
            
            
SELECT COUNT(1) into TOTAL_DISP  FROM EBANKING.TOKEN_DISP
        WHERE  ID_ALNOVA = V_NUM_CLIENTE_IN
            AND ESTADO = 1;
            
            
SELECT COUNT(1) into TOTAL_TAR  FROM TOKENADMIN.STATUS_TARJETA
        WHERE  ID_ALNOVA = V_NUM_CLIENTE_IN
            AND STATUS = 1;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_TOTAL_TOKEN correctamente';
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el numero de tokens del usuario';
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el numero de tokens del usuario';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TOTAL_TOKEN (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_TOTAL_TOKEN ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_TOT_RFAM (
                                       
V_NUM_CLIENTE_IN               IN     EBANKING.EBANKING_TOKEN_STATUS.NUM_CLIENTE%TYPE,
V_STATUS_IN                        IN       EBANKING.EBANKING_TOKEN_STATUS.STATUS%TYPE,
TOTAL_RSA                       out   number,
TOTAL_DISP                       out   number,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2
)
IS
BEGIN
   
SELECT COUNT(1) into TOTAL_RSA   FROM EBANKING.EBANKING_TOKEN_STATUS
        WHERE  NUM_CLIENTE = V_NUM_CLIENTE_IN
            AND STATUS = V_STATUS_IN;
            
            
SELECT COUNT(1) into TOTAL_DISP  FROM EBANKING.TOKEN_DISP
        WHERE  ID_ALNOVA = V_NUM_CLIENTE_IN
            AND ESTADO = V_STATUS_IN;            
            
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_TOT_RFAM correctamente';
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el numero de tokens del usuario';
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el numero de tokens del usuario';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TOT_RFAM (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_TOT_RFAM ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_USER_AL_TAR (    
 V_ID_TARJETA                  IN     TOKENADMINPRU.STATUS_TARJETA.ID_TARJETA%TYPE,
 V_ID_ALNOVA                   OUT    TOKENADMINPRU.STATUS_TARJETA.ID_ALNOVA%TYPE,
 V_STATUS                      OUT    TOKENADMINPRU.STATUS_TARJETA.STATUS%TYPE
)
IS
ERROR NUMBER;      
BEGIN
    ERROR:=0;
    BEGIN
        SELECT ID_ALNOVA, STATUS INTO V_ID_ALNOVA, V_STATUS
            FROM TOKENADMINPRU.STATUS_TARJETA
            WHERE STATUS=1 
                AND ID_TARJETA=V_ID_TARJETA;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                V_ID_ALNOVA := '-1';
                ERROR:=1;
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_TAR_AL_ACTI (' || SQLCODE || '  ' || SQLERRM || ')');
        END;
END GET_USER_AL_TAR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          GET_USER_EMAIL(
P_IDUSER IN EBANKING.EBANKING_USER.ID%TYPE ,
cursor_salida out SYS_REFCURSOR
)

IS
BEGIN
OPEN cursor_salida FOR
 SELECT EMAIL FROM EBANKING_USER WHERE ID = P_IDUSER;
END GET_USER_EMAIL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_USER_STA_DI (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
V_TIPO                         IN     TOKENADMINPRU.STATUS_DISP.TIPO%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT ID_ACT_DISPOSITIVO, NUM_CLIENTE, SEMILLA, ESTADO, DESFASE, SINCRONIZACIONES, SISTEMA, PAIS, VERSION, SOPERATIVO , NUM_MODELO,          
        NUM_TELEFONO, CORREO_ELECTONICO, ULTIMA_SINCRONIZACION, ULTIMA_AUTENTICACION, FECHA_ACTIVACION, ULTIMA_MODIFICACION, USUARIO_MODIFICO, TIPO     
    FROM TOKENADMINPRU.STATUS_DISP 
    WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN 
            AND ESTADO = 1 
            AND TIPO = V_TIPO
            and ROWNUM = 1;  --Solo para Pruebas
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_USER_STA_DI correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_USER_STA_DI (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_USER_STA_DI ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_USR_ACT_DIS (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT ID_ACT_DISPOSITIVO, NUM_CLIENTE, SEMILLA, ESTADO, DESFASE, SINCRONIZACIONES, SISTEMA, PAIS, VERSION, SOPERATIVO , NUM_MODELO,          
        NUM_TELEFONO, CORREO_ELECTONICO, ULTIMA_SINCRONIZACION, ULTIMA_AUTENTICACION, FECHA_ACTIVACION, ULTIMA_MODIFICACION, USUARIO_MODIFICO, TIPO     
    FROM TOKENADMINPRU.STATUS_DISP 
    WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN 
            AND ESTADO = 1;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_USR_ACT_DIS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_USR_ACT_DIS (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_USR_ACT_DIS ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_US_LIST_MOV (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
V_TIPO                         IN     TOKENADMINPRU.STATUS_DISP.TIPO%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR
        SELECT ESTADO, TO_CHAR(FECHA_ACTIVACION, 'DD-MM-YYYY HH24:MI:SS'  ) AS FECHA_ACTIVACION
            FROM TOKENADMINPRU.STATUS_DISP
            WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN
            AND TIPO = V_TIPO 
            ORDER BY FECHA_ACTIVACION;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_US_LIST_MOV correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_US_LIST_MOV (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_US_LIST_MOV ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            GET_US_LIST_RSA (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.STATUS_RSA.NUM_CLIENTE%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR
        SELECT NUM_SERIE_TOKEN, STATUS, TO_CHAR(FECHA_ACTIVACION, 'DD-MM-YYYY HH24:MI:SS'  ) AS FECHA_ACTIVACION  
            FROM TOKENADMINPRU.STATUS_RSA
            WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN;
    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en GET_US_LIST_RSA correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar GET_US_LIST_RSA (' || SQLCODE || '  ' || SQLERRM || ')');

END  GET_US_LIST_RSA ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERTAR_CTA_OCULTA 
    (P_IDUSUARIO IN EBANKING.CTAS_OCULTAS.ID_CLI_ALNOVA%TYPE, 
     P_CUENTA IN EBANKING.CTAS_OCULTAS.CUENTA%TYPE,
     P_TIPO_CUENTA IN EBANKING.CTAS_OCULTAS.TIPO_CUENTA%TYPE,
     P_ESTATUS IN EBANKING.CTAS_OCULTAS.ESTATUS%TYPE,
     P_USUARIO_MODIFICO IN EBANKING.CTAS_OCULTAS.USUARIO_MODIFICO%TYPE,
     P_SISTEMA IN EBANKING.CTAS_OCULTAS.SISTEMA%TYPE)
 AS
  ID_CUENTA EBANKING.CTAS_OCULTAS.CUENTA%TYPE; 
BEGIN
   ID_CUENTA:=GET_USR_CTA_OCULTA (P_CUENTA,P_IDUSUARIO);

   IF (ID_CUENTA<0) THEN    --cuenta no exite en alnova
      INSERT INTO EBANKING.CTAS_OCULTAS
    (ID_CONSECUTIVO,ID_CLI_ALNOVA, TIPO_CUENTA,CUENTA,ESTATUS,ULTIMA_MODIFICACION,USUARIO_MODIFICO,SISTEMA,PAIS,FECHA_ALTA)
        VALUES (EBANKING.SEQCTAOCULTA.NEXTVAL,P_IDUSUARIO,P_TIPO_CUENTA ,P_CUENTA ,P_ESTATUS,SYSDATE,P_USUARIO_MODIFICO, P_SISTEMA,'MX',SYSDATE);
   END IF;
   
   COMMIT; 
   EXCEPTION
     WHEN OTHERS THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20000, 'Error al insertar cuenta en EBANKING.INSERTAR_CUENTAOCULTA  (' || SQLCODE || '  ' || SQLERRM || ')');
END INSERTAR_CTA_OCULTA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE insertar_usuario (val number,val2 varchar2)
is
begin
insert into usuario values(val, val2);
commit
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERTATERMINAL( 
    ID IN NUMBER
   ,CODE IN VARCHAR2
   ,BUSY IN NUMBER
   ,APP IN VARCHAR2
   ,USUARIO_MODIFICO IN VARCHAR2
   ,FECHA_OPERACION IN DATE
   ,PASMSG_ERROR  OUT VARCHAR2
)
IS

BEGIN

INSERT INTO EBANKING.ALNOVA_TERM_SEL (ID, CODE, BUSY, APP, USUARIO_MODIFICO, FECHA_OPERACION) 
VALUES (ID,CODE,BUSY,APP,USUARIO_MODIFICO,FECHA_OPERACION);
COMMIT;
PASMSG_ERROR := 'EXITOSO';
   EXCEPTION
     WHEN OTHERS THEN
        PASMSG_ERROR:=SQLCODE || ' NO EXITOSO SP_BLOQUEOINAC' || SQLERRM;
        ROLLBACK;
        RAISE;
END INSERTATERMINAL;
/

SHOW ERRORS;


CREATE OR REPLACE Procedure          Inserta_Historico
     ( idCliente in NUMBER,
	   tipoTransferencia in NUMBER,
		cuentaDestino in varchar,
		tipoCuentaDestino in  varchar,
		nombreDestino in varchar,
		codBanco in NUMBER)
AS
   	vId_Registro number;
	numero number;
  BEGIN
     select count( * ) into numero
     from ebanking.HISTORICO_TEF_SPEI_TERCEROS
     where id_Cliente=idCliente
     and cuenta_destino=cuentaDestino
	 and id_tipoTransferencia=tipoTransferencia;
IF numero>=1 THEN
     update ebanking.HISTORICO_TEF_SPEI_TERCEROS
	 set fecha_modificacion = sysdate
     where id_Cliente=idCliente
     and cuenta_destino=cuentaDestino
	 and id_tipoTransferencia=tipoTransferencia;
     commit;
ELSE
	 select ebanking.SEQ_HISTORICO_TEF_SPEI_TER_ID.nextval INTO vId_Registro from dual ;
     insert into ebanking.HISTORICO_TEF_SPEI_TERCEROS(ID ,ID_CLIENTE ,ID_TIPOTRANSFERENCIA ,CUENTA_DESTINO ,
	 			 NOMBRE_DESTINO ,TIPO_CUENTA_DESTINO ,FECHA_MODIFICACION ,COD_BANCO)
     values (
	 vId_Registro,
	 idCliente,
	 tipoTransferencia ,
	 cuentaDestino ,
	 nombreDestino ,
	 tipoCuentaDestino ,sysdate,
	 codBanco
	  );
     commit;
END IF;
EXCEPTION
WHEN OTHERS THEN
      raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END Inserta_Historico;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          insertError(idUsuarioOperacion  IN NUMBER, idUsuario IN NUMBER,idOperacion IN VARCHAR,idTracking IN NUMBER, 
codigoOperacion IN NUMBER,estatus IN VARCHAR)

AS
IDUSEROPE number;
BEGIN

        INSERT INTO EBANKING.M_usuarios_operaciones 
        VALUES(idUsuarioOperacion,idUsuario,idOperacion,'USRMNTR',SYSDATE);
        COMMIT;
        
        SELECT MAX(up.ID_Usuario_Operacion) into IDUSEROPE 
        FROM EBANKING.M_USUARIOS_OPERACIONES up
        WHERE up.IDUSUARIO=idUsuario;
   
       
        INSERT INTO EBANKING.M_tracking 
        VALUES(idTracking,IDUSEROPE,codigoOperacion, estatus,'USRMNTR',SYSDATE);
        COMMIT;
        
  EXCEPTION
         WHEN OTHERS THEN
         ROLLBACK;  
        
END insertError;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          InsertransDex(
    CLIENTE_ID NUMBER, 
    MTCN VARCHAR, 
    MONTO_ENVIADO NUMBER, 
    BENEFICIARIO_ID NUMBER, 
    TARIFA NUMBER, 
    NUM_CUENTA VARCHAR, 
    FECHA_ENVIO DATE, 
    FOLIO_RETENCION VARCHAR, 
    PAIS_ID_DESTINO NUMBER, 
    ESTADO_ID_DESTINO NUMBER, 
    CIUDAD_ID_DESTINO NUMBER, 
    ID_MONEDA_ENVIO NUMBER, 
    ID_MONEDA_DESTINO NUMBER,     
    NOMBRE_IMPUESTO VARCHAR,
    MONTO_IMPUESTO NUMBER, 
    ID_IMPUESTO NUMBER, 
    ID_IMPORTE NUMBER, 
    NOMBRE_CORTO_IMPUESTO VARCHAR, 
    ULTIMA_MODIFICACION DATE, 
    USUARIO_MODIFICO VARCHAR
)
AS
BEGIN
  INSERT INTO EBANKING.TRANSFER_DEX 
  VALUES(CLIENTE_ID, 
    MTCN, 
   MONTO_ENVIADO, 
   BENEFICIARIO_ID, 
   TARIFA, 
   NUM_CUENTA, 
   FECHA_ENVIO, 
   FOLIO_RETENCION, 
   PAIS_ID_DESTINO, 
   ESTADO_ID_DESTINO, 
   CIUDAD_ID_DESTINO, 
   ID_MONEDA_ENVIO, 
   ID_MONEDA_DESTINO, 
   ULTIMA_MODIFICACION, 
   USUARIO_MODIFICO);
  INSERT INTO EBANKING.IMPUESTO_DEX
  VALUES(
      MTCN, 
      NOMBRE_IMPUESTO,
      MONTO_IMPUESTO, 
      ID_IMPUESTO, 
      ID_IMPORTE, 
      NOMBRE_CORTO_IMPUESTO, 
      ULTIMA_MODIFICACION, 
      USUARIO_MODIFICO
  );
  EXCEPTION 
      WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR (-20102, 'Error al grabar la transaccion en NEBDPROD ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END InsertransDex;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERTTRACKING(ID_TRACKING IN NUMBER,IDUSUARIOOPERACION IN NUMBER,CODIGO_OPERACION IN NUMBER,ESTATUS IN VARCHAR)
AS

BEGIN

        INSERT INTO EBANKING.M_TRACKING 
        VALUES(ID_TRACKING,IDUSUARIOOPERACION,CODIGO_OPERACION,ESTATUS,'USRMNTR',SYSDATE);
        COMMIT;
        
EXCEPTION
     WHEN OTHERS THEN
        ROLLBACK;  
        

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           INSERTTRACKINGDE(idTRACKINGDETALLE IN NUMBER, ID_TRACKING IN NUMBER,CAMPO IN VARCHAR,
VALOR IN VARCHAR)

AS
BEGIN

        INSERT INTO EBANKING.M_TRACKING_DETALLE 
        VALUES(IDTRACKINGDETALLE,ID_TRACKING,CAMPO,VALOR,'USRMNTR',SYSDATE);
        COMMIT;
        
  EXCEPTION
        WHEN OTHERS THEN
        ROLLBACK;  
        

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERTUSUARIOS( PAFC_USERNAME IN VARCHAR2                 
                                                    ,PAFC_NOMBREAPLICACION IN VARCHAR2
                                                    ,PAFC_NOMBRECOMPLETO IN VARCHAR2 
                                                    ,PAFC_USR_ALNOVA IN VARCHAR2
                                                    ,PAFN_ISEMPLEADO IN NUMBER)
AS
    VL_IDUSER NUMBER;

BEGIN
    UPDATE  EBANKING.M_USUARIOS
        SET USRALNOVA = NVL(USRALNOVA, PAFC_USR_ALNOVA)
           ,EMPLEADO  = PAFN_ISEMPLEADO
        WHERE USER_NAME = PAFC_USERNAME
        AND APLICACION  = PAFC_NOMBREAPLICACION
        RETURNING IDUSUARIO
        INTO VL_IDUSER;
        COMMIT;

IF VL_IDUSER IS NULL THEN
        INSERT INTO EBANKING.M_USUARIOS FD(FD.IDUSUARIO,FD.USER_NAME,FD.APLICACION,FD.NOMBRECOMPLETO,FD.USUARIO_MODIFICO,FD.FECHA_OPERACION,FD.USRALNOVA, FD.EMPLEADO)
        VALUES(0,PAFC_USERNAME,PAFC_NOMBREAPLICACION,PAFC_NOMBRECOMPLETO,'USRMNTR',SYSDATE,PAFC_USR_ALNOVA,PAFN_ISEMPLEADO);
        COMMIT;

END IF;

  EXCEPTION
        WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        ROLLBACK;        
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERTUSUARIOSOP(IDUSUARIOOPERACION IN NUMBER, ID_USUARIO IN NUMBER,OPERACION IN VARCHAR)
AS
BEGIN
        INSERT INTO EBANKING.M_USUARIOS_OPERACIONES 
        VALUES(IDUSUARIOOPERACION,ID_USUARIO,OPERACION,'USRMNTR',SYSDATE);
        COMMIT;
        
  EXCEPTION
         WHEN OTHERS THEN
         ROLLBACK;  
        
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERT_EJB_CORE(
    P_EJB               IN  EBANKING.EJB_CORE.EJB%TYPE,
    P_DESCRIPCION       IN  EBANKING.EJB_CORE.DESCRIPCION%TYPE,
    P_STATUS            IN  EBANKING.EJB_CORE.STATUS%TYPE,
    P_USUARIO_MODIFICO  IN  EBANKING.EJB_CORE.USUARIO_MODIFICO%TYPE,
    P_RESULTADO         OUT VARCHAR2)
IS
BEGIN
 
  INSERT INTO EBANKING.EJB_CORE("EJB", "DESCRIPCION", "STATUS", "USUARIO_MODIFICO") 
  VALUES (P_EJB, P_DESCRIPCION, P_STATUS, P_USUARIO_MODIFICO);
  P_RESULTADO:='El EJB se agrego correctamente a la Base de Datos';
  dbms_output.put_line('EJB insertado correctamente');
  COMMIT;
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        P_RESULTADO:='El EJB ya existe en la Base de Datos';
        ROLLBACK;
    WHEN OTHERS THEN
        P_RESULTADO:='Error al insertar en la Base de Datos'; 
        ROLLBACK;
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           INSERT_EJB_METODOS_CORE(entrada_usuario	IN	SYS_REFCURSOR , RESULTADO OUT BOOLEAN)


IS
    TYPE TABLA_METODOS IS RECORD (
       METODO            VARCHAR2(60) ,
       EJB              VARCHAR2(60) ,
       DESCRIPCION          VARCHAR2(80) ,
       STATUS                       VARCHAR2(2)  ,
       ULTIMA_MODIFICACION  DATE         ,
       USUARIO_MODIFICO     VARCHAR2(30) 
    );

    TABLA_METODOS_CURSOR TABLA_METODOS;


BEGIN

 
    -- Open the incoming Salaries REFerence CURsor
    LOOP
        FETCH entrada_usuario INTO TABLA_METODOS_CURSOR;
        
        EXIT WHEN entrada_usuario%NOTFOUND;
                 DBMS_OUTPUT.PUT_LINE('no hay datos');

    END LOOP;

    RESULTADO:= TRUE;

EXCEPTION
    WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('Fatal error encountered!');
        RESULTADO:= TRUE;
       
END INSERT_EJB_METODOS_CORE;
/

SHOW ERRORS;


CREATE OR REPLACE procedure          INSERT_IUPI_FREQ (
    P_ID_CLIENTE IN EBANKING.IUPIFRECUENT.ID_CLIENTE%TYPE,
    P_ALIAS IN EBANKING.IUPIFRECUENT.APODO%TYPE,
    P_CUENTA_DESTINO IN EBANKING.IUPIFRECUENT.CUENTA_DESTINO%TYPE,
    P_IP_ORIGEN IN EBANKING.IUPIFRECUENT.IP_ORIGEN%TYPE,
    P_EMAIL_DESTINO IN EBANKING.IUPIFRECUENT.EMAIL_DESTINO%TYPE
)
IS
BEGIN
       INSERT INTO EBANKING.IUPIFRECUENT(ID_CLIENTE,APODO,FECHA_MODIFICACION,CUENTA_DESTINO,IP_ORIGEN,  STATUS, CANAL, EMAIL_DESTINO)
              VALUES (P_ID_CLIENTE,P_ALIAS,SYSDATE,P_CUENTA_DESTINO,P_IP_ORIGEN,1,'NET',P_EMAIL_DESTINO);
              COMMIT; 
   EXCEPTION
     WHEN OTHERS THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20000, 'Error al insertar cuenta en EBANKING.INSERT_IUPI_FREQ  (' || SQLCODE || '  ' || SQLERRM || ')');
END INSERT_IUPI_FREQ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           INSERT_METODOS_EJB_CORE(entrada_usuario	IN	SYS_REFCURSOR , RESULTADO OUT BOOLEAN)


IS
    TYPE TABLA_METODOS IS RECORD (
       METODO            VARCHAR2(60) ,
       EJB              VARCHAR2(60) ,
       DESCRIPCION          VARCHAR2(80) ,
       STATUS                       VARCHAR2(2)  ,
       ULTIMA_MODIFICACION  DATE         ,
       USUARIO_MODIFICO     VARCHAR2(30) 
    );

    TABLA_METODOS_CURSOR TABLA_METODOS;


BEGIN

 
    -- Open the incoming Salaries REFerence CURsor
    LOOP
        FETCH entrada_usuario INTO TABLA_METODOS_CURSOR;
        
        EXIT WHEN entrada_usuario%NOTFOUND;
                 DBMS_OUTPUT.PUT_LINE('no hay datos');

    END LOOP;

    RESULTADO:= TRUE;

EXCEPTION
    WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('Fatal error encountered!');
        RESULTADO:= TRUE;
       
END INSERT_METODOS_EJB_CORE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE INSERT_RMASMS(
	   	  		   SMSKEY IN NUMBER
				  ,ALNOVA_CLIENT IN VARCHAR2
				  ,ACCOUNT_NUMBER IN VARCHAR2
				  ,PHONE IN VARCHAR2
				  ,CARRIER_ID IN NUMBER
				  ,ACTIVATION_DATE IN DATE
				  ,CANCEL_DATE IN DATE
				  ,STATUS IN VARCHAR2
				  ,SISTEMA IN VARCHAR2
				  ,PAIS IN VARCHAR2
				  ,USUARIO_MODIFICO IN VARCHAR2
   				  ,PASMSG_ERROR  OUT VARCHAR2
				  )
IS

BEGIN   
   
   INSERT INTO
	   EBANKING.EBANKING_RMASMS 
	VALUES
	(
		 SMSKEY
		,ALNOVA_CLIENT
		,ACCOUNT_NUMBER
		,PHONE
		,CARRIER_ID
		,to_date(ACTIVATION_DATE,'dd-mm-YYYY')
		,CANCEL_DATE
		,STATUS
		,SISTEMA
		,PAIS
		,to_date(ACTIVATION_DATE,'dd-mm-YYYY')
		,USUARIO_MODIFICO
	);
	COMMIT;
PASMSG_ERROR := 'EXITOSO';
	   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
	 	  PASMSG_ERROR := SQLCODE || ' ERROR SP_INSERT_RMASMS' || SQLERRM;
          ROLLBACK; 
		  RAISE;
END INSERT_RMASMS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          INSERT_USER_PRE (    
TITULAR                      IN     varchar2,EMAIL                        IN     varchar2,
IP                           IN     varchar2,NUM_SERIE_TOKEN              IN     varchar2,
TEL_PARTICULAR               IN     varchar2,TEL_CELULAR                  IN     varchar2,
CARRIER_CEL                  IN     varchar2,NUM_CLIENTE                  IN     varchar2,
ESTATUS                      IN     varchar2,MOTIVO_PREV_FRAUDE           IN     varchar2,
ALIAS                        IN     varchar2,TIPO_OPERACION               IN     varchar2,
SISTEMA                      IN     varchar2,IDPAIS                       IN     varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2) IS

BEGIN
        
    INSERT INTO EBANKING_TOKEN_PREVENCION T(T.TITULAR,T.EMAIL,
                                           T.IP,T.NUM_SERIE_TOKEN,
                                           T.TEL_PARTICULAR,T.TEL_CELULAR,
                                           T.CARRIER_CEL,T.NUM_CLIENTE,
                                           T.ESTATUS,T.MOTIVO_PREV_FRAUDE,
                                           T.ALIAS,T.TIPO_OPERACION,
                                           T.SISTEMA,T.IDPAIS)
		                            VALUES (TITULAR,EMAIL,
                                           IP,NUM_SERIE_TOKEN,
                                           TEL_PARTICULAR,TEL_CELULAR,
                                           CARRIER_CEL,NUM_CLIENTE,
                                           ESTATUS,MOTIVO_PREV_FRAUDE,
                                           ALIAS,TIPO_OPERACION,
                                           SISTEMA,IDPAIS);
                                           
    COMMIT;
    
    PSCod_Error := 0;
    PSMsg_Error := 'insert en EBANKING_TOKEN_PREVENCION correcto';

    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar en EBANKING_TOKEN_PREVENCION (' || SQLCODE || '  ' || SQLERRM || ')');
END INSERT_USER_PRE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            IS_TOKE_USO_RSA (
V_NUM_SERIE_TOKEN              IN     TOKENADMINPRU.STATUS_RSA.NUM_SERIE_TOKEN%TYPE,
V_NUM_CLIENTE_OUT              OUT    TOKENADMINPRU.STATUS_RSA.NUM_CLIENTE%TYPE,
V_STATUS                       OUT    TOKENADMINPRU.STATUS_RSA.STATUS%TYPE,
V_TIPO                         OUT    TOKENADMINPRU.STATUS_RSA.TIPO%TYPE
)
IS
BEGIN
     SELECT NUM_CLIENTE, STATUS, TIPO INTO V_NUM_CLIENTE_OUT, V_STATUS, V_TIPO FROM TOKENADMINPRU.STATUS_RSA WHERE NUM_SERIE_TOKEN = V_NUM_SERIE_TOKEN;
EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_NUM_CLIENTE_OUT:=0;
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar IS_TOKE_USO_RSA (' || SQLCODE || '  ' || SQLERRM || ')');
END  IS_TOKE_USO_RSA ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          IS_USER_ACTIVE (
V_ID                           IN     EBANKING.EBANKING_USER.ID%TYPE,
PSCod_Error                    OUT    NUMBER,
PSMsg_Error                    OUT    VARCHAR2) IS
NUM_COUNT INTEGER;
ACTIVO INTEGER :=1;
BEGIN

  SELECT COUNT(1) INTO NUM_COUNT FROM EBANKING.EBANKING_USER where ID=V_ID AND ACTIVE = ACTIVO;
    
   IF (NUM_COUNT>0) THEN
     PSCod_Error := 1;
     PSMsg_Error := 'El usuario '|| V_ID||' se enecuentra activo';
   ELSE
     PSCod_Error := 0;
     PSMsg_Error := 'El usuario '|| V_ID||' se enecuentra bloqueado por inactividad';
   END IF;
   
   EXCEPTION                
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar IS_USER_ACTIVE (' || SQLCODE || '  ' || SQLERRM || ')');

END IS_USER_ACTIVE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            IS_USER_ACT_RSA (
V_NUM_CLIENTE_IN          IN     TOKENADMINPRU.STATUS_RSA.NUM_CLIENTE%TYPE,
V_TIPO_TOKEN_IN           IN     TOKENADMINPRU.STATUS_RSA.TIPO%TYPE,
V_STATUS_OUT              OUT    TOKENADMINPRU.STATUS_RSA.STATUS%TYPE
)
IS
BEGIN
     SELECT STATUS INTO V_STATUS_OUT FROM TOKENADMINPRU.STATUS_RSA 
            WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN 
            AND TIPO = V_TIPO_TOKEN_IN
            AND STATUS IN (1,2) ;
EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_STATUS_OUT:=0;
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar IS_USER_ACT_RSA (' || SQLCODE || '  ' || SQLERRM || ')');
END  IS_USER_ACT_RSA ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE loadarray IS
      TYPE cust_table_type IS TABLE OF VARCHAR2(100)
           INDEX BY BINARY_INTEGER;
      cust_table  cust_table_type;
    BEGIN
      FOR crec IN (select ID, EMAIL AS name from EBANKING.EBANKING_USER) LOOP
        cust_table(CREC.ID) := crec.name;
      END LOOP;
      dbms_output.put_line(cust_table(21000303));
   END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_OPS_DIS(
V_SISTEMA               IN     TOKENADMINPRU.HIST_DISP.SISTEMA%TYPE,
V_TIPO                  IN     TOKENADMINPRU.HIST_DISP.TIPO%TYPE,
V_OPERACION             IN     TOKENADMINPRU.HIST_DISP.OPERACION%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.HIST_DISP
    WHERE SISTEMA = V_SISTEMA
    AND TIPO = V_TIPO
    AND OPERACION = V_OPERACION
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_OPS_DIS (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_OPS_DIS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_OPS_RSA(
V_OPERACION                IN     TOKENADMINPRU.HIST_RSA.OPERACION%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.HIST_RSA
    WHERE OPERACION = V_OPERACION
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_OPS_RSA (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_OPS_RSA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_OPS_TAR(
V_OPERACION             IN     TOKENADMINPRU.HIST_TARJETA.OPERACION%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.HIST_TARJETA
    WHERE OPERACION = V_OPERACION
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_OPS_TAR (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_OPS_TAR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_STD_DIS(
V_SISTEMA               IN     TOKENADMINPRU.STATUS_DISP.SISTEMA%TYPE,
V_TIPO                  IN     TOKENADMINPRU.STATUS_DISP.TIPO%TYPE,
V_ESTADO                IN     TOKENADMINPRU.STATUS_DISP.ESTADO%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.STATUS_DISP
    WHERE SISTEMA = V_SISTEMA
    AND TIPO = V_TIPO
    AND ESTADO= V_ESTADO
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_STD_DIS (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_STD_DIS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_STD_RSA(
V_STATUS                IN     TOKENADMINPRU.STATUS_RSA.STATUS%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.STATUS_RSA
    WHERE STATUS = V_STATUS
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_STD_RSA (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_STD_RSA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_CNT_STD_TAR(
V_STATUS                IN     TOKENADMINPRU.STATUS_TARJETA.STATUS%TYPE,
V_FECHA_A               IN     VARCHAR2,
V_FECHA_B               IN     VARCHAR2,
V_COUNT_REGISTROS       OUT    NUMBER,       
PSCod_Error             OUT    NUMBER,
PSMsg_Error             OUT    VARCHAR2
)
AS
    BAD_FORMAT EXCEPTION;
    PRAGMA EXCEPTION_INIT(BAD_FORMAT, -01861);
BEGIN
    SELECT COUNT(1) INTO V_COUNT_REGISTROS FROM TOKENADMINPRU.STATUS_TARJETA
    WHERE STATUS = V_STATUS
    AND ULTIMA_MODIFICACION >= TO_DATE(V_FECHA_A,'YYYY-MM-DD-HH24-MI-SS')
    AND ULTIMA_MODIFICACION <= TO_DATE(V_FECHA_B,'YYYY-MM-DD-HH24-MI-SS');
    PSCod_Error := 0;
    PSMsg_Error := 'Se contaron correctamente los registros';
EXCEPTION
         WHEN BAD_FORMAT THEN
            PSCod_Error := -2;
            PSMsg_Error := 'Fecha con formato incorrecto';
         WHEN NO_DATA_FOUND THEN
            PSCod_Error := -1;
            PSMsg_Error := 'No se encontraron registros';
         WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al realizar consulta';
            RAISE_APPLICATION_ERROR (-20100, 'ERROR EN MNT_CNT_STD_TAR (' || SQLCODE || '  ' || SQLERRM || ')');
END MNT_CNT_STD_TAR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_FAM_USR (
V_NUM_CLIENTE               IN    TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
V_ESTADO_1                  IN    varchar2,
V_ESTADO_2                  IN    varchar2,
V_ESTADO_3                  IN    varchar2,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_CLIENTE              OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
          SELECT ID_ACT_DISPOSITIVO, 
                NUM_CLIENTE, 
                SEMILLA, 
                ESTADO, 
                DESFASE, 
                SINCRONIZACIONES, 
                SISTEMA, 
                PAIS, 
                VERSION, 
                SOPERATIVO , 
                NUM_MODELO,
                NUM_TELEFONO, 
                CORREO_ELECTONICO, 
                TO_CHAR(ULTIMA_SINCRONIZACION,'DD-MM-YYYY HH24:MI:SS') ULTIMA_SINCRONIZACION, 
                TO_CHAR(ULTIMA_AUTENTICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_AUTENTICACION, 
                TO_CHAR(FECHA_ACTIVACION, 'DD-MM-YYYY HH24:MI:SS') FECHA_ACTIVACION,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
                USUARIO_MODIFICO, 
                TIPO     
            FROM TOKENADMINPRU.STATUS_DISP 
            WHERE NUM_CLIENTE = V_NUM_CLIENTE
            AND (ESTADO =V_ESTADO_1 OR ESTADO =V_ESTADO_2 OR ESTADO = V_ESTADO_3 )
            ORDER BY FECHA_ACTIVACION DESC ;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_FAM_USR correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_FAM_USR (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_FAM_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_BIT_TRANS (
V_NUM_CLIENTE                  IN     TOKENADMINPRU.BIT_TRANSACCION.NUM_CLIENTE%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_TRANSACCIONES           OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_TRANSACCIONES FOR
        SELECT  ID_TRANSACCION, 
                NUM_CLIENTE, 
                DISPOSITIVO, 
                RESULTADO_AUTH,
                IP_CLIENTE,
                IP_INSTANCIA,
                SISTEMA,
                TO_CHAR(FECHA_AUTH, 'DD-MM-YYYY HH24:MI:SS')  FECHA_AUTH,
                USUARIO_MODIFICO,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION
            FROM TOKENADMINPRU.BIT_TRANSACCION
            WHERE NUM_CLIENTE = V_NUM_CLIENTE
            ORDER BY FECHA_AUTH DESC;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_BIT_TRANS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar BITACORA TRANSACCION';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_BIT_TRANS (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_BIT_TRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_MODELOS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_MODELOS                OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_MODELOS FOR
        SELECT ID, 
                NUM_MODELO, 
                SISTEMA_OPERATIVO, 
                DESCRIPCION,
                TIPO,
                ID_SISTEMA,
                ACTIVO,
                VERSION,
                STORE,
                STORE_URL,
                USUARIO_MODIFICO,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION
            FROM TOKENADMINPRU.CAT_VER_FAM
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_MODELOS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO MODELOS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_MODELOS (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_MODELOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_QUEMADOS_DIS (
V_ID_ALNOVA        IN    TOKENADMINPRU.QUEMADO_TKN_DIS.ID_ALNOVA%TYPE,
PSCod_Error       OUT    number,
PSMsg_Error       OUT    varchar2,
CURSOR_DIS        OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_DIS FOR
        SELECT ID_ALNOVA, 
                TOKEN,
                TIPO,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
                USUARIO_MODIFICO
        FROM TOKENADMINPRU.QUEMADO_TKN_DIS
        WHERE ID_ALNOVA = V_ID_ALNOVA
            ORDER BY ULTIMA_MODIFICACION DESC;               
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_QUEMADOS_DIS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consulDIS MNT_GET_QUEMADOS_DIS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_QUEMADOS_DIS (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_QUEMADOS_DIS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_QUEMADOS_TAR (
V_ID_ALNOVA        IN    TOKENADMINPRU.QUEMADO_TKN_TAR.ID_ALNOVA%TYPE,
PSCod_Error       OUT    number,
PSMsg_Error       OUT    varchar2,
CURSOR_TAR        OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_TAR FOR
        SELECT ID_ALNOVA, 
                ID_TARJETA, 
                TOKEN,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
                USUARIO_MODIFICO
        FROM TOKENADMINPRU.QUEMADO_TKN_TAR
        WHERE ID_ALNOVA = V_ID_ALNOVA
            ORDER BY ULTIMA_MODIFICACION DESC;               
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_QUEMADOS_TAR correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar MNT_GET_QUEMADOS_TAR';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_QUEMADOS_TAR (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_QUEMADOS_TAR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_SISTEMAS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_SISTEMAS                OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_SISTEMAS FOR
        SELECT     ID, 
                ID_SISTEMA, 
                DESCRIPCION,
                USUARIO_MODIFICO,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION
            FROM TOKENADMINPRU.CAT_SISTEMA
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_SISTEMAS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO SISTEMAS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_SISTEMAS (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_SISTEMAS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_SIST_OPE (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_SISOP                   OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_SISOP FOR
        SELECT ID_SISTEMA, 
                NOMBRE, 
                DESCRIPCION,
                USUARIO_MODIFICO,
                TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION
            FROM TOKENADMINPRU.CAT_VER_SOPERAT
            ORDER BY ID_SISTEMA;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_SIST_OPE correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO SIST OPE';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_SIST_OPE (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_SIST_OPE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_GET_TIPOS (
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,
CURSOR_TIPOS                   OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_TIPOS FOR
        SELECT ID, 
                NOMBRE, 
                DESCRIPCION,
                USUARIO_MODIFICO,
                ULTIMA_MODIFICACION
            FROM TOKENADMINPRU.CAT_TIPO_FAM
            ORDER BY ID;    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_GET_TIPOS correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar CATALOGO TIPOS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_GET_TIPOS (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_GET_TIPOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_HIST_DSP (
V_NUM_CLIENTE               IN    TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
CURSOR_CLIENTE              OUT    sys_refcursor,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT NUM_CLIENTE, 
           SEMILLA, 
           SISTEMA, 
           OPERADOR, 
           SUCURSAL, 
           OPERACION, 
           IDPAIS, 
           VERSION, 
           SOPERATIVO,
           IP_SUCURSAL_TERMINAL, 
           TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
           USUARIO_MODIFICO, 
           TIPO     
    FROM TOKENADMINPRU.HIST_DISP 
    WHERE NUM_CLIENTE = V_NUM_CLIENTE
    ORDER BY ULTIMA_MODIFICACION DESC ;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_HIST_DSP correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_HIST_DSP (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_HIST_DSP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_HIST_RSA_SER (
V_NUM_SERIE_TOKEN           IN    TOKENADMINPRU.HIST_RSA.NUM_SERIE_TOKEN%TYPE,
CURSOR_CLIENTE              OUT    sys_refcursor,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT NUM_CLIENTE, 
           NUM_SERIE_TOKEN,
           TIPO, 
           TO_CHAR(FECHA_APLICACION, 'DD-MM-YYYY HH24:MI:SS')  FECHA_APLICACION,
           IP_SUCURSAL_TERMINAL, 
           OPERADOR, 
           SUCURSAL,
           OPERACION,
           SISTEMA, 
           IDPAIS, 
           TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
           USUARIO_MODIFICO  
    FROM TOKENADMINPRU.HIST_RSA 
    WHERE NUM_SERIE_TOKEN   = V_NUM_SERIE_TOKEN
    ORDER BY ULTIMA_MODIFICACION DESC;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_HIST_RSA_SER correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_HIST_RSA_SER (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_HIST_RSA_SER ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_HIST_RSA_USR (
V_NUM_CLIENTE               IN    TOKENADMINPRU.HIST_RSA.NUM_CLIENTE%TYPE,
CURSOR_CLIENTE              OUT    sys_refcursor,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT NUM_CLIENTE, 
           NUM_SERIE_TOKEN,
           TIPO, 
           TO_CHAR(FECHA_APLICACION, 'DD-MM-YYYY HH24:MI:SS')  FECHA_APLICACION,
           IP_SUCURSAL_TERMINAL, 
           OPERADOR, 
           SUCURSAL,
           OPERACION,
           SISTEMA, 
           IDPAIS, 
           TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
           USUARIO_MODIFICO  
    FROM TOKENADMINPRU.HIST_RSA 
    WHERE NUM_CLIENTE = V_NUM_CLIENTE
    ORDER BY ULTIMA_MODIFICACION DESC;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_HIST_RSA_USR correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_HIST_RSA_USR (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_HIST_RSA_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_HIST_TAR_NUM(
V_NUMERO_TARJETA             IN    TOKENADMINPRU.HIST_TARJETA.NUMERO_TARJETA%TYPE,
CURSOR_CLIENTE              OUT    sys_refcursor,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT  NUM_CLIENTE,
            NUMERO_TARJETA,
            TO_CHAR(FECHA_APLICACION, 'DD-MM-YYYY HH24:MI:SS') FECHA_APLICACION,
            IP_SUCURSAL_TERMINAL,
            OPERADOR,
            SUCURSAL,
            OPERACION,
            SISTEMA,
            IDPAIS,
            TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
            USUARIO_MODIFICO
    FROM TOKENADMINPRU.HIST_TARJETA 
    WHERE NUMERO_TARJETA  = V_NUMERO_TARJETA
    ORDER BY ULTIMA_MODIFICACION DESC;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_HIST_TAR_NUMcorrectamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_HIST_TAR_NUM (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_HIST_TAR_NUM ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_HIST_TAR_USR(
V_NUM_CLIENTE                 IN    TOKENADMINPRU.HIST_TARJETA.NUM_CLIENTE%TYPE,
CURSOR_CLIENTE              OUT    sys_refcursor,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
    SELECT  NUM_CLIENTE,
            NUMERO_TARJETA,
            TO_CHAR(FECHA_APLICACION, 'DD-MM-YYYY HH24:MI:SS') FECHA_APLICACION,
            IP_SUCURSAL_TERMINAL,
            OPERADOR,
            SUCURSAL,
            OPERACION,
            SISTEMA,
            IDPAIS,
            TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS')  ULTIMA_MODIFICACION,
            USUARIO_MODIFICO
    FROM TOKENADMINPRU.HIST_TARJETA 
    WHERE NUM_CLIENTE  = V_NUM_CLIENTE
    ORDER BY ULTIMA_MODIFICACION DESC;         
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_HIST_TAR_NUMcorrectamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_HIST_TAR_NUM (' || SQLCODE || '  ' || SQLERRM || ')');
END  MNT_HIST_TAR_USR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_RSA_SER (
V_NUM_SERIE                 IN    TOKENADMINPRU.STATUS_RSA.NUM_SERIE_TOKEN%TYPE,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_CLIENTE              OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR           
    SELECT      
            ID, 
            NUM_CLIENTE, 
            NUM_SERIE_TOKEN, 
            STATUS, 
            TO_CHAR(FECHA_MODIFICACION,'DD-MM-YYYY HH24:MI:SS') FECHA_MODIFICACION, 
            TO_CHAR(FECHA_ACTIVACION, 'DD-MM-YYYY HH24:MI:SS') FECHA_ACTIVACION, 
            SISTEMA, 
            IDPAIS, 
            TIPO, 
            TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_MODIFICACION,
            USUARIO_MODIFICO
        FROM TOKENADMINPRU.STATUS_RSA
        WHERE NUM_SERIE_TOKEN = V_NUM_SERIE
        ORDER BY FECHA_ACTIVACION DESC;         
   
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_RSA_SER correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_RSA_SER  (' || SQLCODE || '  ' || SQLERRM || ')');

END  MNT_RSA_SER ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_RSA_USR (
V_NUM_CLIENTE               IN    TOKENADMINPRU.STATUS_RSA.NUM_CLIENTE%TYPE,
V_ESTADO_1                  IN    varchar2,
V_ESTADO_2                  IN    varchar2,
V_ESTADO_3                  IN    varchar2,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_CLIENTE              OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR           
    SELECT      
        ID, 
        NUM_CLIENTE, 
        NUM_SERIE_TOKEN, 
        STATUS, 
        TO_CHAR(FECHA_MODIFICACION,'DD-MM-YYYY HH24:MI:SS') FECHA_MODIFICACION, 
        TO_CHAR(FECHA_ACTIVACION, 'DD-MM-YYYY HH24:MI:SS') FECHA_ACTIVACION, 
        SISTEMA, 
        IDPAIS, 
        TIPO, 
        TO_CHAR(ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_MODIFICACION,
        USUARIO_MODIFICO
            FROM TOKENADMINPRU.STATUS_RSA
            WHERE NUM_CLIENTE = V_NUM_CLIENTE
            AND (STATUS = V_ESTADO_1 OR STATUS = V_ESTADO_2 OR STATUS = V_ESTADO_3)
        ORDER BY FECHA_ACTIVACION DESC;         
   
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_RSA_USR correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_RSA_USR  (' || SQLCODE || '  ' || SQLERRM || ')');

END  MNT_RSA_USR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_TAR_NUM (
V_NUM_TARJETA               IN    TOKENADMINPRU.STATUS_TARJETA.ID_TARJETA%TYPE,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_CLIENTE              OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
          SELECT 
                ID_TARJETA, 
                ID_ALNOVA, 
                STATUS, 
                DESFASE, 
                SINCRONIZACIONES, 
                TO_CHAR(FECHA_ACTIVACION,'DD-MM-YYYY HH24:MI:SS') FECHA_ACTIVACION, 
                TO_CHAR(FECHA_MODIF, 'DD-MM-YYYY HH24:MI:SS') FECHA_MODIF,
                TO_CHAR( ULTIMA_SINCRONIZACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_SINCRONIZACION,
                TO_CHAR( ULTIMA_AUTENTICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_AUTENTICACION,
                SISTEMA, 
                PAIS, 
                TO_CHAR( ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_MODIFICACION,
                USUARIO_MODIFICO                     
            FROM TOKENADMINPRU.STATUS_TARJETA 
            WHERE ID_TARJETA = V_NUM_TARJETA
            ORDER BY FECHA_ACTIVACION DESC ;         
   
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_TAR_NUM correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_TAR_NUM (' || SQLCODE || '  ' || SQLERRM || ')');

END MNT_TAR_NUM;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            MNT_TAR_USR (
V_NUM_CLIENTE               IN    TOKENADMINPRU.STATUS_TARJETA.ID_ALNOVA%TYPE,
V_ESTADO_1                  IN    varchar2,
V_ESTADO_2                  IN    varchar2,
V_ESTADO_3                  IN    varchar2,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2,
CURSOR_CLIENTE              OUT    sys_refcursor
)
IS
BEGIN
    OPEN CURSOR_CLIENTE FOR   
          SELECT 
                ID_TARJETA, 
                ID_ALNOVA, 
                STATUS, 
                DESFASE, 
                SINCRONIZACIONES, 
                TO_CHAR(FECHA_ACTIVACION,'DD-MM-YYYY HH24:MI:SS') FECHA_ACTIVACION, 
                TO_CHAR(FECHA_MODIF, 'DD-MM-YYYY HH24:MI:SS') FECHA_MODIF,
                TO_CHAR( ULTIMA_SINCRONIZACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_SINCRONIZACION,
                TO_CHAR( ULTIMA_AUTENTICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_AUTENTICACION,
                SISTEMA, 
                PAIS, 
                TO_CHAR( ULTIMA_MODIFICACION, 'DD-MM-YYYY HH24:MI:SS') ULTIMA_MODIFICACION,
                USUARIO_MODIFICO                     
            FROM TOKENADMINPRU.STATUS_TARJETA 
            WHERE ID_ALNOVA = V_NUM_CLIENTE
            AND (STATUS = V_ESTADO_1 OR STATUS = V_ESTADO_2 OR STATUS = V_ESTADO_3 )
            ORDER BY FECHA_ACTIVACION DESC ;         
   
    PSCod_Error := 0;
    PSMsg_Error := 'consulta en MNT_TAR_USR correctamente ';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar MNT_TAR_USR (' || SQLCODE || '  ' || SQLERRM || ')');

END MNT_TAR_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            NEW_MONITOR_USER (       
 V_USERNAME             IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,         
 V_PASSWORD             IN     TOKENADMINPRU.USUARIOS_TOKEN.PASSWORD%TYPE,          
 V_ENABLED              IN     TOKENADMINPRU.USUARIOS_TOKEN.ENABLED%TYPE,
 V_MODIFICO             IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,
 PSCod_Error            OUT    number,
 PSMsg_Error            OUT    varchar2
)
AS
     UNIQ_VIOLATED EXCEPTION;
     PRAGMA EXCEPTION_INIT(UNIQ_VIOLATED, -00001);
     V_CHECKSUM VARCHAR(50);
BEGIN
     V_CHECKSUM := UTL_RAW.CAST_TO_RAW(DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING => V_PASSWORD));
     INSERT INTO TOKENADMINPRU.USUARIOS_TOKEN(     
            USERNAME, PASSWORD, ENABLED, USUARIO_MODIFICO, ULTIMA_MODIFICACION
     )VALUES( 
            V_USERNAME, V_CHECKSUM, V_ENABLED, V_MODIFICO, SYSDATE
     );
     PSCod_Error := 0;
     PSMsg_Error := 'Usuario creado correctamente';
EXCEPTION
        WHEN UNIQ_VIOLATED THEN
            PSCod_Error:=-1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al crear el cliente';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar NEW_MONITOR_USER (' || SQLCODE || '  ' || SQLERRM || ')');
END  NEW_MONITOR_USER ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE OBTAIN_CELL_COMPANIES ( 
CELL_COMPANIES              OUT     sys_refcursor
) IS

BEGIN

	 OPEN CELL_COMPANIES FOR
	 	  select
		  		EBANKING.CARRIER.carrier_id,
				EBANKING.CARRIER.descripcion,
				EBANKING.CARRIER.status 
		  from 
		  	   EBANKING.CARRIER 
		  where
		  	   status = 1;

  	 EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al llamar OBTAIN_CELL_COMPANIES (' || SQLCODE || '  ' || SQLERRM || ')');
END OBTAIN_CELL_COMPANIES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          Operacion
(
 TIPOOPERACION NUMBER,
 P_NOMBRE IN EBANKING.USUARIO.NOMBRE %TYPE,
 P_USUARIO IN EBANKING.USUARIO.USUARIO %TYPE,
 P_CONTRASENA IN EBANKING.USUARIO.CONTRASENA %TYPE,
 P_TELEFONO IN EBANKING.USUARIO.TELEFONO %TYPE,
 P_ID IN EBANKING.USUARIO.ID_USUARIO %TYPE,
 S_CURSOR OUT EBANKING.TYPES.REFCURSOR
 )
 AS
 BEGIN
  IF(TIPOOPERACION=1) THEN
    INSERT INTO Usuario( ID_USUARIO, NOMBRE, USUARIO, CONTRASENA, TELEFONO) 
    VALUES(EBANKING.SQ_ID.NEXTVAL, LTRIM(RTRIM(P_NOMBRE)), LTRIM(RTRIM(P_USUARIO)), LTRIM(RTRIM(P_CONTRASENA)), LTRIM(RTRIM(P_TELEFONO)));
  
  ELSE IF(TIPOOPERACION=2)THEN 
    UPDATE Usuario SET NOMBRE=LTRIM(RTRIM(P_NOMBRE)), CONTRASENA=LTRIM(RTRIM(P_CONTRASENA)), TELEFONO=LTRIM(RTRIM(P_TELEFONO)),
    USUARIO=LTRIM(RTRIM(P_USUARIO)) WHERE ID_USUARIO=LTRIM(RTRIM(P_ID));
 
  ELSE IF (TIPOOPERACION=3)THEN
    DELETE Usuario WHERE ID_USUARIO = LTRIM(RTRIM(P_ID));
    
  ELSE IF (TIPOOPERACION=4)THEN
    OPEN S_CURSOR FOR SELECT ID_USUARIO, NOMBRE, USUARIO, CONTRASENA, TELEFONO FROM EBANKING.USUARIO
    WHERE LTRIM(RTRIM(USUARIO))= LTRIM(RTRIM(P_USUARIO));
    
  ELSE IF (TIPOOPERACION=5)THEN
    OPEN S_CURSOR FOR SELECT USUARIO, CONTRASENA FROM EBANKING.USUARIO
    WHERE USUARIO = LTRIM(RTRIM(P_USUARIO)) AND CONTRASENA = LTRIM(RTRIM(P_CONTRASENA));
    
  ELSE
    OPEN S_CURSOR FOR SELECT ID_USUARIO, NOMBRE,USUARIO,CONTRASENA,TELEFONO FROM EBANKING.USUARIO ORDER BY ID_USUARIO ASC;

END IF;
END IF;
END IF;
END IF;
END IF;
COMMIT;
EXCEPTION
WHEN OTHERS THEN
RAISE_APPLICATION_ERROR
      (
        -20100, 'Error ocurrido en el Store Operacion  ( * ' || SQLCODE || '  ' || SQLERRM || ' *)'
      );
END;
/

SHOW ERRORS;


CREATE OR REPLACE procedure printHello
is
begin
DBMS_OUTPUT.PUT_LINE('Hello World!');
 
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE PRTransactionPF
       (p_fechaini IN VARCHAR2,
        p_fechafin IN VARCHAR2)
AS

 	   contador NUMBER:=0;

	   CURSOR cemp2 IS
			 select sum(m.importe)        M_IMPORTE,
			        m.operacion           M_OPERACION,
					sum(m.movimiento)     M_MOV,
					to_char(m.fecha,'MM') MONTH,
					to_char(m.fecha,'YY') YEAR,
			        count(a.cliente)      C_CLINTE
			  from ebanking.movimientos m, ebanking.operaciones_cli a
			 where TO_CHAR(a.fecha(+),'YYYY') = TO_CHAR(m.fecha,'YYYY')
			   and TO_CHAR(a.fecha(+),'MM') = TO_CHAR(m.fecha,'MM')
			   and TO_CHAR(a.fecha(+),'DD') = TO_CHAR(m.fecha,'DD')
			   and a.operacion(+) = m.operacion
			   and m.fecha >= TO_DATE(p_fechaini,'dd/mm/yyyy')
               and m.fecha <= TO_DATE(p_fechafin,'dd/mm/yyyy')
			 GROUP BY TO_CHAR(m.fecha,'MM'),TO_CHAR(m.fecha,'YY'),m.operacion;

       cepm_rec cemp2%ROWTYPE;

	 BEGIN
       FOR cemp_rec IN cemp2
       LOOP

	     contador:=0;

	     DBMS_OUTPUT.PUT_LINE(cemp_rec.M_IMPORTE || '@' ||
		                      cemp_rec.M_OPERACION || '@' ||
							  cemp_rec.M_MOV || '@' ||
							  cemp_rec.YEAR || '@' ||
							  cemp_rec.C_CLINTE
							  );


       END LOOP;
     END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE pruebas (p_cuenta_abono  IN varchar2, p_recordset OUT SYS_REFCURSOR) AS

BEGIN
  OPEN p_recordset FOR
    SELECT * FROM ebanking.transfinternalfrecuent;
END pruebas;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            "PRUEBA_STORE" (CURSOR_PRUEBA OUT CURSOR) AS
BEGIN
  OPEN CURSOR_PRUEBA FOR
  SELECT * 
    FROM FIAR_CLIENTES;
END PRUEBA_STORE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE P_ADDDATOSGEN
(
           PA_APATERNO             IN    CUENTASELECTA.TA_TITULAR.APATERNO%TYPE
          ,PA_AMATERNO             IN    CUENTASELECTA.TA_TITULAR.AMATERNO%TYPE
          ,PA_NOMBRE               IN    CUENTASELECTA.TA_TITULAR.NOMBRE%TYPE
          ,PA_SEXO                 IN    CUENTASELECTA.TA_TITULAR.SEXO%TYPE
          ,PA_EDOCIVIL             IN    CUENTASELECTA.TA_TITULAR.EDOCIVIL%TYPE
          ,PA_FENACIMIENTO         IN    CUENTASELECTA.TA_TITULAR.FENACIMIENTO%TYPE
          ,PA_NACIONALIDAD         IN    CUENTASELECTA.TA_TITULAR.NACIONALIDAD%TYPE
          ,PA_RFC                  IN    CUENTASELECTA.TA_TITULAR.RFC%TYPE
          ,PA_CURP                 IN    CUENTASELECTA.TA_TITULAR.CURP%TYPE
          ,PA_TIPOIDENT            IN    CUENTASELECTA.TA_TITULAR.TIPOIDENTIFICACION%TYPE
          ,PA_NUMIDENT             IN    CUENTASELECTA.TA_TITULAR.NUMIDENTIFICACION%TYPE
          ,PA_EMAIL                IN    CUENTASELECTA.TA_TITULAR.EMAIL%TYPE
          ,PA_FOLIO                IN    CUENTASELECTA.TA_TITULAR.IDTITULAR%TYPE
          ,PA_USR_MOD              IN    CUENTASELECTA.TA_TITULAR.USUARIO_MODIFICO%TYPE
          ,PA_FECH_MOD             IN    CUENTASELECTA.TA_TITULAR.FECHA_MODIFICO%TYPE
          ,PA_ESTATUSREG           IN    CUENTASELECTA.TA_TITULAR.ESTATUSREGISTRO%TYPE
          ,PA_IMPORTE              IN    CUENTASELECTA.TA_TITULAR.IMPORTEOPERACION%TYPE
          ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_TITULAR.PORCENTAJE%TYPE
          ,PASCOD_ERROR            OUT   NUMBER
          ,PASMSG_ERROR            OUT   VARCHAR2
          ,PA_ENVIARCORREO         IN    CUENTASELECTA.TA_TITULAR.ENVIARCORREO%TYPE
)
IS
VL_NUMFORMULARIO           INTEGER := 1;
VL_ENVIARCORREO            VARCHAR2(1) := '1';

BEGIN    
     BEGIN
     
      IF PA_ENVIARCORREO <> VL_ENVIARCORREO
        THEN
        IF PA_ENVIARCORREO IS NOT NULL 
        THEN
            VL_ENVIARCORREO := PA_ENVIARCORREO;
        END IF;
     END IF;
         
           INSERT INTO  CUENTASELECTA.TA_TITULAR 
                      ( 
                          IDTITULAR
                        , APATERNO 
                        , AMATERNO 
                        , NOMBRE
                        , SEXO
                        , EDOCIVIL
                        , FENACIMIENTO
                        , NACIONALIDAD 
                        , RFC
                        , CURP
                        ,TIPOIDENTIFICACION
                        , NUMIDENTIFICACION
                        , EMAIL
                        , NUMFORMULARIO
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                        , PORCENTAJE
                        , IMPORTEOPERACION
                        , ESTATUSREGISTRO
                        , ENVIARCORREO
                      
                       )
                  VALUES
                      (  
                        PA_FOLIO
                        ,PA_APATERNO
                        ,PA_AMATERNO 
                        ,PA_NOMBRE
                        ,PA_SEXO
                        ,PA_EDOCIVIL
                        ,PA_FENACIMIENTO
                        ,PA_NACIONALIDAD 
                        ,PA_RFC
                        ,PA_CURP
                        ,PA_TIPOIDENT
                        ,PA_NUMIDENT
                        ,PA_EMAIL
                        ,VL_NUMFORMULARIO
                        ,PA_USR_MOD
                        ,PA_FECH_MOD
                        ,PA_PORCENTAJE
                        ,PA_IMPORTE
                        ,PA_ESTATUSREG
                        ,VL_ENVIARCORREO
                      );
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION  
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDDATOSGEN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            REMOVE_PRIVILEGE_MONITOR (       
 V_USERNAME             IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,         
 V_AUTHORITY            IN     TOKENADMINPRU.AUTHORITIES.AUTHORITY%TYPE,       
 PSCod_Error            OUT    number,
 PSMsg_Error            OUT    varchar2
)
IS
BEGIN
     DELETE FROM TOKENADMINPRU.AUTHORITIES
     WHERE USERNAME = V_USERNAME
     AND AUTHORITY = V_AUTHORITY;
     PSCod_Error := 0;
     PSMsg_Error := 'Prvilegio removido correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al remover privelegios al cliente monitor';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al delete AUTHORITIES (' || SQLCODE || '  ' || SQLERRM || ')');
END  REMOVE_PRIVILEGE_MONITOR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          REPO_INSERT_CLIENT(
    idAlnova        IN VARCHAR2,
    cuenta          IN VARCHAR2,
    contrato        IN VARCHAR2,
    usuarioModifico IN VARCHAR2,
	  tipoPersona     IN VARCHAR2)
AS
BEGIN
  INSERT
  INTO EBANKING.REPO_CLIENTES
    (
      ID_ALNOVA,
      CUENTA,
      CONTRATO_TAS,
      ULTIMA_MODIFICACION,
      USUARIO_MODIFICO,
	  TIPO_PERSONA
    )
    VALUES
    (
      idAlnova,
      cuenta,
      contrato,
      SYSDATE,
      usuarioModifico,
	  tipoPersona
    );
  COMMIT;
EXCEPTION
WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar un cliente de reportos (' || SQLCODE || '  ' || SQLERRM || ')'
  )
  ;
WHEN OTHERS THEN
  ROLLBACK;
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar un cliente de reportos  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)'
  )
  ;
END REPO_INSERT_CLIENT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          REPO_INSERT_OPERAC(
    idAlnova          IN VARCHAR2,
    folioAlnova       IN VARCHAR2,
    folioTas          IN VARCHAR2,
    folioEbanking IN VARCHAR2,
    usuarioModifico   IN VARCHAR2)
AS
BEGIN
  INSERT
  INTO EBANKING.REPO_REG_OPERAC
    (
      ID_ALNOVA,
      FOLIO_ALNOVA,
      FOLIO_TAS,
      FOLIO_EBANKING,
      ULTIMA_MODIFICACION,
      USUARIO_MODIFICO
    )
    VALUES
    (
      idAlnova,
      folioAlnova,
      folioTas,
      folioEbanking,
      SYSDATE,
      usuarioModifico
    );
  COMMIT;
EXCEPTION
WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar una operacion de reportos (' || SQLCODE || '  ' || SQLERRM || ')'
  )
  ;
WHEN OTHERS THEN
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar una operacion de reportos  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)'
  )
  ;
END REPO_INSERT_OPERAC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SELECT_FRECSERVICIOS (userid NUMBER,
        frecuente VARCHAR,
        status VARCHAR ,
        idservicio VARCHAR ,
        CUR_STATUS OUT SYS_REFCURSOR, 
        PASCOD_ERROR        OUT     NUMBER,
        PASMSG_ERROR        OUT     VARCHAR2
          
) 
AS 
BEGIN
    OPEN CUR_STATUS FOR
        SELECT STATUS FROM EBANKING.ALL_FRECUENTES
        WHERE EBANKING.ALL_FRECUENTES.USER_ID=userid AND EBANKING.ALL_FRECUENTES.FRECUENTE=frecuente AND EBANKING.ALL_FRECUENTES.ID_SERVICIO=idservicio;
        
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
        
    EXCEPTION
    WHEN OTHERS THEN
          raise_application_error(-20001,'Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM);
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          select_usuariosBloqueados
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,P_CLIENTE   OUT   sys_refcursor 
          
) 
AS 
BEGIN
    OPEN P_CLIENTE FOR
 SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD  WHERE user_id=p_usuario AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario AND paso=2 AND status=1)ult_psw_movdinero
,(SELECT cellular_old FROM ebanking_user_old euo
WHERE CELLULAR_CHANGE_DATE=(SELECT MAX(CELLULAR_CHANGE_DATE) 
 FROM ebanking.EBANKING_USER_OLD 
WHERE user_id=p_usuario) AND user_id=p_usuario)celular_anterior
,(SELECT telefono_alterno_old FROM ebanking_user_old WHERE user_id=p_usuario AND 
alterno_change_date=(SELECT MAX(ALTERNO_CHANGE_DATE) AS ALTERNO_CHANGE_DATE
 FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)    
) telefono_alterno_anterior
,(SELECT email_old FROM ebanking.ebanking_user_old WHERE  user_id=p_usuario
AND EMAIL_CHANGE_DATE=(SELECT MAX(EMAIL_CHANGE_DATE) 
FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario))email_anterior
,(SELECT MAX(QUESTION_CHANGE_DATE) AS QUESTION_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD 
  WHERE user_id=p_usuario)ult_camb_pregunta
,(SELECT MAX(ANSWER_CHANGE_DATE) AS ANSWER_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)
 ult_camb_respuesta  
FROM EBANKING.ebanking_user WHERE EBANKING.ebanking_user.ID=p_usuario;
   
  PSCod_Error := 0;
   PSMsg_Error := 'Se encontro cliente en SP_BUSCA_CLEXIS';
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar cliente en SP_BUSCA_CLEXIS  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END select_usuariosBloqueados;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SEMILLA_ACTIVA (
V_SEMILLA_IN                       IN     EBANKING.TOKEN_DISP.SEMILLA%TYPE,
V_COUNT_SEMILLA                    OUT    number
)
IS

BEGIN

     SELECT COUNT(1) INTO V_COUNT_SEMILLA FROM EBANKING.TOKEN_DISP WHERE SEMILLA = V_SEMILLA_IN ;

EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_COUNT_SEMILLA:=0;
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SEMILLA_ACTIVA (' || SQLCODE || '  ' || SQLERRM || ')');

END SEMILLA_ACTIVA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SETHUELLAMONTOS
( numCliente IN varchar2, montoCOM IN varchar2, montoMX IN varchar2 )
IS

BEGIN

	 INSERT INTO EBANKING.EBANKING_MONTOS_USER tabla (tabla.ID_EBANKING_MONTOUSER, tabla.ID_USER,tabla.MONTO_COM,tabla.MONTO_MX)
	 VALUES (SEQ_EBANKING_MONTOSUSER.nextval, numCliente, montoCOM, montoMX);

	 COMMIT;

   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       ROLLBACK;
END SETHUELLAMONTOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SETUSRALNOVA(USERNAME IN VARCHAR, NOMBREAPLICACION IN VARCHAR, USR_ALNOVA IN VARCHAR)
AS

BEGIN
       UPDATE  EBANKING.M_USUARIOS
       SET USRALNOVA =  USR_ALNOVA
       WHERE USER_NAME = USERNAME 
       AND APLICACION = NOMBREAPLICACION;

EXCEPTION
       WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       ROLLBACK;
      
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SET_ENABLED_MONITOR (
V_USERNAME               IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,
V_ENABLED                IN     TOKENADMINPRU.USUARIOS_TOKEN.ENABLED%TYPE,
V_MODIFICO               IN     TOKENADMINPRU.USUARIOS_TOKEN.USUARIO_MODIFICO%TYPE,
PSCod_Error              OUT    number,
PSMsg_Error              OUT    varchar2
)
IS
BEGIN
    UPDATE TOKENADMINPRU.USUARIOS_TOKEN
    SET 
        ENABLED = V_ENABLED,
        USUARIO_MODIFICO = V_MODIFICO,
        ULTIMA_MODIFICACION = SYSDATE
    WHERE USERNAME = V_USERNAME;
    IF SQL%ROWCOUNT  = 0 THEN
           PSCod_Error := 2;
           PSMsg_Error := 'no hubo modificaciones';   
    ELSE
           PSCod_Error := 0;
           PSMsg_Error := 'se cambio el estado correctamente';
    END IF;
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Ocurrio un error al tratar de cambiar la propiedad enabled';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al updatear USUARIOS_TOKEN (' || SQLCODE || '  ' || SQLERRM || ')');
END  SET_ENABLED_MONITOR ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SET_NEW_PSWD_MNT (
V_USERNAME               IN     TOKENADMINPRU.USUARIOS_TOKEN.USERNAME%TYPE,
V_PASSWORD               IN     TOKENADMINPRU.USUARIOS_TOKEN.PASSWORD%TYPE,
V_MODIFICO               IN     TOKENADMINPRU.USUARIOS_TOKEN.USUARIO_MODIFICO%TYPE,
PSCod_Error              OUT    number,
PSMsg_Error              OUT    varchar2
)
AS
    V_CHECKSUM_PASSWORD VARCHAR(50);
BEGIN
    V_CHECKSUM_PASSWORD := UTL_RAW.CAST_TO_RAW(DBMS_OBFUSCATION_TOOLKIT.MD5(INPUT_STRING => V_PASSWORD));
    UPDATE TOKENADMINPRU.USUARIOS_TOKEN
    SET 
        PASSWORD = V_CHECKSUM_PASSWORD,
        USUARIO_MODIFICO = V_MODIFICO,
        ULTIMA_MODIFICACION = SYSDATE
    WHERE USERNAME = V_USERNAME;
    IF SQL%ROWCOUNT  = 0 THEN
           PSCod_Error := 2;
           PSMsg_Error := 'usuario no existe';   
           ROLLBACK;
    ELSE
           PSCod_Error := 0;
           PSMsg_Error := 'Se cambio el password correctamente';
           COMMIT;
    END IF;
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Ocurrio un error al tratar de setear el password';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al updatear USERS (' || SQLCODE || '  ' || SQLERRM || ')');
            ROLLBACK;
END  SET_NEW_PSWD_MNT ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE spalbum_delete_postit (
   pid        NUMBER,
   pidalbum   NUMBER,
   pidfoto    NUMBER
)
AS
BEGIN
   DELETE FROM postit
         WHERE ID = pid AND idalbum = pidalbum AND idfoto = pidfoto;

   COMMIT;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_delete_postit;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPCANCELPROGRATRANS(P_PROGRAMMED_TRANSFER_ID IN NUMBER,
                                                          P_DB_KEY                 IN VARCHAR2,
                                                          PSCod_Error             OUT NUMBER,
                                                          PSMsg_Error             OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SPCANCELPROGRATRANS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        12/04/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SPCANCELPROGRATRANS
      Sysdate:         12/04/2013
      Date and Time:   12/04/2013, 06:50:21 p.m., and 12/04/2013 06:50:21 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   
    UPDATE EBANKING.SCHEDULED_PAYMENT 
       SET STATUS ='CANC POR USUARIO',
           RESPONSE = EBANKING.ENCRYPTREQUEST ('CANCELADO POR USUARIO ' || SYSDATE, P_DB_KEY)
     WHERE SCHEDULED_PAYMENT_ID = P_PROGRAMMED_TRANSFER_ID;

   PSCod_Error := 0;
   PSMsg_Error := 'ejecucion de SPCANCELPROGRATRANS exitosa';
   
   COMMIT;
   EXCEPTION
     WHEN OTHERS THEN
     ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SPCANCELPROGRATRANS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SPCANCELPROGRATRANS (' || SQLCODE || '  ' || SQLERRM || ')');
       
END SPCANCELPROGRATRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPCONFIRMACIONWU(
           PA_FCIDUSUARIO			  IN EBANKING.TA_WU_CONFIRMACION.IDUSUARIO%TYPE,
		   PA_FCIDALNOVA		      IN EBANKING.TA_WU_CONFIRMACION.IDALNOVA%TYPE,
		   PA_FCUID                   IN EBANKING.TA_WU_CONFIRMACION.FCUID%TYPE,
 		   PA_FCIDCU                  IN EBANKING.TA_WU_CONFIRMACION.FCIDCU%TYPE,
 		   PA_FCIDOPERACION           IN EBANKING.TA_WU_CONFIRMACION.FCIDOPERACION%TYPE, 		    		  
 		   PA_FCNOMBREREMIT           IN EBANKING.TA_WU_CONFIRMACION.FCNOMBREREMIT%TYPE,
 		   PA_FCAPELLIDOREMIT         IN EBANKING.TA_WU_CONFIRMACION.FCAPELLIDOREMIT%TYPE,
 		   PA_FCDIRECCIONREMIT        IN EBANKING.TA_WU_CONFIRMACION.FCDIRECCIONREMIT%TYPE,
           PA_FCESTADOREMIT           IN EBANKING.TA_WU_CONFIRMACION.FCESTADOREMIT%TYPE,
           PA_FCTELREMIT              IN EBANKING.TA_WU_CONFIRMACION.FCTELREMIT%TYPE,
           PA_FCBENEFNOMBRE           IN EBANKING.TA_WU_CONFIRMACION.FCBENEFNOMBRE%TYPE,
           PA_FCBENEFAPELLIDOS        IN EBANKING.TA_WU_CONFIRMACION.FCBENEFAPELLIDOS%TYPE,
           PA_FCPRINCIPAL             IN EBANKING.TA_WU_CONFIRMACION.FCPRINCIPAL%TYPE,
           PA_FCTOTALPAGO             IN EBANKING.TA_WU_CONFIRMACION.FCTOTALPAGO%TYPE,
           PA_FCMONTOPAGO             IN EBANKING.TA_WU_CONFIRMACION.FCMONTOPAGO%TYPE,
           PA_FCPAISORIGEN            IN EBANKING.TA_WU_CONFIRMACION.FCPAISORIGEN%TYPE,
           PA_FCMONEDAORIGEN          IN EBANKING.TA_WU_CONFIRMACION.FCMONEDAORIGEN%TYPE,
           PA_FCPAISDESTINO           IN EBANKING.TA_WU_CONFIRMACION.FCPAISDESTINO%TYPE,
           PA_FCPAISDESTINOESTADO     IN EBANKING.TA_WU_CONFIRMACION.FCPAISDESTINOESTADO%TYPE,
           PA_FCMTCN                  IN EBANKING.TA_WU_CONFIRMACION.FCMTCN%TYPE,
           PA_FCCUENTACARGO           IN EBANKING.TA_WU_CONFIRMACION.FCCUENTACARGO%TYPE,
		   FN_PSCOD 			      OUT NUMBER
                                                )
                                                AS
/****************************************************************************
   Proyecto:               Ebanking
   
   Descripcion:            Funcion pare insertar en la tabla TA_WU_CONFIRMACION
						   las transacciones exitosas
                           
   Parametros de entrada:
                                         PA_FCIDUSUARIO         -Id de usuario que realiza transaccion,
                                         PA_FCIDALNOVA          -Id alnova que realiza la transaccion,
                                         PA_FCUID               -Identificador ?nico de petici?n generado en la sucursal,
                                         PA_FCIDCU              -N?mero de cliente ?nico del remitente,
                                         PA_FCIDOPERACION       -N?mero de operaci?n requerido para b?squeda y rastreo de transacciones,    , 
                                         PA_FCNOMBREREMIT       -Nombre del remitente,
                                         PA_FCAPELLIDOREMIT     -Apellidos del remitente,
                                         PA_FCDIRECCIONREMIT    -Direccion del remitente,
                                         PA_FCESTADOREMIT       -Estado del remitente,
                                         PA_FCTELREMIT          -Telefono del remitente,
                                         PA_FCBENEFNOMBRE       -Nombre del beneficiario,
                                         PA_FCBENEFAPELLIDOS    -Apellidos del beneficiario,
                                         PA_FCPRINCIPAL         -Monto principal del env?o,
                                         PA_FCTOTALPAGO         -Total de pago del env?o,
                                         PA_FCMONTOPAGO         -Monto de pago,
                                         PA_FCPAISORIGEN        -Pa?s de origen del env?o,
                                         PA_FCMONEDAORIGEN      -Moneda origen del env?o,
                                         PA_FCPAISDESTINO       -Pa?s destino del env?o,
                                         PA_FCPAISDESTINOESTADO -Estado del pa?s destino,
                                         PA_FCMTCN              -mtcn temporal de WU obtenido en la trama de env?o,
                                         PA_FCCUENTACARGO       -Cuenta a que se le realiza el descuento  
 Parametros de salida:        
                                         FN_PSCOD 			    -Codigo de la execucion
                     
   Creador:                Victor Castillo
   Fecha:                  27/11/2013
****************************************************************************/   
   BEGIN  
   FN_PSCOD := 0;
      INSERT INTO EBANKING.TA_WU_CONFIRMACION (
                                              ID                      ,
                                              IDUSUARIO               ,
                                              IDALNOVA                ,
                                              FCUID                   ,
                                              FCIDCU                  ,
                                              FCIDOPERACION           ,
                                              FCNOMBREREMIT           ,
                                              FCAPELLIDOREMIT         ,
                                              FCDIRECCIONREMIT        ,
                                              FCESTADOREMIT           ,
                                              FCTELREMIT              ,
                                              FCBENEFNOMBRE           ,
                                              FCBENEFAPELLIDOS        ,
                                              FCPRINCIPAL             ,
                                              FCTOTALPAGO             ,
                                              FCMONTOPAGO             ,
                                              FCPAISORIGEN            ,
                                              FCMONEDAORIGEN          ,
                                              FCPAISDESTINO           ,
                                              FCPAISDESTINOESTADO     ,
                                              FCMTCN                  ,
                                              FDFECHATRANSACCION      ,
                                              FCCUENTACARGO
                                         )
                                  VALUES (
                                         EBANKING.sequence_wu_confirmacion.NEXTVAL,
                                         PA_FCIDUSUARIO,
                                         PA_FCIDALNOVA,
                                         PA_FCUID,
                                         PA_FCIDCU,
                                         PA_FCIDOPERACION,
                                         PA_FCNOMBREREMIT,
                                         PA_FCAPELLIDOREMIT,
                                         PA_FCDIRECCIONREMIT,
                                         PA_FCESTADOREMIT,
                                         PA_FCTELREMIT,
                                         PA_FCBENEFNOMBRE,
                                         PA_FCBENEFAPELLIDOS,
                                         PA_FCPRINCIPAL,
                                         PA_FCTOTALPAGO,
                                         PA_FCMONTOPAGO,
                                         PA_FCPAISORIGEN,
                                         PA_FCMONEDAORIGEN,
                                         PA_FCPAISDESTINO,
                                         PA_FCPAISDESTINOESTADO,
                                         PA_FCMTCN,
                                         SYSDATE,
                                         PA_FCCUENTACARGO
      
                                        );
          

      COMMIT; 
      
            
EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
     FN_PSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en la tabla TA_WU_CONFIRMACION ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END SPCONFIRMACIONWU;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPCURRENTDATE( fnDateCurrent  OUT VARCHAR2
                                                   ,fnPsCod OUT NUMBER
                                                   ,fcPsMsg OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para obtener la fecha actual.
   Parametros de entrada:  N/A.                           
   Parametros de salida:   fnDateCurrent     - Fecha actual de retorno.
                           fnPsCod           - Codigo de retorno del procedimiento.
                           fcPsMsg           - Mensaje de de la base de datos retoro del procedimiento.
   Creador:                Oscar Tzompantzi Astivia.
   Fecha:                  10/05/2013.
****************************************************************************/
   BEGIN
   FCPSMSG := 'OPERACION EXITOSA';
   FNPSCOD := 0;
   SELECT TO_CHAR(SYSDATE,'DD/MM/YYYY hh24:mi:ss') AS DATECURRENT
     INTO fnDateCurrent
     FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN
      FCPSMSG := 'ERROR AL CONSULTAR LA FECHA ACTUAL DE LA BASE DE DATOS';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al consultar la fecha actual de la base de datos ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END SPCURRENTDATE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE      SPFRREG_BOPREAFI
( P_NOEMP IN NVARCHAR2  
, P_EXITO OUT VARCHAR2
, P_ERROR OUT VARCHAR2) AS
EXITE_EMP NUMERIC:=0;
BEGIN
  
   SELECT ID_REGISTRO INTO EXITE_EMP
      FROM ebanking.FIAR_REGISTRO
     WHERE NUM_EMPLEADO = P_NOEMP;

    DELETE ebanking.FIAR_REGISTRO WHERE NUM_EMPLEADO = P_NOEMP;
    COMMIT;
    P_EXITO := '1';
    P_ERROR := 'SE ELIMINO CORRECTAMENTE EL EMPLEADO';
    
  EXCEPTION
    WHEN NO_DATA_FOUND THEN 
        P_EXITO := '0';
        P_ERROR := 'NO EXISTE EL EMPLEADO';
        
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
        P_EXITO := '0';
        P_ERROR := SQLERRM;
        ROLLBACK;
END SPFRREG_BOPREAFI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPFRREG_BORRAPREAFILIACION
( P_NOEMP IN NVARCHAR2  
, P_EXITO OUT VARCHAR2
, P_ERROR OUT VARCHAR2) AS
EXITE_EMP NUMERIC:=0;
BEGIN
  
   SELECT ID_REGISTRO INTO EXITE_EMP
      FROM ebanking.FIAR_REGISTRO
     WHERE NUM_EMPLEADO = P_NOEMP;

    DELETE ebanking.FIAR_REGISTRO WHERE NUM_EMPLEADO = P_NOEMP;
    COMMIT;
    P_EXITO := '1';
    P_ERROR := 'SE ELIMINO CORRECTAMENTE EL EMPLEADO';
    
  EXCEPTION
    WHEN NO_DATA_FOUND THEN 
        P_EXITO := '0';
        P_ERROR := 'NO EXISTE EL EMPLEADO';
        
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
        P_EXITO := '0';
        P_ERROR := SQLERRM;
        ROLLBACK;
END SPFRREG_BORRAPREAFILIACION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPFRREG_REGHUELLA 
( P_NOEMP IN NVARCHAR2  
, P_CTA_NOM IN NVARCHAR2
, P_HUELLAEMP IN CLOB 
, P_ESTATUS IN VARCHAR2
, P_USRMOD IN VARCHAR2
, P_EXITO OUT VARCHAR2
, P_ERROR OUT VARCHAR2) AS
EXITE_EMP NUMERIC:=0;
BEGIN

  SELECT COUNT(ID_REGISTRO) INTO EXITE_EMP
      FROM ebanking.FIAR_REGISTRO
     WHERE NUM_EMPLEADO = P_NOEMP;
    
  IF (EXITE_EMP=0) THEN
    INSERT INTO ebanking.FIAR_REGISTRO
      (ID_REGISTRO, NUM_EMPLEADO, CTA_NOMINA, HUELLA_EMPLEADO, ESTATUS_REGISTRO, ULTIMA_MODIFICACION, USUARIO_MODIFICO)
    VALUES
       (SEQ_ID_REGISTRO.nextval, P_NOEMP, P_CTA_NOM, P_HUELLAEMP, P_ESTATUS, SYSDATE, P_USRMOD);
    COMMIT;
    P_EXITO := '1';
    P_ERROR := 'SE ALMACENO CORRECTAMENTE EL EMPLEADO';
  ELSE
    P_EXITO := '0';
    P_ERROR := 'EL EMPLEADO YA ESTA REGISTRADO';
  END IF;
  
    
  EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);
        P_EXITO := '0';
        P_ERROR := SQLERRM;
  
END SPFRREG_REGHUELLA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPGETPROGRATRANSFERS(P_EMP_NUM               IN  NUMBER,
                                                          P_DB_KEY                IN  VARCHAR2,
                                                          P_FLAG                  IN  NUMBER,
                                                          P_BEGINNING_DATE        IN  VARCHAR2,
                                                          P_ENDING_DATE           IN  VARCHAR2,
                                                          P_PROGRAMMED_TRANSFERS  OUT SYS_REFCURSOR,
                                                          PSCod_Error             OUT number,
                                                          PSMsg_Error             OUT varchar2) IS
/******************************************************************************
   NAME:       SPGETPROGRATRANSFERS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        10/04/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SPGETPROGRATRANSFERS
      Sysdate:         10/04/2013
      Date and Time:   10/04/2013, 11:48:14 a.m., and 10/04/2013 11:48:14 a.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
CSLNUMCER0 NUMBER := 0;
BEGIN
OPEN P_PROGRAMMED_TRANSFERS FOR
    SELECT SCHEDULED_PAYMENT_ID, 
           APPLY_DATE, 
           PROGRAM_DATE, 
           STATUS, 
           FOLIO_PROGRAMADO, 
           EBANKING.DESCRYPTREQUEST (REQUEST, P_DB_KEY, P_FLAG) AS REQUEST, 
           EBANKING.DESCRYPTREQUEST (RESPONSE, P_DB_KEY, P_FLAG) AS RESPONSE
    FROM EBANKING.SCHEDULED_PAYMENT 
    WHERE SCHEDULED_PAYMENT_ID > CSLNUMCER0
        AND USER_ID = P_EMP_NUM
        AND TX_NAME='SPEI' 
        AND (
                (PROGRAM_DATE >= TO_DATE(P_BEGINNING_DATE,'DD-MM-YYYY') AND PROGRAM_DATE <= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY')) 
                OR (APPLY_DATE >= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY'))
            )
    ORDER BY PROGRAM_DATE DESC;
    
   PSCod_Error := 0;
   PSMsg_Error := 'consulta a SPGETPROGRATRANSFERS exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SPGETPROGRATRANSFERS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SPGETPROGRATRANSFERS (' || SQLCODE || '  ' || SQLERRM || ')');
END SPGETPROGRATRANSFERS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPGETREMITBYCUSTOMER(P_DEX_CUSTOMER_ID IN NUMBER,
                                                                    P_REMITTANCES OUT SYS_REFCURSOR,
                                                                    PSCod_Error  OUT NUMBER,
                                                                    PSMsg_Error  OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SPGETREMITBYCUSTOMER
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        01/08/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SPGETREMITBYCUSTOMER
      Sysdate:         01/08/2013
      Date and Time:   01/08/2013, 07:19:19 p.m., and 01/08/2013 07:19:19 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   
    OPEN P_REMITTANCES FOR
    SELECT TRANSFER_DEX.CLIENTE_ID, 
           TRANSFER_DEX.MTCN,
           PAIS_ID_DESTINO,
           ESTADO_ID_DESTINO,
           CIUDAD_ID_DESTINO,
           IMPUESTO_DEX.MONTO,
           FECHA_ENVIO,
           TARIFA
    FROM EBANKING.TRANSFER_DEX
    JOIN EBANKING.IMPUESTO_DEX 
        ON TRANSFER_DEX.MTCN=IMPUESTO_DEX.MTCN
    WHERE TRANSFER_DEX.MTCN=IMPUESTO_DEX.MTCN 
      AND TRANSFER_DEX.CLIENTE_ID = P_DEX_CUSTOMER_ID
    ORDER BY TRANSFER_DEX.ULTIMA_MODIFICACION,
             TO_NUMBER(TRANSFER_DEX.MTCN);

    PSCod_Error := 0;
    PSMsg_Error := 'consulta a SPGETREMITBYCUSTOMER exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SPGETREMITBYCUSTOMER';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SPGETREMITBYCUSTOMER (' || SQLCODE || '  ' || SQLERRM || ')');
END SPGETREMITBYCUSTOMER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPINSEMITOP15
(  PAFNEMISORID             EBANKING.TATOP15_PS.FNEMISORID%TYPE 
  , PAFNSUCRSALID             EBANKING.TATOP15_PS.FNSUCRSALID%TYPE 
   ,PAFCNOMBRECOMERCIAL     EBANKING.TATOP15_PS.FCNOMBRECOMERCIAL%TYPE 
   ,PAFCNOMBRECORTO         EBANKING.TATOP15_PS.FCNOMBRECORTO%TYPE
   ,PAFNSTATUS              EBANKING.TATOP15_PS.FNESTATUS%TYPE
   ,PAFNREFERENCIAMIN       EBANKING.TATOP15_PS.FNREFERENCIAMIN%TYPE
   ,PAFNREFERENCIAMAX       EBANKING.TATOP15_PS.FNREFERENCIAMAX%TYPE
   ,PAFNFORMASPAGO          EBANKING.TATOP15_PS.FNFORMASPAGO%TYPE
   ,PAFNPERMITECANCELAR     EBANKING.TATOP15_PS.FNPERMITECANCELAR%TYPE
   ,PAFNREFERENCIAVARIABLE  EBANKING.TATOP15_PS.FNREFERENCIAVARIABLE%TYPE
   ,PAFNCATEGORIAID         EBANKING.TATOP15_PS.FNCATEGORIAID%TYPE
   ,PAFCCATEGORIA           EBANKING.TATOP15_PS.FCCATEGORIA%TYPE
   ,PAFNORDENTOP            EBANKING.TATOP15_PS.FNORDENTOP%TYPE
   ,PAFCUSUARIOMODIFICO     EBANKING.TATOP15_PS.USUARIO_MODIFICO%TYPE
   ,PA_COD_ERROR            OUT  NUMBER
   ,PA_MSG_ERROR            OUT  VARCHAR2 )
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TATOP15_PS
   Parametros de entrada:   PAFIEMISORID            -- Identificador del emisor
                          ,PAFNSUCRSALID                    --Identificador de la sucursal
                           ,PAFCNOMBRECOMERCIAL     -- Nombre comercial
                           ,PAFCNOMBRECORTO         -- Nombre Corto
                           ,PAFNSTATUS              -- Estatus
                           ,PAFNREFERENCIAMIN       -- Referencia minima
                           ,PAFNREFERENCIAMAX       -- Refrencia maxima
                           ,PAFNFORMASPAGO          -- Identificador de la forma de pago
                           ,PAFNPERMITECANCELAR     -- Bandera de si permite cancelar o no
                           ,PAFNREFERENCIAVARIABLE  -- Identificador de si es variable o no
                           ,PAFNCATEGORIAID         -- Identificador de la categoria
                           ,PAFCCATEGORIA           -- Descripcion de la categoria
                           ,PAFNORDENTOP            -- Numero de posicion del top
                           ,USUARIO_MODIFICO     -- Identificador del usuario que realiza la modificacion

   Parametros de salida:  FNPSCOD   -Codigo de retorno del procedimiento
                          FCPSMSG   -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 23/05/2014
****************************************************************************/
BEGIN
   INSERT INTO  EBANKING.TATOP15_PS( FNEMISORID
                                       ,FNSUCRSALID
                                       ,FCNOMBRECOMERCIAL
                                       ,FCNOMBRECORTO
                                       ,FNESTATUS
                                       ,FNREFERENCIAMIN
                                       ,FNREFERENCIAMAX
                                       ,FNFORMASPAGO
                                       ,FNPERMITECANCELAR
                                       ,FNREFERENCIAVARIABLE
                                       ,FNCATEGORIAID
                                       ,FCCATEGORIA
                                       ,FNORDENTOP
                                       ,USUARIO_MODIFICO ) 
                              VALUES ( PAFNEMISORID
                                      ,PAFNSUCRSALID
                                      ,PAFCNOMBRECOMERCIAL
                                      ,PAFCNOMBRECORTO
                                      ,PAFNSTATUS
                                      ,PAFNREFERENCIAMIN
                                      ,PAFNREFERENCIAMAX
                                      ,PAFNFORMASPAGO
                                      ,PAFNPERMITECANCELAR
                                      ,PAFNREFERENCIAVARIABLE
                                      ,PAFNCATEGORIAID
                                      ,PAFCCATEGORIA
                                      ,PAFNORDENTOP
                                      ,PAFCUSUARIOMODIFICO  );
             COMMIT;
              PA_COD_ERROR:=0;
              PA_MSG_ERROR:='OPERACION EXITOSA ';
    EXCEPTION
            WHEN OTHERS THEN
            ROLLBACK;
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'FALLO AL INSERTAR EN  TATOP15_PS (' || SQLCODE || '  ' || SQLERRM || ')');

END SPINSEMITOP15;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPINSERTAAPERTN2 (   PAFCCLIENTE_UNICO      IN  EBANKING.TAAPERTURASN2.FCCLIENTE_UNICO%TYPE
                                                                                                    ,PAFCCLIENTE_TIENDA    IN  EBANKING.TAAPERTURASN2.FCCLIENTE_TIENDA%TYPE
                                                                                                    ,PAFCCLIENTE_ALNOVA   IN  EBANKING.TAAPERTURASN2.FCCLIENTE_ALNOVA%TYPE
                                                                                                    ,PAFCNUMERO_CTA        IN  EBANKING.TAAPERTURASN2.FCNUMERO_CTA%TYPE
                                                                                                    ,PAFCNUMERO_TARJ       IN  EBANKING.TAAPERTURASN2.FCNUMERO_TARJ%TYPE
                                                                                                    ,PAFCSISTEMA               IN  EBANKING.TAAPERTURASN2.FCSISTEMA%TYPE
                                                                                                    ,PAFCUSUARIO_MOD       IN  EBANKING.TAAPERTURASN2.FCUSUARIO_MOD%TYPE
                                                                                                    ,FNPSCOD                    OUT NUMBER
                                                                                                    ,FCPSMSG                    OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:                         Ebanking
   Descripcion:                    Procedimiento para insertar las cuentas de nivel 2 creadas
   Parametros de entrada:  PAFCCLIENTE_UNICO       - Identificador de cu
                                       PAFCCLIENTE_TIENDA     - Identificador de tienda
                                      PAFCCLIENTE_ALNOVA     - Identifiador de cliente alnova
                                      PAFCNUMERO_CTA          - Numero de cuenta creada
                                     PAFCNUMERO_TARJ          - Numero de tarjeta
                                     PAFCSISTEMA                  - Sistema
                                     PAFCUSUARIO_MOD         - Usuario que modifica
   Parametros de salida:  FNPSCOD                        - Codigo de retorno del procedimiento
                                    FCPSMSG                        - Mensaje de retoro del procedimiento
   Creador:                    Oscar Tzompantzi Astivia
   Fecha:                       15/10/2013
****************************************************************************/

BEGIN
    FCPSMSG := 'OPERACION EXITOSA';
    FNPSCOD := 0;
    INSERT INTO EBANKING.TAAPERTURASN2( FCCLIENTE_UNICO
                                                                 , FCCLIENTE_TIENDA
                                                                 , FCCLIENTE_ALNOVA
                                                                 , FCNUMERO_CTA
                                                                 , FCNUMERO_TARJ
                                                                 , FCSISTEMA
                                                                 , FDFECHA_MOD
                                                                 , FCUSUARIO_MOD ) 
                                                     VALUES( PAFCCLIENTE_UNICO
                                                                 , PAFCCLIENTE_TIENDA
                                                                 , PAFCCLIENTE_ALNOVA
                                                                 , PAFCNUMERO_CTA
                                                                 , PAFCNUMERO_TARJ
                                                                 , PAFCSISTEMA
                                                                 , SYSDATE
                                                                 , PAFCUSUARIO_MOD );
    COMMIT;
EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EN LA TABLA DE DE APERTURASN2';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en aperturaN2 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPINSERTHISTORIC (PAFCUSERNAME        IN  EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE
                                             ,PAFCREMOTEADDRESS   IN  EBANKING.EBANKING_LOGIN_HIST.IP%TYPE
                                             ,PAFNIDALNOVA   IN  EBANKING.EBANKING_LOGIN_HIST.USER_ID%TYPE
                                             ,FNPSCOD OUT NUMBER
                                             ,FCPSMSG OUT VARCHAR2)AS
BEGIN
    FCPSMSG := 'OPERACION EXITOSA';
    FNPSCOD := 0;
    INSERT INTO EBANKING.EBANKING_LOGIN_HIST( ID
                                            , USER_ID
                                            , LOGIN_DATE
                                            , ALIAS
                                            , ATTEMPT
                                            , IP
                                            , VALIDACION) SELECT ID_LOGIN_HISTORY_SEQ.NEXTVAL
                                                                ,USER_ID
                                                                ,LOGIN_DATE
                                                                ,PAFCUSERNAME ALIAS
                                                                ,ATTEMPTS
                                                                ,PAFCREMOTEADDRESS IP
                                                                ,NULL 
                                                            FROM EBANKING.EBANKING_LOGIN
                                                           WHERE USER_ID = PAFNIDALNOVA;
    COMMIT;
EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EN LA TABLA DE HISTORICOS';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar el historico ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPINSERTOPEPROGRA( paFcId_Alnova        IN EBANKING.OPE_PROGRAMADAS.ID_ALNOVA%TYPE
                                                       ,paFcTipo_Operacion   IN EBANKING.OPE_PROGRAMADAS.TIPO_OPERACION%TYPE
                                                       ,paFcUsuario          IN EBANKING.OPE_PROGRAMADAS.USUARIO%TYPE
                                                       ,paFnEstado           IN EBANKING.OPE_PROGRAMADAS.ESTADO%TYPE
                                                       ,paFcCorreo           IN EBANKING.OPE_PROGRAMADAS.CORREO%TYPE
                                                       ,paFcLlaveValor       IN EBANKING.OPE_PROGRAMADAS.LLAVE_VALOR%TYPE
                                                       ,paFcFecha_Pro        IN EBANKING.OPE_PROGRAMADAS.FECHA_PROGRAMACION%TYPE
                                                       ,paFcFecha_UltModi    IN EBANKING.OPE_PROGRAMADAS.ULTIMA_MODIFICACION%TYPE
                                                       ,paFcFechaEjecucion   IN VARCHAR2--EBANKING.OPE_PROGRAMADAS.FECHA_DE_EJECUCION%TYPE
                                                       ,paFcDescripcion_Resp IN EBANKING.OPE_PROGRAMADAS.DESCRIPCION_RESPUESTA%TYPE
                                                       ,paFcUsua_Modifi      IN EBANKING.OPE_PROGRAMADAS.USUARIO_MODIFICO%TYPE
                                                       ,paFcIp               IN EBANKING.OPE_PROGRAMADAS.IP%TYPE 
                                                       ,fnPsCod             OUT NUMBER
                                                       ,fcPsMsg             OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking.
   Descripcion:            Procedimiento para actualizar una frecuente.
   Parametros de entrada:  paFnId               - Identificador
                           paFcId_Alnova        - Identificador de Alnova. 
                           paFcTipo_Operacion   - Tipo de Operacion.
                           paFcUsuario          - Usuario.
                           paFnEstado           - Id del Estado.
                           paFcCorreo           - Correo electronico.
                           paFcLlaveValor       - Valor de la llave.
                           paFcFecha_Pro        - Fecha programada.
                           paFcFecha_UltModi    - Fecha de Ejecuto.
                           paFcFechaEjecucion   - Fecha de Ejecucion.
                           paFcDescripcion_Resp - Descripcion de la respuesta.
                           paFcUsua_Modifi      - Usuario de Modificacion.
                           paFcIp               - Direccion Ip.
   Parametros de salida:   fnPsCod              - Codigo de retorno del procedimiento.
                           fcPsMsg              - Mensaje de retoro del procedimiento.
   Creador:                Oscar Tzompantzi Astivia.
   Fecha:                  10/05/2013.
****************************************************************************/
BEGIN
    fnPsCod := 0;
    fcPsMsg := 'OPERACION EXITOSA';
        INSERT INTO EBANKING.OPE_PROGRAMADAS( ID
                                                     ,ID_ALNOVA
                                                     ,TIPO_OPERACION
                                                     ,USUARIO
                                                     ,ESTADO
                                                     ,CORREO
                                                     ,LLAVE_VALOR
                                                     ,FECHA_PROGRAMACION
                                                     ,ULTIMA_MODIFICACION
                                                     ,FECHA_DE_EJECUCION
                                                     ,DESCRIPCION_RESPUESTA
                                                     ,USUARIO_MODIFICO
                                                     ,IP ) 
                                             VALUES ( EBANKING.SEQ_OPE_PROG.NEXTVAL 
                                                     ,paFcId_Alnova
                                                     ,paFcTipo_Operacion
                                                     ,paFcUsuario
                                                     ,paFnEstado
                                                     ,paFcCorreo
                                                     ,paFcLlaveValor
                                                     ,SYSDATE--paFcFecha_Pro
                                                     ,SYSDATE--paFcFecha_UltModi
                                                     ,TO_DATE(paFcFechaEjecucion,'YYYY-MM-DD hh24:mi:ss')
                                                     ,paFcDescripcion_Resp
                                                     ,paFcUsua_Modifi
                                                     ,paFcIp );
    COMMIT;
EXCEPTION
  WHEN OTHERS THEN
      ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EN LA TABLA DE OPERACIONES_PROGRAMADAS';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en la tabla de Operaciones_Programadas ( * '||paFcFechaEjecucion||'*' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END SPINSERTOPEPROGRA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SPINSERTSOLPAYMENT (PAFNFOLIO_SOLICITUD    IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOL_PAGO.FOLIO_SOLICITUD%TYPE
                                               ,PAFCNUM_CTE            IN EBANKING.EBANKING_TOKEN_SOL_PAGO.NUM_CTE%TYPE
                                               ,PAFCCTA_CARGO          IN EBANKING.EBANKING_TOKEN_SOL_PAGO.CTA_CARGO%TYPE
                                               ,PAFCREF_CTA_CARGO      IN EBANKING.EBANKING_TOKEN_SOL_PAGO.REF_CTA_CARGO%TYPE
                                               ,PAFCTIT_CTA_CARGO      IN EBANKING.EBANKING_TOKEN_SOL_PAGO.TIT_CTA_CARGO%TYPE
                                               ,PAFCCUENTA_DESTINO     IN EBANKING.EBANKING_TOKEN_SOL_PAGO.CUENTA_DESTINO%TYPE
                                               ,PAFCREF_CUENTA_DESTINO IN EBANKING.EBANKING_TOKEN_SOL_PAGO.REF_CUENTA_DESTINO%TYPE
                                               ,PAFCTIT_CTA_DESTINO IN EBANKING.EBANKING_TOKEN_SOL_PAGO.TIT_CTA_DESTINO%TYPE
                                               ,PAFCREQUES          IN EBANKING.EBANKING_TOKEN_SOL_PAGO.REQUES%TYPE
                                               ,PAFNESTATUS_PAGO    IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOL_PAGO.ESTATUS_PAGO%TYPE
                                               ,PAFDFECHA_PAGO      IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOL_PAGO.FECHA_PAGO%TYPE
                                               ,PAFCRETENCION_PAGOS IN EBANKING.EBANKING_TOKEN_SOL_PAGO.RETENCION_PAGOS%TYPE
                                               ,PAFNIMPORTE         IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOL_PAGO.IMPORTE%TYPE 
                                               ,SISTEMA         IN EBANKING.EBANKING_TOKEN_SOL_PAGO.SISTEMA%TYPE
                                               ,IDPAIS         IN EBANKING.EBANKING_TOKEN_SOL_PAGO.IDPAIS%TYPE
                                               ,FNPSCOD OUT NUMBER
                                               ,FCPSMSG OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para insertar registros en la tabla EBANKING_TOKEN_SOL_PAGO 
   Parametros de entrada:  FOLIO_SOLICITUD     -Folio de solicitud
                           NUM_CTE             -Numero decliente
                           CTA_CARGO           -Cuenta cargo
                           REF_CTA_CARGO       -Ref cuenta cargo
                           TIT_CTA_CARGO       -Titular cuenta cargo
                           CUENTA_DESTINO      -Cuenta destino
                           REF_CUENTA_DESTINO  -Ref Cuenta destino
                           TIT_CTA_DESTINO     -Titular cuenta destino
                           REQUES              -Reques
                           ESTATUS_PAGO        -Estatus de pago
                           FECHA_PAGO          -Fecha de pago
                           RETENCION_PAGOS     -Retencion de pagos
                           IMPORTE             -Importe
   Parametros de salida:  FNPSCOD              -Codigo de retorno del procedimiento
                          FCPSMSG              -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 27/02/2013
****************************************************************************/

BEGIN
    FCPSMSG := 'OPERACION EXITOSA';
    FNPSCOD := 0;
    INSERT INTO EBANKING.EBANKING_TOKEN_SOL_PAGO (FOLIO_SOLICITUD
                                                 ,NUM_CTE
                                                 ,CTA_CARGO
                                                 ,REF_CTA_CARGO
                                                 ,TIT_CTA_CARGO
                                                 ,CUENTA_DESTINO
                                                 ,REF_CUENTA_DESTINO
                                                 ,TIT_CTA_DESTINO
                                                 ,REQUES
                                                 ,FECHA_SOLICITUD
                                                 ,ESTATUS_PAGO
                                                 ,FECHA_PAGO
                                                 ,RETENCION_PAGOS
                                                 ,IMPORTE
                                                 ,SISTEMA
                                                 ,IDPAIS)
                                           VALUES(PAFNFOLIO_SOLICITUD
                                                 ,PAFCNUM_CTE
                                                 ,PAFCCTA_CARGO
                                                 ,PAFCREF_CTA_CARGO
                                                 ,PAFCTIT_CTA_CARGO
                                                 ,PAFCCUENTA_DESTINO
                                                 ,PAFCREF_CUENTA_DESTINO
                                                 ,PAFCTIT_CTA_DESTINO
                                                 ,PAFCREQUES
                                                 ,SYSDATE
                                                 ,TO_NUMBER(PAFNESTATUS_PAGO)
                                                 ,PAFDFECHA_PAGO
                                                 ,PAFCRETENCION_PAGOS
                                                 ,TO_NUMBER(PAFNIMPORTE,'999999999.99')
                                                 ,'NETNET'
                                                 ,'MX');
    COMMIT;
EXCEPTION
   WHEN OTHERS THEN
   ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EL REGISTRO EN LA TABLA';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar el registro en la tabla ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SPINSERTSOLTOKEN (PAFNFOLIO_SOLICITUD IN EBANKING.EBANKING_TOKEN_SOLICITUD.FOLIO_SOLICITUD%TYPE
                                             ,PAFCNUM_CTE         IN EBANKING.EBANKING_TOKEN_SOLICITUD.NUM_CTE%TYPE
                                             ,PAFCNOM_CTE         IN EBANKING.EBANKING_TOKEN_SOLICITUD.NOM_CTE%TYPE
                                             ,PAFCAPE_PAT_CTE IN EBANKING.EBANKING_TOKEN_SOLICITUD.APE_PAT_CTE%TYPE
                                             ,PAFCAPE_MAT_CTE IN EBANKING.EBANKING_TOKEN_SOLICITUD.APE_MAT_CTE%TYPE
                                             ,PAFCRFC_CTE     IN EBANKING.EBANKING_TOKEN_SOLICITUD.RFC_CTE%TYPE
                                             ,PAFCDIR_ENT     IN EBANKING.EBANKING_TOKEN_SOLICITUD.DIR_ENT%TYPE
                                             ,PAFCCOL_ENT     IN EBANKING.EBANKING_TOKEN_SOLICITUD.COL_ENT%TYPE
                                             ,PAFCCP_ENT      IN EBANKING.EBANKING_TOKEN_SOLICITUD.CP_ENT%TYPE
                                             ,PAFCCIUDAD_ENT  IN EBANKING.EBANKING_TOKEN_SOLICITUD.CIUDAD_ENT%TYPE
                                             ,PAFCEDO_ENT     IN EBANKING.EBANKING_TOKEN_SOLICITUD.EDO_ENT%TYPE
                                             ,PAFCTEL_ENT     IN EBANKING.EBANKING_TOKEN_SOLICITUD.TEL_ENT%TYPE
                                             ,PAFCTEL_ADI_ENT IN EBANKING.EBANKING_TOKEN_SOLICITUD.TEL_ADI_ENT%TYPE
                                             ,PAFCPER_AUT1    IN EBANKING.EBANKING_TOKEN_SOLICITUD.PER_AUT1%TYPE
                                             ,PAFCPER_AUT2    IN EBANKING.EBANKING_TOKEN_SOLICITUD.PER_AUT2%TYPE
                                             ,PAFCPER_AUT3    IN EBANKING.EBANKING_TOKEN_SOLICITUD.PER_AUT3%TYPE
                                             ,PAFNESTATUS_SOL IN EBANKING.EBANKING_TOKEN_SOLICITUD.ESTATUS_SOL%TYPE
                                             ,PAFNNUM_PEDIDO_EKT IN EBANKING.EBANKING_TOKEN_SOLICITUD.NUM_PEDIDO_EKT%TYPE
                                             ,PAFCDIR_IP         IN EBANKING.EBANKING_TOKEN_SOLICITUD.DIR_IP%TYPE
                                             ,PAFCFECHA_SOL_PREVFRA       IN EBANKING.EBANKING_TOKEN_SOLICITUD.FECHA_SOL_PREVFRA%TYPE
                                             ,PAFCID_USUARIO_PREV_FRAUDES IN EBANKING.EBANKING_TOKEN_SOLICITUD.ID_USUARIO_PREV_FRAUDES%TYPE
                                             ,PAFCEMAIL     IN EBANKING.EBANKING_TOKEN_SOLICITUD.EMAIL%TYPE
                                             ,PAFCALIAS     IN EBANKING.EBANKING_TOKEN_SOLICITUD.ALIAS%TYPE
                                             ,PAFCCTA_CARGO IN EBANKING.EBANKING_TOKEN_SOLICITUD.CTA_CARGO%TYPE
                                             ,PAFCTIPO_CTA_CARGO IN EBANKING.EBANKING_TOKEN_SOLICITUD.TIPO_CTA_CARGO%TYPE
                                             ,PAFCSKU1           IN EBANKING.EBANKING_TOKEN_SOLICITUD.SKU1%TYPE
                                             ,PAFCSKU2           IN EBANKING.EBANKING_TOKEN_SOLICITUD.SKU2%TYPE
                                             ,PAFNCANT_SKU1      IN varchar2--EBANKING.EBANKING_TOKEN_SOLICITUD.CANT_SKU1%TYPE
                                             ,PAFNCANT_SKU2      IN varchar2--EBANKING.EBANKING_TOKEN_SOLICITUD.CANT_SKU2%TYPE
                                             ,PAFNCOSTO_ENVIO    IN varchar2--EBANKING.EBANKING_TOKEN_SOLICITUD.COSTO_ENVIO%TYPE
                                             ,PAFCID_MENSAJERIA  IN EBANKING.EBANKING_TOKEN_SOLICITUD.ID_MENSAJERIA%TYPE
                                             ,PAFCDES_MENSAJERIA IN EBANKING.EBANKING_TOKEN_SOLICITUD.DES_MENSAJERIA%TYPE
                                             ,PAFNNO_INTENTOS    IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOLICITUD.NO_INTENTOS%TYPE
                                             ,PAFCOBS            IN EBANKING.EBANKING_TOKEN_SOLICITUD.OBS%TYPE
                                             ,PAFDPRIMER_INTENTO IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOLICITUD.PRIMER_INTENTO%TYPE
                                             ,PAFDULTIMO_INTENTO IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOLICITUD.ULTIMO_INTENTO%TYPE
                                             ,PAFNIMPORTE             IN VARCHAR2--EBANKING.EBANKING_TOKEN_SOLICITUD.IMPORTE%TYPE
                                             ,PAFCRETENCION_SOLICITUD IN EBANKING.EBANKING_TOKEN_SOLICITUD.RETENCION_SOLICITUD%TYPE
                                             ,PAFCSISTEMA IN EBANKING.EBANKING_TOKEN_SOLICITUD.SISTEMA%TYPE
                                             ,PAFCPAIS IN EBANKING.EBANKING_TOKEN_SOLICITUD.IDPAIS%TYPE
                                             ,FNPSCOD OUT NUMBER
                                             ,FCPSMSG OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para insertar registros en la tabla EBANKING_TOKEN_SOLICITUD 
   Parametros de entrada:   PAFNFOLIO_SOLICITUD Folio de solicitud
                          PAFCNUM_CTE    -Numero de cliente
                         PAFCNOM_CTE     -Nombre del cliente
                         PAFCAPE_PAT_CTE -Apellido paterno del cliente
                         PAFCAPE_MAT_CTE -Apellido materno del cliente
                         PAFCRFC_CTE     -RFC del cliente
                         PAFCDIR_ENT     -Direccion del cliente
                         PAFCCOL_ENT     -Colonia del cliente
                         PAFCCP_ENT      -Codigo Postal del cliente 
                         PAFCCIUDAD_ENT  -Ciudad
                         PAFCEDO_ENT     -Estado
                         PAFCTEL_ENT     -Telefono
                         PAFCTEL_ADI_ENT -Telefono adicional
                         PAFCPER_AUT1    -Persona1 autorizada
                         PAFCPER_AUT2    -Persona2 autorizada
                         PAFCPER_AUT3    -Persona3 autorizada
                         PAFNESTATUS_SOL -Estatus de solicitud
                         PAFNNUM_PEDIDO_EKT -Numero de pedido
                         PAFCDIR_IP            -Direccion ip
                         PAFCFECHA_SOL_PREVFRA -Fecha de solicitud prevencionde fraudes
                         PAFCID_USUARIO_PREV_FRAUDES -Usuario de prevencion de fraudes
                         PAFCEMAIL           -Direccion de correo electronico
                         PAFCALIAS          -Alias
                         PAFCCTA_CARGO      -Cuenta Cargo
                         PAFCTIPO_CTA_CARGO -Tipo de cuenta cargo
                         PAFCSKU1        -sku1 token
                         PAFCSKU2        -sku2 lector
                         PAFNCANT_SKU1   -Cantidad de sku1 token
                         PAFNCANT_SKU2   -Cantidad de sku2 lector
                         PAFNCOSTO_ENVIO -Costo de envio
                         PAFCID_MENSAJERIA -ID de la Mensajeria
                         PAFCDES_MENSAJERIA -Descripcion de la mensajeria
                         PAFNNO_INTENTOS    -Numero de intentos
                         PAFCOBS            -Observaciones
                         PAFDPRIMER_INTENTO -Primer Intento
                         PAFDULTIMO_INTENTO -Ultimo intento
                         PAFNIMPORTE        -Importe
                         PAFCRETENCION_SOLICITUD -Solicitud de retencion
   Parametros de salida:  FNPSCOD                -Codigo de retorno del procedimiento
                          FCPSMSG                -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 27/02/2013
****************************************************************************/

BEGIN
    FCPSMSG := 'OPERACION EXITOSA';
    FNPSCOD := 0;
    --RAISE_APPLICATION_ERROR (-20100, '------'||PAFNFOLIO_SOLICITUD);
    
    INSERT INTO EBANKING.EBANKING_TOKEN_SOLICITUD (FOLIO_SOLICITUD
                                                  ,NUM_CTE,NOM_CTE
                                                  ,APE_PAT_CTE
                                                  ,APE_MAT_CTE
                                                  ,RFC_CTE
                                                  ,DIR_ENT
                                                  ,COL_ENT
                                                  ,CP_ENT
                                                  ,CIUDAD_ENT
                                                  ,EDO_ENT
                                                  ,TEL_ENT
                                                  ,TEL_ADI_ENT
                                                  ,PER_AUT1
                                                  ,PER_AUT2
                                                  ,PER_AUT3
                                                  ,FECHA_SOL_INTERNET
                                                  ,ESTATUS_SOL
                                                  ,NUM_PEDIDO_EKT
                                                  ,DIR_IP
                                                  ,FECHA_SOL_PREVFRA
                                                  ,ID_USUARIO_PREV_FRAUDES
                                                  ,EMAIL
                                                  ,ALIAS
                                                  ,CTA_CARGO
                                                  ,TIPO_CTA_CARGO
                                                  ,SKU1
                                                  ,SKU2
                                                  ,CANT_SKU1
                                                  ,CANT_SKU2
                                                  ,COSTO_ENVIO
                                                  ,ID_MENSAJERIA
                                                  ,DES_MENSAJERIA
                                                  ,NO_INTENTOS
                                                  ,OBS
                                                  ,PRIMER_INTENTO
                                                  ,ULTIMO_INTENTO
                                                  ,IMPORTE
                                                  ,RETENCION_SOLICITUD
                                                  ,SISTEMA
                                                  ,IDPAIS)
                                            VALUES(PAFNFOLIO_SOLICITUD
                                                  ,PAFCNUM_CTE
                                                  ,PAFCNOM_CTE
                                                  ,PAFCAPE_PAT_CTE
                                                  ,PAFCAPE_MAT_CTE
                                                  ,PAFCRFC_CTE
                                                  ,PAFCDIR_ENT
                                                  ,PAFCCOL_ENT
                                                  ,PAFCCP_ENT
                                                  ,PAFCCIUDAD_ENT
                                                  ,PAFCEDO_ENT
                                                  ,PAFCTEL_ENT
                                                  ,PAFCTEL_ADI_ENT
                                                  ,PAFCPER_AUT1
                                                  ,PAFCPER_AUT2
                                                  ,PAFCPER_AUT3
                                                  ,SYSDATE
                                                  ,PAFNESTATUS_SOL
                                                  ,PAFNNUM_PEDIDO_EKT
                                                  ,PAFCDIR_IP
                                                  ,PAFCFECHA_SOL_PREVFRA
                                                  ,PAFCID_USUARIO_PREV_FRAUDES
                                                  ,PAFCEMAIL
                                                  ,PAFCALIAS
                                                  ,PAFCCTA_CARGO
                                                  ,PAFCTIPO_CTA_CARGO
                                                  ,TO_NUMBER(PAFCSKU1)
                                                  ,TO_NUMBER(PAFCSKU2)
                                                  ,PAFNCANT_SKU1
                                                  ,PAFNCANT_SKU2
                                                  ,TO_NUMBER(PAFNCOSTO_ENVIO,'9999999999.99')
                                                  ,PAFCID_MENSAJERIA
                                                  ,PAFCDES_MENSAJERIA
                                                  ,TO_NUMBER(PAFNNO_INTENTOS)
                                                  ,PAFCOBS
                                                  ,PAFDPRIMER_INTENTO
                                                  ,PAFDULTIMO_INTENTO
                                                  ,TO_NUMBER(PAFNIMPORTE,'999999999.99')
                                                  ,PAFCRETENCION_SOLICITUD
                                                  ,'NETNET'
                                                  ,'MX');
    COMMIT;
EXCEPTION
   WHEN OTHERS THEN
   ROLLBACK;
      FCPSMSG := 'ERROR AL INSERTAR EL REGISTRO EN LA TABLA';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al insertar el registro en la tabla ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPINSSPEICELULAR
( PAFIOPCION                       IN   EBANKING.TASPEICELULAR.FIOPCION%TYPE 
  ,PAFCNUMEROACC               IN   EBANKING.TASPEICELULAR.FCNUMEROACC%TYPE 
  ,PAFCNUMEROTARJ              IN   EBANKING.TASPEICELULAR.FCNUMEROTARJ%TYPE 
  ,PAFCCTACLABE                   IN   EBANKING.TASPEICELULAR.FCCTACLABE%TYPE 
  ,PAPAFCNUMCEL                      IN   EBANKING.TASPEICELULAR.FCNUMCEL%TYPE 
  ,PAFCNOMBRECNIACEL         IN   EBANKING.TASPEICELULAR.FCNOMBRECNIACEL%TYPE 
  ,PAFCMONTOMAXPERMI       IN   EBANKING.TASPEICELULAR.FCMONTOMAXPERMI%TYPE 
  ,PAFCMONTOMAXTRANS      IN   EBANKING.TASPEICELULAR.FCMONTOMAXTRANS%TYPE 
  ,PAFCMONTOMAXSPEI         IN   EBANKING.TASPEICELULAR.FCMONTOMAXSPEI%TYPE 
  ,PAFCMONTOMAXTEF          IN   EBANKING.TASPEICELULAR.FCMONTOMAXTEF%TYPE 
  ,PAFCBANDERALIBRE1          IN   EBANKING.TASPEICELULAR.FCBANDERALIBRE1%TYPE 
  ,PAFCBANDERALIBRE2          IN   EBANKING.TASPEICELULAR.FCBANDERALIBRE2%TYPE 
  ,PAFCCAMPOMONTOLIB1      IN   EBANKING.TASPEICELULAR.FCCAMPOMONTOLIB1%TYPE 
  ,PAFCCAMPOMONTOLIB2      IN   EBANKING.TASPEICELULAR.FCCAMPOMONTOLIB2%TYPE 
  ,PAPAFCCAMALFALIB1              IN   EBANKING.TASPEICELULAR.FCCAMALFALIB1%TYPE 
  ,PAFCCAMALFALIB2              IN   EBANKING.TASPEICELULAR.FCCAMALFALIB2%TYPE 
  ,PAFCUSUARIO_MODIFICO    IN   EBANKING.TASPEICELULAR.FCUSUARIO_MODIFICO%TYPE 
 ,PA_COD_ERROR         OUT  NUMBER
 ,PA_MSG_ERROR         OUT  VARCHAR2 )
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TASPEICELULAR
   Parametros de entrada:   PA_FIID        - Identificador unico del movimiento programado

   Parametros de salida:  FNPSCOD                -Codigo de retorno del procedimiento
                                    FCPSMSG                -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 16/04/2014
****************************************************************************/
BEGIN
      INSERT INTO  EBANKING.TASPEICELULAR(FIID
										  ,FIOPCION
										  ,FCNUMEROACC
										  ,FCNUMEROTARJ
										  ,FCCTACLABE 
										  ,FCNUMCEL 
										  ,FCNOMBRECNIACEL
										  ,FCMONTOMAXPERMI
										  ,FCMONTOMAXTRANS
										  ,FCMONTOMAXSPEI
										  ,FCMONTOMAXTEF
										  ,FCBANDERALIBRE1
										  ,FCBANDERALIBRE2
										  ,FCCAMPOMONTOLIB1
										  ,FCCAMPOMONTOLIB2
										  ,FCCAMALFALIB1
										  ,FCCAMALFALIB2
										  ,FDULTIMA_OPERACION
										  ,FDULTIMA_MODIFICACION
										  ,FCUSUARIO_MODIFICO) 
							VALUES ( EBANKING.SEC_TASPEICELULAR.NEXTVAL
										  ,PAFIOPCION
										  ,PAFCNUMEROACC 
										  ,PAFCNUMEROTARJ 
										  ,PAFCCTACLABE 
										  ,PAPAFCNUMCEL 
										  ,PAFCNOMBRECNIACEL 
										  ,PAFCMONTOMAXPERMI 
										  ,PAFCMONTOMAXTRANS 
										  ,PAFCMONTOMAXSPEI 
										  ,PAFCMONTOMAXTEF 
										  ,PAFCBANDERALIBRE1 
										  ,PAFCBANDERALIBRE2 
										  ,PAFCCAMPOMONTOLIB1 
										  ,PAFCCAMPOMONTOLIB2 
										  ,PAPAFCCAMALFALIB1 
										  ,PAFCCAMALFALIB2
										  ,SYSDATE
										  ,SYSDATE
										  ,PAFCUSUARIO_MODIFICO  );
             COMMIT;
              PA_COD_ERROR:=0;
              PA_MSG_ERROR:='OPERACION EXITOSA ';
    EXCEPTION
			WHEN OTHERS THEN
            ROLLBACK;
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'FALLO AL INSERTAR EN  TASPEICELULAR (' || SQLCODE || '  ' || SQLERRM || ')');

END SPINSSPEICELULAR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPI_ACTIVACIONACRTUM
 (
  P_TELEFONO IN EBANKING.ACTIVAR_ACRTUM.TELEFONO %TYPE,
  P_NUMERO_CLIENTE IN EBANKING.ACTIVAR_ACRTUM.NUMERO_CLIENTE %TYPE,
  P_EMAIL IN EBANKING.ACTIVAR_ACRTUM.EMAIL %TYPE,
  P_PRIMER_LOGEO IN EBANKING.ACTIVAR_ACRTUM.PRIMER_LOGEO %TYPE,
  P_USUARIO_MODIFICO IN EBANKING.ACTIVAR_ACRTUM.USUARIO_MODIFICO %TYPE
 )
 AS
 V_FECHA_ACTUAL DATE :=SYSDATE;
 BEGIN
 INSERT INTO EBANKING.ACTIVAR_ACRTUM
                  (TELEFONO,NUMERO_CLIENTE,EMAIL,PRIMER_LOGEO,FECHA_ACTIVACION,FECHA_MODIFICACION,USUARIO_MODIFICO)
           VALUES(P_TELEFONO,P_NUMERO_CLIENTE,P_EMAIL,P_PRIMER_LOGEO,V_FECHA_ACTUAL,V_FECHA_ACTUAL,P_USUARIO_MODIFICO);
COMMIT;              
 EXCEPTION
  WHEN OTHERS THEN
  ROLLBACK;
      RAISE_APPLICATION_ERROR
      (
        -20100, 'Error ocurrido en el stored EBANKING.SPI_ACTIVACIONACRTUM  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)'
      );
 END SPI_ACTIVACIONACRTUM;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SPOBTAINTOKENSEC (PAFNSOLTOKENID OUT VARCHAR2
                                             ,FNPSCOD        OUT NUMBER
                                             ,FCPSMSG        OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento para obtener la secuencia de la solicitud de token
   Parametros de entrada:   
   Parametros de salida:   PAFNSOLTOKENID      - Numero obtenido de la secuencia para la solicitud de token
                           FNPSCOD             - Codigo de retorno del procedimiento
                           FCPSMSG             - Mensaje de retoro del procedimiento
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  27/02/2013
****************************************************************************/
--vlUno VARCHAR2(20 char);
BEGIN
    FCPSMSG := 'OPERACION EXITOSA';
    FNPSCOD := 0;
    SELECT EBANKING.SEQ_TOKEN_SOLICITUD_ID.NEXTVAL
      INTO PAFNSOLTOKENID
      FROM DUAL; 
     -- PAFNSOLTOKENID := vlUno;
   --RAISE_APPLICATION_ERROR (-20100, 'E--'||FNPSCOD||'-----'||PAFNSOLTOKENID||'--'||vlUno);
    -- FNPSCOD := PAFNSOLTOKENID;
EXCEPTION
   WHEN OTHERS THEN
      FCPSMSG := 'ERROR AL OBTENER LA SECUENCIA DE LA SOLICITUD DE TOKEN';
      FNPSCOD := SQLCODE;
      RAISE_APPLICATION_ERROR (-20100, 'Error al obtener la secuencia del token ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SPRepo_Borrar
AS BEGIN
    DELETE 
    FROM EBANKING.REPO_TASA_PLAZO;
END SPRepo_Borrar;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SPRepo_Insertar(
    ID_TASA_PLAZO IN NUMBER,
    TASA          IN VARCHAR,
    PLAZO         IN VARCHAR,
    FECHA         IN     VARCHAR,
    ULTIMA_MODIFICACION IN VARCHAR,
    USUARIO_MODIFICO IN VARCHAR,
    TIPO_PERSONA     IN VARCHAR)
AS
BEGIN
 
  INSERT
  INTO EBANKING.REPO_TASA_PLAZO
    (
      ID_TASA_PLAZO,
      TASA,
      PLAZO,
      FECHA,
      ULTIMA_MODIFICACION,
      USUARIO_MODIFICO,
      TIPO_PERSONA
    )
    VALUES
    (
      ID_TASA_PLAZO,
      TASA,
      PLAZO,
      to_date(FECHA,'dd/mm/yyyy'),
      sysdate,
      USUARIO_MODIFICO,
      TIPO_PERSONA
    );
  COMMIT;
EXCEPTION
WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar una tasa de plazo (' || SQLCODE || '  ' || SQLERRM || ')'
  )
  ;
WHEN OTHERS THEN
  ROLLBACK;
  RAISE_APPLICATION_ERROR
  (
    -20100, 'Error ocurrido al insertar una tasa de plazo  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)'
  )
  ;
END SPRepo_Insertar;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPTRUNEMITOP15
( PA_COD_ERROR            OUT  NUMBER
 ,PA_MSG_ERROR            OUT  VARCHAR2 )
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TATOP15_PS
   Parametros de entrada:  
   Parametros de salida:  FNPSCOD   -Codigo de retorno del procedimiento
                          FCPSMSG   -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 28/05/2014.
****************************************************************************/
BEGIN
  EXECUTE IMMEDIATE ' TRUNCATE TABLE EBANKING.TATOP15_PS';
   COMMIT;
   PA_COD_ERROR:=0;
   PA_MSG_ERROR:='OPERACION EXITOSA ';
   EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        PA_COD_ERROR:=1;
        PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
        RAISE_APPLICATION_ERROR (-20100, 'FALLO AL BLANQUEAR TATOP15_PS (' || SQLCODE || '  ' || SQLERRM || ')');
END SPTRUNEMITOP15;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPUPDATEPAGOPROGRA
(  PA_FIID        IN   EBANKING.TAOP_PROGRA_30_MIN.FIID%TYPE 
   ,PA_FCESTADONEW EBANKING.TAOP_PROGRA_30_MIN.FCESTADO%TYPE
   ,PA_FCRESPUESTA EBANKING.TAOP_PROGRA_30_MIN.FCRESPUESTA%TYPE  
   ,PA_COD_ERROR         OUT  NUMBER
   ,PA_MSG_ERROR         OUT  VARCHAR2 )
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TAPAGOSELEKTRA
   Parametros de entrada:   PA_FIID        - Identificador unico del movimiento programado

   Parametros de salida:  FNPSCOD                -Codigo de retorno del procedimiento
                                    FCPSMSG                -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 04/04/2014
****************************************************************************/
BEGIN
      UPDATE EBANKING.TAOP_PROGRA_30_MIN
             SET FCESTADO = PA_FCESTADONEW
                   ,FCRESPUESTA = PA_FCRESPUESTA
             WHERE FIID = PA_FIID;
             
             COMMIT;
               PA_COD_ERROR:=0;
              PA_MSG_ERROR:='OPERACION EXITOSA';
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
            ROLLBACK;
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'FALLO AL INSERTAR EN  TAPAGOSELEKTRA (' || SQLCODE || '  ' || SQLERRM || ')');


END SPUPDATEPAGOPROGRA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SPVALIDNIP (PAFNNIP   IN  EBANKING.EBANKING_TARJETASNIP.CUENTA%TYPE
                                        ,FNPSCOD OUT NUMBER
                                        ,FCPSMSG OUT VARCHAR2)AS
/****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Procedimiento encargado de consultar el nip
   Parametros de entrada:  PAFNNIP           -Identificador del NIP
   Parametros de salida:   FNPSCOD           -Codigo de retorno del procedimiento
                           FCPSMSG           -Mensaje de retoro del procedimiento
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  01/02/2013
****************************************************************************/
VLISVALID EBANKING.EBANKING_TARJETASNIP.STATUS%TYPE := 1;--indica si es valido o no 0 es valido 1 invalido
CSLNUMUNO NUMBER := 1;
CSLNUMCERO NUMBER := 0;
BEGIN
FNPSCOD :=CSLNUMUNO;--Por default el nip es invalido
    SELECT STATUS
      INTO VLISVALID 
      FROM EBANKING.EBANKING_TARJETASNIP
     WHERE CUENTA = PAFNNIP 
       AND STATUS = CSLNUMCERO; 
       FNPSCOD := VLISVALID;
       FCPSMSG := CASE WHEN VLISVALID = CSLNUMUNO THEN 'EL NIP ES INVALIDO' ELSE 'EL NIP ES VALIDO'END;
EXCEPTION
WHEN NO_DATA_FOUND THEN   
   FCPSMSG := 'EL NIP ES INVALIDO';
   RAISE_APPLICATION_ERROR (-20100, 'No se encontraron resultados ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)'||FNPSCOD||'--'||FCPSMSG);
WHEN OTHERS THEN
   FCPSMSG := 'EL NIP ES INVALIDO';
   RAISE_APPLICATION_ERROR (-20100, 'Error al buscar el NIP ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END SPVALIDNIP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_AAAA_PROBAR_FOR(
PSCod_Error    OUT     NUMBER,
PSMsg_Error    OUT     VARCHAR2
)
IS
BEGIN
  FOR CICLO IN 1..4 LOOP
        UPDATE AAAA
        SET NOMBRE = 4
        WHERE ID = CICLO;

  END LOOP;  
END SP_AAAA_PROBAR_FOR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ACERTUM_INS
(USER_ID_ins IN  EBANKING.TA_ACERTUM_USER.USER_ID%TYPE,
CELLULAR_ins IN EBANKING.TA_ACERTUM_USER.CELLULAR%TYPE,
EMAIL_ins IN EBANKING.TA_ACERTUM_USER.EMAIL%TYPE,
USER2CELLCOMPANY_ins IN EBANKING.TA_ACERTUM_USER.USER2CELLCOMPANY%TYPE,
CELLULAR_OLD_ins IN EBANKING.TA_ACERTUM_USER.CELLULAR_OLD%TYPE,
EMAIL_OLD_ins IN EBANKING.TA_ACERTUM_USER.EMAIL_OLD%TYPE,
USER2CELLCOMPANY_OLD_ins IN EBANKING.TA_ACERTUM_USER.USER2CELLCOMPANY_OLD%TYPE,
USUARIO_MODIFICA_ins IN EBANKING.TA_ACERTUM_USER.USUARIO_MODIFICA%TYPE)
AS
MENSAJE varchar2(50);
BEGIN
    Insert INTO EBANKING.TA_ACERTUM_USER (USER_ID,
    CELLULAR, EMAIL , USER2CELLCOMPANY,
    CELLULAR_OLD , EMAIL_OLD ,USER2CELLCOMPANY_OLD ,
    FECHA_MODIFICACION ,ULTIMA_MODIFICACION ,
    USUARIO_MODIFICA ) values(USER_ID_ins ,CELLULAR_ins ,EMAIL_ins ,
    USER2CELLCOMPANY_ins ,CELLULAR_OLD_ins ,EMAIL_OLD_ins ,
    USER2CELLCOMPANY_OLD_ins ,sysdate ,sysdate ,USUARIO_MODIFICA_ins);
    COMMIT;
    MENSAJE:='Datos insertados correctamente';    
    DBMS_OUTPUT.PUT_LINE(MENSAJE);
    EXCEPTION WHEN OTHERS THEN 
    ROLLBACK;
    raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);
END ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ACERTUM_SEL
(PA_ID IN  EBANKING.TA_ACERTUM_USER.USER_ID%TYPE, 
 ID_SALIDA OUT EBANKING.TA_ACERTUM_USER.USER_ID%TYPE )
AS
MENSAJE varchar2(50);
BEGIN
        SELECT USER_ID into ID_SALIDA FROM EBANKING.TA_ACERTUM_USER WHERE USER_ID=PA_ID;    
        MENSAJE:='SELECT EJECUTADO CORRECTAMENTE';     
        DBMS_OUTPUT.PUT_LINE(MENSAJE);
        EXCEPTION WHEN OTHERS THEN
        raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);
END ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ACTIVATEUSER(	
		IDALNOVA			EBANKING.EBANKING_USER.ID%TYPE,
		USRALIAS		EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE,
		MAIL		 EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE,
		USRQUESTION		EBANKING.EBANKING_ACTIVATION.QUESTION%TYPE,
		USRANSWER			EBANKING.EBANKING_ACTIVATION.ANSWER%TYPE,
		USRCELPHONE		EBANKING.EBANKING_ACTIVATION.CEL_PHONE%TYPE,
		USRCOMPANY			EBANKING.EBANKING_ACTIVATION.COMPANY%TYPE,
		UUSER2CELLCOMPANY	EBANKING.EBANKING_USER.USER2CELLCOMPANY%TYPE
)IS

BEGIN

	UPDATE EBANKING.EBANKING_ACTIVATION 
	SET EMAIL = MAIL, QUESTION = USRQUESTION, ANSWER = USRANSWER, CEL_PHONE = USRCELPHONE, COMPANY = USRCOMPANY  WHERE ALIAS = USRALIAS;
	
	UPDATE EBANKING.EBANKING_USER 
	SET ANSWER = USRANSWER,CELLULAR = USRCELPHONE,EMAIL = MAIL, QUESTION = USRQUESTION, USER2CELLCOMPANY = UUSER2CELLCOMPANY, TRACKING = 0 WHERE ID = IDALNOVA;
	
	COMMIT;
	
  EXCEPTION
     WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al activar usuario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
     ROLLBACK;
     RAISE;
END SP_ACTIVATEUSER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           SP_ACTUALIZABEN
(
           PA_FOLIO        IN      VARCHAR
          ,PA_IDBENEF      IN      EBANKING.TA_BENEFICIARIO.IDBENEFICIARIO%TYPE
          ,PA_APATERNO     IN      EBANKING.TA_BENEFICIARIO.APATERNO%TYPE
          ,PA_AMATERNO     IN      EBANKING.TA_BENEFICIARIO.AMATERNO%TYPE
          ,PA_NOMBRE       IN      EBANKING.TA_BENEFICIARIO.NOMBRE%TYPE
          ,PA_PARENTESCO   IN      EBANKING.TA_BENEFICIARIO.PARENTESCO%TYPE
          ,PA_PORCENTAJE   IN      EBANKING.TA_BENEFICIARIO.PORCENTAJE%TYPE
          ,PA_CALLE        IN      EBANKING.TA_DIRECCION.CALLE%TYPE
          ,PA_NUMEXT       IN      EBANKING.TA_DIRECCION.NUMEXT%TYPE
          ,PA_NUMINT       IN      EBANKING.TA_DIRECCION.NUMINT%TYPE
          ,PA_CP           IN      EBANKING.TA_DIRECCION.CP%TYPE
          ,PA_COLONIA      IN      EBANKING.TA_DIRECCION.COLONIA%TYPE
          ,PA_ESTADO       IN      EBANKING.TA_DIRECCION.ESTADO%TYPE
          ,PA_POBLACION    IN      EBANKING.TA_DIRECCION.POBLACION%TYPE
          ,PA_LADA         IN      EBANKING.TA_DIRECCION.LADA%TYPE
          ,PA_TELOF        IN      EBANKING.TA_DIRECCION.TELOFICINA%TYPE
          ,PA_EXTENSION    IN      EBANKING.TA_DIRECCION.EXTENSION%TYPE
          ,PA_NUMBENEF     IN      EBANKING.TA_BENEFICIARIO.NUMBENEFICIARIO%TYPE
          ,PA_USRMOD       IN      VARCHAR2
          ,PA_FECHMOD      IN      DATE
          ,PA_PORCENTF     IN      EBANKING.TA_BENEFICIARIO.PORCENTAJEF%TYPE
          ,PA_GRABADO      IN      EBANKING.TA_BENEFICIARIO.GRABADO%TYPE
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2 
          
)
IS
  
BEGIN
    UPDATE  EBANKING.TA_BENEFICIARIO SET
                   APATERNO=PA_APATERNO
                  ,AMATERNO=PA_AMATERNO
                  ,NOMBRE=PA_NOMBRE
                  ,PARENTESCO=PA_PARENTESCO
                  ,PORCENTAJE=PA_PORCENTAJE
                  ,USUARIO_MODIFICO=PA_USRMOD
                  ,FECHA_MODIFICO=PA_FECHMOD
                  ,NUMBENEFICIARIO=PA_NUMBENEF
                  ,PORCENTAJEF=PA_PORCENTF
                  ,GRABADO=PA_GRABADO               
      WHERE 
        TA_BENEFICIARIO.IDTITULAR=PA_FOLIO 
      AND 
         TA_BENEFICIARIO.IDBENEFICIARIO=PA_IDBENEF;
        
             UPDATE  EBANKING.TA_DIRBENEF SET
                         CALLE=PA_CALLE	                     
                        , NUMEXT=PA_NUMEXT
                        , NUMINT=PA_NUMINT
                        , CP=PA_CP   
                        , COLONIA=PA_COLONIA
                        , ESTADO=PA_ESTADO  
                        , POBLACION=PA_POBLACION    
                        , LADA=PA_LADA 
                        , TELOFICINA=PA_TELOF 
                        , EXTENSION=PA_EXTENSION        
                        , PORCENTAJE=PA_PORCENTAJE 
                        , USUARIO_MODIFICO=PA_USRMOD 
                        , FECHA_MODIFICO=PA_FECHMOD 
              WHERE  TA_DIRBENEF.IDBENEFICIARIO=PA_IDBENEF;
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO'; 
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          ROLLBACK ;
          PASCOD_ERROR:=1;
          PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
          RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_ACTUALIZABEN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ACTUALIZABENEF(
           P_FOLIO        IN      VARCHAR
          ,P_IDBENEF      IN      ta_beneficiario.idbeneficiario%TYPE
          ,P_APATERNO     IN      ta_beneficiario.apaterno%TYPE
          ,P_AMATERNO     IN      ta_beneficiario.amaterno%TYPE
          ,P_NOMBRE       IN      ta_beneficiario.nombre%TYPE
          ,P_PARENTESCO   IN      ta_beneficiario.parentesco%TYPE
          ,P_PORCENTAJE   IN      ta_beneficiario.porcentaje%TYPE
          ,P_CALLE        IN      ta_direccion.calle%TYPE
          ,P_NUMEXT       IN      ta_direccion.numext%TYPE
          ,P_NUMINT       IN      ta_direccion.numint%TYPE
          ,P_CP           IN      ta_direccion.cp%TYPE
          ,P_COLONIA      IN      ta_direccion.colonia%TYPE
          ,P_ESTADO       IN      ta_direccion.estado%TYPE
          ,P_POBLACION    IN      ta_direccion.poblacion%TYPE
          ,P_LADA         IN      ta_direccion.lada%TYPE
          ,P_TELOF        IN      ta_direccion.teloficina%TYPE
          ,P_EXTENSION    IN      ta_direccion.extension%TYPE
          ,P_NUMBENEF     IN      ta_beneficiario.numbeneficiario%TYPE
          ,P_USRMOD       IN      VARCHAR2
          ,P_FECHMOD      IN      DATE
          ,P_PORCENTF     IN      ta_beneficiario.porcentajef%TYPE
          ,P_GRABADO      IN      ta_beneficiario.grabado%TYPE
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2 
          
)
IS
  V_IDBENEF         INTEGER := 0;
  V_NUMFORMULARIO   INTEGER := 3;
  IDBENEF INTEGER:=0;
BEGIN
    UPDATE EBANKING.ta_beneficiario SET
                
                  ta_beneficiario.apaterno=P_APATERNO
                  ,ta_beneficiario.amaterno=P_AMATERNO
                  ,ta_beneficiario.nombre=P_NOMBRE
                  ,ta_beneficiario.parentesco=P_PARENTESCO
                  ,ta_beneficiario.porcentaje=P_PORCENTAJE
                  ,ta_beneficiario.usuario_modifico=P_USRMOD
                  ,ta_beneficiario.fecha_modifico=P_FECHMOD
                  ,ta_beneficiario.numbeneficiario=P_NUMBENEF
                  ,ta_beneficiario.porcentajef=P_PORCENTF
                  ,ta_beneficiario.grabado=P_GRABADO
                
      WHERE EBANKING.ta_beneficiario.idtitular=P_FOLIO 
      AND EBANKING.ta_beneficiario.idbeneficiario=P_IDBENEF;
        
             UPDATE EBANKING.ta_dirbenef SET
                        EBANKING.ta_dirbenef.CALLE=P_CALLE	                     
                        ,EBANKING.ta_dirbenef.NUMEXT=P_NUMEXT
                        ,EBANKING.ta_dirbenef.NUMINT=P_NUMINT
                        ,EBANKING.ta_dirbenef.CP=P_CP   
                        ,EBANKING.ta_dirbenef.COLONIA=P_COLONIA
                        ,EBANKING.ta_dirbenef.ESTADO=P_ESTADO  
                        ,EBANKING.ta_dirbenef.POBLACION=P_POBLACION    
                        ,EBANKING.ta_dirbenef.LADA=P_LADA 
                        ,EBANKING.ta_dirbenef.TELOFICINA=P_TELOF 
                        ,EBANKING.ta_dirbenef.EXTENSION=P_EXTENSION        
                        ,EBANKING.ta_dirbenef.PORCENTAJE=P_PORCENTAJE 
                        ,EBANKING.ta_dirbenef.USUARIO_MODIFICO=P_USRMOD 
                        ,EBANKING.ta_dirbenef.FECHA_MODIFICO=P_FECHMOD 
                        ,EBANKING.ta_dirbenef.idtitular = P_FOLIO 
              WHERE EBANKING.ta_dirbenef.idbeneficiario=P_IDBENEF;
    PSCod_Error := 0;
    PSMsg_Error := 'Se MODIFICO beneficiario en SP_ACTUALIZABENEF'; 
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          ROLLBACK ;
          PSCod_Error:=1;
          PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
          RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar beneficiario en SP_ADDBENEFICIARIO  (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_ACTUALIZABENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ACTUALIZA_WS 
(
          P_FOLIO          IN      EBANKING.ta_cliente.idusuario%type
          ,P_IMEI          IN      EBANKING.ta_cliente.imei%type 
          ,PSCod_Error     OUT     NUMBER
          ,P_STATUS        OUT     VARCHAR2
          ,PSMsg_Error     OUT     VARCHAR2
) 
IS
v_valida number := 0;
v_folioprereg varchar(20) := '';
BEGIN

        SELECT EBANKING.ta_cliente.idusuario
        INTO v_folioprereg
        FROM EBANKING.ta_cliente
        WHERE EBANKING.ta_cliente.idusuario = P_FOLIO;
        
        
        IF v_folioprereg = P_FOLIO THEN
            UPDATE EBANKING.ta_usuario
            SET EBANKING.ta_usuario.estatuslogin = 1
            WHERE EBANKING.ta_usuario.idusuario = P_FOLIO; 
            
            UPDATE EBANKING.ta_cliente
            SET EBANKING.ta_cliente.imei = P_IMEI
            WHERE EBANKING.ta_cliente.idusuario = P_FOLIO;
            
            P_STATUS := '1';
            PSCod_Error := 0;
            PSMsg_Error := 'Actulizo registro en ta_cliente';
            COMMIT;
        ELSE
            P_STATUS := '0';
            PSCod_Error := 1;
            PSMsg_Error := 'No se actulizo registro en ta_cliente';            
        END IF;
        
        
        
    EXCEPTION
             WHEN NO_DATA_FOUND THEN 
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'NO_DATA_FOUND' );
              
              UPDATE EBANKING.ta_usuario
              SET EBANKING.ta_usuario.estatuslogin = 0
              WHERE EBANKING.ta_usuario.idusuario = P_FOLIO; 
              
              P_STATUS := '0';
              
            WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
              P_STATUS := '0';
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              P_STATUS:='0';
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar usuario en SP_ACTUALIZA_WS   (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_ACTUALIZA_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ACT_FRECINT(IDALNOVA_FRECUENT IN NUMBER, STATUS_FRECUENT IN NUMBER, CTADESTINO_FRECUENT IN VARCHAR2)
AS
BENEF_STATUS_EXISTE     NUMBER;
PSCod_Error             NUMBER;
PSMsg_Error             VARCHAR2(1000);
BEGIN
  
  SELECT STATUS_BLOQUEO INTO BENEF_STATUS_EXISTE 
  FROM EBANKING.TRANSFINTERNALFRECUENT 
  WHERE CLIENT = IDALNOVA_FRECUENT 
  AND DESTINO = CTADESTINO_FRECUENT;
  
  IF BENEF_STATUS_EXISTE = STATUS_FRECUENT THEN
  
      PSCod_Error := 2;
      PSMsg_Error := 'No sufrio cambio el ESTATUS DE BLOQUEO';
  
  ELSE
  
      UPDATE EBANKING.TRANSFINTERNALFRECUENT  
      SET STATUS_BLOQUEO = STATUS_FRECUENT, FECHA_MODIFICACION = SYSDATE
      WHERE CLIENT = IDALNOVA_FRECUENT  
      AND DESTINO = CTADESTINO_FRECUENT;
      COMMIT;
      PSCod_Error := 0;
      PSMsg_Error := 'Se actualizo el ESTATUS DE BLOQUEO Y LA FECHA DE MODIFICACION correctamente';
  
  END IF;
  
  EXCEPTION WHEN OTHERS THEN
      PSCod_Error := 1;
      PSMsg_Error := 'Error al actualizar SP_UPDATE_FRECUENT_INTERNAL(' || SQLCODE || '  ' || SQLERRM || ')';
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20100, PSMsg_Error);
      
END SP_ACT_FRECINT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           SP_ADDBENEFICIA
(
           PA_FOLIO        IN      VARCHAR
          ,PA_APATERNO     IN      EBANKING.TA_BENEFICIARIO.APATERNO%TYPE
          ,PA_AMATERNO     IN      EBANKING.TA_BENEFICIARIO.AMATERNO%TYPE
          ,PA_NOMBRE       IN      EBANKING.TA_BENEFICIARIO.NOMBRE%TYPE
          ,PA_PARENTESCO   IN      EBANKING.TA_BENEFICIARIO.PARENTESCO%TYPE
          ,PA_PORCENTAJE   IN      EBANKING.TA_BENEFICIARIO.PORCENTAJE%TYPE
          ,PA_CALLE        IN      EBANKING.TA_DIRECCION.CALLE%TYPE
          ,PA_NUMEXT       IN      EBANKING.TA_DIRECCION.NUMEXT%TYPE
          ,PA_NUMINT       IN      EBANKING.TA_DIRECCION.NUMINT%TYPE
          ,PA_CP           IN      EBANKING.TA_DIRECCION.CP%TYPE
          ,PA_COLONIA      IN      EBANKING.TA_DIRECCION.COLONIA%TYPE
          ,PA_ESTADO       IN      EBANKING.TA_DIRECCION.ESTADO%TYPE
          ,PA_POBLACION    IN      EBANKING.TA_DIRECCION.POBLACION%TYPE
          ,PA_LADA         IN      EBANKING.TA_DIRECCION.LADA%TYPE
          ,PA_TELOF        IN      EBANKING.TA_DIRECCION.TELOFICINA%TYPE
          ,PA_EXTENSION    IN      EBANKING.TA_DIRECCION.EXTENSION%TYPE
          ,PA_NUMBENEF     IN      EBANKING.TA_BENEFICIARIO.NUMBENEFICIARIO%TYPE
          ,PA_USRMOD       IN      VARCHAR2
          ,PA_FECHMOD      IN      DATE
          ,PA_PORCENTF     IN      EBANKING.TA_BENEFICIARIO.PORCENTAJEF%TYPE
          ,PA_GRABADO      IN      EBANKING.TA_BENEFICIARIO.GRABADO%TYPE
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2 
)
IS
BEGIN
    INSERT INTO  EBANKING.TA_BENEFICIARIO 
                (
                   IDBENEFICIARIO
                  ,IDTITULAR
                  ,APATERNO
                  ,AMATERNO
                  ,NOMBRE
                  ,PARENTESCO
                  ,PORCENTAJE
                  ,USUARIO_MODIFICO
                  ,FECHA_MODIFICO
                  ,NUMBENEFICIARIO
                  ,PORCENTAJEF
                  ,GRABADO
                )
          VALUES
                ( 
                  EBANKING.SE_IDBENEF.NEXTVAL
                  ,PA_FOLIO
                  ,PA_APATERNO
                  ,PA_AMATERNO
                  ,PA_NOMBRE  
                  ,PA_PARENTESCO
                  ,PA_PORCENTAJE
                  ,PA_USRMOD
                  ,PA_FECHMOD
                  ,PA_NUMBENEF
                  ,PA_PORCENTF
                  ,PA_GRABADO
                );
          
           
            
             INSERT INTO  EBANKING.TA_DIRBENEF
                      ( 
                          IDDIRBENEF
                        , IDBENEFICIARIO
                        , CALLE                     
                        , NUMEXT
                        , NUMINT
                        , CP
                        , COLONIA
                        , ESTADO
                        , POBLACION
                        , LADA
                        , TELOFICINA
                        , EXTENSION
                        , PORCENTAJE
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                        , GRABADO
                        , IDTITULAR
                       )
                  VALUES
                      ( 
                         EBANKING.SE_IDDIRBENEF.NEXTVAL 
                        ,EBANKING.SE_IDBENEF.CURRVAL 
                        ,PA_CALLE		                     
                        ,PA_NUMEXT       
                        ,PA_NUMINT       
                        ,PA_CP           
                        ,PA_COLONIA      
                        ,PA_ESTADO       
                        ,PA_POBLACION    
                        ,PA_LADA         
                        ,PA_TELOF          
                        ,PA_EXTENSION          
                        ,PA_PORCENTAJE                                
                        ,PA_USRMOD   
                        ,PA_FECHMOD
                        ,PA_GRABADO
                        ,PA_FOLIO
                      );
          
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO'; 
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          PASCOD_ERROR:=1;
          PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
          ROLLBACK ;
          RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_ADDBENEFICIA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ADDBENEFICIARIO(
           P_FOLIO        IN     VARCHAR
          ,P_APATERNO     IN      ta_beneficiario.apaterno%TYPE
          ,P_AMATERNO     IN      ta_beneficiario.amaterno%TYPE
          ,P_NOMBRE       IN      ta_beneficiario.nombre%TYPE
          ,P_PARENTESCO   IN      ta_beneficiario.parentesco%TYPE
          ,P_PORCENTAJE   IN      ta_beneficiario.porcentaje%TYPE
          ,P_CALLE        IN      ta_direccion.calle%TYPE
          ,P_NUMEXT       IN      ta_direccion.numext%TYPE
          ,P_NUMINT       IN      ta_direccion.numint%TYPE
          ,P_CP           IN      ta_direccion.cp%TYPE
          ,P_COLONIA      IN      ta_direccion.colonia%TYPE
          ,P_ESTADO       IN      ta_direccion.estado%TYPE
          ,P_POBLACION    IN      ta_direccion.poblacion%TYPE
          ,P_LADA         IN      ta_direccion.lada%TYPE
          ,P_TELOF        IN      ta_direccion.teloficina%TYPE
          ,P_EXTENSION    IN      ta_direccion.extension%TYPE
          ,P_NUMBENEF     IN      ta_beneficiario.numbeneficiario%TYPE
          ,P_USRMOD       IN      VARCHAR2
          ,P_FECHMOD      IN      DATE
          ,P_PORCENTF     IN      ta_beneficiario.porcentajef%TYPE
          ,P_GRABADO      IN      ta_beneficiario.grabado%TYPE
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2 
)
IS
  V_IDBENEF         INTEGER := 0;
  V_NUMFORMULARIO   INTEGER := 3;
  IDBENEF INTEGER:=0;
BEGIN
    INSERT INTO EBANKING.ta_beneficiario 
                (
                  ta_beneficiario.idbeneficiario
                  ,ta_beneficiario.idtitular
                  ,ta_beneficiario.apaterno
                  ,ta_beneficiario.amaterno
                  ,ta_beneficiario.nombre
                  ,ta_beneficiario.parentesco
                  ,ta_beneficiario.porcentaje
                  ,ta_beneficiario.usuario_modifico
                  ,ta_beneficiario.fecha_modifico
                  ,ta_beneficiario.numbeneficiario
                  ,ta_beneficiario.porcentajef
                  ,ta_beneficiario.grabado
                )
          VALUES
                ( 
                  SE_IDBENEF.NEXTVAL
                  ,P_FOLIO
                  ,P_APATERNO
                  ,P_AMATERNO
                  ,P_NOMBRE  
                  ,P_PARENTESCO
                  ,P_PORCENTAJE
                  ,P_USRMOD
                  ,P_FECHMOD
                  ,P_NUMBENEF
                  ,P_PORCENTF
                  ,P_GRABADO
                );
          
           SELECT *
            INTO V_IDBENEF
              FROM (
                    SELECT idbeneficiario 
                    FROM EBANKING.ta_beneficiario
                    ORDER BY ta_beneficiario.idbeneficiario DESC 
                  )
            WHERE ROWNUM = 1;
            
             INSERT INTO EBANKING.ta_dirbenef
                      ( 
                         EBANKING.ta_dirbenef.IDDIRBENEF
                        ,EBANKING.ta_dirbenef.IDBENEFICIARIO
                        ,EBANKING.ta_dirbenef.CALLE                     
                        ,EBANKING.ta_dirbenef.NUMEXT
                        ,EBANKING.ta_dirbenef.NUMINT
                        ,EBANKING.ta_dirbenef.CP
                        ,EBANKING.ta_dirbenef.COLONIA
                        ,EBANKING.ta_dirbenef.ESTADO
                        ,EBANKING.ta_dirbenef.POBLACION
                        ,EBANKING.ta_dirbenef.LADA
                        ,EBANKING.ta_dirbenef.TELOFICINA
                        ,EBANKING.ta_dirbenef.EXTENSION
                        ,EBANKING.ta_dirbenef.PORCENTAJE
                        ,EBANKING.ta_dirbenef.USUARIO_MODIFICO
                        ,EBANKING.ta_dirbenef.FECHA_MODIFICO
                        ,EBANKING.ta_dirbenef.grabado
                        ,EBANKING.ta_dirbenef.idtitular
                       )
                  VALUES
                      ( 
                        SE_IDDIRBENEF.nextval 
                        ,V_IDBENEF
                        ,P_CALLE		                     
                        ,P_NUMEXT       
                        ,P_NUMINT       
                        ,P_CP           
                        ,P_COLONIA      
                        ,P_ESTADO       
                        ,P_POBLACION    
                        ,P_LADA         
                        ,P_TELOF          
                        ,P_EXTENSION          
                        ,P_PORCENTAJE                                
                        ,P_USRMOD   
                        ,P_FECHMOD
                        ,P_GRABADO
                        ,P_FOLIO
                      );
          
    PSCod_Error := 0;
    PSMsg_Error := 'Se inserto beneficiario en SP_ADDBENEFICIARIO'; 
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          PSCod_Error:=1;
          PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
          RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar beneficiario en SP_ADDBENEFICIARIO  (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_ADDBENEFICIARIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE               SP_ADDCATALOGO

(
PA_IDCATALAGO     IN    EBANKING.TA_CATALOGOS.IDCATALOGO%TYPE,
PA_CATALOGO       IN    EBANKING.TA_CATALOGOS.CATALOGO%TYPE,
PA_USU_MODIF      IN   VARCHAR2,
PA_FECHA_MODIF    IN   DATE,
PA_COD_ERROR      OUT  NUMBER,
PA_MSG_ERROR      OUT  VARCHAR2
)
IS
BEGIN
		INSERT INTO EBANKING.TA_CATALOGOS		
		(
    IDCATALOGO		
		,CATALOGO
		,USUARIO_MODIFICO
		,FECHA_MODIFICO
		)
		VALUES
		(
		   PA_IDCATALAGO 
      ,PA_CATALOGO
		  ,PA_USU_MODIF
		  ,PA_FECHA_MODIF 
	     );
	  PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');


END SP_ADDCATALOGO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                SP_ADDCONTENIDO
(
PA_IDCATALOGO     IN   EBANKING.TA_CONTENIDOCAT.IDCATALOGO%TYPE,
PA_CLAVE          IN   EBANKING.TA_CONTENIDOCAT.CLAVE%TYPE,
PA_CONTENIDO      IN   EBANKING.TA_CONTENIDOCAT.CONTENIDO%TYPE,
PA_ORDEN          IN   EBANKING.TA_CONTENIDOCAT.ORDEN%TYPE,
PA_STATUS         IN   EBANKING.TA_CONTENIDOCAT.STATUS%TYPE,
PA_USU_MODIF      IN   VARCHAR2,
PA_FECHA_MODIF    IN   DATE,
PA_COD_ERROR      OUT  NUMBER,
PA_MSG_ERROR      OUT  VARCHAR2		
)
IS
BEGIN
		INSERT INTO EBANKING.TA_CONTENIDOCAT		
		(
		 IDCONTENIDO
		,IDCATALOGO
		,CLAVE
		,CONTENIDO
		,ORDEN
		,STATUS
		,USUARIO_MODIFICO
		,FECHA_MODIFICO
		)
		VALUES
		(
		  EBANKING.SE_IDCONTENIDO.NEXTVAL
                  ,PA_IDCATALOGO
		  ,PA_CLAVE
		  ,PA_CONTENIDO
		  ,PA_ORDEN
		  ,PA_STATUS
		  ,PA_USU_MODIF
		  ,PA_FECHA_MODIF
	     );
	    PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');


END SP_ADDCONTENIDO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE               SP_ADDDATOSGEN
(
           PA_APATERNO             IN    CUENTASELECTA.TA_TITULAR.APATERNO%TYPE
          ,PA_AMATERNO             IN    CUENTASELECTA.TA_TITULAR.AMATERNO%TYPE
          ,PA_NOMBRE               IN    CUENTASELECTA.TA_TITULAR.NOMBRE%TYPE
          ,PA_SEXO                 IN    CUENTASELECTA.TA_TITULAR.SEXO%TYPE
          ,PA_EDOCIVIL             IN    CUENTASELECTA.TA_TITULAR.EDOCIVIL%TYPE
          ,PA_FENACIMIENTO         IN    CUENTASELECTA.TA_TITULAR.FENACIMIENTO%TYPE
          ,PA_NACIONALIDAD         IN    CUENTASELECTA.TA_TITULAR.NACIONALIDAD%TYPE
          ,PA_RFC                  IN    CUENTASELECTA.TA_TITULAR.RFC%TYPE
          ,PA_CURP                 IN    CUENTASELECTA.TA_TITULAR.CURP%TYPE
          ,PA_TIPOIDENT            IN    CUENTASELECTA.TA_TITULAR.TIPOIDENTIFICACION%TYPE
          ,PA_NUMIDENT             IN    CUENTASELECTA.TA_TITULAR.NUMIDENTIFICACION%TYPE
          ,PA_EMAIL                IN    CUENTASELECTA.TA_TITULAR.EMAIL%TYPE
          ,PA_FOLIO                IN    CUENTASELECTA.TA_TITULAR.IDTITULAR%TYPE
          ,PA_USR_MOD              IN    CUENTASELECTA.TA_TITULAR.USUARIO_MODIFICO%TYPE
          ,PA_FECH_MOD             IN    CUENTASELECTA.TA_TITULAR.FECHA_MODIFICO%TYPE
          ,PA_ESTATUSREG           IN    CUENTASELECTA.TA_TITULAR.ESTATUSREGISTRO%TYPE
          ,PA_IMPORTE              IN    CUENTASELECTA.TA_TITULAR.IMPORTEOPERACION%TYPE
          ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_TITULAR.PORCENTAJE%TYPE
          ,PASCOD_ERROR            OUT   NUMBER
          ,PASMSG_ERROR            OUT   VARCHAR2
          ,PA_ENVIARCORREO         IN    CUENTASELECTA.TA_TITULAR.ENVIARCORREO%TYPE
)
IS
VL_NUMFORMULARIO           INTEGER := 1;
VL_ENVIARCORREO           VARCHAR2(1) := '1';

BEGIN    
     BEGIN
     
      IF PA_ENVIARCORREO <> VL_ENVIARCORREO
        THEN
        IF PA_ENVIARCORREO IS NOT NULL 
        THEN
            VL_ENVIARCORREO := PA_ENVIARCORREO;
        END IF;
     END IF;

           INSERT INTO  CUENTASELECTA.TA_TITULAR 
                      ( 
                          IDTITULAR
                        , APATERNO 
                        , AMATERNO 
                        , NOMBRE
                        , SEXO
                        , EDOCIVIL
                        , FENACIMIENTO
                        , NACIONALIDAD 
                        , RFC
                        , CURP
                        ,TIPOIDENTIFICACION
                        , NUMIDENTIFICACION
                        , EMAIL
                        , NUMFORMULARIO
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                        , PORCENTAJE
                        , IMPORTEOPERACION
                        , ESTATUSREGISTRO
                        , ENVIARCORREO
                      
                       )
                  VALUES
                      (  
                        PA_FOLIO
                        ,PA_APATERNO
                        ,PA_AMATERNO 
                        ,PA_NOMBRE
                        ,PA_SEXO
                        ,PA_EDOCIVIL
                        ,PA_FENACIMIENTO
                        ,PA_NACIONALIDAD 
                        ,PA_RFC
                        ,PA_CURP
                        ,PA_TIPOIDENT
                        ,PA_NUMIDENT
                        ,PA_EMAIL
                        ,VL_NUMFORMULARIO
                        ,PA_USR_MOD
                        ,PA_FECH_MOD
                        ,PA_PORCENTAJE
                        ,PA_IMPORTE
                        ,PA_ESTATUSREG
                        ,VL_ENVIARCORREO
                      );
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION  
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDDATOSGEN ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE        SP_ADDDIRECCION(
   P_ID_TITULAR           IN    ta_direccion.idtitular%TYPE
  ,P_CALLE                IN    ta_direccion.calle%TYPE
  ,P_NUM_EXT              IN    ta_direccion.numext%TYPE
  ,P_NUM_INT              IN    ta_direccion.numint%TYPE
  ,P_CP                   IN    ta_direccion.cp%TYPE
  ,P_COLONIA              IN    ta_direccion.colonia%TYPE
  ,P_ESTADO               IN    ta_direccion.estado%TYPE
  ,P_POBLACION            IN    ta_direccion.poblacion%TYPE
  ,P_LADA                 IN    ta_direccion.lada%TYPE
  ,P_TELEFONO             IN    ta_direccion.teloficina%TYPE
  ,P_EXTENSION            IN    ta_direccion.extension%type
  ,P_PORCENTAJE           IN    ta_direccion.porcentaje%TYPE
  ,P_USRMOD               IN    ta_direccion.usuario_modifico%TYPE
  ,P_FECMOD               IN    ta_direccion.fecha_modifico%TYPE
  ,PSCod_Error            OUT   NUMBER
  ,PSMsg_Error            OUT   VARCHAR2
)
IS
V_NUMFORMULARIO           INTEGER := 2;
BEGIN    
     BEGIN
           INSERT INTO EBANKING.ta_direccion
                      ( 
                        ta_direccion.iddireccion
                        ,ta_direccion.idtitular
                        ,ta_direccion.calle
                        ,ta_direccion.numext
                        ,ta_direccion.numint
                        ,ta_direccion.cp
                        ,ta_direccion.colonia
                        ,ta_direccion.estado
                        ,ta_direccion.poblacion
                        ,ta_direccion.lada
                        ,ta_direccion.teloficina
                        ,ta_direccion.extension
                        ,ta_direccion.porcentaje
                       )
                  VALUES
                      (  
                        SE_IDDIRECCION.NEXTVAL
                        ,P_ID_TITULAR
                        ,P_CALLE
                        ,P_NUM_EXT
                        ,P_NUM_INT
                        ,P_CP
                        ,P_COLONIA
                        ,P_ESTADO
                        ,P_POBLACION
                        ,P_LADA
                        ,P_TELEFONO
                        ,P_EXTENSION
                        ,P_PORCENTAJE
                      );
              
              UPDATE EBANKING.ta_titular
            SET 
                ta_titular.numformulario = V_NUMFORMULARIO
            WHERE
                ta_titular.idtitular = P_ID_TITULAR;
                
            PSCod_Error := 0;
            PSMsg_Error := 'Agrego registro en ta_direccion';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al agregar datos en ta_direccion, SP_ADDDIRECCION  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDDIRECCION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                                              SP_ADDDIRTIT
(

  
  
   PA_ID_TITULAR           IN    CUENTASELECTA.TA_DIRECCION.IDTITULAR%TYPE
  ,PA_CALLE                IN    CUENTASELECTA.TA_DIRECCION.CALLE%TYPE
  ,PA_NUM_EXT              IN    CUENTASELECTA.TA_DIRECCION.NUMEXT%TYPE
  ,PA_NUM_INT              IN    CUENTASELECTA.TA_DIRECCION.NUMINT%TYPE
  ,PA_CP                   IN    CUENTASELECTA.TA_DIRECCION.CP%TYPE
  ,PA_COLONIA              IN    CUENTASELECTA.TA_DIRECCION.COLONIA%TYPE
  ,PA_ESTADO               IN    CUENTASELECTA.TA_DIRECCION.ESTADO%TYPE
  ,PA_POBLACION            IN    CUENTASELECTA.TA_DIRECCION.POBLACION%TYPE
  ,PA_LADA                 IN    CUENTASELECTA.TA_DIRECCION.LADA%TYPE
  ,PA_TELEFONO             IN    CUENTASELECTA.TA_DIRECCION.TELOFICINA%TYPE
  ,PA_EXTENSION            IN    CUENTASELECTA.TA_DIRECCION.EXTENSION%TYPE
  ,PA_TELCASA              IN    CUENTASELECTA.TA_DIRECCION.TELCASA%TYPE
  ,PA_TELCELULAR           IN    CUENTASELECTA.TA_DIRECCION.TELCEL%TYPE
  ,PA_FECHAVISITA          IN    CUENTASELECTA.TA_DIRECCION.FECHAVISITA%TYPE
  ,PA_HORAVISITA           IN    CUENTASELECTA.TA_DIRECCION.HORAVISITA%TYPE
  ,PA_REFCALLES            IN    CUENTASELECTA.TA_DIRECCION.REFERENCIACALLES%TYPE
  ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_DIRECCION.PORCENTAJE%TYPE
  ,PA_GRABADO              IN    CUENTASELECTA.TA_DIRECCION.GRABADO%TYPE
  ,PA_USRMOD               IN    CUENTASELECTA.TA_DIRECCION.USUARIO_MODIFICO%TYPE
  ,PA_FECMOD               IN    CUENTASELECTA.TA_DIRECCION.FECHA_MODIFICO%TYPE
  ,PA_VISITA               IN    CUENTASELECTA.TA_DIRECCION.VISITA%TYPE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
  ,PA_LADACASA             IN    CUENTASELECTA.TA_DIRECCION.LADACASA%TYPE default '0'
  
)
IS
VL_NUMFORMULARIO           INTEGER := 2;

BEGIN    
     BEGIN
     
           INSERT INTO  CUENTASELECTA.TA_DIRECCION
                      ( 
                         IDDIRECCION
                        , IDTITULAR
                        , CALLE
                        , NUMEXT
                        , NUMINT
                        , CP
                        , COLONIA
                        , ESTADO
                        , POBLACION
                        , LADA
                        , TELOFICINA
                        , EXTENSION
                        , TELCASA
                        , TELCEL
                        , FECHAVISITA
                        , HORAVISITA
                        , REFERENCIACALLES
                        , PORCENTAJE
                        , GRABADO
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                        , VISITA
                        ,LADACASA
                       )
                  VALUES
                      (  
                        CUENTASELECTA.SE_IDDIRECCION.NEXTVAL
                        ,PA_ID_TITULAR
                        ,PA_CALLE
                        ,PA_NUM_EXT
                        ,PA_NUM_INT
                        ,PA_CP
                        ,PA_COLONIA
                        ,PA_ESTADO
                        ,PA_POBLACION
                        ,PA_LADA
                        ,PA_TELEFONO
                        ,PA_EXTENSION
                        ,PA_TELCASA
                        ,PA_TELCELULAR
                        ,PA_FECHAVISITA
                        ,PA_HORAVISITA
                        ,PA_REFCALLES
                        ,PA_PORCENTAJE
                        ,PA_GRABADO
                        ,PA_USRMOD
                        ,PA_FECMOD
                        ,PA_VISITA
                        ,PA_LADACASA
                      );
              
              UPDATE  CUENTASELECTA.TA_TITULAR
            SET 
                 NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                 IDTITULAR = PA_ID_TITULAR;
            
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PASCOD_ERROR:=1;
                PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDDIRTIT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_ADDINFOECYFI
(
             PA_ID_TITULAR           IN    EBANKING.TA_INFOECOYFIN.IDTITULAR%TYPE
            ,PA_DIRECCION_TRABAJO    IN    EBANKING.TA_INFOECOYFIN.DIREMPRESA%TYPE
            ,PA_EGRESOS_MENSUALES    IN    EBANKING.TA_INFOECOYFIN.EGRMENSUAL%TYPE
            ,PA_EMPINSTLAB           IN    EBANKING.TA_INFOECOYFIN.EMPRESATRABAJO%TYPE
            ,PA_FUENTE_INGRESO       IN    EBANKING.TA_INFOECOYFIN.FUENTEINGRESOS%TYPE
            ,PA_INGRESOS_MENSUALES   IN    EBANKING.TA_INFOECOYFIN.INGMENSUAL%TYPE
            ,PA_PROF_OFICIO          IN    EBANKING.TA_INFOECOYFIN.PROFUOFICIO%TYPE
            ,PA_PUESTODESEMP         IN    EBANKING.TA_INFOECOYFIN.PUESTO%TYPE
            ,PA_SECTOR_EMP           IN    EBANKING.TA_INFOECOYFIN.SECTEMPRESARIAL%TYPE
            ,PA_TELS_TRABAJO         IN    EBANKING.TA_INFOECOYFIN.TELEFONO%TYPE
            ,PA_TIEMPO_LABORAR       IN    EBANKING.TA_INFOECOYFIN.TIEMPOLABORADO%TYPE    
            ,PA_PORCENTAJE           IN    EBANKING.TA_INFOECOYFIN.PORCENTAJE%TYPE
            ,PA_GRABADO              IN    EBANKING.TA_INFOECOYFIN.GRABADO%TYPE
            ,PA_USR_MOD              IN    EBANKING.TA_INFOECOYFIN.USUARIO_MODIFICO%TYPE
            ,PA_FECH_MOD             IN    EBANKING.TA_INFOECOYFIN.FECHA_MODIFICO%TYPE
            ,PASCOD_ERROR            OUT   NUMBER
            ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
VL_NUMFORMULARIO           INTEGER := 5;
BEGIN    
     BEGIN
           INSERT INTO  EBANKING.TA_INFOECOYFIN
                      ( 
                         IDINFOECOYFIN
                        ,IDTITULAR
                        , FUENTEINGRESOS
                        , EMPRESATRABAJO
                        , PUESTO
                        , TIEMPOLABORADO
                        , DIREMPRESA
                        , TELEFONO
                        , INGMENSUAL
                        , EGRMENSUAL
                        , SECTEMPRESARIAL
                        , PROFUOFICIO
                        , PORCENTAJE
                        , GRABADO
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                       )
                  VALUES
                      (  
                        EBANKING.SE_IDINFOEYF.NEXTVAL
                        ,PA_ID_TITULAR
                        ,PA_FUENTE_INGRESO
                        ,PA_EMPINSTLAB
                        ,PA_PUESTODESEMP
                        ,PA_TIEMPO_LABORAR
                        ,PA_DIRECCION_TRABAJO
                        ,PA_TELS_TRABAJO
                        ,PA_INGRESOS_MENSUALES
                        ,PA_EGRESOS_MENSUALES
                        ,PA_SECTOR_EMP
                        ,PA_PROF_OFICIO
                        ,PA_PORCENTAJE
                        ,PA_GRABADO
                        ,PA_USR_MOD
                        ,PA_FECH_MOD
                      );
              
              UPDATE  EBANKING.TA_TITULAR
            SET 
               NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                IDTITULAR = PA_ID_TITULAR;
            
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDINFOECYFI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ADDPAGOSELEKTRA
(
PA_FCCTEALNOVA        IN   EBANKING.TAPAGOSELEKTRA.FCCTEALNOVA%TYPE,
PA_FCREFERENCIA       IN   EBANKING.TAPAGOSELEKTRA.FCREFERENCIA%TYPE,
PA_FNMONTO            IN   EBANKING.TAPAGOSELEKTRA.FNMONTO%TYPE,
PA_FCCUENTACARGO      IN   EBANKING.TAPAGOSELEKTRA.FCCUENTACARGO%TYPE,
PA_FCRESP_ALNOVA      IN   EBANKING.TAPAGOSELEKTRA.FCRESP_ALNOVA%TYPE,
PA_FCAPLICACION       IN   EBANKING.TAPAGOSELEKTRA.FCAPLICACION%TYPE,
PA_FCUSUARIO_MODIFICO IN   EBANKING.TAPAGOSELEKTRA.FCUSUARIO_MODIFICO%TYPE,
PA_COD_ERROR         OUT  NUMBER,
PA_MSG_ERROR         OUT  VARCHAR2
)
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TAPAGOSELEKTRA
   Parametros de entrada:   PA_FCCTEALNOVA        - Identificador del cliente
                            PA_FCREFERENCIA       - Referencia
                            PA_FNMONTO            - Monto del pago
                            PA_FCCUENTACARGO      - Cuenta cargo
                            PA_FCRESP_ALNOVA      - Respuesta de alnova
                            PA_FCAPLICACION       - Aplicacion donde se hizo el pago
                            PA_FCUSUARIO_MODIFICO - Usuaio que modifico

   Parametros de salida:  FNPSCOD                -Codigo de retorno del procedimiento
                          FCPSMSG                -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 10/09/2013
****************************************************************************/
BEGIN
        INSERT INTO EBANKING.TAPAGOSELEKTRA
        ( FCCTEALNOVA
         ,FCREFERENCIA
         ,FNMONTO
         ,FCCUENTACARGO
         ,FCRESP_ALNOVA
         ,FCAPLICACION
         ,FCUSUARIO_MODIFICO )
        VALUES
        (
          PA_FCCTEALNOVA
         ,PA_FCREFERENCIA
         ,PA_FNMONTO
         ,PA_FCCUENTACARGO
         ,PA_FCRESP_ALNOVA
         ,PA_FCAPLICACION
         ,PA_FCUSUARIO_MODIFICO
         );
        PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'OPERACION EXITOSA';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
            ROLLBACK;
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'FALLO AL INSERTAR EN  TAPAGOSELEKTRA (' || SQLCODE || '  ' || SQLERRM || ')');


END SP_ADDPAGOSELEKTRA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                          SP_ADDPERPOLEXP
(
  
   PA_ID_TITULAR           IN    CUENTASELECTA.TA_PERSONAPEXP.IDTITULAR%TYPE
  ,PA_PUESTO_TITULAR       IN    CUENTASELECTA.TA_PERSONAPEXP.PUESTOTITULAR%TYPE
  ,PA_PUESTO_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.PUESTOFAMILIAR%TYPE
  ,PA_NOMBRE_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NOMBRE%TYPE
  ,PA_APATERNO_FAMILIAR    IN    CUENTASELECTA.TA_PERSONAPEXP.APATERNO%TYPE
  ,PA_AMATERNO_FAMILIAR    IN    CUENTASELECTA.TA_PERSONAPEXP.AMATERNO%TYPE
  ,PA_CALLE_FAMILIAR       IN    CUENTASELECTA.TA_PERSONAPEXP.CALLE%TYPE
  ,PA_NUMEXT_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NUMEXT%TYPE
  ,PA_NUMINT_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NUMINT%TYPE
  ,PA_CP_FAMILIAR          IN    CUENTASELECTA.TA_PERSONAPEXP.CP%TYPE
  ,PA_COLONIA_FAMILIAR     IN    CUENTASELECTA.TA_PERSONAPEXP.COLONIA%TYPE
  ,PA_ESTADO_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.ESTADO%TYPE
  ,PA_POBLACION_FAMILIAR   IN    CUENTASELECTA.TA_PERSONAPEXP.POBLACION%TYPE
  ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_PERSONAPEXP.PORCENTAJE%TYPE
  ,PA_GRABADO              IN    CUENTASELECTA.TA_PERSONAPEXP.GRABADO%TYPE
  ,PA_USR_MOD              IN    CUENTASELECTA.TA_PERSONAPEXP.USUARIO_MODIFICO%TYPE
  ,PA_FECH_MOD             IN    CUENTASELECTA.TA_PERSONAPEXP.FECHA_MODIFICO%TYPE
  ,PA_FUEPPETIT            IN    CUENTASELECTA.TA_PERSONAPEXP.FUEPPETIT%TYPE
  ,PA_FUEPPEFAM            IN    CUENTASELECTA.TA_PERSONAPEXP.FUEPPEFAM%TYPE
  ,PA_PARENTESCO           IN    CUENTASELECTA.TA_PERSONAPEXP.PARENTESCO%TYPE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
  ,PA_LADA                 IN    CUENTASELECTA.TA_PERSONAPEXP.LADA%TYPE
  ,PA_TELEFONO             IN    CUENTASELECTA.TA_PERSONAPEXP.TELEFONO%TYPE
)
IS
VL_NUMFORMULARIO   INTEGER := 6;
VL_LADA            VARCHAR2(5) :='0';
VL_TELEFONO        VARCHAR2(20) :='0';
BEGIN    
     BEGIN
     
      IF PA_LADA <> VL_LADA
        THEN
        IF PA_LADA IS NOT NULL 
        THEN
            VL_LADA := PA_LADA;
        END IF;
      END IF;
      
      IF PA_TELEFONO <> VL_TELEFONO
        THEN
        IF PA_TELEFONO IS NOT NULL 
        THEN
            VL_TELEFONO := PA_TELEFONO;
        END IF;
     END IF;
     
     
           INSERT INTO  CUENTASELECTA.TA_PERSONAPEXP
                      ( 
                      IDPERSONAPOLITEXP
                        ,PUESTOTITULAR
                        ,PUESTOFAMILIAR
                        ,APATERNO
                        ,AMATERNO
                        ,NOMBRE
                        ,CALLE
                        ,NUMEXT
                        ,NUMINT
                        ,CP
                        ,COLONIA
                        ,ESTADO
                        ,POBLACION
                        ,IDTITULAR
                        ,PORCENTAJE
                        ,GRABADO
                        ,USUARIO_MODIFICO
                        ,FECHA_MODIFICO
                        ,FUEPPETIT
                        ,FUEPPEFAM
                        ,PARENTESCO
                        ,LADA
                        ,TELEFONO
                       )
                  VALUES
                      (  
                        CUENTASELECTA.SE_IDPERSONAPE.NEXTVAL
                        ,PA_PUESTO_TITULAR
                        ,PA_PUESTO_FAMILIAR
                        ,PA_APATERNO_FAMILIAR
                        ,PA_AMATERNO_FAMILIAR
                        ,PA_NOMBRE_FAMILIAR
                        ,PA_CALLE_FAMILIAR
                        ,PA_NUMEXT_FAMILIAR
                        ,PA_NUMINT_FAMILIAR
                        ,PA_CP_FAMILIAR
                        ,PA_COLONIA_FAMILIAR
                        ,PA_ESTADO_FAMILIAR
                        ,PA_POBLACION_FAMILIAR
                        ,PA_ID_TITULAR
                        ,PA_PORCENTAJE
                        ,PA_GRABADO
                        ,PA_USR_MOD
                        ,PA_FECH_MOD
                        ,PA_FUEPPETIT
                        ,PA_FUEPPEFAM
                        ,PA_PARENTESCO
                        ,VL_LADA
                        ,VL_TELEFONO
                      );
              
              UPDATE  CUENTASELECTA.TA_TITULAR
            SET 
                TA_TITULAR.NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                TA_TITULAR.IDTITULAR = PA_ID_TITULAR;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
    
    EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDPERPOLEXP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ADDUSOCUENTA
(
          PA_ID_TITULAR            IN    EBANKING.TA_USOCUENTA.IDTITULAR%TYPE
          ,PA_ACTIVIDAD            IN    EBANKING.TA_USOCUENTA.ACTIVIDAD%TYPE
          ,PA_SECTOR_LAB           IN    EBANKING.TA_USOCUENTA.SECTLABORAL%TYPE
          ,PA_ACTIVIDAD_ECO        IN    EBANKING.TA_USOCUENTA.ACTECONOMICA%TYPE
          ,PA_TRAN_DEPOSITOS       IN    EBANKING.TA_USOCUENTA.TRANDEPOSITOS%TYPE
          ,PA_TRAN_RETIROS         IN    EBANKING.TA_USOCUENTA.TRANRETIROS%TYPE
          ,PA_TRAN_TRANSFER        IN    EBANKING.TA_USOCUENTA.TRANTRANSFERENCIAS%TYPE
          ,PA_TRAN_COMPVENTDIV     IN    EBANKING.TA_USOCUENTA.TRANCVD%TYPE
          ,PA_ORIGEN_RECURSO       IN    EBANKING.TA_USOCUENTA.ORIGENRECURSOS%TYPE
          ,PA_USO_DARA_CUENTA      IN    EBANKING.TA_USOCUENTA.USOCUENTA%TYPE
          ,PA_PORCENTAJE           IN    EBANKING.TA_USOCUENTA.PORCENTAJE%TYPE
          ,PA_GRABADO              IN    EBANKING.TA_USOCUENTA.GRABADO%TYPE
          ,PA_USR_MOD              IN    EBANKING.TA_USOCUENTA.USUARIO_MODIFICO%TYPE
          ,PA_FECH_MOD             IN    EBANKING.TA_USOCUENTA.FECHA_MODIFICO%TYPE
          ,PASCOD_ERROR            OUT   NUMBER
          ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
VL_NUMFORMULARIO           INTEGER := 4;
BEGIN    
     BEGIN
           INSERT INTO  EBANKING.TA_USOCUENTA
                      ( 
                        IDUSOCUENTA
                        , IDTITULAR
                        , ACTIVIDAD
                        , SECTLABORAL
                        , ACTECONOMICA
                        , TRANDEPOSITOS
                        , TRANRETIROS
                        , TRANTRANSFERENCIAS
                        , TRANCVD
                        , ORIGENRECURSOS
                        , USOCUENTA
                        , PORCENTAJE
                        , GRABADO
                        , USUARIO_MODIFICO
                        , FECHA_MODIFICO
                       )
                  VALUES
                      (  
                        EBANKING.SE_IDUSOCUENTA.NEXTVAL
                        ,PA_ID_TITULAR
                        ,PA_ACTIVIDAD
                        ,PA_SECTOR_LAB
                        ,PA_ACTIVIDAD_ECO
                        ,PA_TRAN_DEPOSITOS
                        ,PA_TRAN_RETIROS
                        ,PA_TRAN_TRANSFER
                        ,PA_TRAN_COMPVENTDIV
                        ,PA_ORIGEN_RECURSO
                        ,PA_USO_DARA_CUENTA
                        ,PA_PORCENTAJE
                        ,PA_GRABADO
                        ,PA_USR_MOD
                        ,PA_FECH_MOD
                      );

              
              UPDATE  EBANKING.TA_TITULAR
            SET 
                 NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
		IDTITULAR = PA_ID_TITULAR;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PASCOD_ERROR:=1;
                PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADDUSOCUENTA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ADD_BENEF
(
  
   PA_IDUSUARIO	         IN	 EBANKING.TA_BENEFAFILIA.IDUSUARIO%TYPE
  ,PA_NUMBENEF           IN   EBANKING.TA_BENEFAFILIA.NUMBENEFICIARIO%TYPE
  ,PA_PATERNO            IN   EBANKING.TA_BENEFAFILIA.APATERNO%TYPE
  ,PA_MATERNO            IN   EBANKING.TA_BENEFAFILIA.AMATERNO%TYPE
  ,PA_NOMBRE             IN   EBANKING.TA_BENEFAFILIA.NOMBRE%TYPE
  ,PA_PARENTESCO         IN   EBANKING.TA_BENEFAFILIA.PARENTESCO%TYPE
  ,PA_GRABADO            IN   EBANKING.TA_BENEFAFILIA.GRABADO%TYPE
  ,PA_PORCENTAJE         IN   EBANKING.TA_BENEFAFILIA.PORCENTAJE%TYPE
  ,PA_EMAIL              IN   EBANKING.TA_BENEFAFILIA.EMAIL%TYPE
  ,PA_CALLE		           IN	 EBANKING.TA_DIRECCIONAFI.CALLE%TYPE                     
  ,PA_NUMEXT             IN   EBANKING.TA_DIRECCIONAFI.NUMEXT%TYPE
  ,PA_NUMINT             IN   EBANKING.TA_DIRECCIONAFI.NUMINT%TYPE
  ,PA_CP                 IN   EBANKING.TA_DIRECCIONAFI.CP%TYPE
  ,PA_COLONIA            IN   EBANKING.TA_DIRECCIONAFI.COLONIA%TYPE
  ,PA_ESTADO             IN   EBANKING.TA_DIRECCIONAFI.ESTADO%TYPE
  ,PA_POBLACION          IN   EBANKING.TA_DIRECCIONAFI.POBLACION%TYPE
  ,PA_LADA               IN   EBANKING.TA_DIRECCIONAFI.LADA%TYPE
  ,PA_TEL                IN   EBANKING.TA_DIRECCIONAFI.TELOFICINA%TYPE
  ,PA_EXT                IN   EBANKING.TA_DIRECCIONAFI.EXTENSION%TYPE
  ,PA_USUARIOMODIFICO    IN    VARCHAR2
  ,PA_FECHAMOD           IN    DATE
  ,PASCOD_ERROR          OUT   NUMBER
  ,PASMSG_ERROR          OUT   VARCHAR2
)
IS
BEGIN    
           INSERT INTO EBANKING.TA_BENEFAFILIA 
                      ( 
                         EBANKING.TA_BENEFAFILIA.IDBENEFICIARIO
                        ,EBANKING.TA_BENEFAFILIA.IDUSUARIO
                        ,EBANKING.TA_BENEFAFILIA.NUMBENEFICIARIO
                        ,EBANKING.TA_BENEFAFILIA.APATERNO
                        ,EBANKING.TA_BENEFAFILIA.AMATERNO
                        ,EBANKING.TA_BENEFAFILIA.NOMBRE
                        ,EBANKING.TA_BENEFAFILIA.PARENTESCO
                        ,EBANKING.TA_BENEFAFILIA.GRABADO
                        ,EBANKING.TA_BENEFAFILIA.PORCENTAJE
                        ,EBANKING.TA_BENEFAFILIA.EMAIL
                        ,EBANKING.TA_BENEFAFILIA.USUARIO_MODIFICO
                        ,EBANKING.TA_BENEFAFILIA.FECHA_MODIFICO
                       )
                  VALUES
                      ( 
                        EBANKING.SE_IDBENEFAF.NEXTVAL 
                        ,PA_IDUSUARIO	  
                        ,PA_NUMBENEF      
                        ,PA_PATERNO       
                        ,PA_MATERNO       
                        ,PA_NOMBRE      
                        ,PA_PARENTESCO  
                        ,PA_GRABADO     
                        ,PA_PORCENTAJE  
                        ,PA_EMAIL       
                        ,PA_USUARIOMODIFICO     
                        ,PA_FECHAMOD            
                      );
                      
             INSERT INTO EBANKING.TA_DIRECCIONAFI
                      ( 
                         EBANKING.TA_DIRECCIONAFI.IDDIRECCION
                        ,EBANKING.TA_DIRECCIONAFI.IDBENEFICIARIO
                        ,EBANKING.TA_DIRECCIONAFI.IDUSUARIO
                        ,EBANKING.TA_DIRECCIONAFI.CALLE                     
                        ,EBANKING.TA_DIRECCIONAFI.NUMEXT
                        ,EBANKING.TA_DIRECCIONAFI.NUMINT
                        ,EBANKING.TA_DIRECCIONAFI.CP
                        ,EBANKING.TA_DIRECCIONAFI.COLONIA
                        ,EBANKING.TA_DIRECCIONAFI.ESTADO
                        ,EBANKING.TA_DIRECCIONAFI.POBLACION
                        ,EBANKING.TA_DIRECCIONAFI.LADA
                        ,EBANKING.TA_DIRECCIONAFI.TELOFICINA
                        ,EBANKING.TA_DIRECCIONAFI.EXTENSION
                        ,EBANKING.TA_DIRECCIONAFI.PORCENTAJE
                        ,EBANKING.TA_DIRECCIONAFI.USUARIO_MODIFICO
                        ,EBANKING.TA_DIRECCIONAFI.FECHA_MODIFICO
                       )
                  VALUES
                      ( 
                        EBANKING.SE_IDDIRECAFI.NEXTVAL 
                        ,EBANKING.SE_IDBENEFAF.CURRVAL 
                        ,PA_IDUSUARIO
                        ,PA_CALLE		                     
                        ,PA_NUMEXT       
                        ,PA_NUMINT       
                        ,PA_CP           
                        ,PA_COLONIA      
                        ,PA_ESTADO       
                        ,PA_POBLACION    
                        ,PA_LADA         
                        ,PA_TEL          
                        ,PA_EXT           
                        ,PA_PORCENTAJE                                
                        ,PA_USUARIOMODIFICO     
                        ,PA_FECHAMOD            
                      );
            
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_ADD_BENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                SP_ADD_FISCAL
(
  
   PA_IDUSUARIO	   IN	EBANKING.TA_FISCAL.IDUSUARIO%TYPE  
  ,PA_CALLE		   IN	EBANKING.TA_FISCAL.CALLE%TYPE                     
  ,PA_NUMEXT        IN   EBANKING.TA_FISCAL.NUMEXT%TYPE
  ,PA_NUMINT        IN   EBANKING.TA_FISCAL.NUMINT%TYPE
  ,PA_CP            IN   EBANKING.TA_FISCAL.CODPOSTAL%TYPE
  ,PA_COLONIA       IN   EBANKING.TA_FISCAL.COLONIA%TYPE
  ,PA_ESTADO        IN   EBANKING.TA_FISCAL.ESTADO%TYPE
  ,PA_POBLACION     IN   EBANKING.TA_FISCAL.CIUDAD%TYPE
  ,PA_LADA          IN   EBANKING.TA_FISCAL.LADA%TYPE
  ,PA_TEL           IN   EBANKING.TA_FISCAL.TELEFONO%TYPE
  ,PA_EXT           IN   EBANKING.TA_FISCAL.EXTENSION%TYPE
  
  ,PA_USUARIOMODIFICO      IN    VARCHAR2
  ,PA_FECHAMOD             IN    DATE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
BEGIN    
          
            
            
             INSERT INTO EBANKING.TA_FISCAL
                      ( 
                         EBANKING.TA_FISCAL.IDFISCAL
                        ,EBANKING.TA_FISCAL.IDUSUARIO
                        ,EBANKING.TA_FISCAL.CALLE                     
                        ,EBANKING.TA_FISCAL.NUMEXT
                        ,EBANKING.TA_FISCAL.NUMINT
                        ,EBANKING.TA_FISCAL.CODPOSTAL
                        ,EBANKING.TA_FISCAL.COLONIA
                        ,EBANKING.TA_FISCAL.ESTADO
                        ,EBANKING.TA_FISCAL.CIUDAD
                        ,EBANKING.TA_FISCAL.LADA
                        ,EBANKING.TA_FISCAL.TELEFONO
                        ,EBANKING.TA_FISCAL.EXTENSION                      
                        ,EBANKING.TA_FISCAL.USUARIO_MODIFICO
                        ,EBANKING.TA_FISCAL.FECHA_MODIFICO
                        
                        
                        
                       )
                  VALUES
                      ( 
                       EBANKING.SE_IDFISCAL.NEXTVAL 
                       ,PA_IDUSUARIO                     
                       ,PA_CALLE		                     
  					   ,PA_NUMEXT       
  					   ,PA_NUMINT       
  					   ,PA_CP           
  					   ,PA_COLONIA      
                       ,PA_ESTADO       
                       ,PA_POBLACION    
  				       ,PA_LADA         
                       ,PA_TEL          
                       ,PA_EXT                                                               
                       ,PA_USUARIOMODIFICO     
                       ,PA_FECHAMOD            
                      );
            
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_ADD_FISCAL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE       SP_ADD_INFOCLI
(
  P_FOLIOAFILIA           IN    EBANKING.ta_cliente.idusuario%TYPE
  ,P_IMEI                 IN    EBANKING.ta_cliente.IMEI%TYPE
  ,P_APATERNO             IN    EBANKING.ta_cliente.apaterno%TYPE
  ,P_AMATERNO             IN    EBANKING.ta_cliente.amaterno%TYPE
  ,P_NOMBRE               IN    EBANKING.ta_cliente.nombrecli%TYPE
  ,P_SEXO                 IN    EBANKING.ta_cliente.sexo%TYPE
  ,P_ESTADOCIVIL          IN    EBANKING.ta_cliente.estadocivil%TYPE
  ,P_CALLE                IN    EBANKING.ta_cliente.callecli%TYPE
  ,P_NUMEXT               IN    EBANKING.ta_cliente.numext%TYPE
  ,P_CP                   IN    EBANKING.ta_cliente.codpostalcli%TYPE
  ,P_COLONIA              IN    EBANKING.ta_cliente.coloniacli%TYPE
  ,P_ESTADO               IN    EBANKING.ta_cliente.estadocli%TYPE
  ,P_CIUDAD               IN    EBANKING.ta_cliente.ciudad%TYPE
  ,P_FECHANAC             IN    EBANKING.ta_cliente.fechanac%TYPE
  ,P_NUMIDENT             IN   EBANKING.ta_cliente.numidentific%TYPE
  ,P_LADA                 IN    EBANKING.ta_cliente.lada%TYPE
  ,P_TELCASA              IN    EBANKING.ta_cliente.telcasa%TYPE
  ,P_USUARIOMODIFICO      IN    EBANKING.ta_cliente.usuario_modifico%TYPE
  ,P_FECHAMOD             IN    EBANKING.ta_cliente.fecha_modifico%TYPE
  ,PSCod_Error            OUT   number
  ,PSMsg_Error            OUT   varchar2
)
IS
V_GRABADO INTEGER := 1;
BEGIN    
           INSERT INTO EBANKING.ta_cliente 
                      ( 
                        EBANKING.ta_cliente.idusuario
                        ,EBANKING.ta_cliente.IMEI
                        ,EBANKING.ta_cliente.apaterno
                        ,EBANKING.ta_cliente.amaterno
                        ,EBANKING.ta_cliente.nombrecli
                        ,EBANKING.ta_cliente.sexo
                        ,EBANKING.ta_cliente.estadocivil
                        ,EBANKING.ta_cliente.callecli
                        ,EBANKING.ta_cliente.numext
                        ,EBANKING.ta_cliente.codpostalcli
                        ,EBANKING.ta_cliente.coloniacli
                        ,EBANKING.ta_cliente.estadocli
                        ,EBANKING.ta_cliente.ciudad
                        ,EBANKING.ta_cliente.fechanac
                        ,EBANKING.ta_cliente.numidentific
                        ,EBANKING.ta_cliente.lada
                        ,EBANKING.ta_cliente.telcasa
                        ,EBANKING.ta_cliente.usuario_modifico
                        ,EBANKING.ta_cliente.fecha_modifico
                        ,EBANKING.ta_cliente.grabado
                       )
                  VALUES
                      ( 
                        P_FOLIOAFILIA
                        ,P_IMEI
                        ,P_APATERNO
                        ,P_AMATERNO
                        ,P_NOMBRE
                        ,P_SEXO
                        ,P_ESTADOCIVIL
                        ,P_CALLE
                        ,P_NUMEXT
                        ,P_CP
                        ,P_COLONIA
                        ,P_ESTADO
                        ,P_CIUDAD
                        ,P_FECHANAC
                        ,P_NUMIDENT
                        ,P_LADA
                        ,P_TELCASA 
                        ,P_USUARIOMODIFICO
                        ,P_FECHAMOD
                        ,V_GRABADO
                      );
    
    PSCod_Error := 0;
    PSMsg_Error := 'Agrego registro en EBANKING.ta_cliente';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al agregar la SP_ADD_INFOCLIENTE  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_ADD_INFOCLI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                SP_ADD_INFONEG
(
  PA_FOLIOAFILIA          IN  EBANKING.TA_NEGOCIO.IDUSUARIO%TYPE
  ,PA_NOMBRENEGOCIO        IN  EBANKING.TA_NEGOCIO.NOMBRENEG%TYPE
  ,PA_RFC                  IN  EBANKING.TA_NEGOCIO.RFC%TYPE
  ,PA_SECTLABORAL          IN  EBANKING.TA_NEGOCIO.SECTORLAB%TYPE
  ,PA_CALLENEGOCIO         IN  EBANKING.TA_NEGOCIO.CALLENEG%TYPE
  ,PA_NUMNEGOCIO           IN  EBANKING.TA_NEGOCIO.NUMEXT%TYPE
  ,PA_CPNEGOCIO            IN  EBANKING.TA_NEGOCIO.CODPOSTALNEG%TYPE
  ,PA_COLONIANEG           IN  EBANKING.TA_NEGOCIO.COLONIANEG%TYPE
  ,PA_ESTADONEGOCIO        IN  EBANKING.TA_NEGOCIO.ESTADONEG%TYPE
  ,PA_CIUDADNEGOCIO        IN  EBANKING.TA_NEGOCIO.CIUDAD%TYPE
  ,PA_LADA                 IN  EBANKING.TA_NEGOCIO.LADA%TYPE
  ,PA_TELEFONO             IN  EBANKING.TA_NEGOCIO.TELNEG%TYPE        
  ,PA_SITIOWEB             IN  EBANKING.TA_NEGOCIO.PAGWEB%TYPE
  ,PA_USUARIOMODIFICO      IN  EBANKING.TA_NEGOCIO.USUARIO_MODIFICO%TYPE
  ,PA_FECHAMOD             IN  EBANKING.TA_NEGOCIO.FECHA_MODIFICO%TYPE
  ,PA_CORREO               IN  EBANKING.TA_NEGOCIO.CORREONEG%TYPE
  ,PA_NUMFORM              IN  EBANKING.TA_NEGOCIO.NUMFORM%TYPE
  ,PA_PORCENTAJE           IN  EBANKING.TA_NEGOCIO.PORCENTAJE%TYPE
  ,PA_GRABADO              IN  EBANKING.TA_NEGOCIO.GRABADO%TYPE
  ,PA_NUMINT               IN  EBANKING.TA_NEGOCIO.NUMINT%TYPE
  ,PA_NUMEXTENSION         IN  EBANKING.TA_NEGOCIO.NUMEXTENSION%TYPE
  
  ,PASCOD_ERROR            OUT NUMBER
  ,PASMSG_ERROR            OUT VARCHAR2
)
IS
VL_GRABADO INTEGER :=0;
BEGIN
    BEGIN
            INSERT INTO EBANKING.TA_NEGOCIO
            (
              EBANKING.TA_NEGOCIO.IDNEGOCIO
              ,EBANKING.TA_NEGOCIO.IDUSUARIO
              ,EBANKING.TA_NEGOCIO.NOMBRENEG
              ,EBANKING.TA_NEGOCIO.RFC
              ,EBANKING.TA_NEGOCIO.SECTORLAB
              ,EBANKING.TA_NEGOCIO.CALLENEG
              ,EBANKING.TA_NEGOCIO.NUMEXT
              ,EBANKING.TA_NEGOCIO.CODPOSTALNEG
              ,EBANKING.TA_NEGOCIO.COLONIANEG
              ,EBANKING.TA_NEGOCIO.ESTADONEG
              ,EBANKING.TA_NEGOCIO.CIUDAD
              ,EBANKING.TA_NEGOCIO.LADA
              ,EBANKING.TA_NEGOCIO.TELNEG
              ,EBANKING.TA_NEGOCIO.PAGWEB
              ,EBANKING.TA_NEGOCIO.USUARIO_MODIFICO
              ,EBANKING.TA_NEGOCIO.FECHA_MODIFICO
              ,EBANKING.TA_NEGOCIO.CORREONEG
              ,EBANKING.TA_NEGOCIO.NUMFORM
              ,EBANKING.TA_NEGOCIO.PORCENTAJE
              ,EBANKING.TA_NEGOCIO.GRABADO
              ,EBANKING.TA_NEGOCIO.NUMINT
              ,EBANKING.TA_NEGOCIO.NUMEXTENSION
            )
            VALUES
            (  
              EBANKING.SE_IDNEGOCIO.nextval
              ,PA_FOLIOAFILIA
              ,PA_NOMBRENEGOCIO
              ,PA_RFC    
              ,PA_SECTLABORAL
              ,PA_CALLENEGOCIO
              ,PA_NUMNEGOCIO
              ,PA_CPNEGOCIO
              ,PA_COLONIANEG
              ,PA_ESTADONEGOCIO
              ,PA_CIUDADNEGOCIO
              ,PA_LADA
              ,PA_TELEFONO
              ,PA_SITIOWEB
              ,PA_USUARIOMODIFICO
              ,PA_FECHAMOD
              ,PA_CORREO
              ,PA_NUMFORM             
              ,PA_PORCENTAJE  
              ,PA_GRABADO  
              ,PA_NUMINT
              ,PA_NUMEXTENSION 
            );
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                  PASCOD_ERROR:=1;
                  PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                  ROLLBACK;
                  RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_ADD_INFONEG;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ADD_PAGOSMICRONEGOCIO
(
  
   PA_SUCURSAL       IN    EBANKING.TAPAGOMICRONEG.FNSUCURSAL%TYPE  
  ,PA_IMPORTE           IN    EBANKING.TAPAGOMICRONEG.FNIMPORTE%TYPE                     
  ,PA_GRUPO        IN   EBANKING.TAPAGOMICRONEG.FCGRUPO%TYPE
  ,PA_REFERENCIA        IN   EBANKING.TAPAGOMICRONEG.FCREFERENCIA%TYPE
  ,PA_REFEREN_CAJA IN   EBANKING.TAPAGOMICRONEG.FCREFEREN_CAJA%TYPE
  ,PA_USUARIO       IN   EBANKING.TAPAGOMICRONEG.FNUSUARIO%TYPE
  ,PA_TIENDA        IN   EBANKING.TAPAGOMICRONEG.FCTIENDA%TYPE
  ,PA_CAJERO     IN   EBANKING.TAPAGOMICRONEG.FCCAJERO%TYPE
  ,PA_CUENTA_CARGO        IN   EBANKING.TAPAGOMICRONEG.FCCUENTA_CARGO%TYPE
  ,PA_NOM_INTEGRANTE     IN   EBANKING.TAPAGOMICRONEG.FCNOM_INTEGRAN%TYPE
  ,PA_FECHA_PAGO IN   EBANKING.TAPAGOMICRONEG.FDFECHA_PAGO%TYPE
  ,PA_SISTEMA IN   EBANKING.TAPAGOMICRONEG.FCSISTEMA%TYPE
  
  ,PA_FECHA_MOD             IN    DATE
  ,PA_USUARIO_MOD      IN    VARCHAR2
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
BEGIN

    INSERT INTO EBANKING.TAPAGOMICRONEG (
       FNSUCURSAL, 
       FNIMPORTE, 
       FCGRUPO, 
       FCREFERENCIA, 
       FCREFEREN_CAJA, 
       FNUSUARIO, 
       FCTIENDA, 
       FCCAJERO,    
       FCCUENTA_CARGO,
       FCNOM_INTEGRAN, 
       FDFECHA_PAGO, 
       FCSISTEMA, 
       FDFECHA_MOD, 
       FCUSUARIO_MOD) 
    VALUES ( 
    PA_SUCURSAL, 
    PA_IMPORTE, 
    PA_GRUPO,
    PA_REFERENCIA, 
    PA_REFEREN_CAJA, 
    PA_USUARIO,
    PA_TIENDA, 
    PA_CAJERO,
    PA_CUENTA_CARGO, 
    PA_NOM_INTEGRANTE, 
    PA_FECHA_PAGO,
    PA_SISTEMA, 
    PA_FECHA_MOD, 
    PA_USUARIO_MOD
    );       
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_ADD_PAGOSMICRONEGOCIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE               SP_ADD_REG_WS
(
  
   P_FOLIO                IN  CUENTASELECTA.TA_USUARIO.IDUSUARIO%TYPE
  ,P_APAT                 IN  CUENTASELECTA.TA_CLIENTE.APATERNO%TYPE
  ,P_AMAT                 IN  CUENTASELECTA.TA_CLIENTE.AMATERNO%TYPE
  ,P_NOMBRE               IN  CUENTASELECTA.TA_CLIENTE.NOMBRECLI%TYPE
  ,P_USUARIO              IN  CUENTASELECTA.TA_USUARIO.USUARIO%TYPE
  ,P_CLAVE                IN  CUENTASELECTA.TA_USUARIO.PASSWD%TYPE
  ,P_EMAIL                IN  CUENTASELECTA.TA_CLIENTE.EMAIL%TYPE
  ,P_ACTIVIDAD            IN  CUENTASELECTA.TA_CLIENTE.ACTIVIDAD%TYPE
  ,P_RFC                  IN  CUENTASELECTA.TA_CLIENTE.RFC%TYPE
  ,P_RAZONSOC             IN  CUENTASELECTA.TA_NEGOCIO.NOMBRENEG%TYPE
  ,P_TELEFONO             IN  CUENTASELECTA.TA_CLIENTE.TELCASA%TYPE
  ,P_CALLE                IN  CUENTASELECTA.TA_CLIENTE.CALLECLI%TYPE
  ,P_NUMERO               IN  CUENTASELECTA.TA_CLIENTE.NUMEXT%TYPE
  ,P_MUNICIPIO            IN  CUENTASELECTA.TA_CLIENTE.CIUDAD%TYPE
  ,P_ESTADO               IN  CUENTASELECTA.TA_CLIENTE.ESTADOCLI%TYPE
  ,P_COLONIA              IN  CUENTASELECTA.TA_CLIENTE.COLONIACLI%TYPE
  ,P_CODPOST              IN  CUENTASELECTA.TA_CLIENTE.CODPOSTALCLI%TYPE  
  ,P_USUARIOMODIFICO      IN    varchar2
  ,P_FECHAMOD             IN    date
  ,PSCod_Error            OUT   number
  ,PSMsg_Error            OUT   varchar2
)
IS
v_rows int :=0;
v_usuario varchar2(30) :='';
BEGIN
                SELECT CUENTASELECTA.ta_usuario.usuario
                into v_usuario
                FROM CUENTASELECTA.ta_usuario
                WHERE CUENTASELECTA.ta_usuario.usuario =  P_USUARIO
                OR ta_usuario.idusuario = P_FOLIO;
                
                PSCod_Error := 1;
                PSMsg_Error := 'El usuario ya existe';
                
        EXCEPTION   
            WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
        
            WHEN DUP_VAL_ON_INDEX THEN
                PSCod_Error := 1;
                PSMsg_Error := 'Error: estas tratando de insertar un registro duplicado';
                dbms_output.put_line( 'DUP_VAL_ON_INDEX');
                
            WHEN NO_DATA_FOUND THEN
                 INSERT INTO CUENTASELECTA.TA_USUARIO
                    (
                       CUENTASELECTA.TA_USUARIO.IDUSUARIO
                      ,CUENTASELECTA.TA_USUARIO.USUARIO
                      ,CUENTASELECTA.TA_USUARIO.PASSWD
                      ,CUENTASELECTA.TA_USUARIO.ESTATUS
                      ,CUENTASELECTA.ta_usuario.usuario_modifico
                      ,CUENTASELECTA.ta_usuario.fecha_modifico
                    )
                    VALUES
                    (
                       P_FOLIO
                      ,P_USUARIO
                      ,P_CLAVE
                      ,1
                      ,P_USUARIOMODIFICO
                      ,P_FECHAMOD
                    );
                    
                    INSERT INTO CUENTASELECTA.TA_CLIENTE
                    (
                       CUENTASELECTA.TA_CLIENTE.IDCLIENTE
                      ,CUENTASELECTA.TA_CLIENTE.IDUSUARIO
                      ,CUENTASELECTA.TA_CLIENTE.APATERNO
                      ,CUENTASELECTA.TA_CLIENTE.AMATERNO
                      ,CUENTASELECTA.TA_CLIENTE.NOMBRECLI
                      ,CUENTASELECTA.TA_CLIENTE.EMAIL
                      ,CUENTASELECTA.TA_CLIENTE.ACTIVIDAD
                      ,CUENTASELECTA.TA_CLIENTE.RFC
                      ,CUENTASELECTA.TA_CLIENTE.TELCASA
                      ,CUENTASELECTA.TA_CLIENTE.CALLECLI
                      ,CUENTASELECTA.TA_CLIENTE.NUMEXT
                      ,CUENTASELECTA.TA_CLIENTE.CIUDAD
                      ,CUENTASELECTA.TA_CLIENTE.ESTADOCLI
                      ,CUENTASELECTA.TA_CLIENTE.COLONIACLI
                      ,CUENTASELECTA.TA_CLIENTE.CODPOSTALCLI
                      ,CUENTASELECTA.ta_cliente.usuario_modifico
                      ,CUENTASELECTA.ta_cliente.fecha_modifico
                    )
                    VALUES
                    (
                       CUENTASELECTA.SE_IDCLIENTE.NEXTVAL
                      ,P_FOLIO
                      ,P_APAT
                      ,P_AMAT
                      ,P_NOMBRE
                      ,P_EMAIL
                      ,P_ACTIVIDAD
                      ,P_RFC
                      ,P_TELEFONO
                      ,P_CALLE
                      ,P_NUMERO
                      ,P_MUNICIPIO
                      ,P_ESTADO
                      ,P_COLONIA
                      ,P_CODPOST
                      ,P_USUARIOMODIFICO
                      ,P_FECHAMOD
                    );
                                                    
                    INSERT INTO CUENTASELECTA.TA_NEGOCIO
                    (
                      CUENTASELECTA.ta_negocio.idnegocio
                      ,CUENTASELECTA.ta_negocio.idusuario
                      ,CUENTASELECTA.TA_NEGOCIO.NOMBRENEG
                      ,CUENTASELECTA.ta_negocio.usuario_modifico
                      ,CUENTASELECTA.ta_negocio.fecha_modifico
                    )
                    VALUES
                    (
                      CUENTASELECTA.SE_IDNEGOCIO.nextval
                      ,P_FOLIO
                      ,P_RAZONSOC
                      ,P_USUARIOMODIFICO
                      ,P_FECHAMOD
                    );
                    PSCod_Error := 0;
                    PSMsg_Error := 'Agrego registro en ta_usuario, ta_cliente y ta_negocio';
                    COMMIT;
                dbms_output.put_line( 'NO_DATA_FOUND');
                
            WHEN OTHERS THEN
              PSCod_Error := 1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'OTHERS');
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al agregar en SP_ADD_REG_WS  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_ADD_REG_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           SP_ADD_USR
(
   PA_USUARIO              IN    EBANKING.TA_USUARIO.USUARIO%TYPE
  ,PA_PASSWD               IN    EBANKING.TA_USUARIO.PASSWD%TYPE
  ,PA_CORREO               IN    EBANKING.TA_CLIENTE.EMAIL%TYPE
  ,PA_FOLIOAFILIA          IN    VARCHAR2
  ,PA_FOLIOALNOVA          IN    EBANKING.TA_USUARIO.FOLIOALNOVA%TYPE
  ,PA_ESTATUS              IN    EBANKING.TA_USUARIO.ESTATUS%TYPE
  ,PA_PORCTOTAL            IN    EBANKING.TA_USUARIO.PORCENTOTAL%TYPE
  ,PA_USUARIOMODIFICO      IN    VARCHAR2
  ,PA_FECHAMOD             IN    DATE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
BEGIN    
           INSERT INTO EBANKING.TA_USUARIO 
                      ( 
                         EBANKING.TA_USUARIO.IDUSUARIO
                        ,EBANKING.TA_USUARIO.USUARIO
                        ,EBANKING.TA_USUARIO.PASSWD
                        ,EBANKING.TA_USUARIO.FOLIOALNOVA
                        ,EBANKING.TA_USUARIO.ESTATUS
                        ,EBANKING.TA_USUARIO.PORCENTOTAL
                        ,EBANKING.TA_USUARIO.USUARIO_MODIFICO
                        ,EBANKING.TA_USUARIO.FECHA_MODIFICO
                       )
                  VALUES
                      ( 
                        PA_FOLIOAFILIA
                        ,PA_USUARIO
                        ,PA_PASSWD  
                        ,PA_FOLIOALNOVA         
                        ,PA_ESTATUS             
                        ,PA_PORCTOTAL           
                        ,PA_USUARIOMODIFICO     
                        ,PA_FECHAMOD            
                      );
            
             INSERT INTO EBANKING.TA_CLIENTE 
                      ( 
                        EBANKING.TA_CLIENTE.IDCLIENTE
                        ,EBANKING.TA_CLIENTE.IDUSUARIO
                        ,EBANKING.TA_CLIENTE.EMAIL                      
                        ,EBANKING.TA_CLIENTE.USUARIO_MODIFICO
                        ,EBANKING.TA_CLIENTE.FECHA_MODIFICO
                       )
                  VALUES
                      ( 
                        SE_IDCLIENTE.NEXTVAL
                        ,PA_FOLIOAFILIA
                        ,PA_CORREO
                        ,PA_USUARIOMODIFICO
                        ,PA_FECHAMOD
                      );
            
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_ADD_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          sp_album_enviado (pidalbum NUMBER, pstatus VARCHAR2)
IS
BEGIN
   UPDATE album
      SET enviado = pstatus
    WHERE ID = pidalbum;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END sp_album_enviado;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BB70 
(
           PA_FOLIO         IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE 
          ,PASCOD_ERROR     OUT     NUMBER
          ,PASMSG_ERROR     OUT     VARCHAR2
          ,CUR_LIST         OUT     TYPES.REFCURSOR  
) 
IS
BEGIN
        OPEN CUR_LIST FOR
        SELECT
            EBANKING.TA_TITULAR.IDTITULAR 
            ,EBANKING.TA_TITULAR.TIPOIDENTIFICACION
            ,EBANKING.TA_TITULAR.NUMIDENTIFICACION
            ,EBANKING.TA_TITULAR.FENACIMIENTO
            ,EBANKING.TA_TITULAR.RFC
            ,EBANKING.TA_TITULAR.NACIONALIDAD
            ,EBANKING.TA_TITULAR.SEXO
            ,EBANKING.TA_TITULAR.EDOCIVIL
            ,EBANKING.TA_TITULAR.CURP
            ,EBANKING.TA_TITULAR.IMPORTEOPERACION
            ,EBANKING.TA_TITULAR.ESTATUSREGISTRO
            ,EBANKING.TA_TITULAR.OBSERVACIONES
            ,EBANKING.TA_TITULAR.COMENTARIOS
            ,EBANKING.TA_TITULAR.EMAIL
            ,EBANKING.TA_TITULAR.APATERNO
            ,EBANKING.TA_TITULAR.AMATERNO
            ,EBANKING.TA_TITULAR.NOMBRE
            ,EBANKING.TA_TITULAR.FECHAREGISTRO
            ,EBANKING.TA_DIRECCION.CALLE
            ,EBANKING.TA_DIRECCION.NUMEXT
            ,EBANKING.TA_DIRECCION.NUMINT
            ,EBANKING.TA_DIRECCION.CP
            ,EBANKING.TA_DIRECCION.COLONIA
            ,EBANKING.TA_DIRECCION.ESTADO
            ,EBANKING.TA_DIRECCION.POBLACION
            ,EBANKING.TA_DIRECCION.LADA
            ,EBANKING.TA_DIRECCION.EXTENSION
            ,EBANKING.TA_DIRECCION.TELOFICINA
            ,EBANKING.TA_DIRECCION.TELCASA
            ,EBANKING.TA_DIRECCION.TELCEL
            ,EBANKING.TA_DIRECCION.VISITA
            ,EBANKING.TA_DIRECCION.FECHAVISITA
            ,EBANKING.TA_DIRECCION.HORAVISITA
            ,EBANKING.TA_DIRECCION.REFERENCIACALLES
        FROM  EBANKING.TA_DIRECCION ,EBANKING.TA_TITULAR 
        WHERE TA_TITULAR.IDTITULAR = PA_FOLIO 
        AND   TA_DIRECCION.IDTITULAR = PA_FOLIO
        AND   TA_TITULAR.IDTITULAR = TA_DIRECCION.IDTITULAR;
        
        PASCOD_ERROR:=0;
        PASMSG_ERROR:='EXITOSO';
        
    EXCEPTION
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BB70;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BB71 
(
          PA_FOLIO          IN      EBANKING.TA_BENEFICIARIO.IDTITULAR%TYPE 
          ,PASCOD_ERROR     OUT     NUMBER
          ,PASMSG_ERROR     OUT     VARCHAR2
          ,CUR_LIST         OUT    TYPES.REFCURSOR  
) 
IS
BEGIN
        OPEN CUR_LIST FOR
        SELECT 
             EBANKING.TA_BENEFICIARIO.IDTITULAR 
            ,EBANKING.TA_BENEFICIARIO.APATERNO
            ,EBANKING.TA_BENEFICIARIO.AMATERNO
            ,EBANKING.TA_BENEFICIARIO.NOMBRE
            ,EBANKING.TA_BENEFICIARIO.PARENTESCO
            ,EBANKING.TA_BENEFICIARIO.PORCENTAJE
            ,EBANKING.TA_BENEFICIARIO.NUMBENEFICIARIO
            ,EBANKING.TA_DIRBENEF.CALLE
            ,EBANKING.TA_DIRBENEF.NUMEXT
            ,EBANKING.TA_DIRBENEF.NUMINT
            ,EBANKING.TA_DIRBENEF.CP
            ,EBANKING.TA_DIRBENEF.COLONIA
            ,EBANKING.TA_DIRBENEF.ESTADO
            ,EBANKING.TA_DIRBENEF.POBLACION
            ,EBANKING.TA_DIRBENEF.LADA
            ,EBANKING.TA_DIRBENEF.EXTENSION
            ,EBANKING.TA_DIRBENEF.TELOFICINA
        FROM  EBANKING.TA_BENEFICIARIO ,EBANKING.TA_DIRBENEF 
        WHERE TA_BENEFICIARIO.IDTITULAR=PA_FOLIO 
        AND TA_BENEFICIARIO.IDBENEFICIARIO = TA_DIRBENEF.IDBENEFICIARIO;
        
        PASCOD_ERROR:=0;
        PASMSG_ERROR:='EXITOSO';
          
    EXCEPTION
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO   (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BB71;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BB73 
(
           PA_FOLIO          IN     EBANKING.TA_TITULAR.IDTITULAR%TYPE 
          ,PASCOD_ERROR     OUT     NUMBER
          ,PASMSG_ERROR     OUT     VARCHAR2
          ,CUR_LIST         OUT     SYS_REFCURSOR  
) 
IS

BEGIN
        OPEN CUR_LIST FOR
        SELECT 
             TA_USOCUENTA.ACTIVIDAD
            ,TA_USOCUENTA.ACTECONOMICA 
            ,TA_USOCUENTA.ORIGENRECURSOS
            ,TA_USOCUENTA.SECTLABORAL
            ,TA_USOCUENTA.TRANCVD 
            ,TA_USOCUENTA.TRANDEPOSITOS
            ,TA_USOCUENTA.TRANTRANSFERENCIAS
            ,TA_USOCUENTA.TRANRETIROS
            ,TA_USOCUENTA.USOCUENTA
            ,TA_INFOECOYFIN.DIREMPRESA
            ,TA_INFOECOYFIN.EGRMENSUAL
            ,TA_INFOECOYFIN.EMPRESATRABAJO
            ,TA_INFOECOYFIN.FUENTEINGRESOS
            ,TA_INFOECOYFIN.INGMENSUAL
            ,TA_INFOECOYFIN.PROFUOFICIO
            ,TA_INFOECOYFIN.PUESTO
            ,TA_INFOECOYFIN.SECTEMPRESARIAL
            ,TA_INFOECOYFIN.TELEFONO
            ,TA_INFOECOYFIN.TIEMPOLABORADO
            ,TA_PERSONAPEXP.AMATERNO 
            ,TA_PERSONAPEXP.APATERNO
            ,TA_PERSONAPEXP.NOMBRE
            ,TA_PERSONAPEXP.CALLE
            ,TA_PERSONAPEXP.NUMEXT
            ,TA_PERSONAPEXP.NUMINT
            ,TA_PERSONAPEXP.COLONIA
            ,TA_PERSONAPEXP.CP
            ,TA_PERSONAPEXP.ESTADO
            ,TA_PERSONAPEXP.POBLACION
            ,TA_PERSONAPEXP.FUEPPEFAM
            ,TA_PERSONAPEXP.FUEPPETIT
            ,TA_PERSONAPEXP.PUESTOTITULAR
            ,TA_PERSONAPEXP.PUESTOFAMILIAR
            ,TA_PERSONAPEXP.LADA
            ,TA_PERSONAPEXP.TELEFONO
        FROM 
              EBANKING.TA_TITULAR 
            , EBANKING.TA_USOCUENTA 
            , EBANKING.TA_INFOECOYFIN 
            , EBANKING.TA_PERSONAPEXP 

        
         WHERE TA_TITULAR.IDTITULAR = PA_FOLIO
        AND TA_TITULAR.IDTITULAR = TA_USOCUENTA.IDTITULAR
        AND TA_USOCUENTA.IDTITULAR = TA_INFOECOYFIN.IDTITULAR
        AND TA_INFOECOYFIN.IDTITULAR = TA_PERSONAPEXP.IDTITULAR;


        PASCOD_ERROR:=0;
        PASMSG_ERROR:='EXITOSO';
        
    EXCEPTION
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BB73;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BLOQUEAINAC (
        LISTA           IN      IDCORREOS
        ,PASMSG_ERROR   OUT     VARCHAR2
)

IS

BEGIN  

    FOR i IN 1 .. LISTA.COUNT
       LOOP
            INSERT INTO EBANKING.BLOQUEOINAC_H (ID_BLOQUEO,CTE_ALNOVA,FECHA_MODIFICACION,ESTATUS,ULTIMA_MODIFICACION,USUARIOS_MODIFICO,SISTEMA,PAIS)
            VALUES(EBANKING.SEQ_BLOQ_INAC.NEXTVAL,LISTA(i),SYSDATE,'BLOQUEADO',SYSDATE,'NETNET','PORTAL','MEX');
            UPDATE EBANKING.EBANKING_USER_BACK SET ACTIVE = 0 WHERE ID = LISTA(i);
        END LOOP;
        COMMIT;
        PASMSG_ERROR := 'EXITOSO';    
 
   EXCEPTION
        WHEN OTHERS THEN
        PASMSG_ERROR:=SQLCODE || ' NO EXITOSO SP_BLOQUEOINAC' || SQLERRM;
        ROLLBACK;
        RAISE;
END SP_BLOQUEAINAC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BLOQUEO(
         
     PRIMERO       IN NUMBER
    ,SEGUNDO       IN NUMBER
    ,TERCERO       IN NUMBER
    ,BLOQUEO       IN NUMBER
    ,FECHAPIVOTE   IN VARCHAR2
    ,PASMSG_ERROR  OUT VARCHAR2
    ,REGRESA       OUT SYS_REFCURSOR
)
IS

MES NUMBER;
IDEN VARCHAR2(8 BYTE);
CORREO EBANKING.EBANKING_USER.EMAIL%TYPE;
        

BEGIN
    BEGIN
         OPEN REGRESA FOR
         SELECT EMAIL,TRUNC(MONTHS_BETWEEN(SYSDATE,ULT_ACCESO))MES,TO_CHAR(ID) INTO CORREO, MES, IDEN 
            FROM EBANKING.EBANKING_USER 
            WHERE TO_CHAR(ULT_ACCESO,'dd/mm/yyyy')>=FECHAPIVOTE AND EMAIL IS NOT NULL 
            AND ((MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=PRIMERO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<PRIMERO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=SEGUNDO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<SEGUNDO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=TERCERO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<TERCERO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=BLOQUEO));
         
         COMMIT; 
         PASMSG_ERROR := 'EXITOSO';

         EXCEPTION
            WHEN OTHERS THEN
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');

    END;
END SP_BLOQUEO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BUSCAFOLIOMOVIL
(
    OUT_FOLIO      OUT       NUMBER
)
IS

BEGIN
      SELECT EBANKING.SQ_FOLIOMOVIL.NEXTVAL INTO OUT_FOLIO FROM DUAL;
      
      EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO SE PUDO OBTENER EL FOLIO: EBANKING.SP_BUSCAFOLIOMOVIL (' || SQLCODE || '  ' || SQLERRM || ')');      
END SP_BUSCAFOLIOMOVIL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BUSCAUSREXIS
(
          PA_CORREO            IN      EBANKING.TA_TITULAR.EMAIL%TYPE
          ,PASCOD_ERROR        OUT     NUMBER
          ,PASMSG_ERROR        OUT     VARCHAR2
          ,CUR_CLIENTE         OUT     TYPES.REFCURSOR 
)
AS
BEGIN
      OPEN CUR_CLIENTE FOR
        SELECT 
              IDTITULAR 
              ,EMAIL
              ,PASSWD
        FROM EBANKING.TA_TITULAR
        WHERE TA_TITULAR.EMAIL = PA_CORREO;
        
        PASCOD_ERROR:=0;
        PASMSG_ERROR:='EXITOSO';

EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BUSCAUSREXIS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE              SP_BUSCA_CLEXIS
( 
          PA_FOLIOAFILIA       IN      EBANKING.TA_CLIENTE.IDUSUARIO%TYPE
          ,PASCOD_ERROR        OUT     NUMBER
          ,PASMSG_ERROR        OUT     VARCHAR2
          ,CUR_CLIENTE          OUT     SYS_REFCURSOR 
          
) 
AS 
BEGIN
    OPEN CUR_CLIENTE FOR
        SELECT      EBANKING.TA_CLIENTE.ACTIVIDAD
                    ,EBANKING.TA_CLIENTE.ACTIVIDADECO
                    ,EBANKING.TA_CLIENTE.AMATERNO
                    ,EBANKING.TA_CLIENTE.APATERNO
                    ,EBANKING.TA_CLIENTE.CALLECLI
                    ,EBANKING.TA_CLIENTE.CIUDAD
                    ,EBANKING.TA_CLIENTE.CODPOSTALCLI
                    ,EBANKING.TA_CLIENTE.COLONIACLI
                    ,EBANKING.TA_CLIENTE.CURP
                    ,EBANKING.TA_CLIENTE.EMAIL
                    ,EBANKING.TA_CLIENTE.ESTADOCIVIL
                    ,EBANKING.TA_CLIENTE.ESTADOCLI
                    ,EBANKING.TA_CLIENTE.FECHA_MODIFICO
                    ,EBANKING.TA_CLIENTE.FECHANAC
                    ,EBANKING.TA_CLIENTE.GRABADO
                    ,EBANKING.TA_CLIENTE.IDCLIENTE
                    ,EBANKING.TA_CLIENTE.IDUSUARIO
                    ,EBANKING.TA_CLIENTE.IMEI
                    ,EBANKING.TA_CLIENTE.LADA
                    ,EBANKING.TA_CLIENTE.NOMBRECLI
                    ,EBANKING.TA_CLIENTE.TIPODISP   /*Este es el que renombre de NUMCREDELECT  A  TIPODISP */
                    ,EBANKING.TA_CLIENTE.NUMEXT
                    ,EBANKING.TA_CLIENTE.NUMFORM
                    ,EBANKING.TA_CLIENTE.PASSWD
                    ,EBANKING.TA_CLIENTE.PORCENTAJE
                    ,EBANKING.TA_CLIENTE.PREGUNTASECRET
                    ,EBANKING.TA_CLIENTE.RESPUESTA
                    ,EBANKING.TA_CLIENTE.RFC
                    ,EBANKING.TA_CLIENTE.SEXO
                    ,EBANKING.TA_CLIENTE.TELCASA
                    ,EBANKING.TA_CLIENTE.USUARIO_MODIFICO
                    ,EBANKING.TA_CLIENTE.NUMINT
                    ,EBANKING.TA_CLIENTE.TIPOIDENTIFICACION
                    ,EBANKING.TA_CLIENTE.NUMEXTENSION
                    ,EBANKING.TA_CLIENTE.NUMIDENTIFIC
        FROM EBANKING.TA_CLIENTE
        WHERE EBANKING.TA_CLIENTE.IDUSUARIO =  PA_FOLIOAFILIA;
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BUSCA_CLEXIS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BUSCA_Usuario
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,P_CLIENTE   OUT   sys_refcursor 
          
) 
AS 
BEGIN
    OPEN P_CLIENTE FOR
 SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD  WHERE user_id=p_usuario AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario AND paso=2 AND status=1)ult_psw_movdinero
,(SELECT cellular_old FROM ebanking_user_old euo
WHERE CELLULAR_CHANGE_DATE=(SELECT MAX(CELLULAR_CHANGE_DATE) 
 FROM ebanking.EBANKING_USER_OLD 
WHERE user_id=p_usuario) AND user_id=p_usuario)celular_anterior
,(SELECT telefono_alterno_old FROM ebanking_user_old WHERE user_id=p_usuario AND 
alterno_change_date=(SELECT MAX(ALTERNO_CHANGE_DATE) AS ALTERNO_CHANGE_DATE
 FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)    
) telefono_alterno_anterior
,(SELECT email_old FROM ebanking.ebanking_user_old WHERE  user_id=p_usuario
AND EMAIL_CHANGE_DATE=(SELECT MAX(EMAIL_CHANGE_DATE) 
FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario))email_anterior
,(SELECT MAX(QUESTION_CHANGE_DATE) AS QUESTION_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD 
  WHERE user_id=p_usuario)ult_camb_pregunta
,(SELECT MAX(ANSWER_CHANGE_DATE) AS ANSWER_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)
 ult_camb_respuesta  
FROM EBANKING.ebanking_user WHERE EBANKING.ebanking_user.ID=p_usuario;
       -- SELECT *
       -- FROM EBANKING.ebanking_user   
       -- WHERE EBANKING.ebanking_user.ID  =  p_idUsuario ;
  PSCod_Error := 0;
   PSMsg_Error := 'Se encontro cliente en SP_BUSCA_CLEXIS';
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar cliente en SP_BUSCA_CLEXIS  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_BUSCA_Usuario;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BUS_FRECINT(FRECUENT OUT SYS_REFCURSOR)
AS
PSCod_Error     NUMBER;
PSMsg_Error     VARCHAR2(1000);
BEGIN

  OPEN FRECUENT FOR
  SELECT TFF.CLIENT AS idAlnova, TFF.DESTINO AS cuentaDestino, 
  TFF.NAME AS nombre, TFF.APELLIDO_PATERNO AS apellidoPaterno, 
  TFF.APELLIDO_MATERNO AS apellidoMaterno, TFF.FECHA_NACIMIENTO AS fechaNacimiento, 
  SFT.PAIS AS pais, TFF.LUGAR_NACIMIENTO AS NACIONALIDAD, 
  TFF.CLAVE_SWIFT AS claveSwift, TFF.STATUS_BLOQUEO AS estado 
  FROM EBANKING.TRANSFINTERNALFRECUENT TFF, EBANKING.SWIFTABA SFT 
  WHERE TFF.CLAVE_SWIFT = SFT.CLAVE
  ORDER BY CLIENT, DESTINO, CLAVE_SWIFT ASC;
  
  PSCod_Error := 0;
  PSMsg_Error := 'Registro SP_SEARCH_FRECUENT_INTERNAL correctamente';
  
  EXCEPTION WHEN OTHERS THEN
      PSCod_Error:=1;
      PSMsg_Error:='Error al consultar SP_SEARCH_FRECUENT_INTERNAL(' || SQLCODE || '  ' || SQLERRM || ')';
      RAISE_APPLICATION_ERROR(-20100, PSMsg_Error);
      
END SP_BUS_FRECINT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_BUS_FRECINT_PAG(PAGINA IN INTEGER, REGISTROS IN INTEGER, FRECUENT OUT SYS_REFCURSOR)
AS
PSCod_Error     NUMBER;
PSMsg_Error     VARCHAR2(1000);
BEGIN

  OPEN FRECUENT FOR
  SELECT * FROM (
    SELECT ROWNUM AS REGISTRO, TFF.CLIENT AS idAlnova, TFF.DESTINO AS cuentaDestino, 
      TFF.NAME AS nombre, TFF.APELLIDO_PATERNO AS apellidoPaterno, 
      TFF.APELLIDO_MATERNO AS apellidoMaterno, TFF.FECHA_NACIMIENTO AS fechaNacimiento, 
      SFT.PAIS AS pais, TFF.LUGAR_NACIMIENTO AS NACIONALIDAD, 
      TFF.CLAVE_SWIFT AS claveSwift, TFF.STATUS_BLOQUEO AS estado 
    FROM EBANKING.TRANSFINTERNALFRECUENT TFF, EBANKING.SWIFTABA SFT 
    WHERE TFF.CLAVE_SWIFT = SFT.CLAVE
    ORDER BY CLIENT, DESTINO, CLAVE_SWIFT ASC
  ) 
  WHERE REGISTRO BETWEEN ((PAGINA - 1) * REGISTROS + 1) AND (PAGINA * REGISTROS) 
  ORDER BY REGISTRO ASC;
  
  PSCod_Error := 0;
  PSMsg_Error := 'Registro SP_SEARCH_FRECUENT_INTERNAL correctamente';
  
  EXCEPTION WHEN OTHERS THEN
      PSCod_Error:=1;
      PSMsg_Error:='Error al consultar SP_SEARCH_FRECUENT_INTERNAL(' || SQLCODE || '  ' || SQLERRM || ')';
      RAISE_APPLICATION_ERROR(-20100, PSMsg_Error);
      
END SP_BUS_FRECINT_PAG;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_CANCEL_PROGRAMMED_TRANSFER(P_PROGRAMMED_TRANSFER_ID IN NUMBER,
                                                          P_DB_KEY                 IN VARCHAR2,
                                                          PSCod_Error             OUT number,
                                                          PSMsg_Error             OUT varchar2) IS
/******************************************************************************
   NAME:       SP_CANCEL_PROGRAMMED_TRANSFER
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        12/04/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_CANCEL_PROGRAMMED_TRANSFER
      Sysdate:         12/04/2013
      Date and Time:   12/04/2013, 06:50:21 p.m., and 12/04/2013 06:50:21 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   
    UPDATE SCHEDULED_PAYMENT 
    SET STATUS ='CANC POR USUARIO',
        RESPONSE = EBANKING.ENCRYPTREQUEST ('CANCELADO POR USUARIO ' || SYSDATE, P_DB_KEY)
    WHERE SCHEDULED_PAYMENT_ID = P_PROGRAMMED_TRANSFER_ID;

   PSCod_Error := 0;
   PSMsg_Error := 'ejecucion de SP_CANCEL_PROGRAMMED_TRANSFER exitosa';
   
   COMMIT;
   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_CANCEL_PROGRAMMED_TRANSFER';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_CANCEL_PROGRAMMED_TRANSFER (' || SQLCODE || '  ' || SQLERRM || ')');
       
END SP_CANCEL_PROGRAMMED_TRANSFER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CANC_PROG_TRANS(P_PROGRAMMED_TRANSFER_ID IN NUMBER,
                                                          P_DB_KEY                 IN VARCHAR2,
                                                          PSCod_Error             OUT number,
                                                          PSMsg_Error             OUT varchar2) IS
BEGIN
    UPDATE EBANKING.SCHEDULED_PAYMENT 
    SET STATUS ='CANC POR USUARIO',
        RESPONSE = EBANKING.ENCRYPTREQUEST ('CANCELADO POR USUARIO ' || SYSDATE, P_DB_KEY)
    WHERE SCHEDULED_PAYMENT_ID = P_PROGRAMMED_TRANSFER_ID;

   PSCod_Error := 0;
   PSMsg_Error := 'ejecucion de SP_CANC_PROG_TRANS exitosa';
   
   COMMIT;
   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_CANC_PROG_TRANS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_CANC_PROG_TRANS (' || SQLCODE || '  ' || SQLERRM || ')');
       
END SP_CANC_PROG_TRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                 SP_CATALOGOS
( 
           PA_CLAVECATALOGO    IN      EBANKING.TA_CATALOGOS.IDCATALOGO%TYPE
          ,PASCOD_ERROR        OUT     NUMBER
          ,PASMSG_ERROR        OUT     VARCHAR2
          ,CUR_CURSOR           OUT    TYPES.REFCURSOR         
)
IS
VL_VAR EBANKING.TA_CONTENIDOCAT.IDCATALOGO%TYPE;
VL_UNO INT := 1;
VL_SEPARADOR VARCHAR2(1) := '|';
BEGIN

        SELECT TA_CONTENIDOCAT.CLAVE || VL_SEPARADOR || TA_CONTENIDOCAT.CONTENIDO
        INTO VL_VAR
        FROM EBANKING.TA_CONTENIDOCAT
        WHERE TA_CONTENIDOCAT.IDCATALOGO = PA_CLAVECATALOGO AND TA_CONTENIDOCAT.STATUS = VL_UNO ORDER BY TA_CONTENIDOCAT.ORDEN; 
          
    EXCEPTION
            WHEN NO_DATA_FOUND THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:='NO SE ENCONTRO EL CATALOGO';
              DBMS_OUTPUT.PUT_LINE( 'NO_DATA_FOUND');           
           
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=0;             
              PASMSG_ERROR:= 'SE ENCONTRO EL CATALOGO';
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');   
			  
              OPEN CUR_CURSOR FOR
                SELECT TA_CONTENIDOCAT.CLAVE || VL_SEPARADOR || TA_CONTENIDOCAT.CONTENIDO AS CONTENIDO
                FROM EBANKING.TA_CONTENIDOCAT
                WHERE TA_CONTENIDOCAT.IDCATALOGO = PA_CLAVECATALOGO AND TA_CONTENIDOCAT.STATUS = VL_UNO ORDER BY TA_CONTENIDOCAT.ORDEN;
				
          WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_CATALOGOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CHANSTATPREA(
     IDALNOVA   IN EBANKING.PREACTIVE_USER.ID_ALNOVA%TYPE
     ,SALIDA OUT VARCHAR2
)AS

BEGIN
   UPDATE EBANKING.PREACTIVE_USER SET STATUS = '1' WHERE ID_ALNOVA = IDALNOVA;
   SALIDA := 'CORRECTO';
   
   IF SQL%FOUND THEN
       SALIDA := 'CORRECTO'; 
   ELSE
      SALIDA:='ERROR';
   END IF;

    
   EXCEPTION
    WHEN NO_DATA_FOUND THEN
        SALIDA:='ERROR';
        RAISE_APPLICATION_ERROR (-20100, 'No se encontraron datos  (' || SQLCODE || '  ' || SQLERRM || ')');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20000, 'Error al obtener IDALNOVA(' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_CHANSTATPREA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CLIENTE_CONOCIDO_UPD (numUser IN  number,
                                                              monto_Max_anterior IN  number,
                                                              monto_Max_pagos IN number,
                                                              monto_Max_internac IN number,
                                                              monto_Max_interbanc IN number,
                                                              monto_Max_terceros IN number,
                                                              monto_Max_semanal_NUEVO IN number,
                                                              STATUS_ACTUAL IN number,
                                                              STATUS_NUEVO IN number)
IS
BEGIN
    -- REGRESA EL USER_STATUS DEL EBANKING_USER A su estatus anterior
       update ebanking.ebanking_user set user_status=STATUS_ACTUAL where id=numUser;
    -- actualiza los montos
       update ebanking.EBANKING_SECURITY_MAX_AMOUNT set TERCEROS=monto_Max_terceros, interbancario=monto_Max_interbanc,
          internacionales=monto_Max_internac, pagos=monto_Max_pagos,diario=monto_Max_semanal_NUEVO  where IDUSER=numUser;
    -- Inserta en Historico de UserStatus
       insert into ebanking.EBANKING_USER_STATUS_H(ID,STATUS_ACTUAL,STATUS_NUEVO,MONTO_MAX_ACTUAL,MONTO_MAX_NUEVO,FECHA_CAMBIO,IP,SISTEMA)
       values (numUser,STATUS_ACTUAL,STATUS_NUEVO,monto_Max_anterior,monto_Max_semanal_NUEVO,SYSDATE,'AutoGenerated','NETNET');

    -- inserta en Historico de MAX_AMOUNTS
    --insert into EBANKING_SECURITY_MAX_AMOUNT_H (IDUSER,TERCEROS,INTERBANCARIO,PAGOS,INTERNACIONALES)
   -- values (numUser,monto_Max_terceros,monto_Max_interbanc,monto_Max_pagos,monto_Max_internac);

    -- elimina registro de EBANKING_USER_CERT_VIP
    delete from ebanking.EBANKING_USER_CERT_VIP where id=numUser;

  COMMIT;

EXCEPTION

	WHEN NO_DATA_FOUND THEN
     ROLLBACK;
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
    ROLLBACK;
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END SP_CLIENTE_CONOCIDO_UPD;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONBENEF
(
          PA_FOLIO          IN      EBANKING.TA_BENEFICIARIO.IDTITULAR%TYPE 
          ,PASCOD_ERROR     OUT     NUMBER
          ,PASMSG_ERROR     OUT     VARCHAR2
          ,CUR_LIST         OUT     TYPES.REFCURSOR  
) 
AS 
BEGIN
      OPEN CUR_LIST FOR
          SELECT 
            TA_BENEFICIARIO.IDTITULAR
            ,TA_BENEFICIARIO.IDBENEFICIARIO
            ,TA_BENEFICIARIO.APATERNO
            ,TA_BENEFICIARIO.AMATERNO
            ,TA_BENEFICIARIO.NOMBRE
            ,TA_BENEFICIARIO.PARENTESCO
            ,TA_BENEFICIARIO.PORCENTAJE
            ,TA_BENEFICIARIO.NUMBENEFICIARIO
            ,TA_BENEFICIARIO.PORCENTAJEF
            ,TA_BENEFICIARIO.GRABADO
            ,TA_DIRBENEF.CALLE
            ,TA_DIRBENEF.NUMEXT
            ,TA_DIRBENEF.NUMINT
            ,TA_DIRBENEF.CP
            ,TA_DIRBENEF.COLONIA
            ,TA_DIRBENEF.ESTADO
            ,TA_DIRBENEF.POBLACION
            ,TA_DIRBENEF.LADA
            ,TA_DIRBENEF.EXTENSION
            ,TA_DIRBENEF.TELOFICINA
        FROM EBANKING.TA_BENEFICIARIO ,EBANKING.TA_DIRBENEF 
        WHERE TA_BENEFICIARIO.IDTITULAR=PA_FOLIO AND TA_BENEFICIARIO.IDBENEFICIARIO=TA_DIRBENEF.IDBENEFICIARIO 
        ORDER BY EBANKING.TA_BENEFICIARIO.NUMBENEFICIARIO;
      EXCEPTION
            WHEN OTHERS THEN
              ROLLBACK ;
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO   (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_CONBENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_CONBENEFICIA
(
          foli            IN      ta_titular.idtitular%type
          ,correo         IN      ta_titular.email%type  
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,beneficiario   OUT     sys_refcursor  
) AS 
BEGIN
OPEN beneficiario FOR
        SELECT 
          ben.idbeneficiario
          ,ben.idtitular
          ,ben.apaterno
          ,ben.amaterno
          ,ben.nombre
          ,ben.parentesco
          ,ben.porcentaje
          ,ben.email
          ,dir.iddireccion
          ,dir.idbeneficiario
          ,dir.idtitular
          ,dir.calle
          ,dir.numext
          ,dir.numint
          ,dir.cp
          ,dir.estado
          ,dir.poblacion
          ,dir.lada
          ,dir.teloficina
          ,dir.extension
          ,dir.visita
          ,tit.idtitular
        FROM ta_beneficiario ben, ta_direccion dir, ta_titular tit
        WHERE ben.idtitular = tit.idtitular
          AND dir.idbeneficiario = ben.idbeneficiario
          AND dir.idtitular = tit.idtitular
          AND tit.email =  correo
          AND tit.idtitular = foli;
          
    PSCod_Error := 0;
    PSMsg_Error := 'Se valido encontro beneficiario en SP_CONBENEFICIA';
    
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          PSCod_Error:=1;
          PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
          RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al encontrar beneficiario en SP_CONBENEFICIA  (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONBENEFICIA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONCLNOFIREG
( 
          PASCOD_ERROR           OUT     NUMBER
          ,PASMSG_ERROR          OUT     VARCHAR2
          ,CUR_REGISTRO  	 OUT     TYPES.REFCURSOR  
) AS 
BEGIN
 OPEN CUR_REGISTRO FOR
       SELECT
              IDTITULAR
              ,APATERNO
              ,AMATERNO
              ,NOMBRE
              ,EMAIL
        FROM EBANKING.TA_TITULAR 
        WHERE TA_TITULAR.FETERMINO IS NULL
        AND TA_TITULAR.APATERNO IS NOT NULL
        AND TA_TITULAR.AMATERNO IS NOT NULL
        AND TA_TITULAR.NOMBRE IS NOT NULL;
                
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONCLNOFIREG;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONDATGRALES 
(
          PA_FOLIO         IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE  
          ,PA_CORREO       IN      EBANKING.TA_TITULAR.EMAIL%TYPE 
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
          ,CUR_USUARIO     OUT     TYPES.REFCURSOR  
) AS 
BEGIN
 OPEN CUR_USUARIO FOR
        SELECT 
         IDTITULAR   
          ,APATERNO
          ,AMATERNO
          ,NOMBRE
          ,SEXO
          ,EDOCIVIL
          ,FENACIMIENTO
          ,NACIONALIDAD
          ,RFC
          ,CURP
          ,TIPOIDENTIFICACION
          ,NUMIDENTIFICACION
          ,EMAIL
          ,TITPOLITEXP
          ,FAMPOLITEXP
          ,IDTITULAR
          ,FETERMINO
          ,NUMFORMULARIO
          ,PORCENTAJE
          ,GRABADO
        FROM TA_TITULAR
        WHERE TA_TITULAR.IDTITULAR = PA_FOLIO;
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
         EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_CONDATGRALES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_CONDIRECCION
(
          P_FOLIO           IN      ta_titular.idtitular%type
          ,P_CORREO         IN      ta_titular.email%type  
          ,PSCod_Error      OUT     NUMBER
          ,PSMsg_Error      OUT     VARCHAR2
          ,direccion        OUT     sys_refcursor  
) AS 
BEGIN
 OPEN direccion FOR
        SELECT 
          dir.iddireccion
          ,dir.idtitular
          ,dir.calle
          ,dir.numext
          ,dir.numint
          ,dir.cp
          ,dir.colonia
          ,dir.estado
          ,dir.poblacion
          ,dir.lada
          ,dir.teloficina
          ,dir.extension
          ,dir.visita
          ,dir.porcentaje
          ,tit.idtitular
        FROM ta_direccion dir, ta_titular tit
        WHERE dir.idtitular = tit.idtitular
          AND tit.email =  P_CORREO
          AND tit.idtitular = P_FOLIO;
        
        PSCod_Error := 0;
        PSMsg_Error := 'Se encontro Direccion de Usuario en SP_CONDIRECCION';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar Direccion de Usuario en SP_CONDIRECCION  (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONDIRECCION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONDIRTIT
(
          PA_FOLIO           IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE
          ,PA_CORREO         IN      EBANKING.TA_TITULAR.EMAIL%TYPE  
          ,PASCOD_ERROR      OUT     NUMBER
          ,PASMSG_ERROR      OUT     VARCHAR2
          ,CUR_DIRECCIONTITUAR        OUT     TYPES.REFCURSOR  
) AS 
BEGIN
 OPEN CUR_DIRECCIONTITUAR FOR
        SELECT 
          TA_DIRECCION.IDDIRECCION
          ,TA_DIRECCION.IDTITULAR 
          ,TA_DIRECCION.CALLE
          ,TA_DIRECCION.NUMEXT
          ,TA_DIRECCION.NUMINT
          ,TA_DIRECCION.CP
          ,TA_DIRECCION.COLONIA
          ,TA_DIRECCION.ESTADO
          ,TA_DIRECCION.POBLACION
          ,TA_DIRECCION.LADA
          ,TA_DIRECCION.TELOFICINA
          ,TA_DIRECCION.EXTENSION
          ,TA_DIRECCION.TELCASA
          ,TA_DIRECCION.TELCEL
          ,TA_DIRECCION.FECHAVISITA
          ,TA_DIRECCION.HORAVISITA
          ,TA_DIRECCION.REFERENCIACALLES
          ,TA_DIRECCION.VISITA
          ,TA_DIRECCION.PORCENTAJE
          ,TA_DIRECCION.GRABADO
          ,TA_TITULAR.IDTITULAR  
        FROM TA_DIRECCION,TA_TITULAR 
        WHERE TA_DIRECCION.IDTITULAR = TA_TITULAR.IDTITULAR  
          AND TA_TITULAR.IDTITULAR = PA_FOLIO  
          AND TA_DIRECCION.IDTITULAR = PA_FOLIO;  
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONDIRTIT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONECOYFIN
(
          PA_FOLIO         IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE  
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
          ,CUR_ECOYFIN        OUT     TYPES.REFCURSOR  
) AS 
BEGIN
OPEN CUR_ECOYFIN FOR
        SELECT 
          IDINFOECOYFIN
          ,IDTITULAR
          ,FUENTEINGRESOS
          ,EMPRESATRABAJO
          ,PUESTO
          ,TIEMPOLABORADO
          ,DIREMPRESA
          ,TELEFONO
          ,INGMENSUAL
          ,EGRMENSUAL
          ,SECTEMPRESARIAL
          ,PROFUOFICIO
          ,GRABADO
          ,PORCENTAJE
        FROM TA_INFOECOYFIN 
        WHERE TA_INFOECOYFIN.IDTITULAR = PA_FOLIO;
          
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONECOYFIN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE               SP_CONGRABADO
(
          PA_FOLIO         IN      VARCHAR2
          ,PA_GRABADO_DG   OUT     NUMBER
          ,PA_GRABADO_DD   OUT     NUMBER
          ,PA_GRABADO_DB   OUT     NUMBER
          ,PA_GRABADO_UC   OUT     NUMBER
          ,PA_GRABADO_IEF  OUT     NUMBER
          ,PA_GRABADO_PPE  OUT     NUMBER
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
) AS 
VL_CONT INT := 0;
VL_BANDERA INT := 1;
VL_INCREMENTO INT := 1;
VL_DEFAULT INT := 0;
VL_CERO INT := 0;
VL_UNO INT := 1;
VL_DOS INT := 2;
VL_TRES INT := 3;
VL_CUATRO INT := 4;
VL_CINCO INT := 5;
VL_NO VARCHAR(2) := 'NO';

BEGIN
        SELECT NVL(GRABADO , VL_DEFAULT)
        INTO PA_GRABADO_DG     
        FROM EBANKING.TA_TITULAR
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        SELECT NVL(GRABADO, VL_DEFAULT)
        INTO PA_GRABADO_DD     
        FROM EBANKING.TA_DIRECCION
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA
        AND VISITA = VL_NO;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        SELECT NVL(GRABADO, VL_DEFAULT)
        INTO PA_GRABADO_DB     
        FROM EBANKING.TA_BENEFICIARIO
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA
        AND NUMBENEFICIARIO = VL_BANDERA;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        SELECT NVL(GRABADO, VL_DEFAULT)
        INTO PA_GRABADO_UC     
        FROM EBANKING.TA_USOCUENTA
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        SELECT NVL(GRABADO, VL_DEFAULT)
        INTO PA_GRABADO_IEF     
        FROM EBANKING.TA_INFOECOYFIN
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        SELECT NVL(GRABADO, VL_DEFAULT)
        INTO PA_GRABADO_PPE    
        FROM EBANKING.TA_PERSONAPEXP
        WHERE IDTITULAR = PA_FOLIO
        AND GRABADO = VL_BANDERA;
        VL_CONT := VL_CONT + VL_INCREMENTO;
        
        PASCOD_ERROR := VL_DEFAULT;
        PASMSG_ERROR := 'EXITOSO';
        
        
         EXCEPTION
             WHEN NO_DATA_FOUND THEN 
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'NO_DATA_FOUND' );
              DBMS_OUTPUT.PUT_LINE( 'CONTADOR =' ||VL_CONT );
              IF VL_CONT = VL_CERO THEN
                  PA_GRABADO_DG := VL_DEFAULT;
                  PA_GRABADO_DD := VL_DEFAULT;
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_UNO THEN
                  PA_GRABADO_DD := VL_DEFAULT;
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_DOS THEN
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_TRES THEN
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CUATRO THEN
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CINCO THEN
                  PA_GRABADO_PPE := VL_DEFAULT;
              END IF;  
         
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=VL_UNO;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              DBMS_OUTPUT.PUT_LINE( 'CONTADOR =' ||VL_CONT );
               IF VL_CONT = VL_CERO THEN
                  PA_GRABADO_DG := VL_DEFAULT;
                  PA_GRABADO_DD := VL_DEFAULT;
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_UNO THEN
                  PA_GRABADO_DD := VL_DEFAULT;
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_DOS THEN
                  PA_GRABADO_DB := VL_DEFAULT;
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_TRES THEN
                  PA_GRABADO_UC := VL_DEFAULT;
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CUATRO THEN
                  PA_GRABADO_IEF := VL_DEFAULT;
                  PA_GRABADO_PPE := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CINCO THEN
                  PA_GRABADO_PPE := VL_DEFAULT;
              END IF;
              
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_CONGRABADO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_CONINFTRBB60 
(
          P_FOLIO       IN      ta_cliente.idcliente%type
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error  OUT     VARCHAR2
          ,CLIENTE      OUT     sys_refcursor  
) AS 
BEGIN
    OPEN CLIENTE FOR
        SELECT 
          cli.idcliente
          ,cli.apaterno
          ,cli.amaterno
          ,cli.nombrecli
          ,cli.rfc 
          ,cli.curp 
          ,cli.callecli
          ,cli.numext
          ,cli.codpostalcli
          ,cli.coloniacli
          ,cli.estadocli
          ,cli.ciudad
          ,cli.fechanac
          ,cli.actividad
          ,cli.actividadeco
          ,cli.lada 
          ,cli.telcasa
          ,cli.email
        FROM ta_cliente cli
        WHERE cli.idcliente = P_FOLIO;
        
        PSCod_Error := 0;
        PSMsg_Error := 'Se encontro datos para transaccion BB60 en SP_CONINFTRBB60';
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ta_cliente en SP_CONINFTRBB60  (' || SQLCODE || '  ' || SQLERRM || ')');    

END SP_CONINFTRBB60;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONPERPOLEXP
(
          PA_FOLIO           IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE
          ,PASCOD_ERROR      OUT     NUMBER
          ,PASMSG_ERROR      OUT     VARCHAR2
          ,CUR_PERPOLITEXP   OUT     TYPES.REFCURSOR  
) AS 
BEGIN

DBMS_OUTPUT.PUT_LINE( 'Folio = *'||PA_FOLIO||'*' );

OPEN CUR_PERPOLITEXP FOR
        SELECT 
          IDPERSONAPOLITEXP
          ,IDTITULAR
          ,PUESTOTITULAR
          ,PUESTOFAMILIAR
          ,APATERNO
          ,AMATERNO
          ,NOMBRE
          ,CALLE
          ,NUMEXT
          ,NUMINT
          ,CP
          ,COLONIA
          ,ESTADO
          ,POBLACION
          ,PORCENTAJE
          ,GRABADO
          ,FUEPPETIT
          ,FUEPPEFAM
          ,PARENTESCO
          ,LADA
          ,TELEFONO
        FROM EBANKING.TA_PERSONAPEXP 
        WHERE IDTITULAR = PA_FOLIO;
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');  
        
END SP_CONPERPOLEXP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONPORCENT
(
           PA_FOLIO         IN     VARCHAR2
          ,PA_PORCENT_DG   OUT     NUMBER
          ,PA_PORCENT_DD   OUT     NUMBER
          ,PA_PORCENT_DB   OUT     NUMBER
          ,PA_PORCENT_UC   OUT     NUMBER
          ,PA_PORCENT_IEF  OUT     NUMBER
          ,PA_PORCENT_PPE  OUT     NUMBER
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
) AS 

VL_CONT INT := 0;
VL_DEFAULT INT := 0;
VL_INCREMENTO INT := 1;
VL_BANDERA INT := 1;
VL_NO VARCHAR(2) := 'NO';
VL_CERO INT := 0;
VL_UNO INT := 1;
VL_DOS INT := 2;
VL_TRES INT := 3;
VL_CUATRO INT := 4;
VL_CINCO INT := 5;

BEGIN    
     
        SELECT NVL(PORCENTAJE, VL_DEFAULT)
        INTO PA_PORCENT_DG     
        FROM EBANKING.TA_TITULAR
        WHERE IDTITULAR = PA_FOLIO;
        VL_CONT  := VL_CONT + VL_INCREMENTO ; 
        
        SELECT NVL(PORCENTAJE, VL_DEFAULT)
        INTO PA_PORCENT_DD     
        FROM EBANKING.TA_DIRECCION
        WHERE IDTITULAR = PA_FOLIO
        AND VISITA = VL_NO;
        VL_CONT  := VL_CONT + VL_INCREMENTO; 
        
        SELECT NVL(PORCENTAJEF, VL_DEFAULT)
        INTO PA_PORCENT_DB     
        FROM EBANKING.TA_BENEFICIARIO
        WHERE IDTITULAR = PA_FOLIO
        AND NUMBENEFICIARIO=VL_BANDERA;
        VL_CONT  := VL_CONT + VL_INCREMENTO ; 
        
        SELECT NVL(PORCENTAJE, VL_DEFAULT)
        INTO PA_PORCENT_UC     
        FROM EBANKING.TA_USOCUENTA
        WHERE IDTITULAR = PA_FOLIO;
        VL_CONT  := VL_CONT + VL_INCREMENTO; 
        
        SELECT NVL(PORCENTAJE,VL_DEFAULT)
        INTO PA_PORCENT_IEF     
        FROM EBANKING.TA_INFOECOYFIN
        WHERE IDTITULAR = PA_FOLIO;
        VL_CONT  := VL_CONT + VL_INCREMENTO; 
        
        SELECT NVL(PORCENTAJE, VL_DEFAULT)
        INTO PA_PORCENT_PPE    
        FROM EBANKING.TA_PERSONAPEXP
        WHERE IDTITULAR = PA_FOLIO;
        VL_CONT  := VL_CONT + VL_INCREMENTO; 
        
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
         EXCEPTION
            WHEN NO_DATA_FOUND THEN 
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'NO_DATA_FOUND' );
              DBMS_OUTPUT.PUT_LINE( 'CONTADOR =' ||VL_CONT );
			  
              IF VL_CONT = VL_CERO THEN
                  PA_PORCENT_DG   := VL_DEFAULT;
                  PA_PORCENT_DD   := VL_DEFAULT;
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_UNO THEN
                  PA_PORCENT_DD   := VL_DEFAULT;
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_DOS THEN
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_TRES THEN
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CUATRO THEN
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CINCO THEN
                  PA_PORCENT_PPE  := VL_DEFAULT;
              END IF;
              
            WHEN TOO_MANY_ROWS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              DBMS_OUTPUT.PUT_LINE( 'CONTADOR =' ||VL_CONT );
              
              IF VL_CONT = VL_CERO THEN
                  PA_PORCENT_DG   := VL_DEFAULT;
                  PA_PORCENT_DD   := VL_DEFAULT;
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_UNO THEN
                  PA_PORCENT_DD   := VL_DEFAULT;
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_DOS THEN
                  PA_PORCENT_DB   := VL_DEFAULT;
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_TRES THEN
                  PA_PORCENT_UC   := VL_DEFAULT;
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CUATRO THEN
                  PA_PORCENT_IEF  := VL_DEFAULT;
                  PA_PORCENT_PPE  := VL_DEFAULT;
              
              ELSIF VL_CONT = VL_CINCO THEN
                  PA_PORCENT_PPE  := VL_DEFAULT;
              END IF;
              
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_CONPORCENT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONSULSEQWU
(
PA_FNNUMCONSEC         OUT  NUMBER,
PA_COD_ERROR         OUT  NUMBER,
PA_MSG_ERROR         OUT  VARCHAR2
)
IS
/****************************************************************************
   Proyecto:                Ebanking
   Descripcion:             Procedimiento para insertar registros en la tabla TAPAGOSELEKTRA
   Parametros de entrada:   N / A.

   Parametros de salida:   PA_FNNUMCONSEC
                          FNPSCOD                -Codigo de retorno del procedimiento
                          FCPSMSG                -Mensaje de retoro del procedimiento
   Creador:               Oscar Tzompantzi Astivia
   Fecha:                 06/12/2013
****************************************************************************/
BEGIN
       SELECT EBANKING.WUNUMREFERENCE_SEQ.NEXTVAL
         INTO PA_FNNUMCONSEC
         FROM DUAL;
       
      PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'OPERACION EXITOSA';
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'FALLO AL RECUPERAR LA SECUENCIA (' || SQLCODE || '  ' || SQLERRM || ')');


END SP_CONSULSEQWU;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CONUSOCUENTA
(
          PA_FOLIO         IN      EBANKING.TA_TITULAR.IDTITULAR%TYPE  
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
          ,CUR_USOCTA      OUT     TYPES.REFCURSOR  
) AS 
BEGIN
OPEN CUR_USOCTA FOR
        SELECT 
          IDUSOCUENTA
          ,IDTITULAR
          ,SECTLABORAL
          ,ACTECONOMICA
          ,ACTIVIDAD
          ,TRANDEPOSITOS
          ,TRANRETIROS
          ,TRANTRANSFERENCIAS
          ,TRANCVD
          ,ORIGENRECURSOS
          ,USOCUENTA
          ,PORCENTAJE
          ,GRABADO
        FROM TA_USOCUENTA 
        WHERE TA_USOCUENTA.IDTITULAR = PA_FOLIO;
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
        EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
          
END SP_CONUSOCUENTA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CON_EMAIL(
V_NUM_CLIENTE_IN               IN     EBANKING.EBANKING_TOKEN_STATUS.ID%TYPE,
V_NUM_SERIE_IN                 IN     EBANKING.EBANKING_TOKEN_STATUS.NUM_SERIE_TOKEN%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,    
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN

    OPEN CURSOR_CLIENTE FOR        
    SELECT E.ID, E.NUM_SERIE_TOKEN, E.STATUS, E.FECHA_ACTIVACION, E.FECHA_MODIFICACION, 
    E.SISTEMA, E.IDPAIS, U.EMAIL FROM EBANKING.EBANKING_TOKEN_STATUS E 
    LEFT JOIN EBANKING.EBANKING_USER U ON E.ID = U.ID
    WHERE E.NUM_CLIENTE = V_NUM_CLIENTE_IN 
    AND E.NUM_SERIE_TOKEN = V_NUM_SERIE_IN; 
    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar MAILS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_CON_EMAIL (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_CON_EMAIL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_CON_EMAIL_CR(
V_NUM_CLIENTE_IN               IN     EBANKING.EBANKING_TOKEN_STATUS.ID%TYPE,
V_NUM_SERIE_IN                 IN     EBANKING.EBANKING_TOKEN_STATUS.NUM_SERIE_TOKEN%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2,    
CURSOR_CLIENTE                 OUT    sys_refcursor
)
IS
BEGIN

    OPEN CURSOR_CLIENTE FOR        
    SELECT E.ID, E.NUM_SERIE_TOKEN, E.STATUS, E.FECHA_ACTIVACION, E.FECHA_MODIFICACION, 
    E.SISTEMA, E.IDPAIS, U.EMAIL FROM EBANKING.EBANKING_TOKEN_STATUS E, EBANKING.EBANKING_USER U
    WHERE E.NUM_CLIENTE = V_NUM_CLIENTE_IN 
    AND E.NUM_SERIE_TOKEN = V_NUM_SERIE_IN
    AND E.NUM_CLIENTE = U.ID; 
    EXCEPTION
     WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al consultar MAILS';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_CON_EMAIL_CR (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_CON_EMAIL_CR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_CORREO_WS 
(
          P_USUARIO        IN      EBANKING.ta_usuario.usuario%type
          ,PSCod_Error     OUT     NUMBER
          ,P_STATUS        OUT     VARCHAR2
          ,PSMsg_Error     OUT     VARCHAR2
          ,P_CORREO        OUT     sys_refcursor 
) 
AS
BEGIN
        OPEN P_CORREO FOR
        SELECT 
              cli.email
              ,usr.passwd
        FROM EBANKING.ta_cliente cli, EBANKING.ta_usuario usr
        WHERE cli.idusuario = usr.idusuario
        AND usr.usuario=P_USUARIO;
        
        PSCod_Error := 0;
        PSMsg_Error := 'Se encontro correo y contraseña en ta_cliente';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              ROLLBACK ;
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              P_STATUS:='0';
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al solicitar correo y contraseña en SP_CORREO_WS   (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_CORREO_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_DatosUsuario_SELECT
     ( 
        p_usuario  number                 
     ) 
AS 
BEGIN  
  
  SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD  WHERE user_id=p_usuario AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario AND paso=2 AND status=1)ult_psw_movdinero
,(SELECT cellular_old FROM ebanking_user_old euo
WHERE CELLULAR_CHANGE_DATE=(SELECT MAX(CELLULAR_CHANGE_DATE) 
 FROM ebanking.EBANKING_USER_OLD 
WHERE user_id=p_usuario) AND user_id=p_usuario)celular_anterior
,(SELECT telefono_alterno_old FROM ebanking_user_old WHERE user_id=p_usuario AND 
alterno_change_date=(SELECT MAX(ALTERNO_CHANGE_DATE) AS ALTERNO_CHANGE_DATE
 FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)    
) telefono_alterno_anterior
,(SELECT email_old FROM ebanking.ebanking_user_old WHERE  user_id=p_usuario
AND EMAIL_CHANGE_DATE=(SELECT MAX(EMAIL_CHANGE_DATE) 
FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario))email_anterior
,(SELECT MAX(QUESTION_CHANGE_DATE) AS QUESTION_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD 
  WHERE user_id=p_usuario)ult_camb_pregunta
,(SELECT MAX(ANSWER_CHANGE_DATE) AS ANSWER_CHANGE_DATE FROM ebanking.EBANKING_USER_OLD WHERE user_id=p_usuario)
 ult_camb_respuesta  
FROM EBANKING.ebanking_user WHERE ID=p_usuario
END  SP_DatosUsuario_SELECT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_DELETEBENEF

(
           PA_FOLIO        IN      VARCHAR
          ,PA_IDBENEF      IN      NUMBER
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2 
         
)
IS
BEGIN
    DELETE FROM 
       EBANKING.TA_DIRBENEF 
        WHERE  TA_DIRBENEF.IDBENEFICIARIO=PA_IDBENEF;
          
   DELETE FROM 
       EBANKING.TA_BENEFICIARIO
        WHERE  TA_BENEFICIARIO.IDBENEFICIARIO=PA_IDBENEF 
            AND TA_BENEFICIARIO.IDTITULAR=PA_FOLIO;
          
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO'; 
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
      WHEN OTHERS THEN
          PASCOD_ERROR:=1;
          PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
          ROLLBACK;
          RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO(' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_DELETEBENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_DEL_BIT_CAN(
 PSCod_Error                   OUT    number,
 PSMsg_Error                   OUT    varchar2
)
IS
BEGIN
DELETE EBANKING.BIT_CAN_FA;
DELETE EBANKING.BIT_CAN_FA_EBK;
COMMIT;

PSCod_Error:=0;
PSMsg_Error:='Realizo delete en SP_DEL_BIT_CAN correctamente';

EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PSCod_Error:=1;
            PSMsg_Error:='Error al hacer delete en SP_TRUN_BIT_CAN';
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al hacer delete en SP_DEL_BIT_CAN (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_DEL_BIT_CAN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                SP_DEL_CATALOGO

(
 PA_IDCATALOGO  IN     EBANKING.TA_CATALOGOS.IDCATALOGO%TYPE
,PA_COD_ERROR   OUT    NUMBER
,PA_MSG_ERROR   OUT    VARCHAR
)
IS
BEGIN

 DELETE FROM 
      EBANKING.TA_CONTENIDOCAT
        WHERE IDCATALOGO = PA_IDCATALOGO;

DELETE FROM 
      EBANKING.TA_CATALOGOS
        WHERE IDCATALOGO = PA_IDCATALOGO;
          
PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');

END SP_DEL_CATALOGO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_DEL_CONTENIDO
(
 
PA_ID_CATALOGO IN     EBANKING.TA_CONTENIDOCAT.IDCATALOGO%TYPE
,PA_COD_ERROR   OUT    NUMBER
,PA_MSG_ERROR   OUT    VARCHAR2
)
IS
BEGIN

 
	DELETE FROM 
        EBANKING.TA_CONTENIDOCAT
        WHERE IDCATALOGO = PA_ID_CATALOGO;
         		  		  
      PA_COD_ERROR := 0;
      PA_MSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PA_COD_ERROR:=1;
              PA_MSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');

END SP_DEL_CONTENIDO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_ELIGE_PARTICIPANTES(
PSCod_Error    OUT     NUMBER,
PSMsg_Error    OUT     VARCHAR2
)
IS
  SP_STATUS    INT := 9;
  SP_INICIO    INT := 0;
  SP_FIN       INT := 0;
  SP_CICLO_FIN INT := 0;
  SP_SORTEO    INT := 0;
BEGIN
  -------------------------TRUNCAR TABLA---------------------------   
  EXECUTE IMMEDIATE 'TRUNCATE TABLE FIAR_PARTICIPANTES_TEMP';    
  --------------------------LLENAR TABLA---------------------------   
  INSERT INTO FIAR_PARTICIPANTES_TEMP
  SELECT NULL, C.CTE_ALNOVA, C.MONTO_CREDITO, NULL, NULL
  FROM FIAR_CLIENTES C, FIAR_STATUS_CLIENTES S
  WHERE C.CTE_ALNOVA = S.CTE_ALNOVA
  AND S.STATUS = SP_STATUS
  AND C.CTE_ALNOVA NOT IN(SELECT ID_PARTICIPANTE 
                          FROM FIAR_PARTICIPE)
  ORDER BY dbms_random.VALUE;
  ----------------------INSERTAR VALOR DE ID_TEMP--------------------  
  execute immediate 'UPDATE FIAR_PARTICIPANTES_TEMP
                     SET ID_TEMP = ROWNUM';
  ------------------------ADQUIRIR ULTIMO VALOR----------------------  
  SELECT COUNT(ID_PARTICIPANTE) 
  INTO SP_CICLO_FIN
  FROM FIAR_PARTICIPANTES_TEMP;
  --------------------------LLENAR LOS RANGOS------------------------     
  FOR CICLO IN 1..SP_CICLO_FIN LOOP
    
    UPDATE FIAR_PARTICIPANTES_TEMP
                       SET RANGO_INICIAL = (SP_INICIO + 1)
                       WHERE ID_TEMP = CICLO;
    SELECT RANGO_INICIAL
    INTO SP_FIN
    FROM FIAR_PARTICIPANTES_TEMP
    WHERE ID_TEMP = CICLO;

    UPDATE FIAR_PARTICIPANTES_TEMP
                       SET RANGO_FINAL = SP_FIN + MONTO_CREDITO -1
                       WHERE ID_TEMP = CICLO;
    
    SELECT RANGO_FINAL
    INTO SP_INICIO
    FROM FIAR_PARTICIPANTES_TEMP
    WHERE ID_TEMP = CICLO;
  END LOOP;    
----------------------BUSCA EL NUMERO DE SORTEO------------------- 
  SELECT MAX(ID_SORTEO)
  INTO SP_SORTEO
  FROM FIAR_BOLETOS;
  
  SP_SORTEO := SP_SORTEO + 1;
-----------------------LLENAR LA TABLA BOLETOS--------------------    
  INSERT INTO FIAR_BOLETOS
    SELECT SP_SORTEO, ID_PARTICIPANTE, TO_CHAR(CURRENT_DATE, 'DD/MM/YYYY'), RANGO_INICIAL, RANGO_FINAL, TO_CHAR(CURRENT_DATE, 'DD/MM/YYYY'), 'tesoreria'
    FROM FIAR_PARTICIPANTES_TEMP
    ORDER BY ID_TEMP;
  -----------------------------EXCEPCIONES--------------------------     
  COMMIT;
END SP_ELIGE_PARTICIPANTES;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_FEC_ACTI_USR
(  P_ID         IN      EBANKING.EBANKING_USER.ID%TYPE,
   PSCod_Error  OUT     NUMBER,
   PSMsg_Error  OUT     VARCHAR2,
   P_RESPUESTA  OUT     DATE
)AS
   TMP_ACTIVO    DATE;
   
BEGIN
        SELECT 
          EU.ACTIVATION
        INTO TMP_ACTIVO
        FROM EBANKING.EBANKING_USER EU
        WHERE EU.ID=P_ID;
        
        PSCod_Error := 0;
        PSMsg_Error := 'EXITO';
        P_RESPUESTA := TMP_ACTIVO;
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar fecha de registro de usuario (' || SQLCODE || '  ' || SQLERRM || ')');
              

END SP_FEC_ACTI_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_GET_ACTIVE_USER (    
 V_ID_ALNOVA                IN     EBANKING.ebanking_user.id%TYPE
-- V_ACTIVE                    OUT    EBANKING.ebanking_user.active%TYPE
)
IS
ERROR NUMBER;      
BEGIN
    ERROR:=0;
    BEGIN
        SELECT ID INTO V_ID_ALNOVA
            FROM EBANKING.EBANKING_USER
            WHERE ID=01983689;
     
        END;
END SP_GET_ACTIVE_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_GET_BENEFICIARY_BY_DEXID(P_DEX_BENEFICIARY_ID IN NUMBER,
                                                           P_ALIAS OUT VARCHAR2,
                                                           P_NUMCEL OUT VARCHAR2,
                                                           PSCod_Error  OUT NUMBER,
                                                           PSMsg_Error  OUT VARCHAR2) IS
tmpVar NUMBER;
/******************************************************************************
   NAME:       SP_GET_BENEFICIARY_BY_DEXID
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        02/08/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_GET_BENEFICIARY_BY_DEXID
      Sysdate:         02/08/2013
      Date and Time:   02/08/2013, 06:50:13 p.m., and 02/08/2013 06:50:13 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN

    SELECT ALIAS_BENEFICIARIO, NUM_CELULAR
    INTO P_ALIAS, P_NUMCEL
    FROM ebanking.BENEFI_DEX
    WHERE ID_BENEFICIARIO_DEX = P_DEX_BENEFICIARY_ID;

    PSCod_Error := 0;
    PSMsg_Error := 'consulta a SP_GET_BENEFICIARY_BY_DEXID exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_BENEFICIARY_BY_DEXID';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_BENEFICIARY_BY_DEXID (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_BENEFICIARY_BY_DEXID;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_MTCNTRANS(P_ACCOUNT IN VARCHAR2,
                                                    P_MTCNTRANSACTIONS OUT SYS_REFCURSOR,
                                                    PSCod_Error  OUT number,
                                                    PSMsg_Error  OUT varchar2) IS
/******************************************************************************
   NAME:       SP_GET_MTCNTRANS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        23/04/2013                   1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_GET_MTCNTRANS
      Sysdate:         23/04/2013
      Date and Time:   23/04/2013, 10:54:25 a.m., and 23/04/2013 10:54:25 a.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN

OPEN P_MTCNTRANSACTIONS FOR SELECT TRANSFER_DEX.MTCN,
                                  PAIS_ID_DESTINO, 
                                  ESTADO_ID_DESTINO,
                                  CIUDAD_ID_DESTINO,
                                  IMPUESTO_DEX.monto,
                                  TARIFA
                             FROM EBANKING.IMPUESTO_DEX
                       INNER JOIN EBANKING.TRANSFER_DEX
                               ON TRANSFER_DEX.MTCN = IMPUESTO_DEX.MTCN
                            WHERE TRANSFER_DEX.MTCN = IMPUESTO_DEX.MTCN 
                              AND NUM_CUENTA = P_ACCOUNT 
                         ORDER BY TRANSFER_DEX.ULTIMA_MODIFICACION,
                        TO_NUMBER(TRANSFER_DEX.MTCN);

   PSCod_Error := 0;
   PSMsg_Error := 'consulta a SP_GET_MTCNTRANS exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_MTCNTRANS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_MTCNTRANS (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_MTCNTRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_NAME(
            IDALNOVA    IN EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE
            ,SALIDA OUT SYS_REFCURSOR
)
IS
BEGIN    
        OPEN SALIDA FOR SELECT NAME, ALIAS FROM EBANKING.EBANKING_ACTIVATION WHERE CLIENTE = IDALNOVA;
            
        EXCEPTION  
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR (-20100, 'No se encontraron datos  (' || SQLCODE || '  ' || SQLERRM || ')');
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR (-20000, 'Error al obtener IDALNOVA(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_NAME;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_PAGOSMICRONEGOCIO(
                                                    PA_CURSOR OUT SYS_REFCURSOR) IS
BEGIN

    OPEN PA_CURSOR FOR SELECT * FROM EBANKING.TAPAGOMICRONEG 
        WHERE TO_CHAR(FDFECHA_PAGO, 'yyyy-mm-dd') = TO_CHAR(SYSDATE-1, 'yyyy-mm-dd');

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_GET_PROGRAMMED_TRANSFERS(P_EMP_NUM               IN  NUMBER,
                                                        P_DB_KEY                IN  VARCHAR2,
                                                        P_FLAG                  IN  NUMBER,
                                                        P_BEGINNING_DATE        IN  VARCHAR2,
                                                        P_ENDING_DATE           IN  VARCHAR2,
                                                        P_PROGRAMMED_TRANSFERS  OUT SYS_REFCURSOR,
                                                        PSCod_Error             OUT number,
                                                        PSMsg_Error             OUT varchar2) IS
/******************************************************************************
   NAME:       SP_GET_PROGRAMMED_TRANSFERS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        10/04/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_GET_PROGRAMMED_TRANSFERS
      Sysdate:         10/04/2013
      Date and Time:   10/04/2013, 11:48:14 a.m., and 10/04/2013 11:48:14 a.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
OPEN P_PROGRAMMED_TRANSFERS FOR
    select SCHEDULED_PAYMENT_ID, 
           APPLY_DATE, 
           PROGRAM_DATE, 
           STATUS, 
           FOLIO_PROGRAMADO, 
           EBANKING.DESCRYPTREQUEST (REQUEST, P_DB_KEY, P_FLAG) as REQUEST, 
           EBANKING.DESCRYPTREQUEST (RESPONSE, P_DB_KEY, P_FLAG) as RESPONSE
    from SCHEDULED_PAYMENT 
    where USER_ID = P_EMP_NUM
        and TX_NAME='SPEI' 
        and (
                (PROGRAM_DATE >= TO_DATE(P_BEGINNING_DATE,'DD-MM-YYYY') and PROGRAM_DATE <= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY')) 
                or (APPLY_DATE >= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY'))
            )
    order by PROGRAM_DATE DESC;
    
   PSCod_Error := 0;
   PSMsg_Error := 'consulta a SP_GET_PROGRAMMED_TRANSFERS exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_PROGRAMMED_TRANSFERS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_PROGRAMMED_TRANSFERS (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_PROGRAMMED_TRANSFERS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_PROG_TRANS(P_EMP_NUM               IN  NUMBER,
                                                        P_DB_KEY                IN  VARCHAR2,
                                                        P_FLAG                  IN  NUMBER,
                                                        P_BEGINNING_DATE        IN  VARCHAR2,
                                                        P_ENDING_DATE           IN  VARCHAR2,
														TYPE_OPER				IN	VARCHAR2,
                                                        P_PROGRAMMED_TRANSFERS  OUT SYS_REFCURSOR,
                                                        PSCod_Error             OUT number,
                                                        PSMsg_Error             OUT varchar2) IS
BEGIN
OPEN P_PROGRAMMED_TRANSFERS FOR
    select SCHEDULED_PAYMENT_ID, 
           APPLY_DATE, 
           PROGRAM_DATE, 
           STATUS, 
           FOLIO_PROGRAMADO, 
           EBANKING.DESCRYPTREQUEST (REQUEST, P_DB_KEY, P_FLAG) as REQUEST, 
           EBANKING.DESCRYPTREQUEST (RESPONSE, P_DB_KEY, P_FLAG) as RESPONSE
    from EBANKING.SCHEDULED_PAYMENT 
    where USER_ID = P_EMP_NUM
        and TX_NAME=TYPE_OPER 
        and (
                (PROGRAM_DATE >= TO_DATE(P_BEGINNING_DATE,'DD-MM-YYYY') and PROGRAM_DATE <= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY')) 
                or (APPLY_DATE >= TO_DATE(P_ENDING_DATE,'DD-MM-YYYY'))
            )
    order by PROGRAM_DATE DESC;
    
   PSCod_Error := 0;
   PSMsg_Error := 'consulta a SP_GET_PROG_TRANS exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_PROG_TRANS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_PROG_TRANS (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_PROG_TRANS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_REF_PAGOSMICRONEGOCIO(
                                                    PA_REF OUT NUMBER) IS
BEGIN

    SELECT SEQ_MICROBUSINESS_PAYMENT.NextVal INTO PA_REF FROM DUAL;

END;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_GET_REMITTANCES_BY_CUSTOMER(P_DEX_CUSTOMER_ID IN NUMBER,
                                                           P_REMITTANCES OUT SYS_REFCURSOR,
                                                           PSCod_Error  OUT NUMBER,
                                                           PSMsg_Error  OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SP_GET_REMITTANCES_BY_CUSTOMER
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        01/08/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_GET_REMITTANCES_BY_CUSTOMER
      Sysdate:         01/08/2013
      Date and Time:   01/08/2013, 07:19:19 p.m., and 01/08/2013 07:19:19 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
   
    OPEN P_REMITTANCES FOR
    SELECT TRANSFER_DEX.CLIENTE_ID, 
           TRANSFER_DEX.MTCN,
           PAIS_ID_DESTINO,
           ESTADO_ID_DESTINO,
           CIUDAD_ID_DESTINO,
           IMPUESTO_DEX.MONTO,
           FECHA_ENVIO,
           TARIFA
    FROM ebanking.TRANSFER_DEX
    JOIN ebanking.IMPUESTO_DEX 
        ON TRANSFER_DEX.MTCN=IMPUESTO_DEX.MTCN
    WHERE
        TRANSFER_DEX.CLIENTE_ID = P_DEX_CUSTOMER_ID
    ORDER BY TRANSFER_DEX.ULTIMA_MODIFICACION,
             TO_NUMBER(TRANSFER_DEX.MTCN);

    PSCod_Error := 0;
    PSMsg_Error := 'consulta a SP_GET_REMITTANCES_BY_CUSTOMER exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_REMITTANCES_BY_CUSTOMER';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_REMITTANCES_BY_CUSTOMER (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_REMITTANCES_BY_CUSTOMER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_SAMEBANK_TRANSFERS(P_CUENTA     IN  VARCHAR2,
                                                               P_NUM_EMP    IN  VARCHAR2,
                                                               P_FEC_INI    IN  VARCHAR2,
                                                               P_FEC_FIN    IN  VARCHAR2,
                                                               PSCod_Error  OUT number,
                                                               PSMsg_Error  OUT varchar2,
                                                               BACKGROUND   OUT SYS_REFCURSOR) IS
/******************************************************************************
   NAME:       SP_GET_SAMEBANK_TRANSFERS
   PURPOSE:    GETTING SAME BANK TRANSFER BACKGROUND FOR THE ESPECIFIED ARGUMENTS (TRANSFERS MODULE, ENQUIRIES AND RECORDS)

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        03/04/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_GET_SAMEBANK_TRANSFERS
      Sysdate:         03/04/2013
      Date and Time:   03/04/2013, 01:25:38 p.m., and 03/04/2013 01:25:38 p.m.
      Username:         HB
      Table Name:       (set in the "New PL/SQL Object" dialog)
 
    Modification by Juan Antonio Ortiz Guillén
    Description: Se agrega monto en el cursor y se suma un dia a la fecha fin 
    de busqueda. 
     
******************************************************************************/
BEGIN
   
    OPEN BACKGROUND FOR  SELECT cuentaorigen, 
                                cuentadestino, 
                                nombredestino, 
                                textoorigen,
                                textodestino, 
                                fecharetencion, 
                                idstatus_transaccion,
                                monto
                         FROM puntorojo.mon_transaccion
                         WHERE cuentaorigen = P_CUENTA
                              AND idebanking = to_number(P_NUM_EMP)
                              AND fecharetencion BETWEEN TO_DATE (P_FEC_INI, 'DD/MM/YYYY') AND TO_DATE (P_FEC_FIN, 'DD/MM/YYYY') + 1
                         ORDER BY fecharetencion DESC;
                    
    PSCod_Error := 0;
    PSMsg_Error := 'consulta a SP_GET_SAMEBANK_TRANSFERS exitosa';

   EXCEPTION
     WHEN OTHERS THEN
       PSCod_Error := 1;
       PSMsg_Error := 'Error al consultar SP_GET_SAMEBANK_TRANSFERS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_SAMEBANK_TRANSFERS (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_SAMEBANK_TRANSFERS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_GET_TERMINAL(
V_USER_IN                      IN     EBANKING.USERTERMINAL.USUARIO%TYPE, 
CONT                           OUT    NUMBER, 
CURSOR_TERMINAL                OUT    SYS_REFCURSOR
)
IS


BEGIN

    SELECT COUNT(A.USUARIO) INTO CONT FROM EBANKING.USERTERMINAL A  WHERE USUARIO = V_USER_IN;
    
    OPEN CURSOR_TERMINAL FOR        
    SELECT A.USUARIO, A.TERMINAL,A.PROD, A.SPROD, A.ENTITY, A.BRANCH, A.CHANNEL
    FROM EBANKING.USERTERMINAL A
    WHERE A.USUARIO = V_USER_IN; 
    EXCEPTION
     WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar SP_GET_TERMINAL (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_GET_TERMINAL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_IDVALIDATION(
     IDALNOVA   IN EBANKING.EBANKING_USER.ID%TYPE
     ,SALIDA OUT Types.REFCURSOR
)AS

BEGIN
   OPEN SALIDA FOR SELECT COUNT(ID) FROM EBANKING.EBANKING_USER WHERE ID = IDALNOVA;
    
   EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR (-20100, 'No se encontraron datos  (' || SQLCODE || '  ' || SQLERRM || ')');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20000, 'Error al obtener IDALNOVA(' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_IDVALIDATION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERTEBUSER(
        IDALNOVA        EBANKING.EBANKING_USER.ID%TYPE,
        MAIL            EBANKING.EBANKING_USER.EMAIL%TYPE
)IS

BEGIN
   INSERT INTO EBANKING.EBANKING_USER (ID,ACTIVE,ACTIVATION,EMAIL, TRACKING) 
   VALUES(IDALNOVA,'0',SYSDATE,MAIL, 1);
   
                        
   COMMIT;
    
   EXCEPTION
     WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar nuevo usuario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
     ROLLBACK;
     RAISE;
END SP_INSERTEBUSER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_INSERTPREACT(
        IDALNOVA        EBANKING.PREACTIVE_USER.ID_ALNOVA%TYPE,
        ACCOUNTNUMBER   EBANKING.PREACTIVE_USER.ACCOUNT_NUMBER%TYPE,
        STATUS          EBANKING.PREACTIVE_USER.STATUS%TYPE,
        MAIL            EBANKING.PREACTIVE_USER.MAIL%TYPE,
        ALIAS           EBANKING.PREACTIVE_USER.ALIAS%TYPE,
  SUC            EBANKING.PREACTIVE_USER.SUCURSAL%TYPE,
        USR_MODIFICO    EBANKING.PREACTIVE_USER.USUARIO_MODIFICO%TYPE,
        NUMEMPLEADO            EBANKING.PREACTIVE_USER.NUM_EMPLEADO%TYPE
        
)IS

BEGIN
   INSERT INTO EBANKING.PREACTIVE_USER(ID_ALNOVA,ACCOUNT_NUMBER,STATUS,MAIL,ALIAS,SUCURSAL,ULTIMA_MODIFICACION,USUARIO_MODIFICO,NUM_EMPLEADO) 
   VALUES(IDALNOVA,ACCOUNTNUMBER,STATUS,MAIL,ALIAS,SUC,SYSDATE,USR_MODIFICO,NUMEMPLEADO);
   COMMIT;
    
   EXCEPTION
     WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar nuevo usuario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
     ROLLBACK;
     RAISE;
END SP_INSERTPREACT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERTUSERAC(
        ALIAS           EBANKING.EBANKING_ACTIVATION.ALIAS%TYPE,
        IDALNOVA        EBANKING.EBANKING_ACTIVATION.CLIENTE%TYPE,
        MAIL            EBANKING.EBANKING_ACTIVATION.EMAIL%TYPE,
        ACCOUNTNUMBER   EBANKING.EBANKING_ACTIVATION.CUENTA%TYPE,
        NAME            EBANKING.EBANKING_ACTIVATION.NAME%TYPE,
        IP              EBANKING.EBANKING_ACTIVATION.IP%TYPE,
        CODE            EBANKING.EBANKING_ACTIVATION.CODE%TYPE
)IS

BEGIN
   INSERT INTO EBANKING.EBANKING_ACTIVATION(ALIAS,CLIENTE,EMAIL,CUENTA,NAME,STATUS,IP,CODE,CUENTAOTARJ) 
   VALUES(ALIAS,IDALNOVA,MAIL,ACCOUNTNUMBER,NAME,'0',IP,CODE,ACCOUNTNUMBER);
   COMMIT;
    
   EXCEPTION
     WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar nuevo usuario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
     ROLLBACK;
     RAISE;
END SP_INSERTUSERAC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERT_BENEFICIARIOS(P_CU                       IN  VARCHAR2,
                                                              P_ALIAS               IN  VARCHAR2,
                                                              P_PAIS                 IN  VARCHAR2,
                                                              P_CIUDAD                IN  VARCHAR2,
                                                              P_ESTADO              IN  VARCHAR2,
                                                              P_NOMBRE                 IN  VARCHAR2,
                                                              P_AP_PATERNO          IN  VARCHAR2,
                                                              P_AP_MATERNO            IN  VARCHAR2,
                                                              PSCod_Error          OUT NUMBER,
                                                              PSMsg_Error          OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SP_SP_INSERT_BENEFICIARIOS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        14/05/2014          1. Inserta registros sobre BENEFICIARIOS_WU

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_INSERT_BENEFICIARIOS


******************************************************************************/
BEGIN
    INSERT INTO BENEFICIARIOS_WU B (B.CU,
                                    B.ALIAS,
                                    B.ID_BENEFICIARIO_WU,
                                    B.PAIS,
                                    B.CIUDAD,
                                      B.ESTADO,
                                    B.NOMBRE,
                                    B.AP_PATERNO,
                                    B.AP_MATERNO,
                                    B.ESTATUS,
                                    B.FECHA_ACTIVACION,
                                    B.ULTIMA_MODIFICACION,
                                    B.USUARIO_MODIFICO) 
       VALUES(P_CU,
              P_ALIAS,
              EBANKING.SEQUENCE_WU_ID_BENEF.NEXTVAL,
              P_PAIS,
              P_CIUDAD,
              P_ESTADO,
              P_NOMBRE,
              P_AP_PATERNO,
              P_AP_MATERNO,
              0,
              SYSDATE,
              SYSDATE,
              'NETNET');
    
   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de SP_INSERT_BENEFICIARIOS exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_INSERT_BENEFICIARIOS';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_INSERT_BENEFICIARIOS(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_INSERT_BENEFICIARIOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERT_BENF(P_CU                       IN  VARCHAR2,
                                                              P_ALIAS               IN  VARCHAR2,
                                                              P_PAIS                 IN  VARCHAR2,
                                                              P_CIUDAD                IN  VARCHAR2,
                                                              P_ESTADO              IN  VARCHAR2,
                                                              P_NOMBRE                 IN  VARCHAR2,
                                                              P_AP_PATERNO          IN  VARCHAR2,
                                                              P_AP_MATERNO            IN  VARCHAR2,
                                                              PSCod_Error          OUT NUMBER,
                                                              PSMsg_Error          OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SP_INSERT_BENF
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        14/05/2014          1. Inserta registros sobre SP_INSERT_BENF

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_INSERT_BENF


******************************************************************************/
BEGIN
    INSERT INTO BENEFICIARIOWU B (B.CU,
                                    B.ALIAS,
                                    B.ID_BENEFICIARIO_WU,
                                    B.PAIS,
                                    B.CIUDAD,
                                      B.ESTADO,
                                    B.NOMBRE,
                                    B.AP_PATERNO,
                                    B.AP_MATERNO,
                                    B.ESTATUS,
                                    B.FECHA_ACTIVACION,
                                    B.ULTIMA_MODIFICACION,
                                    B.USUARIO_MODIFICO) 
       VALUES(P_CU,
              P_ALIAS,
              EBANKING.SEQ_WU_IDBENEF.NEXTVAL,
              P_PAIS,
              P_CIUDAD,
              P_ESTADO,
              P_NOMBRE,
              P_AP_PATERNO,
              P_AP_MATERNO,
              0,
              SYSDATE,
              SYSDATE,
              'NETNET');
    
   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de SP_INSERT_BENF exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_INSERT_BENF';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_INSERT_BENF(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_INSERT_BENF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERT_BITACORA(P_NUM_CLIENTE		 IN	 NUMBER,
														P_ID_CAT_OPERACION   IN  NUMBER,
                                                        P_IP                 IN  VARCHAR2,
                                                        P_CTA_ORIGEN         IN  VARCHAR2,
                                                        P_CTA_DESTINO        IN  VARCHAR2,
                                                        P_MONTO              IN  NUMBER,
                                                        P_FOLIO              IN  VARCHAR2,
                                                        P_METODO_CONFIR      IN  NUMBER,
                                                        P_DETALLE            IN  VARCHAR2,
                                                        P_DETALLE2           IN  VARCHAR2,
                                                        P_NOMBRE_CLIENTE     IN  VARCHAR2,
                                                        PSCod_Error          OUT NUMBER,
                                                        PSMsg_Error          OUT VARCHAR2) IS
/******************************************************************************
   NAME:       SP_INSERT_BITACORA
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        22/05/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_INSERT_BITACORA
      Sysdate:         22/05/2013
      Date and Time:   22/05/2013, 01:36:11 p.m., and 22/05/2013 01:36:11 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
    INSERT INTO EBANKING_BITACORA_TRAN B (B.ID,
		    						      B.NUM_CLIENTE,
                                          B.ID_CAT_OPERACION,
                                          B.IP,
                                          B.CTA_ORIGEN,
      				                      B.CTA_DESTINO,
                                          B.MONTO,
                                          B.FOLIO,
                                          B.METODO_CONFIR,
                                          B.DETALLE,
                                          B.DETALLE2,
                                          B.NOMBRE_CLIENTE) 
	    VALUES(EBANKING.SEQ_BITACORA_ID.NEXTVAL,
			   P_NUM_CLIENTE,
               P_ID_CAT_OPERACION,
               P_IP,
               P_CTA_ORIGEN,
               P_CTA_DESTINO,
               P_MONTO,
               P_FOLIO,
               P_METODO_CONFIR,
               P_DETALLE,
               P_DETALLE2,
               P_NOMBRE_CLIENTE);
    
   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de SP_INSERT_BITACORA exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_INSERT_BITACORA';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_INSERT_BITACORA(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_INSERT_BITACORA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERT_HIST
(  
   P_USERID       IN    EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
   P_MAXATTEMP    IN    EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE
)
                                  
IS
BEGIN
 -- Inserta en Historico de Intentos del usuario
      INSERT INTO EBANKING.EBANKING_LOGIN(
      USER_ID, 
      ATTEMPTS, 
      LOGIN_DATE 
      ) 
      VALUES( 
      P_USERID, P_MAXATTEMP, SYSDATE );
      COMMIT;
      
EXCEPTION

    WHEN NO_DATA_FOUND THEN
     ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');

    WHEN OTHERS THEN
    ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END SP_INSERT_HIST;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSERT_TARJV_BITACORA(P_NUM_CLIENTE        IN  NUMBER,
                                                              P_TARJETA            IN  VARCHAR2,
                                                              P_OPERACION          IN  VARCHAR2,
                                                              P_USR_MODIF          IN  VARCHAR2,
                                                              PSCod_Error          OUT NUMBER,
                                                              PSMsg_Error          OUT VARCHAR2) IS

BEGIN
    INSERT INTO EBANKING_TARJV_BITACORA B (B.ID,
                                          B.NUM_CLIENTE,
                                          B.TARJETA,
                                          B.OPERACION,
                                          B.FECHA_OPER,
                                          B.USUARIO_MODIF) 
        VALUES(EBANKING.SEQ_TARJV_BITACORA_ID.NEXTVAL,
               P_NUM_CLIENTE,
               P_TARJETA,
               P_OPERACION,
               SYSDATE,
               P_USR_MODIF);
    
   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de SP_INSERT_TARJV_BITACORA exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar SP_INSERT_TARJV_BITACORA';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar SP_INSERT_TARJV_BITACORA(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_INSERT_TARJV_BITACORA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INSTIEME_USR
(
    P_CTE_ALNOVA             IN EBANKING.EBANKING_LOGIN_TIMES.CTE_ALNOVA%TYPE
   ,P_STATUS                 IN EBANKING.EBANKING_LOGIN_TIMES.STATUS%TYPE
   ,P_INSTANCIA              IN EBANKING.EBANKING_LOGIN_TIMES.INSTANCIA%TYPE
   ,P_USUARIO_MODIFICO       IN EBANKING.EBANKING_LOGIN_TIMES.USUARIO_MODIFICO%TYPE
   ,PASCOD_ERROR            OUT NUMBER
   ,PASMSG_ERROR            OUT VARCHAR2
)
IS
VL_GRABADO INTEGER :=0;
BEGIN
    BEGIN

            INSERT INTO EBANKING.EBANKING_LOGIN_TIMES 
                (
                CTE_ALNOVA, 
                FECHA, STATUS, 
                INSTANCIA, 
                ULTIMA_MODIFICACION, 
                USUARIO_MODIFICO
                ) 
            VALUES 
                (P_CTE_ALNOVA, 
                 SYSDATE, 
                 P_STATUS, 
                 P_INSTANCIA, 
                 SYSDATE,
                 P_USUARIO_MODIFICO
                );
                PASCOD_ERROR := 0;
                PASMSG_ERROR := 'EXITOSO';
                COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                  PASCOD_ERROR:=1;
                  PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                  ROLLBACK;
                  RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;

END SP_INSTIEME_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INS_MAXATT
(  
   P_USERID       IN    EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
   P_ALIAS        IN    VARCHAR2,
   P_IP           IN    VARCHAR2,
   P_VALIDACION   IN    INT
)
                                  
IS
BEGIN
  -- INSERTA EN HISTORICO EL MAX ATTEMPT
   INSERT INTO EBANKING.EBANKING_LOGIN_HIST( 
   ID, 
   USER_ID, 
   LOGIN_DATE, 
   ALIAS, 
   ATTEMPT, 
   IP,
   VALIDACION
   ) 
    SELECT 
            EBANKING.ID_LOGIN_HISTORY_SEQ.NEXTVAL,
            USER_ID,
            LOGIN_DATE,
            P_ALIAS,
            ATTEMPTS,
            P_IP,
            P_VALIDACION 
    FROM EBANKING.EBANKING_LOGIN WHERE USER_ID=P_USERID;
    
  COMMIT;
      
EXCEPTION

    WHEN NO_DATA_FOUND THEN
     ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');

    WHEN OTHERS THEN
    ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END SP_INS_MAXATT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_INTERVALOS (
    
    PRIMERO IN NUMBER
    ,SEGUNDO IN NUMBER
    ,TERCERO IN NUMBER
    ,BLOQUEO IN NUMBER
    ,FECHAPIVOTE IN VARCHAR2
    ,PASMSG_ERROR OUT VARCHAR2
    ,CONSULTA OUT SYS_REFCURSOR
) 
IS

CORREO EBANKING.EBANKING_USER.EMAIL%TYPE;
MES NUMBER;
IDEN VARCHAR2(8 BYTE);

BEGIN
    BEGIN
        OPEN CONSULTA FOR
            SELECT EMAIL,TRUNC(MONTHS_BETWEEN(SYSDATE,ULT_ACCESO))MES,TO_CHAR(ID) INTO CORREO, MES, IDEN 
            FROM EBANKING.EBANKING_USER 
            WHERE TO_CHAR(ULT_ACCESO,'dd/mm/yyyy')>=FECHAPIVOTE AND EMAIL IS NOT NULL 
            AND ((MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=PRIMERO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<PRIMERO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=SEGUNDO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<SEGUNDO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=TERCERO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<TERCERO+1)
            OR (MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)>=BLOQUEO 
            AND MONTHS_BETWEEN(SYSDATE,ULT_ACCESO)<BLOQUEO+1));  
      LOOP
         FETCH CONSULTA INTO CORREO, MES, IDEN;   
         IF (MES = 11) THEN
            INSERT INTO EBANKING.BLOQUEOINAC_H VALUES(EBANKING.SEQ_BLOQ_INAC.NEXTVAL,IDEN,SYSDATE,'BLOQUEADO',SYSDATE,'NETNET','PORTAL','MEX');
         END IF;
      END LOOP;     
      
      COMMIT;
      PASMSG_ERROR := 'EXITOSO';
            
   EXCEPTION
   WHEN OTHERS THEN
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
             
      
     END;
END SP_INTERVALOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_LOLO(
PSCod_Error    OUT     NUMBER,
PSMsg_Error    OUT     VARCHAR2
)
IS
BEGIN
FOR CICLO IN 1..3 LOOP
  select * from LOLO
  where id_lolo = CICLO;
  END LOOP;  
END SP_LOLO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_NOMBRESBLOCK (
        LISTA           IN      IDCORREOS
        ,PASMSG_ERROR   OUT     VARCHAR2
        ,NOMBRES        OUT     TYPENOMBRES
)

IS
NOM     VARCHAR2(50 BYTE);
IDEN    VARCHAR2(8 BYTE);
AUX TYPENOMBRES:=TYPENOMBRES();
VALIDA SYS_REFCURSOR;
BEGIN
     FOR i IN 1 .. LISTA.COUNT
       LOOP 
            IDEN:=NULL;
            NOM:=null;
            OPEN VALIDA FOR SELECT CLIENTE, NAME INTO IDEN, NOM FROM EBANKING.EBANKING_ACTIVATION WHERE CLIENTE=LISTA(i);
            
            FETCH VALIDA INTO IDEN, NOM;
            IF VALIDA IS NULL THEN
                NULL;
            END IF;  
            
                AUX.EXTEND;
                AUX(i) := IDEN || ';' || NOM;
            
            
        END LOOP;
        NOMBRES:=AUX;
        PASMSG_ERROR := 'EXITOSO';    
 
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       RAISE;
END SP_NOMBRESBLOCK;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_NUM_INTENTOS
(
        P_USER_ID    IN    EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
        PSCod_Error  OUT     NUMBER,
        PSMsg_Error  OUT     VARCHAR2,
        P_RESPUESTA  OUT     VARCHAR2
         
)
AS
    TMP_ACTIVO  INT; 
BEGIN
        SELECT 
          EL.ATTEMPTS INTO TMP_ACTIVO
        FROM EBANKING.EBANKING_LOGIN EL
        WHERE EL.USER_ID=P_USER_ID;
        
        PSCod_Error := 0;
        PSMsg_Error := 'EXITO';
        P_RESPUESTA := TMP_ACTIVO;
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar numero de intentos (' || SQLCODE || '  ' || SQLERRM || ')');
              
   
END SP_NUM_INTENTOS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_PREACTIVATION(
       IDALNOVA        EBANKING.PREACTIVE_USER.ID_ALNOVA%TYPE,
        ACCOUNTNUMBER   EBANKING.PREACTIVE_USER.ACCOUNT_NUMBER%TYPE,
        STATUS          EBANKING.PREACTIVE_USER.STATUS%TYPE,
        MAIL            EBANKING.PREACTIVE_USER.MAIL%TYPE,
        ALIAS           EBANKING.PREACTIVE_USER.ALIAS%TYPE,
		SUC            EBANKING.PREACTIVE_USER.SUCURSAL%TYPE,
        USR_MODIFICO    EBANKING.PREACTIVE_USER.USUARIO_MODIFICO%TYPE,
        NUMEMPLEADO            EBANKING.PREACTIVE_USER.NUM_EMPLEADO%TYPE,
        CODIGO          EBANKING.EBANKING_ACTIVATION.CODE%TYPE,
        IP              EBANKING.EBANKING_ACTIVATION.IP%TYPE,
        TARJETAASOCIADA EBANKING.EBANKING_ACTIVATION.TARJETA%TYPE,
        ANSWER          EBANKING.EBANKING_USER.ANSWER%TYPE,
		QUESTION		EBANKING.EBANKING_USER.QUESTION%TYPE,
		FULLNAME		EBANKING.EBANKING_ACTIVATION.NAME%TYPE,
    SECUREDATAT		EBANKING.EBANKING_USER.SECUREDATA%TYPE
)IS

	STATUS_RES NUMBER := -9;
	ID_RES NUMBER := 0;
	NUM_TOKEN_SOLICITUD NUMBER := 0;
	NUM_TOKEN_ACTIVO NUMBER := 0;
	NUM_TOKEN_CLIENTE NUMBER :=0;
	NUM_TOKEN_SOLICITUD_CERO NUMBER := 0;
	NUM_SUM_RESULT1 NUMBER := 0;
	NUM_SUM_RESULT2 NUMBER := 0;
	VERIF_ALTA_SUC NUMBER := 0;

BEGIN
  --Inserta registro en tabla PREACTIVE_USER
  INSERT INTO EBANKING.PREACTIVE_USER(ID_ALNOVA,ACCOUNT_NUMBER,STATUS,MAIL,ALIAS,SUCURSAL,ULTIMA_MODIFICACION,USUARIO_MODIFICO,NUM_EMPLEADO) 
  VALUES(IDALNOVA,ACCOUNTNUMBER,STATUS,MAIL,ALIAS,SUC,SYSDATE,USR_MODIFICO,NUMEMPLEADO);
  
  --Busca status del usuario en EBANKING_ACTIVATION
  BEGIN 
  SELECT STATUS INTO STATUS_RES FROM EBANKING.EBANKING_ACTIVATION WHERE CLIENTE = IDALNOVA;
    EXCEPTION
	     WHEN NO_DATA_FOUND then
       DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
  END; 
  
  --Si no encuentra el status del usuario, lo registra, pero si lo encuentra se termina aqui el procedimiento ya que no es usr nuevo
  IF (STATUS_RES = -9)
    THEN
		INSERT INTO EBANKING.EBANKING_ACTIVATION(ALIAS,CLIENTE,EMAIL,CUENTAOTARJ,STATUS,CUENTA,CODE, ip, tarjeta,name) VALUES(ALIAS,IDALNOVA,MAIL,ACCOUNTNUMBER,-1,ACCOUNTNUMBER,CODIGO,IP,TARJETAASOCIADA,FULLNAME);
    ELSE
      ROLLBACK;
      RAISE_APPLICATION_ERROR (-20100, 'Se ha encontrado un registro en la tabla ebanking_activation para el usuario ( Alias: '|| ALIAS ||' IDAlnova: '|| IDALNOVA ||' Status: '|| status_res ||' )');
  END IF;
  
  --Busca al usuario en EBANKING_USER y se trae su ID
  BEGIN 
  SELECT ID INTO ID_RES FROM EBANKING.EBANKING_USER WHERE ID = IDALNOVA;
    EXCEPTION
	     WHEN NO_DATA_FOUND then
       DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
  END;
  
  --Si no encuentra registro del usuario, hace la insercion del mismo, si encuentra, manda error y termina procedimiento.
  IF (ID_RES = 0) 
    THEN
  		insert into EBANKING.EBANKING_USER (id,activation,active,email,advancedservice,pwd_status,old_advancedservice,answer,question,tracking,securedata) VALUES(IDALNOVA,SYSDATE,1,MAIL,-1,7,-1,ANSWER,QUESTION,2,SECUREDATAT);
    ELSE
      ROLLBACK;
      RAISE_APPLICATION_ERROR (-20100, 'Se ha encontrado un registro en la tabla ebanking_user para el usuario ( IDAlnova: '|| IDALNOVA ||' )');
  END IF;
  
  --Actualizacion status ebanking_activation
  UPDATE EBANKING.EBANKING_ACTIVATION SET STATUS = 0 WHERE CLIENTE = IDALNOVA; 

  --Adecuacion internet, busca que no tenga solicitudes pendientes y tenga tokens activos
  BEGIN
  SELECT COUNT(1) INTO NUM_TOKEN_SOLICITUD FROM EBANKING.EBANKING_TOKEN_SOLICITUD WHERE NUM_CTE = IDALNOVA AND SKU1 = '251683' AND (ESTATUS_SOL = 1 OR ESTATUS_SOL = 0);
    EXCEPTION
	     WHEN NO_DATA_FOUND then
       DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
  END;
  
  BEGIN
  SELECT COUNT(1) INTO NUM_TOKEN_ACTIVO FROM EBANKING.EBANKING_TOKEN_STATUS WHERE NUM_CLIENTE = IDALNOVA AND STATUS = 1;
    EXCEPTION
	     WHEN NO_DATA_FOUND then
       DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
  END;
  
  IF((NUM_TOKEN_SOLICITUD < 0) OR (NUM_TOKEN_ACTIVO > 0)) THEN
    BEGIN
    SELECT count(1) INTO NUM_TOKEN_CLIENTE FROM EBANKING.EBANKING_TOKEN_STATUS WHERE NUM_CLIENTE = IDALNOVA;
        EXCEPTION
          WHEN NO_DATA_FOUND then
          DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
    END;
    
    --busca solicitudes con estado cero
    BEGIN
    SELECT count(1) INTO NUM_TOKEN_SOLICITUD_CERO FROM EBANKING.EBANKING_TOKEN_SOLICITUD WHERE NUM_CTE = IDALNOVA AND SKU1 = '251683' AND ESTATUS_SOL = 0;
      EXCEPTION
          WHEN NO_DATA_FOUND then
          DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
    END;
    
    NUM_SUM_RESULT1 := NUM_TOKEN_SOLICITUD_CERO + NUM_TOKEN_CLIENTE;
    
    --Verifica que en EBANKING_USER tenga al menos un token y un servicio avanzado.
    BEGIN
    SELECT count(1) INTO VERIF_ALTA_SUC FROM EBANKING.EBANKING_USER WHERE id = IDALNOVA AND token > 0 AND advancedService > 0;
      EXCEPTION
          WHEN NO_DATA_FOUND then
          DBMS_OUTPUT.PUT_LINE('Caught raised exception NO_DATA_FOUND');
    END;
    
    NUM_SUM_RESULT2 := VERIF_ALTA_SUC + NUM_TOKEN_SOLICITUD_CERO;
    
    IF((NUM_SUM_RESULT1=0) AND (NUM_SUM_RESULT2=1)) THEN
      UPDATE EBANKING.eBanking_user SET TOKEN = 1, advancedService= 1 WHERE ID = IDALNOVA;
    END IF;
  END IF;
  
  COMMIT;
  EXCEPTION
     WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar nuevo usuario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
     ROLLBACK;
     RAISE;
END SP_PREACTIVATION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_PREACT_USER(OPCION IN NUMBER, INFORME OUT SYS_REFCURSOR)
IS
PREACTIVO       NUMBER  :=  1;
REG_USUARIO     NUMBER  :=  2;
PSCod_Error     NUMBER;
PSMsg_Error     VARCHAR2(1000);

BEGIN

  IF OPCION = PREACTIVO THEN
    
    OPEN INFORME FOR
    SELECT ID_ALNOVA, ACCOUNT_NUMBER, STATUS, MAIL, ALIAS,ULTIMA_MODIFICACION 
    FROM EBANKING.PREACTIVE_USER
    ORDER BY ID_ALNOVA;
  
  END IF;
  
  IF OPCION = REG_USUARIO THEN
    
    OPEN INFORME FOR
    SELECT ID, ACTIVATION, ACTIVE, ANSWER, CELLULAR, EMAIL, QUESTION, USER2CELLCOMPANY, 
           ADVANCEDSERVICE, SECUREDATA, ACTIVATIONTYPE, SECURITY_LEVEL, STATUSNS, 
           CODIGONS, CONFIRMNS, STATUS_CONT_TRAN, MAIL_RECEIVE, TRACKING, 
           PWD_CONFIRM, PWD_BANCA_TEL, PWD_CHANGE_DATE, PWD_STATUS, 
           PWD_CONFIRM_CHANGE_DATE, BIOMETRICO, TELEFONO_OFICINA, OLD_ADVANCEDSERVICE, 
           ULT_ACCESO, FECHA_CAMBIO_STATUS_BAJA, STATUS_BAJA, TOKEN
    FROM EBANKING.EBANKING_USER
    ORDER BY ID ASC;
      
  END IF;
  PSCod_Error := 0;
  PSMsg_Error := 'consulta SP_PREACT_USER correctamente';

  EXCEPTION 
    WHEN OTHERS THEN
      PSCod_Error:=1;
      PSMsg_Error:='Error al consultar (' || SQLCODE || '  ' || SQLERRM || ')';
      RAISE_APPLICATION_ERROR(-20100, PSMsg_Error);
      
END SP_PREACT_USER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE       SP_REGISTRARCLI
(
  V_NUMFOLIO      IN        EBANKING.ta_cliente.idcliente%TYPE
  ,V_PASSWD       IN        EBANKING.ta_cliente.passwd%TYPE
  ,V_CORREO       IN        EBANKING.ta_cliente.email%TYPE
  ,V_USR_MOD      IN        EBANKING.ta_cliente.usuario_modifico%TYPE
  ,V_FECHA_MOD    IN        EBANKING.ta_cliente.fecha_modifico%TYPE
  ,V_PREGSEC      IN        EBANKING.ta_cliente.preguntasecret%TYPE
  ,V_RESPUESTA    IN        EBANKING.ta_cliente.respuesta%TYPE
  ,V_REGISTRADO   OUT       NUMBER 
)
IS
BEGIN    
     BEGIN
           INSERT INTO EBANKING.ta_cliente 
                      ( 
                        EBANKING.ta_cliente.idcliente
                        ,EBANKING.ta_cliente.email
                        ,EBANKING.ta_cliente.usuario_modifico
                        ,EBANKING.ta_cliente.fecha_modifico
                        ,EBANKING.ta_cliente.passwd
                        ,EBANKING.ta_cliente.preguntasecret
                        ,EBANKING.ta_cliente.respuesta
                       )
                  VALUES
                      (  
                        V_NUMFOLIO
                        ,V_CORREO
                        ,V_USR_MOD 
                        ,V_FECHA_MOD
                        ,V_PASSWD
                        ,V_PREGSEC                        
                        ,V_RESPUESTA
                      );
     V_REGISTRADO := 1;       
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al agregar la SP_REGISTRAR_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
                   V_REGISTRADO := 0;    
     END;
END SP_REGISTRARCLI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_REGISTRA_USR
(
    PA_CONTRASENA   IN        EBANKING.TA_TITULAR.PASSWD%TYPE
    ,PA_CORREO       IN       EBANKING.TA_TITULAR.EMAIL%TYPE
    ,PA_USR_MOD      IN       EBANKING.TA_TITULAR.USUARIO_MODIFICO%TYPE
    ,PA_FECHA_MOD    IN       EBANKING.TA_TITULAR.FECHA_MODIFICO%TYPE
    ,PA_REGISTRADO   OUT       NUMBER 
    ,PA_NUMFOLIO     OUT       VARCHAR2
    ,PASCOD_ERROR    OUT       NUMBER
    ,PASMSG_ERROR    OUT       VARCHAR2
)
AS
VL_GRABADO INTEGER := 1;
VL_PORCENTAJE INTEGER := 0;
VL_VALORSEC NUMBER := 0;
VL_NUMFOLIOCOPY VARCHAR(5);
VL_NUMFOLIO VARCHAR(7);
VL_LONGSEC INTEGER :=0;

VL_UNO INTEGER := 1;
VL_DOS INTEGER := 2;
VL_TRES INTEGER := 3;
VL_CUATRO INTEGER := 4;
VL_CINCO INTEGER := 5;
BEGIN
      SELECT EBANKING.SE_FOLIONUEVO.NEXTVAL INTO VL_VALORSEC FROM DUAL;
      DBMS_OUTPUT.PUT_LINE( 'VAL NUM FOLIO =' || VL_VALORSEC );
      VL_NUMFOLIOCOPY := TO_CHAR(VL_VALORSEC);
      VL_LONGSEC := LENGTH(VL_NUMFOLIOCOPY);
      DBMS_OUTPUT.PUT_LINE( 'VAL LONGITUD =' || VL_LONGSEC );
      
      IF VL_LONGSEC = VL_UNO THEN
        VL_NUMFOLIO := CONCAT('CS0000', VL_NUMFOLIOCOPY);
      ELSIF VL_LONGSEC = VL_DOS THEN
        VL_NUMFOLIO := CONCAT('CS000', VL_NUMFOLIOCOPY);
      ELSIF VL_LONGSEC = VL_TRES THEN
        VL_NUMFOLIO := CONCAT('CS00', VL_NUMFOLIOCOPY);
      ELSIF VL_LONGSEC = VL_CUATRO THEN
        VL_NUMFOLIO := CONCAT('CS0', VL_NUMFOLIOCOPY);
      ELSIF VL_LONGSEC = VL_CINCO  THEN
        VL_NUMFOLIO := CONCAT('CS', VL_NUMFOLIOCOPY);
      END IF;
      
      PA_NUMFOLIO := VL_NUMFOLIO;
      DBMS_OUTPUT.PUT_LINE( 'VAL CAD FOLIO =' || VL_NUMFOLIO );
      
     INSERT INTO EBANKING.TA_TITULAR 
     ( 
               IDTITULAR
              ,EMAIL
              ,USUARIO_MODIFICO
              ,FECHA_MODIFICO
              ,PASSWD
              ,GRABADO
              ,PORCENTAJE
      )
      VALUES
      (  
              VL_NUMFOLIO
              ,PA_CORREO
              ,PA_USR_MOD 
              ,PA_FECHA_MOD
              ,PA_CONTRASENA
              ,VL_GRABADO
              ,VL_PORCENTAJE
      );
                      
      PA_REGISTRADO := 1;       
      PASCOD_ERROR := 0;
      PASMSG_ERROR := 'EXITOSO';
      COMMIT;
      DBMS_OUTPUT.PUT_LINE( 'NUM FOLIO =' || VL_NUMFOLIO );
      EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              DBMS_OUTPUT.PUT_LINE( 'NUM FOLIO =' || VL_NUMFOLIO );
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')'); 
END SP_REGISTRA_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           SP_REINICIO_SORTEOSQ(
  P_Vc_valAnterior OUT VARCHAR2,
  P_Vc_valNuevo OUT VARCHAR2
) AS
valor number := 0;
valor2 number := 1;
stmt VARCHAR(100):=null;
BEGIN
  

  delete from EBANKING.fiar_participe where id_sorteo > valor2;
  delete from EBANKING.fiar_boletos where id_sorteo > valor2;
  delete from EBANKING.fiar_premio where id_sorteo > valor2;
  delete from EBANKING.fiar_sorteo where id_sorteo > valor2;
  select FIAR_SORTEO_SEQ.NEXTVAL into valor from dual;
  P_Vc_valAnterior := valor;
  select FIAR_SORTEO_SEQ.CURRVAL into valor from dual;
  case valor
    when 2 then stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by -1';
    when 3 then stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by -2';
    when 4 then stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by -3';
    when 5 then stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by -4';
    else stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by 1';
  end case;
  EXECUTE IMMEDIATE stmt;
  SELECT EBANKING.FIAR_SORTEO_SEQ.NEXTVAL into valor FROM DUAL;
  stmt := 'ALTER SEQUENCE EBANKING.FIAR_SORTEO_SEQ INCREMENT by 1';
  EXECUTE IMMEDIATE stmt;
  SELECT EBANKING.FIAR_SORTEO_SEQ.CURRVAL into valor FROM DUAL;
  P_Vc_valNuevo := valor;
END SP_REINICIO_SORTEOSQ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE sp_select_usuarios IS
tmpVar NUMBER;
/******************************************************************************
   NAME:       sp_select_usuarios
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        22/09/2011   hb       1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     sp_select_usuarios
      Sysdate:         22/09/2011
      Date and Time:   22/09/2011, 06:01:27 p.m., and 22/09/2011 06:01:27 p.m.
      Username:        hb (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END sp_select_usuarios;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_SOLOPRUEBAS
AS
BEGIN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE FIAR_PARTICIPANTES_TEMP';
END SP_SOLOPRUEBAS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ULT_ACCESO 
(
          FECHA_ANTERIOR   IN      VARCHAR2
          ,PASMSG_ERROR     OUT     VARCHAR2
          ,CUR_LIST         OUT     sys_refcursor  
) 
IS
        
BEGIN
        
        OPEN CUR_LIST FOR
        SELECT EBANKING.EBANKING_USER.ID  
            FROM  EBANKING.EBANKING_USER
        WHERE ULT_ACCESO < FECHA_ANTERIOR ORDER BY ID;
        PASMSG_ERROR:= 'EXITOSO';

        EXCEPTION
            WHEN TOO_MANY_ROWS THEN
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_ULT_ACCESO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_ULT_ACCESO_UPDATE
(
          
          arreglo in tipo
          ,nvo_tracking in EBANKING.EBANKING_USER.TRACKING%TYPE          
          ,PASMSG_ERROR     OUT     VARCHAR2
) 
IS
BEGIN 
        for i in 1 .. arreglo.count      
        loop
            UPDATE EBANKING.EBANKING_USER SET TRACKING = nvo_tracking WHERE EBANKING.EBANKING_USER.ID = arreglo(i);
        end loop;
        PASMSG_ERROR:= 'EXITOSO';
        COMMIT;
        EXCEPTION
            WHEN TOO_MANY_ROWS THEN
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              DBMS_OUTPUT.PUT_LINE( 'TOO_MANY_ROWS');
              
            WHEN OTHERS THEN
              ROLLBACK ;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_ULT_ACCESO_UPDATE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_UPDATE_AMOUNTS(P_IDUSER                IN  NUMBER,
                                                      P_TERCEROS              IN  NUMBER,
                                                      P_INTERBANCARIO         IN  NUMBER,
                                                      P_INTERNACIONALES       IN  NUMBER,
                                                      P_PAGOS                 IN  NUMBER,
                                                      P_DIARIO                IN  NUMBER,
                                                      P_MOV_TERCEROS          IN  NUMBER,
                                                      P_MOV_INTER             IN  NUMBER,
                                                      P_MOV_INTERNACIONALES   IN  NUMBER,
                                                      P_MOV_PAGOS             IN  NUMBER,
                                                      P_MOV_DIARIO            IN  NUMBER,
                                                      PSMSG                   OUT VARCHAR2,
                                                      PSCOD                   OUT NUMBER) IS 
/******************************************************************************
   NAME:       SP_UPDATE_AMOUNTS
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        21/05/2013          1. Created this procedure.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     SP_UPDATE_AMOUNTS
      Sysdate:         21/05/2013
      Date and Time:   21/05/2013, 01:53:46 p.m., and 21/05/2013 01:53:46 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
     UPDATE EBANKING.EBANKING_SECURITY_MAX_AMOUNT S SET   
         S.TERCEROS            = P_TERCEROS,
  		 S.INTERBANCARIO       = P_INTERBANCARIO,
         S.INTERNACIONALES     = P_INTERNACIONALES,
		 S.PAGOS               = P_PAGOS,
         S.DIARIO              = P_DIARIO,
         S.MOV_TERCEROS        = P_MOV_TERCEROS,
		 S.MOV_INTER 		   = P_MOV_INTER,
		 S.MOV_INTERNACIONALES = P_MOV_INTERNACIONALES,
		 S.MOV_PAGOS 		   = P_MOV_PAGOS,
		 S.MOV_DIARIO          = P_MOV_DIARIO,
		 S.ULTIMO_MOVIMIENTO   = SYSDATE
     WHERE S.IDUSER = P_IDUSER;
     
     COMMIT;
     
     PSCOD:=0;
     PSMSG:='Se ejecuto EBANKING.SP_UPDATE_AMOUNTS exitosamente';    
     
     EXCEPTION
      WHEN OTHERS THEN
        ROLLBACK;
        PSCOD:=1;
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido en EBANKING.SP_UPDATE_AMOUNTS(' || SQLCODE || '  ' || SQLERRM || ')');
END SP_UPDATE_AMOUNTS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_UPDATE_ATTEMP
(  P_MAXATTEMP    IN    EBANKING.EBANKING_LOGIN.ATTEMPTS%TYPE,
   P_USERID       IN    EBANKING.EBANKING_LOGIN.USER_ID%TYPE,
   P_ALIAS        IN    EBANKING.EBANKING_LOGIN_HIST.ALIAS%TYPE,
   P_IP           IN    EBANKING.EBANKING_LOGIN_HIST.IP%TYPE,
   P_VALIDACION   IN    EBANKING.EBANKING_LOGIN_HIST.VALIDACION%TYPE
)
                               
IS
BEGIN
    -- ACTUALIZA LOS INTENTOS DEL USUARIO PARA INGRESAR
       UPDATE  EBANKING.EBANKING_LOGIN SET LOGIN_DATE=SYSDATE,ATTEMPTS=CASE
       WHEN
        (TRUNC(LOGIN_DATE)-TRUNC(SYSDATE)<>0 and ATTEMPTS<P_MAXATTEMP) 
       THEN 1 
            ELSE
                ATTEMPTS+1
       END 
    WHERE EBANKING.EBANKING_LOGIN.USER_ID=P_USERID;
   -- Inserta en Historico de Intentos del usuario
      INSERT INTO EBANKING_LOGIN(
      USER_ID, 
      ATTEMPTS, 
      LOGIN_DATE 
      ) 
      VALUES( 
      P_USERID, 1, SYSDATE );
      
    -- INSERTA EN HISTORICO EL MAX ATTEMPT
   INSERT INTO EBANKING.EBANKING_LOGIN_HIST( 
   ID, 
   USER_ID, 
   LOGIN_DATE, 
   ALIAS, 
   ATTEMPT, 
   IP,
   VALIDACION
   ) 
    SELECT 
            EBANKING.ID_LOGIN_HISTORY_SEQ.NEXTVAL,
            USER_ID,
            LOGIN_DATE,
            P_ALIAS,
            ATTEMPTS,
            P_IP,
            P_VALIDACION 
    FROM EBANKING.EBANKING_LOGIN WHERE USER_ID=P_USERID;
    
  COMMIT;

END SP_UPDATE_ATTEMP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_UPDATE_RMASMS(
	   	  		  			FECHA_CANCELACION IN EBANKING.EBANKING_RMASMS.CANCEL_DATE%TYPE
	   	  		  			,FECHA_MODIFICACION IN EBANKING.EBANKING_RMASMS.ULTIMA_MODIFICACION%TYPE
							,ESTATUS IN EBANKING.EBANKING_RMASMS.STATUS%TYPE
							,ALNOVA_CLIENTE IN EBANKING.EBANKING_RMASMS.ALNOVA_CLIENT%TYPE
							,CUENTA IN EBANKING.EBANKING_RMASMS.ACCOUNT_NUMBER%TYPE
					        ,PASCOD_ERROR OUT NUMBER
					        ,PASMSG_ERROR OUT VARCHAR2
							)
IS

tmpVar NUMBER;

BEGIN
    tmpVar := 0;
   
	UPDATE
		  EBANKING.EBANKING_RMASMS
	SET
	   CANCEL_DATE = to_date(FECHA_CANCELACION,'dd-mm-YYYY')
	   ,ULTIMA_MODIFICACION = to_date(FECHA_MODIFICACION,'dd-mm-YYYY')
	   ,STATUS = ESTATUS 
	WHERE
		 ALNOVA_CLIENT = ALNOVA_CLIENTE
	AND
	   ACCOUNT_NUMBER = CUENTA;
	   
	COMMIT;
   
    EXCEPTION
     WHEN OTHERS THEN
        PASCOD_ERROR:=1;
        PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'ACTUALIZACION NO EXITOSA (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_UPDATE_RMASMS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                      SP_UPDDATOSGEN(
             PA_FOLIO                IN    CUENTASELECTA.TA_TITULAR.IDTITULAR%TYPE
            ,PA_APATERNO             IN    CUENTASELECTA.TA_TITULAR.APATERNO%TYPE
            ,PA_AMATERNO             IN    CUENTASELECTA.TA_TITULAR.AMATERNO%TYPE
            ,PA_NOMBRE               IN    CUENTASELECTA.TA_TITULAR.NOMBRE%TYPE
            ,PA_SEXO                 IN    CUENTASELECTA.TA_TITULAR.SEXO%TYPE
            ,PA_EDOCIVIL             IN    CUENTASELECTA.TA_TITULAR.EDOCIVIL%TYPE
            ,PA_FENACIMIENTO         IN    CUENTASELECTA.TA_TITULAR.FENACIMIENTO%TYPE
            ,PA_NACIONALIDAD         IN    CUENTASELECTA.TA_TITULAR.NACIONALIDAD%TYPE
            ,PA_RFC                  IN    CUENTASELECTA.TA_TITULAR.RFC%TYPE
            ,PA_CURP                 IN    CUENTASELECTA.TA_TITULAR.CURP%TYPE
            ,PA_TIPOIDENT            IN    CUENTASELECTA.TA_TITULAR.TIPOIDENTIFICACION%TYPE
            ,PA_NUMIDENT             IN    CUENTASELECTA.TA_TITULAR.NUMIDENTIFICACION%TYPE
            ,PA_EMAIL                IN    CUENTASELECTA.TA_TITULAR.EMAIL%TYPE
            ,PA_USR_MOD              IN    CUENTASELECTA.TA_TITULAR.USUARIO_MODIFICO%TYPE
            ,PA_FECH_MOD             IN    CUENTASELECTA.TA_TITULAR.FECHA_MODIFICO%TYPE
            ,PA_ESTATUSREG           IN    CUENTASELECTA.TA_TITULAR.ESTATUSREGISTRO%TYPE
            ,PA_IMPORTE              IN    CUENTASELECTA.TA_TITULAR.IMPORTEOPERACION%TYPE
            ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_TITULAR.PORCENTAJE%TYPE
            ,PASCOD_ERROR            OUT     NUMBER
            ,PASMSG_ERROR            OUT     VARCHAR2
            ,PA_ENVIARCORREO         IN   CUENTASELECTA.TA_TITULAR.ENVIARCORREO%TYPE
)
IS
VL_NUMFORMULARIO           INTEGER := 1;
VL_ENVIARCORREO            VARCHAR2(1) := '1';
BEGIN    
     BEGIN
     
     IF PA_ENVIARCORREO <> VL_ENVIARCORREO
        THEN
        IF PA_ENVIARCORREO IS NOT NULL 
        THEN
            VL_ENVIARCORREO := PA_ENVIARCORREO;
        END IF;
     END IF;
     
            UPDATE  CUENTASELECTA.TA_TITULAR 

            SET APATERNO = PA_APATERNO
                ,AMATERNO = PA_AMATERNO
                ,NOMBRE = PA_NOMBRE
                ,SEXO = PA_SEXO
                ,EDOCIVIL = PA_EDOCIVIL
                ,FENACIMIENTO = PA_FENACIMIENTO
                ,NACIONALIDAD = PA_NACIONALIDAD
                ,RFC = PA_RFC
                ,CURP = PA_CURP
                ,TIPOIDENTIFICACION = PA_TIPOIDENT
                ,NUMIDENTIFICACION = PA_NUMIDENT
                ,EMAIL = PA_EMAIL
                ,NUMFORMULARIO = VL_NUMFORMULARIO
                ,USUARIO_MODIFICO = PA_USR_MOD
                ,FECHA_MODIFICO = PA_FECH_MOD
                ,PORCENTAJE = PA_PORCENTAJE
                ,IMPORTEOPERACION = PA_IMPORTE
                ,ESTATUSREGISTRO = PA_ESTATUSREG
                ,ENVIARCORREO = VL_ENVIARCORREO
            WHERE TA_TITULAR.IDTITULAR = PA_FOLIO;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION  
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDDATOSGEN;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE        SP_UPDDIRECCION(
   P_FOLIO                IN    ta_direccion.idtitular%TYPE
  ,P_CALLE                IN    ta_direccion.calle%TYPE
  ,P_NUM_EXT              IN    ta_direccion.numext%TYPE
  ,P_NUM_INT              IN    ta_direccion.numint%TYPE
  ,P_CP                   IN    ta_direccion.cp%TYPE
  ,P_COLONIA              IN    ta_direccion.colonia%TYPE
  ,P_ESTADO               IN    ta_direccion.estado%TYPE
  ,P_POBLACION            IN    ta_direccion.poblacion%TYPE
  ,P_LADA                 IN    ta_direccion.lada%TYPE
  ,P_TELEFONO             IN    ta_direccion.teloficina%TYPE
  ,P_EXTENSION            IN    ta_direccion.extension%type
  ,P_TELCASA              IN    ta_direccion.telcasa%TYPE
  ,P_PORCENTAJE           IN    ta_direccion.porcentaje%TYPE
  ,P_USRMOD               IN    ta_direccion.usuario_modifico%TYPE
  ,P_FECMOD               IN    ta_direccion.fecha_modifico%TYPE
  ,PSCod_Error            OUT   NUMBER
  ,PSMsg_Error            OUT   VARCHAR2
)
IS
V_NUMFORMULARIO           INTEGER := 2;
BEGIN    
     BEGIN
           UPDATE EBANKING.ta_direccion
           SET  ta_direccion.calle = P_CALLE
                ,ta_direccion.numext = P_NUM_EXT
                ,ta_direccion.numint = P_NUM_INT
                ,ta_direccion.cp = P_CP
                ,ta_direccion.colonia = P_COLONIA
                ,ta_direccion.estado = P_ESTADO
                ,ta_direccion.poblacion = P_POBLACION
                ,ta_direccion.lada = P_LADA
                ,ta_direccion.teloficina = P_TELEFONO
                ,ta_direccion.extension = P_EXTENSION
                ,ta_direccion.porcentaje = P_PORCENTAJE
            WHERE ta_direccion.idtitular = P_FOLIO;
              
            UPDATE EBANKING.ta_titular
            SET 
                ta_titular.numformulario = V_NUMFORMULARIO
            WHERE
                ta_titular.idtitular = P_FOLIO;
                
            PSCod_Error := 0;
            PSMsg_Error := 'Actualizo registro en ta_direccion';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PSCod_Error:=1;
                PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar datos en ta_direccion, SP_UPDDIRECCION  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDDIRECCION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                                                  SP_UPDDIRTIT
(
   PA_FOLIO                IN    CUENTASELECTA.TA_DIRECCION.IDTITULAR%TYPE
  ,PA_CALLE                IN    CUENTASELECTA.TA_DIRECCION.CALLE%TYPE
  ,PA_NUM_EXT              IN    CUENTASELECTA.TA_DIRECCION.NUMEXT%TYPE
  ,PA_NUM_INT              IN    CUENTASELECTA.TA_DIRECCION.NUMINT%TYPE
  ,PA_CP                   IN    CUENTASELECTA.TA_DIRECCION.CP%TYPE
  ,PA_COLONIA              IN    CUENTASELECTA.TA_DIRECCION.COLONIA%TYPE
  ,PA_ESTADO               IN    CUENTASELECTA.TA_DIRECCION.ESTADO%TYPE
  ,PA_POBLACION            IN    CUENTASELECTA.TA_DIRECCION.POBLACION%TYPE
  ,PA_LADA                 IN    CUENTASELECTA.TA_DIRECCION.LADA%TYPE
  ,PA_TELEFONO             IN    CUENTASELECTA.TA_DIRECCION.TELOFICINA%TYPE
  ,PA_EXTENSION            IN    CUENTASELECTA.TA_DIRECCION.EXTENSION%TYPE
  ,PA_TELCASA              IN    CUENTASELECTA.TA_DIRECCION.TELCASA%TYPE
  ,PA_TELCELULAR           IN    CUENTASELECTA.TA_DIRECCION.TELCEL%TYPE
  ,PA_FECHAVISITA          IN    CUENTASELECTA.TA_DIRECCION.FECHAVISITA%TYPE
  ,PA_HORAVISITA           IN    CUENTASELECTA.TA_DIRECCION.HORAVISITA%TYPE
  ,PA_REFCALLES            IN    CUENTASELECTA.TA_DIRECCION.REFERENCIACALLES%TYPE
  ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_DIRECCION.PORCENTAJE%TYPE
  ,PA_USRMOD               IN    CUENTASELECTA.TA_DIRECCION.USUARIO_MODIFICO%TYPE
  ,PA_FECMOD               IN    CUENTASELECTA.TA_DIRECCION.FECHA_MODIFICO%TYPE
  ,PA_VISITA               IN    CUENTASELECTA.TA_DIRECCION.VISITA%TYPE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
  ,PA_LADACASA             IN    CUENTASELECTA.TA_DIRECCION.LADACASA%TYPE
)
IS
VL_NUMFORMULARIO           INTEGER := 2;
VL_LADACASA                VARCHAR2(5) := '0';
BEGIN    
     BEGIN
     
      IF PA_LADACASA <> VL_LADACASA
        THEN
        IF PA_LADACASA IS NOT NULL 
        THEN
            VL_LADACASA := PA_LADACASA;
        END IF;
     END IF;
     
           UPDATE  CUENTASELECTA.TA_DIRECCION
           SET  CALLE = PA_CALLE
                ,NUMEXT = PA_NUM_EXT
                ,NUMINT = PA_NUM_INT
                ,CP = PA_CP
                ,COLONIA = PA_COLONIA
                ,ESTADO = PA_ESTADO
                ,POBLACION = PA_POBLACION
                ,LADA = PA_LADA
                ,TELOFICINA = PA_TELEFONO
                ,EXTENSION = PA_EXTENSION
                ,TELCASA = PA_TELCASA
                ,TELCEL = PA_TELCELULAR
                ,FECHAVISITA = PA_FECHAVISITA
                ,HORAVISITA = PA_HORAVISITA
                ,REFERENCIACALLES = PA_REFCALLES
                ,PORCENTAJE = PA_PORCENTAJE
                ,VISITA = PA_VISITA
                ,LADACASA = VL_LADACASA
            WHERE IDTITULAR = PA_FOLIO
            AND  UPPER(TA_DIRECCION.VISITA) = PA_VISITA;
              
            UPDATE  CUENTASELECTA.TA_TITULAR
            SET 
                NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                IDTITULAR = PA_FOLIO;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PASCOD_ERROR:=1;
                PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDDIRTIT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_UPDFECHATERM

(
            PA_FOLIO                 IN     EBANKING.TA_TITULAR.IDTITULAR%TYPE
            ,PA_FECH_TERM            IN     EBANKING.TA_TITULAR.FETERMINO%TYPE
            ,PA_USR_MOD              IN     EBANKING.TA_TITULAR.USUARIO_MODIFICO%TYPE
            ,PA_FECH_MOD             IN     EBANKING.TA_TITULAR.FECHA_MODIFICO%TYPE
            ,PASCOD_ERROR            OUT    NUMBER
            ,PASMSG_ERROR            OUT    VARCHAR2
)
IS

BEGIN    
     BEGIN
            UPDATE  EBANKING.TA_TITULAR 
            SET  FETERMINO = PA_FECH_TERM
                , FECHA_MODIFICO = PA_FECH_MOD
                , USUARIO_MODIFICO = PA_USR_MOD
            WHERE IDTITULAR = PA_FOLIO;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION  
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDFECHATERM;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_UPDINFOECYFI
(
             PA_FUENTE_INGRESO       IN    EBANKING.TA_INFOECOYFIN.FUENTEINGRESOS%TYPE
            ,PA_EMPINSTLAB           IN    EBANKING.TA_INFOECOYFIN.EMPRESATRABAJO%TYPE
            ,PA_PUESTODESEMP         IN    EBANKING.TA_INFOECOYFIN.PUESTO%TYPE
            ,PA_TIEMPO_LABORAR       IN    EBANKING.TA_INFOECOYFIN.TIEMPOLABORADO%TYPE
            ,PA_DIRECCION_TRABAJO    IN    EBANKING.TA_INFOECOYFIN.DIREMPRESA%TYPE
            ,PA_TELS_TRABAJO         IN    EBANKING.TA_INFOECOYFIN.TELEFONO%TYPE
            ,PA_INGRESOS_MENSUALES   IN    EBANKING.TA_INFOECOYFIN.INGMENSUAL%TYPE
            ,PA_EGRESOS_MENSUALES    IN    EBANKING.TA_INFOECOYFIN.EGRMENSUAL%TYPE
            ,PA_SECTOR_EMP           IN    EBANKING.TA_INFOECOYFIN.SECTEMPRESARIAL%TYPE
            ,PA_PROF_OFICIO          IN    EBANKING.TA_INFOECOYFIN.PROFUOFICIO%TYPE
            ,PA_ID_TITULAR           IN    EBANKING.TA_INFOECOYFIN.IDTITULAR%TYPE
            ,PA_PORCENTAJE           IN    EBANKING.TA_INFOECOYFIN.PORCENTAJE%TYPE
            ,PA_GRABADO              IN    EBANKING.TA_INFOECOYFIN.GRABADO%TYPE
            ,PA_USR_MOD              IN    EBANKING.TA_INFOECOYFIN.USUARIO_MODIFICO%TYPE
            ,PA_FECH_MOD             IN    EBANKING.TA_INFOECOYFIN.FECHA_MODIFICO%TYPE
            ,PASCOD_ERROR            OUT   NUMBER
            ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
VL_NUMFORMULARIO   INTEGER := 5;
BEGIN    
     BEGIN
           UPDATE  EBANKING.TA_INFOECOYFIN
                    SET FUENTEINGRESOS = PA_FUENTE_INGRESO
                        ,EMPRESATRABAJO = PA_EMPINSTLAB
                        ,PUESTO = PA_PUESTODESEMP
                        ,TIEMPOLABORADO = PA_TIEMPO_LABORAR
                        ,DIREMPRESA = PA_DIRECCION_TRABAJO
                        ,TELEFONO = PA_TELS_TRABAJO
                        ,INGMENSUAL = PA_INGRESOS_MENSUALES
                        ,EGRMENSUAL = PA_EGRESOS_MENSUALES
                        ,SECTEMPRESARIAL = PA_SECTOR_EMP
                        ,PROFUOFICIO = PA_PROF_OFICIO
                        ,PORCENTAJE = PA_PORCENTAJE
                        ,GRABADO = PA_GRABADO
                        ,USUARIO_MODIFICO = PA_USR_MOD
                        ,FECHA_MODIFICO = PA_FECH_MOD
                    WHERE IDTITULAR = PA_ID_TITULAR;
              	  
              UPDATE  EBANKING.TA_TITULAR
            SET 
                NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                IDTITULAR = PA_ID_TITULAR;
            
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDINFOECYFI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                                            SP_UPDPERPOLEXP
(
           
          PA_ID_TITULAR            IN    CUENTASELECTA.TA_PERSONAPEXP.IDTITULAR%TYPE
          ,PA_PUESTO_TITULAR       IN    CUENTASELECTA.TA_PERSONAPEXP.PUESTOTITULAR%TYPE
          ,PA_PUESTO_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.PUESTOFAMILIAR%TYPE
          ,PA_NOMBRE_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NOMBRE%TYPE
          ,PA_APATERNO_FAMILIAR    IN    CUENTASELECTA.TA_PERSONAPEXP.APATERNO%TYPE
          ,PA_AMATERNO_FAMILIAR    IN    CUENTASELECTA.TA_PERSONAPEXP.AMATERNO%TYPE
          ,PA_CALLE_FAMILIAR       IN    CUENTASELECTA.TA_PERSONAPEXP.CALLE%TYPE
          ,PA_NUMEXT_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NUMEXT%TYPE
          ,PA_NUMINT_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.NUMINT%TYPE
          ,PA_CP_FAMILIAR          IN    CUENTASELECTA.TA_PERSONAPEXP.CP%TYPE
          ,PA_COLONIA_FAMILIAR     IN    CUENTASELECTA.TA_PERSONAPEXP.COLONIA%TYPE
          ,PA_ESTADO_FAMILIAR      IN    CUENTASELECTA.TA_PERSONAPEXP.ESTADO%TYPE
          ,PA_POBLACION_FAMILIAR   IN    CUENTASELECTA.TA_PERSONAPEXP.POBLACION%TYPE
          ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_PERSONAPEXP.PORCENTAJE%TYPE
          ,PA_GRABADO              IN    CUENTASELECTA.TA_PERSONAPEXP.GRABADO%TYPE
          ,PA_USR_MOD              IN    CUENTASELECTA.TA_PERSONAPEXP.USUARIO_MODIFICO%TYPE
          ,PA_FECH_MOD             IN    CUENTASELECTA.TA_PERSONAPEXP.FECHA_MODIFICO%TYPE
          ,PA_FUEPPETIT            IN    CUENTASELECTA.TA_PERSONAPEXP.FUEPPETIT%TYPE
          ,PA_FUEPPEFAM            IN    CUENTASELECTA.TA_PERSONAPEXP.FUEPPEFAM%TYPE
          ,PA_PARENTESCO           IN    CUENTASELECTA.TA_PERSONAPEXP.PARENTESCO%TYPE
          ,PASCOD_ERROR            OUT     NUMBER
          ,PASMSG_ERROR            OUT     VARCHAR2
          ,PA_LADA                 IN    CUENTASELECTA.TA_PERSONAPEXP.LADA%TYPE
          ,PA_TELEFONO           IN    CUENTASELECTA.TA_PERSONAPEXP.TELEFONO%TYPE
)
IS
VL_NUMFORMULARIO   INTEGER := 6;
VL_LADA            VARCHAR2(5) := '0';
VL_TELEFONO        VARCHAR2(20) := '0';
BEGIN    
     BEGIN
     
     IF PA_LADA <> VL_LADA
        THEN
        IF PA_LADA IS NOT NULL 
        THEN
            VL_LADA := PA_LADA;
        END IF;
      END IF;
      
      IF PA_TELEFONO <> VL_TELEFONO
        THEN
        IF PA_TELEFONO IS NOT NULL 
        THEN
           VL_TELEFONO := PA_TELEFONO;
        END IF;
     END IF;
     
           UPDATE  CUENTASELECTA.TA_PERSONAPEXP

                    SET PUESTOTITULAR = PA_PUESTO_TITULAR
                        ,PUESTOFAMILIAR = PA_PUESTO_FAMILIAR
                        ,APATERNO = PA_APATERNO_FAMILIAR
                        ,AMATERNO = PA_AMATERNO_FAMILIAR
                        ,NOMBRE = PA_NOMBRE_FAMILIAR
                        ,CALLE = PA_CALLE_FAMILIAR
                        ,NUMEXT = PA_NUMEXT_FAMILIAR
                        ,NUMINT = PA_NUMINT_FAMILIAR
                        ,CP = PA_CP_FAMILIAR
                        ,COLONIA = PA_COLONIA_FAMILIAR
                        ,ESTADO = PA_ESTADO_FAMILIAR
                        ,POBLACION = PA_POBLACION_FAMILIAR
                        ,IDTITULAR = PA_ID_TITULAR
                        ,PORCENTAJE = PA_PORCENTAJE
                        ,GRABADO = PA_GRABADO
                        ,USUARIO_MODIFICO = PA_USR_MOD
                        ,FECHA_MODIFICO = PA_FECH_MOD
                        ,FUEPPETIT = PA_FUEPPETIT
                        ,FUEPPEFAM = PA_FUEPPEFAM
                        ,PARENTESCO = PA_PARENTESCO
                    WHERE IDTITULAR = PA_ID_TITULAR;
              
              UPDATE  CUENTASELECTA.TA_TITULAR
            SET 
                TA_TITULAR.NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                TA_TITULAR.IDTITULAR = PA_ID_TITULAR;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
    
    EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDPERPOLEXP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE           SP_UPDUSOCUENTA
(
           PA_ACTIVIDAD            IN    EBANKING.TA_USOCUENTA.ACTIVIDAD%TYPE
          ,PA_SECTOR_LAB           IN    EBANKING.TA_USOCUENTA.SECTLABORAL%TYPE
          ,PA_ACTIVIDAD_ECO        IN    EBANKING.TA_USOCUENTA.ACTECONOMICA%TYPE
          ,PA_TRAN_DEPOSITOS       IN    EBANKING.TA_USOCUENTA.TRANDEPOSITOS%TYPE
          ,PA_TRAN_RETIROS         IN    EBANKING.TA_USOCUENTA.TRANRETIROS%TYPE
          ,PA_TRAN_TRANSFER        IN    EBANKING.TA_USOCUENTA.TRANTRANSFERENCIAS%TYPE
          ,PA_TRAN_COMPVENTDIV     IN    EBANKING.TA_USOCUENTA.TRANCVD%TYPE
          ,PA_ORIGEN_RECURSO       IN    EBANKING.TA_USOCUENTA.ORIGENRECURSOS%TYPE
          ,PA_USO_DARA_CUENTA      IN    EBANKING.TA_USOCUENTA.USOCUENTA%TYPE
          ,PA_ID_TITULAR           IN    EBANKING.TA_USOCUENTA.IDTITULAR%TYPE
          ,PA_PORCENTAJE           IN    EBANKING.TA_USOCUENTA.PORCENTAJE%TYPE
          ,PA_GRABADO              IN    EBANKING.TA_USOCUENTA.GRABADO%TYPE
          ,PA_USR_MOD              IN    EBANKING.TA_USOCUENTA.USUARIO_MODIFICO%TYPE
          ,PA_FECH_MOD             IN    EBANKING.TA_USOCUENTA.FECHA_MODIFICO%TYPE
          ,PASCOD_ERROR            OUT   NUMBER
          ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
VL_NUMFORMULARIO           INTEGER := 4;
BEGIN    
     BEGIN
           UPDATE  EBANKING.TA_USOCUENTA
                  SET   ACTIVIDAD = PA_ACTIVIDAD
                        ,SECTLABORAL = PA_SECTOR_LAB
                        ,ACTECONOMICA = PA_ACTIVIDAD_ECO
                        ,TRANDEPOSITOS = PA_TRAN_DEPOSITOS
                        ,TRANRETIROS = PA_TRAN_DEPOSITOS
                        ,TRANTRANSFERENCIAS = PA_TRAN_TRANSFER
                        ,TRANCVD = PA_TRAN_COMPVENTDIV
                        ,ORIGENRECURSOS = PA_ORIGEN_RECURSO
                        ,USOCUENTA = PA_USO_DARA_CUENTA
                        ,PORCENTAJE = PA_PORCENTAJE
                        ,GRABADO = PA_GRABADO
                        ,USUARIO_MODIFICO = PA_USR_MOD
                        ,FECHA_MODIFICO = PA_FECH_MOD
                  WHERE TA_USOCUENTA.IDTITULAR = PA_ID_TITULAR;
              
              UPDATE  EBANKING.TA_TITULAR
            SET 
                NUMFORMULARIO = VL_NUMFORMULARIO
            WHERE
                IDTITULAR = PA_ID_TITULAR;
                
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                PASCOD_ERROR:=1;
                PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                ROLLBACK;
                RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPDUSOCUENTA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_UPD_BENEF(
             
        PA_IDUSUARIO	    IN	  EBANKING.TA_BENEFAFILIA.IDUSUARIO%TYPE
  			,PA_NUMBENEF      IN    EBANKING.TA_BENEFAFILIA.NUMBENEFICIARIO%TYPE
  			,PA_PATERNO       IN    EBANKING.TA_BENEFAFILIA.APATERNO%TYPE
  			,PA_MATERNO       IN    EBANKING.TA_BENEFAFILIA.AMATERNO%TYPE
  			,PA_NOMBRE        IN    EBANKING.TA_BENEFAFILIA.NOMBRE%TYPE
  			,PA_PARENTESCO    IN    EBANKING.TA_BENEFAFILIA.PARENTESCO%TYPE
  			,PA_GRABADO       IN    EBANKING.TA_BENEFAFILIA.GRABADO%TYPE
        ,PA_PORCENTAJE    IN    EBANKING.TA_BENEFAFILIA.PORCENTAJE%TYPE
  			,PA_EMAIL         IN    EBANKING.TA_BENEFAFILIA.EMAIL%TYPE
  			,PA_CALLE		      IN	  EBANKING.TA_DIRECCIONAFI.CALLE%TYPE                     
  			,PA_NUMEXT        IN    EBANKING.TA_DIRECCIONAFI.NUMEXT%TYPE
  			,PA_NUMINT        IN    EBANKING.TA_DIRECCIONAFI.NUMINT%TYPE
  			,PA_CP            IN    EBANKING.TA_DIRECCIONAFI.CP%TYPE
  			,PA_COLONIA       IN    EBANKING.TA_DIRECCIONAFI.COLONIA%TYPE
  			,PA_ESTADO        IN    EBANKING.TA_DIRECCIONAFI.ESTADO%TYPE
  			,PA_POBLACION     IN    EBANKING.TA_DIRECCIONAFI.POBLACION%TYPE
  			,PA_LADA          IN    EBANKING.TA_DIRECCIONAFI.LADA%TYPE
  			,PA_TEL           IN    EBANKING.TA_DIRECCIONAFI.TELOFICINA%TYPE
  			,PA_EXT           IN    EBANKING.TA_DIRECCIONAFI.EXTENSION%TYPE
  
  			,PA_USUARIOMODIFICO      IN    VARCHAR2
  			,PA_FECHAMOD             IN    DATE
  			,PASCOD_ERROR            OUT   NUMBER
  			,PASMSG_ERROR            OUT   VARCHAR2
)
IS

VL_IDBENEFICIARIO     EBANKING.TA_BENEFAFILIA.IDBENEFICIARIO%TYPE := 0;


BEGIN    

       SELECT EBANKING.TA_BENEFAFILIA.IDBENEFICIARIO
        INTO VL_IDBENEFICIARIO
        FROM EBANKING.TA_BENEFAFILIA
        WHERE TA_BENEFAFILIA.IDUSUARIO = PA_IDUSUARIO AND TA_BENEFAFILIA.NUMBENEFICIARIO=PA_NUMBENEF;
        
        
       UPDATE EBANKING.TA_BENEFAFILIA  
         SET TA_BENEFAFILIA.APATERNO= PA_PATERNO
            ,TA_BENEFAFILIA.AMATERNO =PA_MATERNO
            ,TA_BENEFAFILIA.NOMBRE =PA_NOMBRE
            ,TA_BENEFAFILIA.PARENTESCO = PA_PARENTESCO 
            ,TA_BENEFAFILIA.GRABADO = PA_GRABADO 
            ,TA_BENEFAFILIA.PORCENTAJE = PA_PORCENTAJE
            ,TA_BENEFAFILIA.EMAIL = PA_EMAIL
            ,TA_BENEFAFILIA.USUARIO_MODIFICO = PA_USUARIOMODIFICO
            ,TA_BENEFAFILIA.FECHA_MODIFICO= PA_FECHAMOD
        WHERE TA_BENEFAFILIA.IDUSUARIO = PA_IDUSUARIO AND TA_BENEFAFILIA.NUMBENEFICIARIO=PA_NUMBENEF;
                
       
        UPDATE EBANKING.TA_DIRECCIONAFI 
         SET TA_DIRECCIONAFI.CALLE  =PA_CALLE	 
            ,TA_DIRECCIONAFI.NUMEXT =PA_NUMEXT 
            ,TA_DIRECCIONAFI.NUMINT =PA_NUMINT
            ,TA_DIRECCIONAFI.CP =PA_CP 
            ,TA_DIRECCIONAFI.COLONIA =PA_COLONIA 
            ,TA_DIRECCIONAFI.ESTADO =PA_ESTADO 
            ,TA_DIRECCIONAFI.POBLACION =PA_POBLACION
            ,TA_DIRECCIONAFI.LADA =PA_LADA  
            ,TA_DIRECCIONAFI.TELOFICINA =PA_TEL 
            ,TA_DIRECCIONAFI.EXTENSION =PA_EXT 
            ,TA_DIRECCIONAFI.GRABADO=PA_GRABADO
            ,TA_DIRECCIONAFI.PORCENTAJE =PA_PORCENTAJE            
            ,TA_DIRECCIONAFI.USUARIO_MODIFICO = PA_USUARIOMODIFICO
            ,TA_DIRECCIONAFI.FECHA_MODIFICO= PA_FECHAMOD
        WHERE TA_DIRECCIONAFI.IDUSUARIO = PA_IDUSUARIO AND TA_DIRECCIONAFI.IDBENEFICIARIO=VL_IDBENEFICIARIO;
               
                                                      
            PASCOD_ERROR := 0;
            PASMSG_ERROR := 'EXITOSO';
            COMMIT;
            
        EXCEPTION  
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END SP_UPD_BENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE              SP_UPD_FISCAL
(
  PA_IDUSUARIO	   IN	EBANKING.TA_FISCAL.IDUSUARIO%TYPE  
  ,PA_CALLE		   IN	EBANKING.TA_FISCAL.CALLE%TYPE                     
  ,PA_NUMEXT        IN   EBANKING.TA_FISCAL.NUMEXT%TYPE
  ,PA_NUMINT        IN   EBANKING.TA_FISCAL.NUMINT%TYPE
  ,PA_CP            IN   EBANKING.TA_FISCAL.CODPOSTAL%TYPE
  ,PA_COLONIA       IN   EBANKING.TA_FISCAL.COLONIA%TYPE
  ,PA_ESTADO        IN   EBANKING.TA_FISCAL.ESTADO%TYPE
  ,PA_POBLACION     IN   EBANKING.TA_FISCAL.CIUDAD%TYPE
  ,PA_LADA          IN   EBANKING.TA_FISCAL.LADA%TYPE
  ,PA_TEL           IN   EBANKING.TA_FISCAL.TELEFONO%TYPE
  ,PA_EXT           IN   EBANKING.TA_FISCAL.EXTENSION%TYPE
  
  ,PA_USUARIOMODIFICO      IN    VARCHAR2
  ,PA_FECHAMOD             IN    DATE
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
  
)
IS

BEGIN
    BEGIN
          UPDATE EBANKING.TA_FISCAL
          SET 
              EBANKING.TA_FISCAL.CALLE = PA_CALLE	                   
             ,EBANKING.TA_FISCAL.NUMEXT=PA_NUMEXT  
             ,EBANKING.TA_FISCAL.NUMINT=PA_NUMINT 
             ,EBANKING.TA_FISCAL.CODPOSTAL=PA_CP
             ,EBANKING.TA_FISCAL.COLONIA=PA_COLONIA
             ,EBANKING.TA_FISCAL.ESTADO=PA_ESTADO 
             ,EBANKING.TA_FISCAL.CIUDAD=PA_POBLACION 
             ,EBANKING.TA_FISCAL.LADA=PA_LADA
             ,EBANKING.TA_FISCAL.TELEFONO=PA_TEL
             ,EBANKING.TA_FISCAL.EXTENSION= PA_EXT                        
             ,EBANKING.TA_FISCAL.USUARIO_MODIFICO=PA_USUARIOMODIFICO  
            ,EBANKING.TA_FISCAL.FECHA_MODIFICO=PA_FECHAMOD
            
        WHERE  PA_IDUSUARIO= EBANKING.TA_FISCAL.IDUSUARIO;
            
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                  PASCOD_ERROR:=1;
                  PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                  ROLLBACK;
                  RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPD_FISCAL;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                SP_UPD_INFOCLI
(
  PA_FOLIOAFILIA           IN    CUENTASELECTA.TA_CLIENTE.IDUSUARIO%TYPE
  ,PA_IMEI                 IN    CUENTASELECTA.TA_CLIENTE.IMEI%TYPE
  ,PA_APATERNO             IN    CUENTASELECTA.TA_CLIENTE.APATERNO%TYPE
  ,PA_AMATERNO             IN    CUENTASELECTA.TA_CLIENTE.AMATERNO%TYPE
  ,PA_NOMBRE               IN    CUENTASELECTA.TA_CLIENTE.NOMBRECLI%TYPE
  ,PA_SEXO                 IN    CUENTASELECTA.TA_CLIENTE.SEXO%TYPE
  ,PA_ESTADOCIVIL          IN    CUENTASELECTA.TA_CLIENTE.ESTADOCIVIL%TYPE
  ,PA_CALLE                IN    CUENTASELECTA.TA_CLIENTE.CALLECLI%TYPE
  ,PA_NUMEXT               IN    CUENTASELECTA.TA_CLIENTE.NUMEXT%TYPE
  ,PA_CP                   IN    CUENTASELECTA.TA_CLIENTE.CODPOSTALCLI%TYPE
  ,PA_COLONIA              IN    CUENTASELECTA.TA_CLIENTE.COLONIACLI%TYPE
  ,PA_ESTADO               IN    CUENTASELECTA.TA_CLIENTE.ESTADOCLI%TYPE
  ,PA_CIUDAD               IN    CUENTASELECTA.TA_CLIENTE.CIUDAD%TYPE
  ,PA_FECHANAC             IN    CUENTASELECTA.TA_CLIENTE.FECHANAC%TYPE
 ,PA_NUMIDENT          IN    CUENTASELECTA.TA_CLIENTE.NUMIDENTIFIC%TYPE  /*Este es un campo nuevo que se agrego*/
  ,PA_LADA                 IN    CUENTASELECTA.TA_CLIENTE.LADA%TYPE
  ,PA_TELCASA              IN    CUENTASELECTA.TA_CLIENTE.TELCASA%TYPE
  ,PA_CURP                 IN    CUENTASELECTA.TA_CLIENTE.CURP%TYPE
  ,PA_RFC                  IN    CUENTASELECTA.TA_CLIENTE.RFC%TYPE
  ,PA_ACTIVIDAD            IN    CUENTASELECTA.TA_CLIENTE.ACTIVIDAD%TYPE
  ,PA_ACTIVIDADECO         IN    CUENTASELECTA.TA_CLIENTE.ACTIVIDADECO%TYPE
  ,PA_NUMFORM              IN    CUENTASELECTA.TA_CLIENTE.NUMFORM%TYPE
  ,PA_PORCENTAJE           IN    CUENTASELECTA.TA_CLIENTE.PORCENTAJE%TYPE
  ,PA_GRABADO              IN    CUENTASELECTA.TA_CLIENTE.GRABADO%TYPE    
  ,PA_USUARIOMODIFICO      IN    CUENTASELECTA.TA_CLIENTE.USUARIO_MODIFICO%TYPE
  ,PA_FECHAMOD             IN    CUENTASELECTA.TA_CLIENTE.FECHA_MODIFICO%TYPE
  ,PA_CORREO               IN    CUENTASELECTA.TA_CLIENTE.EMAIL%TYPE
  ,PA_NUMINT               IN    CUENTASELECTA.TA_CLIENTE.NUMINT%TYPE
  ,PA_TIPOIDEN             IN    CUENTASELECTA.TA_CLIENTE.TIPOIDENTIFICACION%TYPE
  ,PA_NUMEXTENSION         IN    CUENTASELECTA.TA_CLIENTE.NUMEXTENSION%TYPE
  ,PA_DISP                 IN    CUENTASELECTA.TA_CLIENTE.TIPODISP%TYPE   /*Este es el que renombre de NUMCREDELECT  A  TIPODISP */
  ,PASCOD_ERROR            OUT   NUMBER
  ,PASMSG_ERROR            OUT   VARCHAR2
)
IS
BEGIN    
     BEGIN
           UPDATE CUENTASELECTA.TA_CLIENTE 
                  SET   CUENTASELECTA.TA_CLIENTE.IMEI = PA_IMEI
                        ,CUENTASELECTA.TA_CLIENTE.APATERNO = PA_APATERNO
                        ,CUENTASELECTA.TA_CLIENTE.AMATERNO = PA_AMATERNO
                        ,CUENTASELECTA.TA_CLIENTE.NOMBRECLI = PA_NOMBRE
                        ,CUENTASELECTA.TA_CLIENTE.SEXO = PA_SEXO
                        ,CUENTASELECTA.TA_CLIENTE.ESTADOCIVIL = PA_ESTADOCIVIL
                        ,CUENTASELECTA.TA_CLIENTE.CALLECLI = PA_CALLE
                        ,CUENTASELECTA.TA_CLIENTE.NUMEXT = PA_NUMEXT
                        ,CUENTASELECTA.TA_CLIENTE.CODPOSTALCLI = PA_CP
                        ,CUENTASELECTA.TA_CLIENTE.COLONIACLI = PA_COLONIA
                        ,CUENTASELECTA.TA_CLIENTE.ESTADOCLI = PA_ESTADO
                        ,CUENTASELECTA.TA_CLIENTE.CIUDAD = PA_CIUDAD
                        ,CUENTASELECTA.TA_CLIENTE.FECHANAC = PA_FECHANAC
                        ,CUENTASELECTA.TA_CLIENTE.NUMIDENTIFIC = PA_NUMIDENT
                        ,CUENTASELECTA.TA_CLIENTE.LADA = PA_LADA
                        ,CUENTASELECTA.TA_CLIENTE.TELCASA = PA_TELCASA                        
                        ,CUENTASELECTA.TA_CLIENTE.CURP = PA_CURP
                        ,CUENTASELECTA.TA_CLIENTE.RFC = PA_RFC
                        ,CUENTASELECTA.TA_CLIENTE.ACTIVIDAD = PA_ACTIVIDAD
                        ,CUENTASELECTA.TA_CLIENTE.ACTIVIDADECO = PA_ACTIVIDADECO
                        ,CUENTASELECTA.TA_CLIENTE.NUMFORM = PA_NUMFORM
                        ,CUENTASELECTA.TA_CLIENTE.PORCENTAJE = PA_PORCENTAJE
                        ,CUENTASELECTA.TA_CLIENTE.GRABADO = PA_GRABADO                        
                        ,CUENTASELECTA.TA_CLIENTE.USUARIO_MODIFICO = PA_USUARIOMODIFICO
                        ,CUENTASELECTA.TA_CLIENTE.FECHA_MODIFICO = PA_FECHAMOD
                        ,CUENTASELECTA.TA_CLIENTE.EMAIL = PA_CORREO
                        ,CUENTASELECTA.TA_CLIENTE.NUMINT = PA_NUMINT 
                        ,CUENTASELECTA.TA_CLIENTE.TIPOIDENTIFICACION = PA_TIPOIDEN
                        ,CUENTASELECTA.TA_CLIENTE.NUMEXTENSION = PA_NUMEXTENSION
                        ,CUENTASELECTA.TA_CLIENTE.TIPODISP = PA_DISP
                  WHERE CUENTASELECTA.TA_CLIENTE.IDUSUARIO = PA_FOLIOAFILIA;   
    
    PASCOD_ERROR := 0;
    PASMSG_ERROR := 'EXITOSO';
    COMMIT;
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
    END;
END SP_UPD_INFOCLI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            SP_UPD_INFONEG
(
  PA_FOLIOAFILIA           IN  EBANKING.TA_NEGOCIO.IDUSUARIO%TYPE
  ,PA_NOMBRENEGOCIO        IN  EBANKING.TA_NEGOCIO.NOMBRENEG%TYPE
  ,PA_RFC                  IN  EBANKING.TA_NEGOCIO.RFC%TYPE
  ,PA_SECTLABORAL          IN  EBANKING.TA_NEGOCIO.SECTORLAB%TYPE
  ,PA_CALLENEGOCIO         IN  EBANKING.TA_NEGOCIO.CALLENEG%TYPE
  ,PA_NUMNEGOCIO           IN  EBANKING.TA_NEGOCIO.NUMEXT%TYPE
  ,PA_CPNEGOCIO            IN  EBANKING.TA_NEGOCIO.CODPOSTALNEG%TYPE
  ,PA_COLONIANEG           IN  EBANKING.TA_NEGOCIO.COLONIANEG%TYPE
  ,PA_ESTADONEGOCIO        IN  EBANKING.TA_NEGOCIO.ESTADONEG%TYPE
  ,PA_CIUDADNEGOCIO        IN  EBANKING.TA_NEGOCIO.CIUDAD%TYPE
  ,PA_LADA                 IN  EBANKING.TA_NEGOCIO.LADA%TYPE
  ,PA_TELEFONO             IN  EBANKING.TA_NEGOCIO.TELNEG%TYPE        
  ,PA_SITIOWEB             IN  EBANKING.TA_NEGOCIO.PAGWEB%TYPE
  ,PA_USUARIOMODIFICO      IN  EBANKING.TA_NEGOCIO.USUARIO_MODIFICO%TYPE
  ,PA_FECHAMOD             IN  EBANKING.TA_NEGOCIO.FECHA_MODIFICO%TYPE
  ,PA_CORREO               IN  EBANKING.TA_NEGOCIO.CORREONEG%TYPE
  ,PA_NUMFORM              IN  EBANKING.TA_NEGOCIO.NUMFORM%TYPE
  ,PA_PORCENTAJE           IN  EBANKING.TA_NEGOCIO.PORCENTAJE%TYPE
  ,PA_GRABADO              IN  EBANKING.TA_NEGOCIO.GRABADO%TYPE
  ,PA_NUMINT               IN  EBANKING.TA_NEGOCIO.NUMINT%TYPE
  ,PA_NUMEXTENSION         IN  EBANKING.TA_NEGOCIO.NUMEXTENSION%TYPE
  ,PASCOD_ERROR            OUT NUMBER
  ,PASMSG_ERROR            OUT VARCHAR2
)
IS
VL_NUMFORMULARIO           INTEGER := 2;
BEGIN
    BEGIN
          UPDATE EBANKING.TA_NEGOCIO
          SET 
              EBANKING.TA_NEGOCIO.NOMBRENEG = PA_NOMBRENEGOCIO
              ,EBANKING.TA_NEGOCIO.RFC = PA_RFC
              ,EBANKING.TA_NEGOCIO.SECTORLAB = PA_SECTLABORAL
              ,EBANKING.TA_NEGOCIO.CALLENEG = PA_CALLENEGOCIO
              ,EBANKING.TA_NEGOCIO.NUMEXT = PA_NUMNEGOCIO
              ,EBANKING.TA_NEGOCIO.CODPOSTALNEG = PA_CPNEGOCIO
              ,EBANKING.TA_NEGOCIO.COLONIANEG = PA_COLONIANEG
              ,EBANKING.TA_NEGOCIO.ESTADONEG = PA_ESTADONEGOCIO
              ,EBANKING.TA_NEGOCIO.CIUDAD = PA_CIUDADNEGOCIO
              ,EBANKING.TA_NEGOCIO.LADA = PA_LADA
              ,EBANKING.TA_NEGOCIO.TELNEG = PA_TELEFONO
              ,EBANKING.TA_NEGOCIO.PAGWEB = PA_SITIOWEB
              ,EBANKING.TA_NEGOCIO.USUARIO_MODIFICO = PA_USUARIOMODIFICO
              ,EBANKING.TA_NEGOCIO.FECHA_MODIFICO = PA_FECHAMOD
              ,EBANKING.TA_NEGOCIO.CORREONEG = PA_CORREO
              ,EBANKING.TA_NEGOCIO.NUMFORM = VL_NUMFORMULARIO
              ,EBANKING.TA_NEGOCIO.PORCENTAJE = PA_PORCENTAJE 
              ,EBANKING.TA_NEGOCIO.GRABADO = PA_GRABADO 
              ,EBANKING.TA_NEGOCIO.NUMINT = PA_NUMINT 
              ,EBANKING.TA_NEGOCIO.NUMEXTENSION =PA_NUMEXTENSION
        WHERE  PA_FOLIOAFILIA = EBANKING.TA_NEGOCIO.IDUSUARIO;
            
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        COMMIT;
     EXCEPTION                                                                                                                                                                                     
             WHEN OTHERS THEN
                  PASCOD_ERROR:=1;
                  PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
                  ROLLBACK;
                  RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
     END;
END SP_UPD_INFONEG;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                   SP_UPD_SWIFT( VALOR_CLAVE_VIEJO IN VARCHAR2, VALOR_CLAVE_NUEVO IN VARCHAR2 ) 
AS
existe number;
PASCOD_ERROR number;
PASMSG_ERROR varchar2( 1000 );

BEGIN
        
    SELECT COUNT(CLAVE) INTO existe FROM EBANKING.SWIFTABA WHERE CLAVE = VALOR_CLAVE_VIEJO;
    
    IF(existe = 1) THEN
        UPDATE EBANKING.SWIFTABA SET CLAVE = VALOR_CLAVE_NUEVO WHERE CLAVE = VALOR_CLAVE_VIEJO;
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO UPDATE';
        COMMIT;
    END IF;
    IF(existe > 1) THEN
        PASCOD_ERROR := 1;
        PASMSG_ERROR := 'MUCHOS REGISTROS NO SE ACTUALIZA LA INFORMACION';
    END IF;
    IF(existe <= 0) THEN
        PASCOD_ERROR := -1;
        PASMSG_ERROR := 'NO EXISTE REGISTRO POR ACTUALIZAR EN LA TABLA';
    END IF;
    
EXCEPTION                                                                                                                                                                                     
    WHEN OTHERS THEN
        PASCOD_ERROR:=-2;
        PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
        ROLLBACK;
        RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');

END SP_UPD_SWIFT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE   SP_UPD_USR(
            P_FOLIOAFILIA           IN    EBANKING.ta_usuario.idusuario%TYPE
            ,P_USUARIO              IN    EBANKING.ta_usuario.usuario%TYPE
            ,P_PASSWD               IN    EBANKING.ta_usuario.passwd%TYPE
            ,P_FOLIOALNOVA          IN    EBANKING.ta_usuario.folioalnova%TYPE
            ,P_ESTATUS              IN    EBANKING.ta_usuario.estatus%TYPE
            ,P_PORCTOTAL            IN    EBANKING.ta_usuario.porcentotal%TYPE
            ,P_USUARIOMODIFICO      IN    EBANKING.ta_usuario.usuario_modifico%TYPE
            ,P_FECHAMOD             IN    EBANKING.ta_usuario.fecha_modifico%TYPE
            ,PSCod_Error            OUT   number
            ,PSMsg_Error            OUT   varchar2
)
IS
BEGIN    
        UPDATE EBANKING.ta_usuario 
        SET ta_usuario.idusuario = P_FOLIOAFILIA
            ,ta_usuario.usuario = P_USUARIO
            ,ta_usuario.passwd = P_PASSWD
            ,ta_usuario.folioalnova = P_FOLIOALNOVA
            ,ta_usuario.estatus = P_ESTATUS
            ,ta_usuario.porcentotal = P_PORCTOTAL
            ,ta_usuario.usuario_modifico = P_USUARIOMODIFICO
            ,ta_usuario.fecha_modifico = P_FECHAMOD
        WHERE ta_usuario.usuario = P_USUARIO;
                
            PSCod_Error := 0;
            PSMsg_Error := 'Actulizo registro en ta_usuario';
            COMMIT;
        EXCEPTION  
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar datos de usuario en SP_UPD_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_UPD_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_UPD_USR_ACT(
             IDALNOVA            IN    NUMBER
            ,IDALNOVA_ACT       IN    VARCHAR
            ,MAIL_IN               IN    VARCHAR2
            ,SALIDA1             OUT   VARCHAR2
            ,SALIDA2             OUT   VARCHAR2
)
IS
SALIDA3 VARCHAR(12);
BEGIN    

        
        UPDATE EBANKING.EBANKING_USER 
        SET EBANKING.EBANKING_USER.EMAIL = MAIL_IN
        WHERE EBANKING.EBANKING_USER.ID = IDALNOVA;
        
        
            
        IF SQL%FOUND THEN
            SALIDA1 := 'CORRECTO'; 
        ELSE
            SALIDA1:='ERROR';
        END IF;
        
        

        UPDATE EBANKING.PREACTIVE_USER
        SET EBANKING.PREACTIVE_USER.MAIL = MAIL_IN
        WHERE EBANKING.PREACTIVE_USER.ID_ALNOVA = IDALNOVA_ACT;
        
        IF SQL%FOUND THEN
            SALIDA3 := 'CORRECTO2'; 
        ELSE
            SALIDA3:='ERROR2';
        END IF;
        

        
       
        
        
            
        UPDATE EBANKING.EBANKING_ACTIVATION
        SET EBANKING.EBANKING_ACTIVATION.EMAIL = MAIL_IN
        WHERE EBANKING.EBANKING_ACTIVATION.CLIENTE = IDALNOVA_ACT;
            
            
        IF SQL%FOUND THEN
            SALIDA2 := 'CORRECTO1 '|| SALIDA3; 
        ELSE
            SALIDA2:='ERROR1 '|| SALIDA3;
        END IF;
        
        
            
        EXCEPTION  
            WHEN OTHERS THEN
              SALIDA1:='ERROR Exception';
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error SP_UPD_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_UPD_USR_ACT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_UPD_USR_ACT1(
             IDALNOVA            IN    NUMBER
            ,IDALNOVA_ACT       IN    VARCHAR
            ,MAIL_IN               IN    VARCHAR2
            ,SALIDA1             OUT   VARCHAR2
            ,SALIDA2             OUT   VARCHAR2
)
IS
SALIDA3 VARCHAR(20);
BEGIN    

        UPDATE EBANKING.PREACTIVE_USER
        SET EBANKING.PREACTIVE_USER.MAIL = MAIL_IN
        WHERE EBANKING.PREACTIVE_USER.ID_ALNOVA = IDALNOVA_ACT;
        
        IF SQL%FOUND THEN
            SALIDA3 := 'CORRECTO2'; 
        ELSE
            SALIDA3:='ERROR2';
        END IF;
        

        EXCEPTION  
            WHEN OTHERS THEN
              SALIDA1:='ERROR Exception';
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error SP_UPD_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_UPD_USR_ACT1;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_UPD_USR_STAT(
            
            P_USUARIO              IN    EBANKING.ta_usuario.usuario%TYPE       
            ,P_FOLIOALNOVA          IN    EBANKING.ta_usuario.folioalnova%TYPE
            ,P_ESTATUS              IN    EBANKING.ta_usuario.estatus%TYPE
            ,P_PORCTOTAL            IN    EBANKING.ta_usuario.porcentotal%TYPE
            ,P_USUARIOMODIFICO      IN    EBANKING.ta_usuario.usuario_modifico%TYPE
            ,P_FECHAMOD             IN    EBANKING.ta_usuario.fecha_modifico%TYPE
            ,PSCod_Error            OUT   number
            ,PSMsg_Error            OUT   varchar2
)
IS
BEGIN    
        UPDATE EBANKING.ta_usuario 
        SET  ta_usuario.folioalnova = P_FOLIOALNOVA
            ,ta_usuario.estatus = P_ESTATUS
            ,ta_usuario.porcentotal = P_PORCTOTAL
            ,ta_usuario.usuario_modifico = P_USUARIOMODIFICO
            ,ta_usuario.fecha_modifico = P_FECHAMOD
        WHERE ta_usuario.usuario = P_USUARIO;
                
            PSCod_Error := 0;
            PSMsg_Error := 'Actulizo registro en ta_usuario';
            COMMIT;
        EXCEPTION  
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar datos de usuario en SP_UPD_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_UPD_USR_STAT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_USER_ACTIVE( P_IDALNOVA IN OUT EBANKING.EBANKING_USER.ID%TYPE,
                          ACTIVE OUT EBANKING.EBANKING_USER.ACTIVE%TYPE,
                          PSCod_Error    OUT     NUMBER
                          ,PSMsg_Error    OUT     VARCHAR2 ) IS
BEGIN
SELECT ACTIVE, ID INTO ACTIVE, P_IDALNOVA FROM EBANKING.EBANKING_USER WHERE id = p_idalnova;
PSCod_Error := 0;
    PSMsg_Error := 'Consulta exitosa';
    EXCEPTION 
    WHEN NO_DATA_FOUND THEN 
    PSCod_Error:=1;
    PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
    dbms_output.put_line( 'NO_DATA_FOUND' );
     WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar Usuario en SP_USER_ACTIVE  (' || SQLCODE || '  ' || SQLERRM || ')');
END SP_USER_ACTIVE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_USUARIO_WS
( 
          P_USUARIO       IN      EBANKING.ta_usuario.usuario%TYPE
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_STATUS       OUT     VARCHAR2
          ,P_DESC         OUT     sys_refcursor 
          
) 
AS 
/*v_rows int := 0;
v_usuario varchar2(20);*/
BEGIN
        OPEN P_DESC FOR
        SELECT 
            EBANKING.ta_usuario.usuario
        FROM EBANKING.ta_usuario
        WHERE EBANKING.ta_usuario.usuario = P_USUARIO;
        /*OPEN P_DESC FOR*/
        /*SELECT  EBANKING.ta_usuario.usuario
        into v_usuario 
        FROM EBANKING.ta_usuario
        WHERE EBANKING.ta_usuario.usuario = P_USUARIO;
    v_rows := SQL%ROWCOUNT;
    dbms_output.put_line(v_rows);*/
    
    /*IF P_DESC%rowcount >0 THEN
       P_STATUS:= '0';
       PSCod_Error := 0;
        PSMsg_Error := 'Usuario YA registrado';
    ELSE
      P_STATUS:= '1';
      PSCod_Error := 0;
      PSMsg_Error := 'Usuario NO registrado';
    END IF;*/
    
    /*IF v_rows>0 THEN
      P_STATUS:= '0';
      PSCod_Error := 0;
      PSMsg_Error := 'Usuario YA registrado';
    ELSE
      P_STATUS:= '1';
      PSCod_Error := 0;
      PSMsg_Error := 'Usuario NO registrado';
    END IF;*/
    
    PSCod_Error := 0;
    PSMsg_Error := 'Consulta exitosa';
    EXCEPTION 
                
            /*WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=0;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
              P_STATUS := '0';
            
            WHEN NO_DATA_FOUND THEN 
              PSCod_Error:=0;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              P_STATUS :=1;
              dbms_output.put_line( 'NO_DATA_FOUND' );*/
            
            WHEN OTHERS THEN
              ROLLBACK;
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              P_STATUS:= '0';
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar Usuario en SP_USUARIO_WS  (' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_USUARIO_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_VALIDACTIVATION(
     IDALNOVA   IN EBANKING.EBANKING_USER.ID%TYPE
     ,SALIDA OUT SYS_REFCURSOR
)AS

BEGIN
   OPEN SALIDA FOR SELECT COUNT(ID) FROM EBANKING.EBANKING_USER WHERE ID = IDALNOVA;
    
   EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR (-20100, 'No se encontraron datos  (' || SQLCODE || '  ' || SQLERRM || ')');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20000, 'Error al obtener IDALNOVA(' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_VALIDACTIVATION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_VALIDACTUSR
(
         P_IDALNOVA IN  VARCHAR2    
) AS 
BEGIN
        SELECT 
          ACTIVE 
        FROM EBANKING_USER
        WHERE ID=P_IDALNOVA;
   
END SP_VALIDACTUSR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_VALIDA_ACT
(
        P_IDALNOVA    IN     EBANKING.EBANKING_USER.ID%TYPE,
        PSCod_Error  OUT     NUMBER,
        PSMsg_Error  OUT     VARCHAR2,
        P_RESPUESTA  OUT     VARCHAR2
) 
AS 
    TMP_ACTIVO  INT;
BEGIN
        SELECT EU.ACTIVE INTO TMP_ACTIVO
        FROM EBANKING.EBANKING_USER EU
        WHERE EU.ID=P_IDALNOVA;
        
        PSCod_Error := 0;
        PSMsg_Error := 'EXITO';
        P_RESPUESTA := TMP_ACTIVO;
    
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar el usuario activo(' || SQLCODE || '  ' || SQLERRM || ')');
              

   
END SP_VALIDA_ACT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_VALIDA_BENEF 
(
           P_IDUSUARIO    IN      EBANKING.ta_benefafilia.IDUSUARIO%type
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_BENEF      OUT     sys_refcursor  
) 
AS 
BEGIN
    OPEN P_BENEF FOR
        SELECT 
             EBANKING.ta_benefafilia.IDUSUARIO
            ,EBANKING.ta_benefafilia.NUMBENEFICIARIO
            ,EBANKING.ta_benefafilia.APATERNO
            ,EBANKING.ta_benefafilia.AMATERNO
            ,EBANKING.ta_benefafilia.NOMBRE
            ,EBANKING.ta_benefafilia.PARENTESCO
            ,EBANKING.ta_benefafilia.GRABADO
            ,EBANKING.ta_benefafilia.PORCENTAJE
            ,EBANKING.ta_benefafilia.EMAIL
            ,EBANKING.ta_benefafilia.USUARIO_MODIFICO
            ,EBANKING.ta_benefafilia.FECHA_MODIFICO
            ,EBANKING.ta_direccionafi.CALLE
            ,EBANKING.ta_direccionafi.NUMEXT
            ,EBANKING.ta_direccionafi.NUMINT
            ,EBANKING.ta_direccionafi.CP
            ,EBANKING.ta_direccionafi.COLONIA
            ,EBANKING.ta_direccionafi.ESTADO
            ,EBANKING.ta_direccionafi.POBLACION
            ,EBANKING.ta_direccionafi.LADA
            ,EBANKING.ta_direccionafi.TELOFICINA
            ,EBANKING.ta_direccionafi.EXTENSION
           
        FROM EBANKING.ta_benefafilia, EBANKING.ta_direccionafi
        WHERE EBANKING.ta_benefafilia.IDUSUARIO =  P_IDUSUARIO 
        AND EBANKING.ta_direccionafi.IDUSUARIO = EBANKING.ta_benefafilia.IDUSUARIO 
        AND EBANKING.ta_direccionafi.IDBENEFICIARIO = EBANKING.ta_benefafilia.IDBENEFICIARIO ; 
          
        PSCod_Error := 0;
        PSMsg_Error := 'Se valido BENEF en SP_VALIDA_BENEF';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar BENEFICIARIO en SP_VALIDA_BENEF  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_BENEF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_VALIDA_CLI 
(
          P_CONTRASENA    IN      EBANKING.ta_cliente.passwd%type
          ,P_CORREO       IN      EBANKING.ta_cliente.email%type  
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_CLIENTE      OUT     sys_refcursor  
) 
AS 
BEGIN
    OPEN P_CLIENTE FOR
        SELECT 
             EBANKING.ta_cliente.IMEI
            ,EBANKING.ta_cliente.amaterno
            ,EBANKING.ta_cliente.apaterno
            ,EBANKING.ta_cliente.nombrecli
            ,EBANKING.ta_cliente.email
            ,EBANKING.ta_cliente.idcliente
            ,EBANKING.ta_cliente.passwd
            ,EBANKING.ta_cliente.preguntasecret
            ,EBANKING.ta_cliente.respuesta
            ,EBANKING.ta_cliente.TELCASA
            ,EBANKING.ta_cliente.SEXO
            ,EBANKING.ta_cliente.RFC
            ,EBANKING.ta_cliente.NUMEXT
            ,EBANKING.ta_cliente.NUMCREDELECT
            ,EBANKING.ta_cliente.LADA
            ,EBANKING.ta_cliente.FECHANAC
            ,EBANKING.ta_cliente.ESTADOCLI
            ,EBANKING.ta_cliente.ESTADOCIVIL
            ,EBANKING.ta_cliente.CURP
            ,EBANKING.ta_cliente.COLONIACLI
            ,EBANKING.ta_cliente.CODPOSTALCLI
            ,EBANKING.ta_cliente.CIUDAD
            ,EBANKING.ta_cliente.CALLECLI
            ,EBANKING.ta_cliente.ACTIVIDADECO
            ,EBANKING.ta_cliente.ACTIVIDAD
            
        FROM EBANKING.ta_cliente
        WHERE EBANKING.ta_cliente.email =  P_CORREO
        AND EBANKING.ta_cliente.passwd = P_CONTRASENA;
        PSCod_Error := 0;
        PSMsg_Error := 'Se valido Cliente en SP_VALIDA_CLIENTE';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar cliente en SP_VALIDA_CLIENTE  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_CLI;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                 SP_VALIDA_FISC
(
           PA_USUARIO       IN      EBANKING.TA_FISCAL.IDUSUARIO%TYPE
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
          ,CUR_FIS      OUT     SYS_REFCURSOR  
) 
AS 
BEGIN
    OPEN CUR_FIS FOR
        SELECT 
        	   EBANKING.TA_FISCAL.IDUSUARIO
              ,EBANKING.TA_FISCAL.CALLE
              ,EBANKING.TA_FISCAL.NUMEXT
              ,EBANKING.TA_FISCAL.NUMINT
              ,EBANKING.TA_FISCAL.CODPOSTAL
              ,EBANKING.TA_FISCAL.COLONIA
              ,EBANKING.TA_FISCAL.ESTADO
              ,EBANKING.TA_FISCAL.CIUDAD
              ,EBANKING.TA_FISCAL.LADA
              ,EBANKING.TA_FISCAL.TELEFONO
              ,EBANKING.TA_FISCAL.EXTENSION
              ,EBANKING.TA_FISCAL.USUARIO_MODIFICO
              ,EBANKING.TA_FISCAL.FECHA_MODIFICO
              
        FROM EBANKING.TA_FISCAL
        WHERE EBANKING.TA_FISCAL.IDUSUARIO =  PA_USUARIO;
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_FISC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_VALIDA_NEG 
(
           P_IDUSUARIO    IN      EBANKING.ta_negocio.IDUSUARIO%type
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_NEGOCIO      OUT     sys_refcursor  
) 
AS 
BEGIN
    OPEN P_NEGOCIO FOR
        SELECT 
             EBANKING.ta_negocio.IDUSUARIO
            ,EBANKING.ta_negocio.NOMBRENEG
            ,EBANKING.ta_negocio.RFC
            ,EBANKING.ta_negocio.CALLENEG
            ,EBANKING.ta_negocio.NUMEXT
            ,EBANKING.ta_negocio.CODPOSTALNEG
            ,EBANKING.ta_negocio.COLONIANEG
            ,EBANKING.ta_negocio.ESTADONEG
            ,EBANKING.ta_negocio.CIUDAD
            ,EBANKING.ta_negocio.CORREONEG
            ,EBANKING.ta_negocio.NUMFORM
            ,EBANKING.ta_negocio.PORCENTAJE
            ,EBANKING.ta_negocio.GRABADO
            ,EBANKING.ta_negocio.TELNEG
            ,EBANKING.ta_negocio.SECTORLAB
            ,EBANKING.ta_negocio.LADA
            ,EBANKING.ta_negocio.PAGWEB
            ,EBANKING.ta_negocio.NUMINT
            ,EBANKING.ta_negocio.NUMEXTENSION
            
            
        FROM EBANKING.ta_negocio
        WHERE EBANKING.ta_negocio.IDUSUARIO =  P_IDUSUARIO ;      
        PSCod_Error := 0;
        PSMsg_Error := 'Se valido Negocio en SP_VALIDA_NEG';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar Negocio en SP_VALIDA_NEG  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_NEG;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_VALIDA_TIT 
(
           PA_CORREO       IN      EBANKING.TA_TITULAR.EMAIL%TYPE
          ,PA_PASSWD       IN      EBANKING.TA_TITULAR.PASSWD%TYPE 
          ,PASCOD_ERROR    OUT     NUMBER
          ,PASMSG_ERROR    OUT     VARCHAR2
          ,CUR_USR         OUT    TYPES.REFCURSOR 
) 
AS 
BEGIN
    OPEN CUR_USR FOR
        SELECT 
               APATERNO
              ,AMATERNO
              ,NOMBRE
              ,IDTITULAR
              ,EMAIL
              ,PASSWD
              ,NUMFORMULARIO
              ,GRABADO
              ,PORCENTAJE
              ,FETERMINO
        FROM EBANKING.TA_TITULAR
        WHERE TA_TITULAR.EMAIL = PA_CORREO
        AND TA_TITULAR.PASSWD = PA_PASSWD;
        
        PASCOD_ERROR := 0;
        PASMSG_ERROR := 'EXITOSO';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PASCOD_ERROR:=1;
              PASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_TIT;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_VALIDA_USR 
(
          P_USUARIO       IN      EBANKING.ta_usuario.usuario%type
          ,P_PASSWD       IN      EBANKING.ta_usuario.passwd%type  
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_USR      OUT     sys_refcursor  
) 
AS 
BEGIN
    OPEN P_USR FOR
        SELECT 
              EBANKING.ta_usuario.idusuario
              ,EBANKING.ta_usuario.usuario
              ,EBANKING.ta_usuario.passwd
              ,EBANKING.ta_usuario.folioalnova
              ,EBANKING.ta_usuario.estatus
              ,EBANKING.ta_usuario.porcentotal
              ,EBANKING.ta_usuario.usuario_modifico
              ,EBANKING.ta_usuario.fecha_modifico
        FROM EBANKING.ta_usuario
        WHERE EBANKING.ta_usuario.usuario =  P_USUARIO
        AND EBANKING.ta_usuario.passwd = P_PASSWD;
          PSCod_Error := 0;
          PSMsg_Error := 'Se valido usuario en SP_VALIDA_USR';
        
    EXCEPTION    
             WHEN NO_DATA_FOUND THEN 
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'NO_DATA_FOUND' );
            WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar usuario en SP_VALIDA_USR  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALIDA_USR;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_VALPREREG_WS 
(
          P_USUARIO         IN      EBANKING.ta_usuario.usuario%type
          ,PSCod_Error      OUT     NUMBER
          ,PSMsg_Error      OUT     VARCHAR2
          ,P_USR            OUT     sys_refcursor
) 
IS
BEGIN        
          /*obtine los campos del cliente que tiene en Folio: v_folio*/
       OPEN P_USR FOR
              SELECT 
                    usr.usuario
                    ,usr.idusuario
                    ,usr.estatus  
              FROM ta_usuario usr 
              WHERE usr.usuario =  P_USUARIO;
              
              dbms_output.put_line('Existe el usuario');
              PSCod_Error := 0;
              PSMsg_Error := 'Se encontro usuario en SP_VALPREREG_WS';

        
    EXCEPTION   
            WHEN NO_DATA_FOUND THEN 
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'NO_DATA_FOUND' );
            
            WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
           
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar usuario en SP_VALPREREG_WS  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VALPREREG_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE             SP_VAL_BENEFICIARIO 
(
           P_IDUSUARIO    IN      EBANKING.ta_benefafilia.IDUSUARIO%type
          ,PSCod_Error    OUT     NUMBER
          ,PSMsg_Error    OUT     VARCHAR2
          ,P_BENEF      OUT     sys_refcursor  
) 
AS 
BEGIN
    OPEN P_BENEF FOR
        SELECT 
             EBANKING.ta_benefafilia.IDUSUARIO
            ,EBANKING.ta_benefafilia.NUMBENEFICIARIO
            ,EBANKING.ta_benefafilia.APATERNO
            ,EBANKING.ta_benefafilia.AMATERNO
            ,EBANKING.ta_benefafilia.NOMBRE
            ,EBANKING.ta_benefafilia.PARENTESCO
            ,EBANKING.ta_benefafilia.GRABADO
            ,EBANKING.ta_benefafilia.PORCENTAJE
            ,EBANKING.ta_benefafilia.EMAIL
            ,EBANKING.ta_benefafilia.USUARIO_MODIFICO
            ,EBANKING.ta_benefafilia.FECHA_MODIFICO
            ,EBANKING.ta_direccionafi.CALLE
            ,EBANKING.ta_direccionafi.NUMEXT
            ,EBANKING.ta_direccionafi.NUMINT
            ,EBANKING.ta_direccionafi.CP
            ,EBANKING.ta_direccionafi.COLONIA
            ,EBANKING.ta_direccionafi.ESTADO
            ,EBANKING.ta_direccionafi.POBLACION
            ,EBANKING.ta_direccionafi.LADA
            ,EBANKING.ta_direccionafi.TELOFICINA
            ,EBANKING.ta_direccionafi.EXTENSION
           
        FROM EBANKING.ta_benefafilia, EBANKING.ta_direccionafi
        WHERE EBANKING.ta_benefafilia.IDUSUARIO =  P_IDUSUARIO AND  EBANKING.ta_direccionafi.IDUSUARIO=EBANKING.ta_benefafilia.IDUSUARIO AND
        EBANKING.ta_direccionafi.IDBENEFICIARIO=EBANKING.ta_benefafilia.IDBENEFICIARIO ; 
          
        PSCod_Error := 0;
        PSMsg_Error := 'Se valido BENEF en SP_VAL_BENEFICIARIO';
        
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar BENEFICIARIO en SP_VALIDA_BENEF  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VAL_BENEFICIARIO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE SP_VAL_USR_WS 
(
          P_USUARIO         IN      EBANKING.ta_usuario.usuario%type
          ,P_PASSWD         IN      EBANKING.ta_usuario.passwd%type 
          ,PSCod_Error      OUT     NUMBER
          ,PSMsg_Error      OUT     VARCHAR2
          ,P_USR            OUT     sys_refcursor
) 
IS
v_rows int := 0;
v_folio varchar2(20) := '';
BEGIN
      
        /*verifica que exista el Cliente cuyo Usuario sea P_USUARIO y Contraseña P_PASSWD*/
          SELECT ta_usuario.idusuario
          into v_folio
          FROM EBANKING.ta_usuario
          WHERE ta_usuario.usuario =  P_USUARIO
          AND ta_usuario.passwd = P_PASSWD;
          
        
          
          v_rows := SQL%ROWCOUNT;
          dbms_output.put_line(v_rows);
              
        IF v_rows = 1 then
          
          /*obtine los campos del cliente que tiene en Folio: v_folio*/
          OPEN P_USR FOR
              SELECT 
                    usr.usuario
                    ,usr.idusuario
                    ,usr.estatuslogin  
                    ,cli.apaterno
                    ,cli.amaterno
                    ,cli.nombrecli
                    ,cli.actividad
                    ,cli.rfc
                    ,neg.nombreneg
                    ,cli.telcasa
                    ,cli.callecli
                    ,cli.numext
                    ,cli.ciudad
                    ,cli.coloniacli
                    ,cli.estadocli
                    ,cli.codpostalcli
              FROM ta_usuario usr, ta_cliente cli, ta_negocio neg
              WHERE usr.usuario =  P_USUARIO
              AND usr.passwd = P_PASSWD
              AND usr.idusuario = v_folio
              AND cli.idusuario = v_folio
              AND neg.idusuario = v_folio;
              
              dbms_output.put_line('Existe el usuario');
              PSCod_Error := 0;
              PSMsg_Error := 'Se encontro usuario en SP_VAL_USR_WS';
        ELSE
              dbms_output.put_line('No existe el usuario');
              PSCod_Error := 1;
              PSMsg_Error := 'No se encontro usuario en SP_VAL_USR_WS';
        END IF;
        
        
    EXCEPTION  
            WHEN NO_DATA_FOUND THEN 
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'NO_DATA_FOUND' );
            WHEN TOO_MANY_ROWS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'TOO_MANY_ROWS');
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              dbms_output.put_line( 'OTHERS' );
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al validar usuario en SP_VAL_USR_WS  (' || SQLCODE || '  ' || SQLERRM || ')');
        
END SP_VAL_USR_WS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          SP_VERIFY_PREAC(
     IDALNOVA   IN EBANKING.PREACTIVE_USER.ID_ALNOVA%TYPE
     ,ACTIVE    IN EBANKING.PREACTIVE_USER.STATUS%TYPE
     ,SALIDA OUT SYS_REFCURSOR
)AS

BEGIN
   OPEN SALIDA FOR SELECT COUNT(STATUS) AS ACTIVE FROM EBANKING.PREACTIVE_USER WHERE ID_ALNOVA = IDALNOVA AND STATUS = ACTIVE;
    
   EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR (-20100, 'No se encontraron datos  (' || SQLCODE || '  ' || SQLERRM || ')');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20000, 'Error al obtener IDALNOVA(' || SQLCODE || '  ' || SQLERRM || ')');
    
END SP_VERIFY_PREAC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          TA_ACERTUM_USER_INSERT
(USER_ID_ins IN  EBANKING.TA_ACERTUM_USER.USER_ID%TYPE,
CELLULAR_ins IN EBANKING.TA_ACERTUM_USER.CELLULAR%TYPE,
EMAIL_ins IN EBANKING.TA_ACERTUM_USER.EMAIL%TYPE,
USER2CELLCOMPANY_ins IN EBANKING.TA_ACERTUM_USER.USER2CELLCOMPANY%TYPE,
CELLULAR_OLD_ins IN EBANKING.TA_ACERTUM_USER.CELLULAR_OLD%TYPE,
EMAIL_OLD_ins IN EBANKING.TA_ACERTUM_USER.EMAIL_OLD%TYPE,
USER2CELLCOMPANY_OLD_ins IN EBANKING.TA_ACERTUM_USER.USER2CELLCOMPANY_OLD%TYPE,
USUARIO_MODIFICA_ins IN EBANKING.TA_ACERTUM_USER.USUARIO_MODIFICA%TYPE)
AS
MENSAJE varchar2(50);
BEGIN
    Insert INTO EBANKING.TA_ACERTUM_USER (USER_ID,
    CELLULAR, EMAIL , USER2CELLCOMPANY,
    CELLULAR_OLD , EMAIL_OLD ,USER2CELLCOMPANY_OLD ,
    FECHA_MODIFICACION ,ULTIMA_MODIFICACION ,
    USUARIO_MODIFICA ) values(USER_ID_ins ,CELLULAR_ins ,EMAIL_ins ,
    USER2CELLCOMPANY_ins ,CELLULAR_OLD_ins ,EMAIL_OLD_ins ,
    USER2CELLCOMPANY_OLD_ins ,sysdate ,sysdate ,USUARIO_MODIFICA_ins);
    MENSAJE:='Datos insertados correctamente';    
    DBMS_OUTPUT.PUT_LINE(MENSAJE);
    EXCEPTION WHEN OTHERS THEN
    MENSAJE:='Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM;    
    DBMS_OUTPUT.PUT_LINE(MENSAJE);
END ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          TA_ACERTUM_USER_SELECT
(ID IN  EBANKING.TA_ACERTUM_USER.USER_ID%TYPE)
AS
MENSAJE varchar2(50);
BEGIN
    SELECT * FROM TA_ACERTUM_USER WHERE USER_ID=ID;    
    MENSAJE:='SELECT EJECUTADO CORRECTAMENTE';    
    DBMS_OUTPUT.PUT_LINE(MENSAJE);
    EXCEPTION WHEN OTHERS THEN
    MENSAJE:='Un error fue encontrado - '||SQLCODE||' -ERROR- '||SQLERRM;    
    DBMS_OUTPUT.PUT_LINE(MENSAJE);
END ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE TESTINSERTCURSO (
   nombre         IN EBANKING.TESTCURSO.NOMBRE%TYPE,
   apPaterno      IN EBANKING.TESTCURSO.APELLIDOP%TYPE,
   apMaterno      IN VARCHAR2
)
AS
id number;
BEGIN

	SELECT photos_seq.NEXTVAL
	     INTO id
	     FROM DUAL;

	DBMS_OUTPUT.PUT_LINE('El siguiente id es ' || id);
		 
	IF (ID > 0) THEN
	
	    INSERT INTO EBANKING.TESTCURSO (ID,NOMBRE,APELLIDOP,APELLIDOM) VALUES(id,nombre,apPaterno,apMaterno);
	
	    COMMIT;
	
	END IF; 
		 

EXCEPTION
   WHEN OTHERS
   THEN
      ROLLBACK;

END TESTINSERTCURSO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          TESTS2PCONFIRMACIONWU(
PA_FCUID IN EBANKING.TEST2_TA_WU_CONFIRMACION.FCUID%TYPE,
FN_PSCOD OUT NUMBER,
FC_PSMSG OUT VARCHAR2
)
AS
BEGIN  
FC_PSMSG := 'OPERACION EXITOSA';
FN_PSCOD := 1;

      INSERT INTO EBANKING.TEST2_TA_WU_CONFIRMACION (FCUID)
                                  VALUES (PA_FCUID);
      COMMIT;       
END TESTS2PCONFIRMACIONWU;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          TESTSPCONFIRMACIONWU(PA_FCUID IN EBANKING.TESET_TA_WU_CONFIRMACION.FCUID%TYPE)
AS
BEGIN  
FC_PSMSG := 'OPERACION EXITOSA';
FN_PSCOD := 1;
      INSERT INTO EBANKING.TESET_TA_WU_CONFIRMACION (FCUID)
                                  VALUES (PA_FCUID);
      COMMIT;       
END TESTSPCONFIRMACIONWU;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE TESTUPDATECURSO (
   apPaternoOld      IN EBANKING.TESTCURSO.APELLIDOP%TYPE,
   apPaternoNew      IN EBANKING.TESTCURSO.APELLIDOP%TYPE
)
AS
   recTabla EBANKING.TESTCURSO%ROWTYPE;
   
   CURSOR curTabla IS
      SELECT tc.ID, tc.NOMBRE, tc.APELLIDOP, tc.APELLIDOM
        FROM EBANKING.TESTCURSO tc
    ORDER BY ID;
   
BEGIN

     OPEN 
        curTabla;
     LOOP   
        FETCH curTabla INTO recTabla;
        EXIT WHEN curTabla%NOTFOUND;
           IF 
              TRIM(recTabla.APELLIDOP) = apPaternoOld
           THEN
		   
		   	   UPDATE EBANKING.TESTCURSO 
			      SET APELLIDOP=apPaternoNew
				WHERE ID > 30;
           END IF;
     END LOOP;
     CLOSE curTabla;

   COMMIT;						 
	 
EXCEPTION
   WHEN OTHERS
   THEN
      ROLLBACK;

END TESTUPDATECURSO;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          updateFotosDate (
   pidAlbum NUMBER
)
AS
   fechaVisita  DATE;
BEGIN

   SELECT A.FECHA_VISITA
     INTO fechaVisita
     FROM ALBUM A
    WHERE A.ID = pidalbum;

   UPDATE PHOTOS P
      SET P.VISITA = fechaVisita
    WHERE P.IDALBUM = pidAlbum;

   COMMIT;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar el album  (' || SQLCODE || '  ' || SQLERRM || ')');
   WHEN OTHERS
   THEN
      RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar el album ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END updateFotosDate;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE updatepostit (
   pcomentario   VARCHAR2,
   px            FLOAT,
   py            FLOAT,
   pid           NUMBER,
   pidalbum      NUMBER,
   pidfoto       NUMBER
)
AS
BEGIN
   UPDATE postit
      SET comentario = pcomentario,
          x = px,
          y = py
    WHERE ID = pid AND idalbum = pidalbum AND idfoto = pidfoto;

   COMMIT;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END updatepostit;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_AIRTIME_FREC (
V_CLIENT                    IN      EBANKING.CompraTA_TelefonosFrecuentes.CLIENT%TYPE, 
V_CARRIER                   IN      EBANKING.CompraTA_TelefonosFrecuentes.CARRIER%TYPE,
V_TELEPHONE                 IN      EBANKING.CompraTA_TelefonosFrecuentes.TELEPHONE%TYPE,
V_OLD_TELEPHONE             IN      EBANKING.CompraTA_TelefonosFrecuentes.TELEPHONE%TYPE,
V_REFERENCE                 IN      EBANKING.CompraTA_TelefonosFrecuentes.REFERENCE%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
BEGIN

   UPDATE EBANKING.CompraTA_TelefonosFrecuentes SET REFERENCE = V_REFERENCE,
                                ULTIMA_ACTUALIZACION = SYSDATE,
                                              STATUS = ACTIVO,
                                               CANAL = V_CANAL,
                                           TELEPHONE = V_TELEPHONE
                      WHERE CLIENT = V_CLIENT AND CARRIER = V_CARRIER AND STATUS <> INACTIVO AND TELEPHONE = V_OLD_TELEPHONE;
   
   
   IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se Actualizo el registro en UPDATE_AIRTIME_FRECUENTS correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDATE_AIRTIME_FRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_AIRTIME_FREC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE update_album (
   pcomentario   VARCHAR2,
   pnombre    VARCHAR2,
   pid           NUMBER,
   VISITA		 DATE
)
AS
BEGIN
   UPDATE album
      SET comentarios = pcomentario,
          nombre = pnombre,
		  fecha_visita = visita
    WHERE ID = pid;

   COMMIT;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar el album  (' || SQLCODE || '  ' || SQLERRM || ')');
   WHEN OTHERS
   THEN
      RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar el album ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END update_album;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_CTA_OCULTA 
    (P_IDUSUARIO IN EBANKING.CTAS_OCULTAS.ID_CLI_ALNOVA%TYPE, 
     P_CUENTA IN EBANKING.CTAS_OCULTAS.CUENTA%TYPE,
     P_ESTATUS IN EBANKING.CTAS_OCULTAS.ESTATUS%TYPE,
     P_USUARIO_MODIFICO IN EBANKING.CTAS_OCULTAS.USUARIO_MODIFICO%TYPE,
     P_TIPO_CUENTA IN EBANKING.CTAS_OCULTAS.TIPO_CUENTA%TYPE,
     P_SISTEMA IN EBANKING.CTAS_OCULTAS.SISTEMA%TYPE)
     AS
 ID_CUENTA EBANKING.CTAS_OCULTAS.CUENTA%TYPE; 
BEGIN
   ID_CUENTA:=GET_USR_CTA_OCULTA(P_CUENTA,P_IDUSUARIO);
IF(ID_CUENTA<0) THEN
    INSERTAR_CTA_OCULTA (P_IDUSUARIO , P_CUENTA ,P_TIPO_CUENTA, P_ESTATUS , P_USUARIO_MODIFICO ,P_SISTEMA);
END IF;
update  EBANKING.CTAS_OCULTAS set estatus=P_ESTATUS , ultima_modificacion=sysdate , usuario_modifico=P_USUARIO_MODIFICO where (id_cli_alnova=P_IDUSUARIO and cuenta=P_CUENTA);
  
 COMMIT; 
   EXCEPTION
     WHEN OTHERS THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20000, 'Error al Actualizar cuenta en EBANKING.ACTUALIZAR_CUENTAOCULTA  (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_CTA_OCULTA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_FRCTEFSPEITER(
V_ID_CLIENTE                IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_CLIENTE%TYPE,
V_ID_TIPOTRANSFERENCIA      IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.ID_TIPOTRANSFERENCIA%TYPE,
V_CUENTA_DESTINO            IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CUENTA_DESTINO%TYPE,
V_NOMBRE_DESTINO            IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NOMBRE_DESTINO%TYPE,
V_TIPO_CUENTA_DESTINO       IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.TIPO_CUENTA_DESTINO%TYPE,
V_EMAIL_DESTINO             IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.EMAIL_DESTINO%TYPE,
V_COD_BANCO                 IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.COD_BANCO%TYPE,
V_IP_ORIGEN                 IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.IP_ORIGEN%TYPE,
V_APODO                     IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.APODO%TYPE,
V_NUM_CELULAR_DESTINO       IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_CELULAR_DESTINO%TYPE,
V_NUM_TEL_CASA              IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_CASA%TYPE,
V_NUM_TEL_OFFNA             IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.NUM_TEL_OFFNA%TYPE,
V_CARRIER_NAME              IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.CARRIER_NAME%TYPE,
V_DESCRIPCION_CUENTA        IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.DESCRIPCION_CUENTA%TYPE,
V_PLAZA                     IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.PLAZA%TYPE,
V_STATUS                    IN      EBANKING.DESTINOS_TEF_SPEI_TERCEROS.STATUS%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
NUMERO NUMBER;
SPEI   NUMBER:=2;
TEF    NUMBER:=4;
ACTIVO NUMBER:=1;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;

BEGIN

    IF V_ID_TIPOTRANSFERENCIA = SPEI or V_ID_TIPOTRANSFERENCIA = TEF THEN
        SELECT ID INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE 
          AND (ID_TIPOTRANSFERENCIA = SPEI OR ID_TIPOTRANSFERENCIA = TEF);   
    ELSE
        SELECT ID INTO NUMERO  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
        WHERE CUENTA_DESTINO = V_CUENTA_DESTINO 
          AND ID_CLIENTE = V_ID_CLIENTE
          AND ID_TIPOTRANSFERENCIA = V_ID_TIPOTRANSFERENCIA;
    END IF;
    
       UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS SET ID_CLIENTE = V_ID_CLIENTE,
                                   ID_TIPOTRANSFERENCIA = V_ID_TIPOTRANSFERENCIA,
                                         CUENTA_DESTINO = V_CUENTA_DESTINO,
                                         NOMBRE_DESTINO = V_NOMBRE_DESTINO,
                                    TIPO_CUENTA_DESTINO = V_TIPO_CUENTA_DESTINO,
                                          EMAIL_DESTINO = V_EMAIL_DESTINO,
                                    NUM_CELULAR_DESTINO = V_NUM_CELULAR_DESTINO,
                                           NUM_TEL_CASA = V_NUM_TEL_CASA,
                                          NUM_TEL_OFFNA = V_NUM_TEL_OFFNA,
                                              IP_ORIGEN = V_IP_ORIGEN,
                                     FECHA_MODIFICACION = FECHA,
                                                  PLAZA = V_PLAZA ,
                                     DESCRIPCION_CUENTA = V_DESCRIPCION_CUENTA,
                                                  APODO = V_APODO,
                                   ULTIMA_ACTUALIZACION = FECHA,
                                                  CANAL = V_CANAL,
                                                 STATUS = ACTIVO  
                                               WHERE ID = NUMERO;

    

   IF V_CARRIER_NAME IS NOT NULL THEN
        UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS SET CARRIER_NAME = V_CARRIER_NAME  
                                           WHERE ID = NUMERO;
   
   END IF;
   
   IF V_COD_BANCO IS NOT NULL THEN
        UPDATE EBANKING.DESTINOS_TEF_SPEI_TERCEROS SET COD_BANCO = V_COD_BANCO  
                                           WHERE ID = NUMERO;
   END IF;
   
   IF SQL%FOUND THEN
      PSCod_Error:=0;
      PSMsg_Error:='La Frecuente fue modificada con exito';  
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;
       

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_TEF_SPEI_TERCERO (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_TEF_SPEI_TERCERO (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_FRCTEFSPEITER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_FREC_DATA_WU_SP (
V_CU                        IN        EBANKING.BENEFICIARIOS_WU.CU%TYPE,
V_ID_BENEF                  IN        EBANKING.BENEFICIARIOS_WU.ID_BENEFICIARIO_WU%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2
)
IS
/******************************************************************************
   NAME:       UPDATE_FREC_DATA_WU_SP
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        15/05/2014      by VCT    1. Actualiza registros sobre BENEFICIARIOS_WU

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     UPDATE_FREC_DATA_WU_SP


******************************************************************************/

BEGIN
        UPDATE EBANKING.BENEFICIARIOWU 
        SET ESTATUS=-1,ULTIMA_MODIFICACION=SYSDATE WHERE CU=V_CU AND ID_BENEFICIARIO_WU=V_ID_BENEF;

   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de UPDATE_FREC_DATA_WU_SP exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar UPDATE_FREC_DATA_WU_SP';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar UPDATE_FREC_DATA_WU_SP(' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_FREC_DATA_WU_SP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE UPDATE_FREC_INTER (
V_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
V_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
V_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
V_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
V_DESTINO_OLD           IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
V_NAME_OLD              IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
V_CLAVE_SWIFT_OLD       IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
V_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
NUMERO NUMBER;
ACTIVO NUMBER:=1;
V_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;

BEGIN

    UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO,
                                                   CLIENT = V_CLIENT,
                                                  DESTINO = V_DESTINO,
                                              CLAVE_SWIFT = V_CLAVE_SWIFT,
                                                     NAME = V_NAME, 
                                                IP_ORIGEN = V_IP_ORIGEN, 
                                                    CANAL = V_CANAL, 
                                       FECHA_MODIFICACION = FECHA
    WHERE CLIENT = V_CLIENT AND DESTINO = V_DESTINO_OLD AND CLAVE_SWIFT = V_CLAVE_SWIFT_OLD AND NAME = V_NAME_OLD;

   
   IF SQL%FOUND THEN
      PSCod_Error:=0;
      PSMsg_Error:='La Frecuente fue modificada con exito';  
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;
       

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_INTER (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_INTER (' || SQLCODE || '  ' || SQLERRM || ')');

END UPDATE_FREC_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_FREC_SERVICE (      
V_USER_ID                   IN      number, 
V_REFERENCIA                IN      varchar2,
V_OLD_REFERENCIA            IN      varchar2,
V_ID_SERVICIO               IN      number,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS

ACTIVO NUMBER:=1;
V_CANAL VARCHAR(4):= 'NET';

BEGIN

   CASE V_ID_SERVICIO

        WHEN 17 THEN
                    UPDATE EBANKING.EDCULTURALES SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL, REFERENCIA = V_REFERENCIA
                                      WHERE USER_ID = V_USER_ID AND REFERENCIA = V_OLD_REFERENCIA;

--        WHEN 5  THEN 
--                    UPDATE EBANKING.INTERBUS SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL, REFERENCIA = V_REFERENCIA 
--                                       WHERE  USER_ID = V_USER_ID AND REFERENCIA = V_OLD_REFERENCIA;

--        WHEN 27 THEN
--                    UPDATE EBANKING.IUSACELL SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL, CUENTA =V_REFERENCIA 
--                                        WHERE USER_ID = V_USER_ID AND CUENTA = V_OLD_REFERENCIA;

        
--        WHEN 8  THEN
--                    UPDATE EBANKING.MOVISTAR SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL , REFERENCIA = V_REFERENCIA 
--                                        WHERE USER_ID = V_USER_ID AND REFERENCIA = V_OLD_REFERENCIA;

        WHEN 4  THEN
                    UPDATE EBANKING.SKYACCOUNTS SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL, REFERENCIA = V_REFERENCIA
                    WHERE USER_ID = V_USER_ID AND REFERENCIA = V_OLD_REFERENCIA;

        WHEN 1  THEN
                    UPDATE EBANKING.TELMEX SET ULTIMA_ACTUALIZACION = SYSDATE, STATUS = ACTIVO, CANAL = V_CANAL,TELEFONO = V_REFERENCIA
                    WHERE USER_ID = V_USER_ID AND TELEFONO = V_OLD_REFERENCIA;

        ELSE 
                    UPDATE EBANKING.ALL_FRECUENTES SET ULTIMA_ACTUALIZACION= SYSDATE, STATUS = ACTIVO, CANAL=V_CANAL, FRECUENTE=V_REFERENCIA
                    WHERE USER_ID=V_USER_ID AND ID_SERVICIO=TO_CHAR(V_ID_SERVICIO) AND FRECUENTE=V_OLD_REFERENCIA;

    END CASE;

   IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se actualizo el registro en UPDATE_FREC_PAYMENT_SERVICE correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
       COMMIT;
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPDATE_FREC_PAYMENT_SERVICE (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_FREC_SERVICE;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_FREC_TDC (
V_CLIENT                    IN      EBANKING.TDCFRECUENT.CLIENT%TYPE,
V_DESTINO                   IN      EBANKING.TDCFRECUENT.DESTINO%TYPE,
V_OLD_DESTINO               IN      EBANKING.TDCFRECUENT.DESTINO%TYPE,
V_IP_ORIGEN                 IN      EBANKING.TDCFRECUENT.IP_ORIGEN%TYPE,
V_ALIAS                     IN      EBANKING.TDCFRECUENT.ALIAS%TYPE,
V_CARD_NUMBER               IN      varchar2,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
) IS
V_PREFIJO VARCHAR2(8);
V_BANCO   VARCHAR2(30);
V_NOMBRE  VARCHAR2(100);
V_CLASE   VARCHAR2(15);
NUM       NUMBER;
FLAG      BOOLEAN := FALSE;
CONSULTA  SYS_REFCURSOR;
ACTIVO NUMBER:=1;
INACTIVO NUMBER:=0;
V_CANAL VARCHAR(4):= 'NET';
TARJETA VARCHAR(30):= 'TARJETA CREDITO AZTECA';
BEGIN
    OPEN CONSULTA FOR
            SELECT PREFIJO, BANCO, NOMBRE INTO V_PREFIJO, V_BANCO, V_NOMBRE  FROM EBANKING.EBANKING_BINES
            WHERE PREFIJO LIKE SUBSTR(V_CARD_NUMBER, 0, 6)||'%' ORDER BY PREFIJO DESC;
        LOOP
            FETCH CONSULTA INTO V_PREFIJO, V_BANCO, V_NOMBRE;   
            IF V_PREFIJO  = SUBSTR(V_CARD_NUMBER, 0,LENGTH(V_PREFIJO)) THEN
               FLAG:=TRUE;
               EXIT WHEN FLAG;
            END IF;
        END LOOP;
    
    IF FLAG THEN
    
        SELECT COUNT(DESTINO) INTO NUM FROM EBANKING.TDCFRECUENT
        WHERE (CLIENT=V_CLIENT AND NOMBRE<>TARJETA AND status=ACTIVO) and DESTINO = V_OLD_DESTINO;    
        
        IF NUM <> 0 THEN
            SELECT COUNT(CLIENT) INTO NUM FROM EBANKING.TDCFRECUENT
            WHERE CLIENT = V_CLIENT and DESTINO = V_DESTINO;
            IF NUM<>0 THEN
                UPDATE EBANKING.TDCFRECUENT set STATUS = ACTIVO,
                           FECHA_MODIFICACION = sysdate,
                                    IP_ORIGEN = V_IP_ORIGEN,
                                        BANCO = V_BANCO,
                                       NOMBRE = V_NOMBRE,
                                        ALIAS = V_ALIAS 
                where CLIENT = V_CLIENT and DESTINO = V_DESTINO;
                COMMIT;
                PSCod_Error := 0;
                PSMsg_Error := 'Se Actualizo el registro en UPDATE_FREC_ANOTHER_BANK correctamente';
            ELSE
                PSCod_Error := 5;
                PSMsg_Error := 'La Nueva frecuente ya existe';
            
            END IF;
        ELSE
            PSCod_Error := 2;
            PSMsg_Error := 'La frecuente a modificar no existe en UPDATE_FREC_ANOTHER_BANK ';
            
        END IF;
        
    ELSE
        PSCod_Error := 4;
        PSMsg_Error := 'La tarjeta es Invalida ';
    
    END IF;
    


   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDATE_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDATE_FREC_ANOTHER_BANK (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_FREC_TDC;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_FREQ_EXTCRED(
V_CLIENT                IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CLIENTE%TYPE,
V_BANK                  IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BANCO%TYPE,
V_TYPE_CREDIT           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.TIPOCREDITO%TYPE,
V_DESTINO               IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CUENTACREDITO%TYPE,
V_IP_ORIGEN             IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.IP_ORIGEN%TYPE,
V_BENEFICIARY           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BENEFICIARIO%TYPE,
V_DESTINO_OLD           IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.CUENTACREDITO%TYPE,
V_TYPE_CREDIT_OLD       IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.TIPOCREDITO%TYPE,
V_BANK_OLD              IN      EBANKING.CREDITOSOTROSBANCOSFRECUENT.BANCO%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
V_ACTIVE NUMBER:= 1;
V_CANAL VARCHAR(4):= 'NET';
V_FECHA DATE := SYSDATE;
BEGIN
    UPDATE EBANKING.CREDITOSOTROSBANCOSFRECUENT SET FECHA_MODIFICACION = V_FECHA
                                                           , IP_ORIGEN = V_IP_ORIGEN
                                                               , CANAL = V_CANAL
                                                              , STATUS = V_ACTIVE          
                                                       , CUENTACREDITO = V_DESTINO
                                                               , BANCO = V_BANK
                                                        , BENEFICIARIO = V_BENEFICIARY
                                                         , TIPOCREDITO = V_TYPE_CREDIT                                              
                                                    WHERE CLIENTE = V_CLIENT 
                                                        AND CUENTACREDITO = V_DESTINO_OLD
                                                        AND TIPOCREDITO   = V_TYPE_CREDIT_OLD 
                                                        AND BANCO         = V_BANK_OLD
                                                        AND STATUS <> 0;
    IF SQL%FOUND THEN
      PSCod_Error:=0;
      PSMsg_Error:='La Frecuente fue modificada con exito';  
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;       

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDATE_FREQ_EXTCRED (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDATE_FREQ_EXTCRED (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_FREQ_EXTCRED;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDATE_OPFRECUENTS(
V_USUARIO                   IN      EBANKING.OPERACIONES_FREC.USUARIO%TYPE,
V_ALIAS                     IN      EBANKING.OPERACIONES_FREC.ALIAS%TYPE,
V_ID_OPERACION              IN      EBANKING.OPERACIONES_FREC.ID_OPERACION%TYPE,
PSCod_Error                 OUT     number,
PSMsg_Error                 OUT     varchar2
)IS
BEGIN
      UPDATE EBANKING.OPERACIONES_FREC SET ALIAS = V_ALIAS,
                                            ULTIMA_MODIFICACION = SYSDATE
                      WHERE ID_OPERACION = V_ID_OPERACION AND USUARIO = V_USUARIO;
   
   
   IF SQL%FOUND THEN
      PSCod_Error := 0;
      PSMsg_Error := 'Se Actualizo el registro en UPDATE_AIRTIME_FRECUENTS correctamente';
   ELSE
      PSCod_Error := 1;
      PSMsg_Error := 'El frecuente no existe.';
   END IF;
   
   COMMIT;        
   
   
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al modificar en UPDATE_OPFRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
   
     WHEN OTHERS THEN
            PSCod_Error:=3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al modificar en UPDATE_OPFRECUENTS (' || SQLCODE || '  ' || SQLERRM || ')');
END UPDATE_OPFRECUENTS;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            UPDA_STATUS_RSA (
V_NUM_CLIENTE               IN     TOKENADMINPRU.STATUS_RSA.NUM_CLIENTE%TYPE, 
V_NUM_SERIE_TOKEN           IN     TOKENADMINPRU.STATUS_RSA.NUM_SERIE_TOKEN%TYPE, 
V_STATUS                    IN     TOKENADMINPRU.STATUS_RSA.STATUS%TYPE, 
V_USUARIO_MODIFICO          IN     TOKENADMINPRU.STATUS_RSA.USUARIO_MODIFICO%TYPE,
PSCod_Error                OUT    number,
PSMsg_Error                OUT    varchar2
)
IS

BEGIN

     UPDATE TOKENADMINPRU.STATUS_RSA 
        SET ULTIMA_MODIFICACION=SYSDATE,USUARIO_MODIFICO=V_USUARIO_MODIFICO,FECHA_MODIFICACION=SYSDATE, STATUS= V_STATUS
        WHERE NUM_CLIENTE= V_NUM_CLIENTE
        AND NUM_SERIE_TOKEN= V_NUM_SERIE_TOKEN;
     
    PSCod_Error := 0;
    PSMsg_Error := 'actualizo registro en UPDA_STATUS_RSA correctamente';

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPDA_STATUS_RSA (' || SQLCODE || '  ' || SQLERRM || ')');

END  UPDA_STATUS_RSA ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPDT_FREC_WUSP (
    V_CU                        IN        EBANKING.BENEFICIARIOWU.CU%TYPE,
V_ID_BENEF                  IN        EBANKING.BENEFICIARIOWU.ID_BENEFICIARIO_WU%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2
)
IS
/******************************************************************************
   NAME:       UPDT_FREC_WUSP
   PURPOSE:    

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        15/05/2014      by VCT    1. Actualiza registros sobre BENEFICIARIOS_WU
                                            Se toman como eliminado con estatus-1          

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     UPDT_FREC_WUSP


******************************************************************************/

BEGIN
        UPDATE EBANKING.BENEFICIARIOWU 
        SET ESTATUS=-1,ULTIMA_MODIFICACION=SYSDATE WHERE CU=V_CU AND ID_BENEFICIARIO_WU=V_ID_BENEF;

   COMMIT;

   PSCod_Error := 0;
   PSMsg_Error := 'Ejecucion de UPDT_FREC_WUSP exitosa';
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       PSCod_Error := 1;
       PSMsg_Error := 'Error al ejecutar UPDT_FREC_WUSP';
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al ejecutar UPDT_FREC_WUSP(' || SQLCODE || '  ' || SQLERRM || ')');
END UPDT_FREC_WUSP;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE                   UPDT_PREACTIVA
(
  PRA_ESTATUSUNO             IN    PREACTIVACION.ESTATUS%TYPE
  ,PRA_ESTATUSCERO      IN    PREACTIVACION.ESTATUS%TYPE
  
)
aS
PRASCOD_ERROR             NUMBER;
PRASMSG_ERROR             VARCHAR2(1000);
BEGIN
UPDATE EBANKING.PREACTIVACION SET ESTATUS = PRA_ESTATUSCERO  WHERE CLIENTE_ALNOVA IN (SELECT A.CLIENTE_ALNOVA FROM EBANKING.PREACTIVACION A, EBANKING.PREACTIVE_USER B, EBANKING.EBANKING_USER C,EBANKING.EBANKING_ACTIVATION D
WHERE A.ESTATUS = PRA_ESTATUSUNO AND A.CLIENTE_ALNOVA = B.ID_ALNOVA AND A.CLIENTE_ALNOVA = C.ID AND A.CLIENTE_ALNOVA = D.CLIENTE);
       
    
    PRASCOD_ERROR := 0;
    PRASMSG_ERROR := 'EXITOSO';
    COMMIT;
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PRASCOD_ERROR:=1;
              PRASMSG_ERROR:=SQLCODE || '  ' || SQLERRM;
              ROLLBACK;
              RAISE_APPLICATION_ERROR (-20100, 'NO EXITOSO  (' || SQLCODE || '  ' || SQLERRM || ')');
              
END UPDT_PREACTIVA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            UPD_DESFASE_DIS (
V_ID_ACT_DISPOSITIVO           IN     TOKENADMINPRU.STATUS_DISP.ID_ACT_DISPOSITIVO%TYPE, 
V_DESFASE_NUEVO                IN     TOKENADMINPRU.STATUS_DISP.DESFASE%TYPE, 
V_SINCRONIZACIONES             IN     TOKENADMINPRU.STATUS_DISP.SINCRONIZACIONES%TYPE,
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS
    
BEGIN

     UPDATE TOKENADMINPRU.STATUS_DISP
        SET DESFASE=V_DESFASE_NUEVO, SINCRONIZACIONES = V_SINCRONIZACIONES, ULTIMA_SINCRONIZACION = SYSDATE, ULTIMA_MODIFICACION = SYSDATE
        WHERE ID_ACT_DISPOSITIVO= V_ID_ACT_DISPOSITIVO;
     
    PSCod_Error := 0;
    PSMsg_Error := 'actualizo registro en UPD_DESFASE_DIS correctamente';

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPD_DESFASE_DIS (' || SQLCODE || '  ' || SQLERRM || ')');

END  UPD_DESFASE_DIS ;





/*
    26    Procedimiento que actualiza el estado de un token dispositivo
*/
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPD_MORAL_PER (
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE,
P_DESTINO               IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
P_NAME                  IN      EBANKING.TRANSFINTERNALFRECUENT.NAME%TYPE,
P_CLAVE_SWIFT           IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
P_IP_ORIGEN             IN      EBANKING.TRANSFINTERNALFRECUENT.IP_ORIGEN%TYPE,
P_APELLIDO_PATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_PATERNO%TYPE,
P_APELLIDO_MATERNO      IN      EBANKING.TRANSFINTERNALFRECUENT.APELLIDO_MATERNO%TYPE,
P_LUGAR_NACIMIENTO      IN      EBANKING.TRANSFINTERNALFRECUENT.LUGAR_NACIMIENTO%TYPE,
P_RAZON_SOCIAL          IN      EBANKING.TRANSFINTERNALFRECUENT.RFC%TYPE,
P_DESTINO_OLD           IN      EBANKING.TRANSFINTERNALFRECUENT.DESTINO%TYPE,
P_CLAVE_SWIFT_OLD       IN      EBANKING.TRANSFINTERNALFRECUENT.CLAVE_SWIFT%TYPE,
PSCod_Error             OUT     number,
PSMsg_Error             OUT     varchar2
) IS
ACTIVO NUMBER:=1;
PERSONA NUMBER:= 2;
P_CANAL VARCHAR(4):= 'NET';
FECHA DATE := SYSDATE;

BEGIN

    UPDATE EBANKING.TRANSFINTERNALFRECUENT SET STATUS = ACTIVO,
                                              CLAVE_SWIFT = P_CLAVE_SWIFT,
                                                     NAME = P_NAME, 
                                                IP_ORIGEN = P_IP_ORIGEN, 
                                       FECHA_MODIFICACION = FECHA,
                                         APELLIDO_PATERNO = P_APELLIDO_PATERNO,
                                         APELLIDO_MATERNO = P_APELLIDO_MATERNO,
                                         LUGAR_NACIMIENTO = P_LUGAR_NACIMIENTO,
                                           STATUS_BLOQUEO = 2,
                                                      RFC = P_RAZON_SOCIAL
    WHERE CLIENT = P_CLIENT AND DESTINO = P_DESTINO_OLD AND CLAVE_SWIFT = P_CLAVE_SWIFT_OLD AND TIPO_PERSONA = PERSONA AND STATUS = ACTIVO;
   
   IF SQL%FOUND THEN
      PSCod_Error:=0;
      PSMsg_Error:='La Frecuente de UPD_MORAL_PER fue modificada con exito';  
   ELSE
      PSCod_Error := -1;
      PSMsg_Error := 'El frecuente de UPD_MORAL_PER no existe.';
   END IF;
   
   COMMIT;
       

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
            PSCod_Error:=-2;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPD_MORAL_PER (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
            PSCod_Error:=-3;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al insertar UPD_MORAL_PER (' || SQLCODE || '  ' || SQLERRM || ')');

END UPD_MORAL_PER;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          UPD_SEM_TOK (
V_SEM_ENCRIPTADA                         IN     EBANKING.TOKEN_DISP.SEM_ENCRIPTADA%TYPE,
V_ID_ACT_DISPOSITIVO                     IN     EBANKING.TOKEN_DISP.ID_ACT_DISPOSITIVO%TYPE,
PSCod_Error                    OUT    number,
PSMsg_Error                    OUT    varchar2
)
IS
BEGIN
            UPDATE EBANKING.TOKEN_DISP
            SET SEM_ENCRIPTADA = V_SEM_ENCRIPTADA
            WHERE ID_ACT_DISPOSITIVO = V_ID_ACT_DISPOSITIVO;
            COMMIT;
    PSCod_Error := 0;
    PSMsg_Error := 'actualizacion en UPD_SEM_TOK correctamente';
EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error := 1;
            PSMsg_Error := 'Error al actualizar semilla';
            ROLLBACK;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar UPD_SEM_TOK (' || SQLCODE || '  ' || SQLERRM || ')');
END UPD_SEM_TOK;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            UPD_STATUS_DISP (
V_ID_ACT_DISPOSITIVO        IN     TOKENADMINPRU.STATUS_DISP.ID_ACT_DISPOSITIVO%TYPE,
V_ESTADO_NUEVO              IN     TOKENADMINPRU.STATUS_DISP.ESTADO%TYPE, 
PSCod_Error                 OUT    number,
PSMsg_Error                 OUT    varchar2
)
IS

BEGIN

     UPDATE TOKENADMINPRU.STATUS_DISP 
        SET ESTADO=V_ESTADO_NUEVO, ULTIMA_MODIFICACION = SYSDATE
        WHERE ID_ACT_DISPOSITIVO= V_ID_ACT_DISPOSITIVO;
     
    PSCod_Error := 0;
    PSMsg_Error := 'actualizo registro en UPD_STATUS_DISP correctamente';

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar UPD_STATUS_DISP (' || SQLCODE || '  ' || SQLERRM || ')');

END  UPD_STATUS_DISP ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            UPD_STATUS_TARJ (
V_ID_ALNOVA                  IN     TOKENADMINPRU.STATUS_TARJETA.ID_ALNOVA%TYPE,
TARJETAS_ALNOVA              IN     varchar2,
V_SISTEMA                    IN     TOKENADMINPRU.STATUS_TARJETA.SISTEMA%TYPE, 
V_PAIS                       IN     TOKENADMINPRU.STATUS_TARJETA.PAIS%TYPE,
V_ULTIMA_MODIFICACION        IN     TOKENADMINPRU.STATUS_TARJETA.ULTIMA_MODIFICACION%TYPE, 
V_USUARIO_MODIFICO           IN     TOKENADMINPRU.STATUS_TARJETA.USUARIO_MODIFICO%TYPE,
V_IP_SUCURSAL_TERMINAL       IN     TOKENADMINPRU.HIST_TARJETA.IP_SUCURSAL_TERMINAL%TYPE,
V_OPERADOR                   IN     TOKENADMINPRU.HIST_TARJETA.OPERADOR%TYPE,
V_SUCURSAL                   IN     TOKENADMINPRU.HIST_TARJETA.SUCURSAL%TYPE,
V_OPERACION                  IN     TOKENADMINPRU.HIST_TARJETA.OPERACION%TYPE,
PSCod_Error                  OUT    number,
PSMsg_Error                  OUT    varchar2
)
IS
   ID_HISTORICO                NUMBER;
BEGIN
    -- SE ACTUALIZA EL CAMPO DE STATUS A 3 DE TODAS LAS TARJETAS NO ESTEN EN LA VARIABLE TARJETAS_ALNOVA Y QUE PERTENENSCAN AL USUARIO
    
    UPDATE TOKENADMINPRU.STATUS_TARJETA
        SET STATUS=3
        WHERE ID_ALNOVA=V_ID_ALNOVA
            AND ID_TARJETA  NOT IN (TARJETAS_ALNOVA)
            AND STATUS=1;
                
    --SE INSERTAN TODAS LAS TARJETAS, QUE FUERON CANCELADAS EN LA TABLA DE HIST_TARJETA
    
        DECLARE
         CURSOR CURSOR_CANCELADOS_HIST IS
                SELECT ST.ID_ALNOVA AS NUM_CLIENTE, ST.ID_TARJETA AS NUMERO_TARJETA, SYSDATE AS FECHA_APLICACION, V_IP_SUCURSAL_TERMINAL AS IP_SUCURSAL_TERMINAL, 
                    V_OPERADOR AS OPERADOR, V_SUCURSAL AS SUCURSAL,  V_OPERACION AS OPERACION, V_SISTEMA AS SISTEMA, V_PAIS AS IDPAIS, SYSDATE AS ULTIMA_MODIFICACION,
                    V_USUARIO_MODIFICO AS USUARIO_MODIFICO
                FROM TOKENADMINPRU.STATUS_TARJETA ST
                    WHERE ST.ID_ALNOVA = V_ID_ALNOVA AND STATUS = 3
                    AND ST.ID_TARJETA NOT IN (TARJETAS_ALNOVA);
         ROW_HISTORICO                CURSOR_CANCELADOS_HIST%ROWTYPE;
         
        
       BEGIN
            OPEN CURSOR_CANCELADOS_HIST;            
            LOOP
                FETCH CURSOR_CANCELADOS_HIST INTO ROW_HISTORICO;
                EXIT WHEN CURSOR_CANCELADOS_HIST%NOTFOUND;
                --insertamos a historico como CANCELADO
                TOKENADMINPRU.ADD_HISTO_TARJE(ID_HISTORICO , ROW_HISTORICO.NUM_CLIENTE , ROW_HISTORICO.NUMERO_TARJETA , ROW_HISTORICO.FECHA_APLICACION ,
                                        ROW_HISTORICO.IP_SUCURSAL_TERMINAL , ROW_HISTORICO.OPERADOR , ROW_HISTORICO.SUCURSAL , ROW_HISTORICO.OPERACION,
                                        ROW_HISTORICO.SISTEMA , ROW_HISTORICO.IDPAIS , ROW_HISTORICO.ULTIMA_MODIFICACION , ROW_HISTORICO.USUARIO_MODIFICO,PSCod_Error, PSMsg_Error);
            END LOOP;
            CLOSE CURSOR_CANCELADOS_HIST;
        END;
             
    PSCod_Error := 0;
    PSMsg_Error := 'ACTUALIZO registros en UPD_STATUS_TARJ correctamente';

EXCEPTION
        WHEN OTHERS THEN
            PSCod_Error:=1;
            PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al actualizar en UPD_STATUS_TARJ (' || SQLCODE || '  ' || SQLERRM || ')');

END  UPD_STATUS_TARJ ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          userChanges
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,P_CLIENTE   OUT   sys_refcursor 
          
) 
AS 
BEGIN
    OPEN P_CLIENTE FOR
With
tmpcambio as ( SELECT ID,USER_ID,paso,status,fecha FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario )
 SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM tmpcambio  WHERE user_id=eu.ID AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM tmpcambio WHERE user_id=eu.ID AND paso=2 AND status=1)ult_psw_movdinero
FROM EBANKING.ebanking_user eu WHERE eu.ID=    p_usuario ; 

 PSCod_Error := 0;
  PSMsg_Error := 'Se encontro cliente en usuariosCambio';
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar cliente en usuariosCambio  (' || SQLCODE || '  ' || SQLERRM || ')');
              END userChanges;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE            USER_ACTI_DISPO (
V_NUM_CLIENTE_IN               IN     TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE,
V_TIPO                         IN     TOKENADMINPRU.STATUS_DISP.TIPO%TYPE,
V_NUM_CLIENTE_OUT              OUT    TOKENADMINPRU.STATUS_DISP.NUM_CLIENTE%TYPE
)
IS

BEGIN

     SELECT NUM_CLIENTE INTO V_NUM_CLIENTE_OUT FROM TOKENADMINPRU.STATUS_DISP 
            WHERE NUM_CLIENTE = V_NUM_CLIENTE_IN 
            AND ESTADO = 1 
            AND TIPO = V_TIPO;

EXCEPTION
        WHEN NO_DATA_FOUND THEN
            V_NUM_CLIENTE_OUT:=0;
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar USER_ACTI_DISPO (' || SQLCODE || '  ' || SQLERRM || ')');

END  USER_ACTI_DISPO ;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          USER_DATA_ACTIVACION IS



CURSOR registros 
        IS 
        SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
        FROM EBANKING.EBANKING_USER;

reg_cursor micursor%ROWTYPE;


BEGIN
    OPEN registros;
    LOOP
        FETCH registros INTO reg_cursor;
        EXIT WHEN registros%NOTFOUND;
    END LOOP
    CLOSE registros;
END EBANKING.USER_DATA_ACTIVACION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          USER_DATA_ACTIVATION(PC_CURSOR OUT TYPES.refCursor )
 IS 
 
BEGIN

      OPEN PC_CURSOR FOR
            SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
            FROM EBANKING.EBANKING_USER;
            
END USER_DATA_ACTIVATION;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          USER_DATA_ACTIVATION2(PC_CURSOR OUT TYPES.refCursor )
 IS 
 
BEGIN

      OPEN PC_CURSOR FOR
            SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
            FROM (
                (SELECT ID, ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, ULT_ACCESO, TOKEN
                FROM EBANKING.EBANKING_USER)
                    UNION
                (SELECT TO_NUMBER(CLIENTE) AS ID, ACTIVACION AS ACTIVATION, 8 AS ACTIVE, 8 AS ADVANCEDSERVICE, 8 AS TRACKING, SYSDATE AS ULT_ACCESO, 8 AS TOKEN 
                FROM EBANKING.EBANKING_ACTIVATION WHERE EBANKING.EBANKING_ACTIVATION.CLIENTE NOT IN (
                        SELECT EBANKING.EBANKING_USER.ID  FROM EBANKING.EBANKING_USER))
);
            
END USER_DATA_ACTIVATION2;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          USER_DATA_AYDNA(PC_CURSOR OUT TYPES.refCursor )

 IS 
 
 
BEGIN
      OPEN PC_CURSOR FOR
        SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
        FROM EBANKING.EBANKING_USER;
      

END USER_DATA_AYDNA;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          USER_DATA_CLIENTSPF(PC_CURSOR OUT TYPES.refCursor )
 IS 
BEGIN
      OPEN PC_CURSOR FOR
            SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
            FROM (
                (SELECT ID, ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, ULT_ACCESO, TOKEN
                FROM EBANKING.EBANKING_USER)
                    UNION ALL
                (SELECT TO_NUMBER(CLIENTE) AS ID, ACTIVACION AS ACTIVATION, 8 AS ACTIVE, 8 AS ADVANCEDSERVICE, 8 AS TRACKING, SYSDATE AS ULT_ACCESO, 8 AS TOKEN 
                FROM EBANKING.EBANKING_ACTIVATION WHERE EBANKING.EBANKING_ACTIVATION.CLIENTE NOT IN (
                        SELECT EBANKING.EBANKING_USER.ID  FROM EBANKING.EBANKING_USER))
);
          
END USER_DATA_CLIENTSPF;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          usuariosCambio
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,P_CLIENTE   OUT   sys_refcursor 
          
) 
AS 
BEGIN

    OPEN P_CLIENTE FOR
    create table
   tmpcambio
as  SELECT ID,USER ID,paso,status,fecha FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario;
 SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM tmpcambio  WHERE user_id=eu.ID AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM tmpcambio WHERE user_id=eu.ID AND paso=2 AND status=1)ult_psw_movdinero
FROM EBANKING.ebanking_user eu WHERE eu.ID=  p_usuario; 
DROP TABLE tmpcambio;
 PSCod_Error := 0;
  PSMsg_Error := 'Se encontro cliente en usuariosCambio';
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar cliente en usuariosCambio  (' || SQLCODE || '  ' || SQLERRM || ')');
              END select_usuariosBloqueados;
/

SHOW ERRORS;


CREATE OR REPLACE PROCEDURE          usuariosCambio5
( 
          p_usuario  IN  EBANKING.ebanking_user.ID %TYPE
          ,PSCod_Error  OUT     NUMBER
          ,PSMsg_Error   OUT     VARCHAR2
          ,P_CLIENTE   OUT   sys_refcursor 
          
) 
AS 
BEGIN
    OPEN P_CLIENTE FOR
    create table
   tmpcambio as  SELECT ID,USER_ID,paso,status,fecha FROM ebanking.EBANKING_CAMBIO_PWD WHERE user_id=p_usuario; 
 
 SELECT activation,cellular celular_alterno,email,telefono_oficina telefono_alterno, pwd_change_date,pwd_confirm_change_date 
,(SELECT MAX(fecha) FROM tmpcambio  WHERE user_id=eu.ID AND paso=1 AND status=1)ult_psw_acceso 
,(SELECT MAX(fecha) FROM tmpcambio WHERE user_id=eu.ID AND paso=2 AND status=1)ult_psw_movdinero
FROM EBANKING.ebanking_user eu WHERE eu.ID=  p_usuario; 
DROP TABLE tmpcambio;
 PSCod_Error := 0;
  PSMsg_Error := 'Se encontro cliente en usuariosCambio';
    EXCEPTION                                                                                                                                                                                     
            WHEN OTHERS THEN
              PSCod_Error:=1;
              PSMsg_Error:=SQLCODE || '  ' || SQLERRM;
              RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al buscar cliente en usuariosCambio  (' || SQLCODE || '  ' || SQLERRM || ')');
              END select_usuariosBloqueados;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          ACTIVACION_PAGMOV(
   CLIENTE_AL NUMBER,
   TELEFONO_PAGO VARCHAR2,
   CUENTA_ACTIVA VARCHAR2,
   UID_TELEFONO  VARCHAR2,
   USUARIO VARCHAR2 
)
RETURN INTEGER IS

var_Client NUMBER;
 
 
c_UpdateStatus CONSTANT NUMBER(1):=1;
c_ID CONSTANT NUMBER(1):=0;
c_OK CONSTANT NUMBER(1):=1;
c_Error CONSTANT NUMBER(1):=0;
 
BEGIN
      --Primero tengo que verificarque el registro no exista
    --Si NO existe entonces lo agrego como nuevo
     select CTEALNOVA INTO var_Client from EBANKING.PAGO_MOVIL_ACT
    where CTEALNOVA = CLIENTE_AL AND CUENTA=CUENTA_ACTIVA;

    UPDATE EBANKING.PAGO_MOVIL_ACT SET TELEFONO =TELEFONO_PAGO ,UID_TEL =  UID_TELEFONO,STATUS=c_UpdateStatus,
                                        ULTIMA_MODIFICACION = SYSDATE, USUARIO_MODIFICO = USUARIO
            WHERE CTEALNOVA=CLIENTE_AL AND CUENTA=CUENTA_ACTIVA;
            COMMIT;
        RETURN c_OK;


    EXCEPTION
      when no_data_found then
        INSERT INTO EBANKING.PAGO_MOVIL_ACT (ID_ACT_PAGMOV,
            CTEALNOVA, TELEFONO, CUENTA, 
             FECHA_ALTA, UID_TEL,STATUS, ULTIMA_MODIFICACION, 
             USUARIO_MODIFICO) 
             VALUES ( c_ID,CLIENTE_AL,TELEFONO_PAGO ,CUENTA_ACTIVA , SYSDATE ,UID_TELEFONO,c_UpdateStatus,SYSDATE ,USUARIO );
          COMMIT;
    --EL STATUS 1 ES ACTIVO, 0 INACTIVO    
        RETURN c_OK;
      WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR (-20102, 'Error al grabar la transaccion en NEBDPROD ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
          ROLLBACK;
          RETURN c_Error;
  END ACTIVACION_PAGMOV;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION ADD_CATWS_FALLA
 RETURN TYPES.refCursor

IS
cat_id NUMBER;
cat_status NUMBER;
datos   TYPES.refcursor;

 BEGIN
 	  BEGIN
		  SELECT CAT_SEQ.CURRVAL INTO cat_id FROM DUAL;
		  EXCEPTION WHEN NO_DATA_FOUND THEN
		  cat_id := NULL;		 
   	  END;
	   
	  IF(cat_id IS NOT NULL)
	     THEN
		 	 BEGIN
			 	  SELECT PC.STATUS INTO cat_status FROM EBANKING.PORTAL_CAT PC WHERE PC.ID = cat_id;
				  EXCEPTION WHEN NO_DATA_FOUND THEN
				  cat_status := 0;
			 END;
			 IF(cat_status IS NOT NULL)
			     THEN			   
					 IF(cat_status = 0)
					     THEN
						     INSERT INTO EBANKING.PORTAL_CAT PC (PC.ID, PC.FECHA, PC.STATUS) VALUES (0, sysdate, 1);
					 END IF;
			 END IF;	 	 
	     ELSE	 			 	 
		     INSERT INTO EBANKING.PORTAL_CAT PC (PC.ID, PC.FECHA, PC.STATUS) VALUES (0,sysdate, 1);			 			 
	  END IF;
	   
 	  BEGIN
		  SELECT CAT_SEQ.CURRVAL INTO cat_id FROM DUAL;
		  EXCEPTION WHEN NO_DATA_FOUND THEN
		  cat_id := NULL;		 
   	  END;
	  
	  IF(cat_id IS NOT NULL)
		THEN	  	  
		OPEN datos
	 	FOR
		   SELECT PC.STATUS FROM EBANKING.PORTAL_CAT PC WHERE PC.ID = cat_id;
		   RETURN datos;
		ELSE
	 RETURN datos;			 
	 END IF;
	 	 		 		   
EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en add_catws_falla (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en add_catws_falla ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END ADD_CATWS_FALLA ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          add_foto (
   pcomentario    VARCHAR2,
   pdescripcion   VARCHAR2,
   pname          VARCHAR2,
   pruta          VARCHAR2,
   pidalbum       NUMBER
)
   RETURN NUMBER
IS
   idphoto   NUMBER;
   fechaVisita  DATE;
BEGIN
   idphoto := 0;

   SELECT photos_seq.NEXTVAL
     INTO idphoto
     FROM DUAL;

   SELECT A.FECHA_VISITA
     INTO fechaVisita
     FROM ALBUM A
    WHERE A.ID = pidalbum;

   INSERT INTO photos
               (ID, comentario, descripcion, NAME, ruta, idalbum, visita
               )
        VALUES (idphoto, pcomentario, pdescripcion, pname, pruta, pidalbum, fechaVisita
               );
	commit;

   RETURN idphoto;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END add_foto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          add_interesado (
   pnombre         VARCHAR2,
   pemail          VARCHAR2,
   pnum_empleado   VARCHAR2,
   pidalbum        NUMBER,
   ptipo           VARCHAR2,
   pou             VARCHAR2
)
   RETURN NUMBER
IS
   idinteresado   NUMBER;
   numjp          NUMBER;
BEGIN
   idinteresado := 0;
   numjp := 0;

   IF ptipo = 'JP'
   THEN
      SELECT COUNT (*)
        INTO numjp
        FROM interesados i
       WHERE i.tipo = 'JP' AND i.idalbum = pidalbum;

      IF numjp > 0
      THEN
         UPDATE interesados
            SET nombre = pnombre,
                email = pemail,
                num_empleado = pnum_empleado,
                ou = pou
          WHERE idalbum = pidalbum AND tipo = 'JP';
      ELSE
         SELECT interesados_seq.NEXTVAL
           INTO idinteresado
           FROM DUAL;

         INSERT INTO interesados
                     (ID, nombre, email, num_empleado, idalbum,
                      tipo, ou
                     )
              VALUES (idinteresado, pnombre, pemail, pnum_empleado, pidalbum,
                      ptipo, pou
                     );
      END IF;
   ELSE
      SELECT interesados_seq.NEXTVAL
        INTO idinteresado
        FROM DUAL;

      INSERT INTO interesados
                  (ID, nombre, email, num_empleado, idalbum,
                   tipo, ou
                  )
           VALUES (idinteresado, pnombre, pemail, pnum_empleado, pidalbum,
                   ptipo, pou
                  );
   END IF;

   COMMIT;
   RETURN idinteresado;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END add_interesado;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION adquireterminal(
  IDTERMINAL NUMBER
  )
    RETURN VARCHAR2
  IS
  CODIGOTERMINAL VARCHAR2(10);
BEGIN
  SELECT CODE INTO CODIGOTERMINAL FROM  ALNOVA_TERMINAL
  WHERE BUSY = 0
  AND ID = IDTERMINAL
  FOR UPDATE;
   IF CODIGOTERMINAL IS NOT NULL THEN
   	  UPDATE ALNOVA_TERMINAL SET BUSY = 1
	  WHERE ID = IDTERMINAL;
      COMMIT;
   	  RETURN CODIGOTERMINAL;
   END IF;
   RETURN CODIGOTERMINAL;
   END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          ADYACENCIA_CONSECUTIVOS(p_word IN VARCHAR, p_invWord IN VARCHAR)
  RETURN INTEGER IS
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)
        INTO v_count
        FROM ebanking.ebanking_adyacencia
        WHERE longitud = 3
            AND (INSTR( p_word, adyacencia )+INSTR( p_invWord, adyacencia ))!=0;

    IF v_count IS NULL
    THEN
        v_count:=0;
    END IF;

    RETURN v_count;
EXCEPTION

    WHEN OTHERS
    THEN
        RETURN 0;
END ADYACENCIA_CONSECUTIVOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          ADYACENCIA_LETRAS(p_word IN VARCHAR)
  RETURN INTEGER IS
BEGIN
    RETURN ebanking.ADYACENCIA_PARAM( 1, 1, p_word );
END ADYACENCIA_LETRAS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          ADYACENCIA_NUMEROS(p_word IN VARCHAR)
  RETURN INTEGER IS
BEGIN
    RETURN ebanking.ADYACENCIA_PARAM( 1, 0, p_word );
END ADYACENCIA_NUMEROS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          ADYACENCIA_PARAM( p_longitud INTEGER, p_esLetra VARCHAR, p_word IN VARCHAR)
  RETURN INTEGER IS
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)
        INTO v_count
        FROM ebanking.ebanking_adyacencia
        WHERE longitud = p_longitud
            AND es_letra = p_esLetra
            AND INSTR( p_word, adyacencia )!=0;

    IF v_count IS NULL
    THEN
        v_count:=0;
    END IF;

    RETURN v_count;
EXCEPTION

    WHEN OTHERS
    THEN
        RETURN 0;
END ADYACENCIA_PARAM;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION bloqueojobs(
  STATUS NUMBER,
  JOB VARCHAR2,
  SERVER VARCHAR2,
  NUEVOSTATUS NUMBER
  )
    RETURN INTEGER
  IS
  verdadero INTEGER := 0;
  falso INTEGER := -1;

   CURSOR control_jobs_cur
   IS
      SELECT * FROM  EBANKING_CONTROL_HILOS
	  WHERE BANDERA = STATUS
	  AND NOMBRE = JOB
	  FOR UPDATE;

	BEGIN
   /* For each job fetched by the cursor... */
   FOR control_job_rec IN control_jobs_cur
   LOOP
      /*
      	Bloquear el job
      */
      UPDATE EBANKING_CONTROL_HILOS SET BANDERA = NUEVOSTATUS,LASTDATE = SYSDATE, INSTANCIA = SERVER
	  WHERE BANDERA = STATUS
	  AND NOMBRE = JOB;
      COMMIT;
	  RETURN verdadero;
   END LOOP;
   RETURN falso;
   END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          BUSQUEDA_DICCIONARIO(p_word IN VARCHAR)
  RETURN INTEGER IS
    v_count INTEGER;
BEGIN
    SELECT DISTINCT COUNT(*) COUNT
        INTO v_count
        FROM ebanking.ebanking_diccionario
        WHERE LOWER(palabra) = p_word;
    RETURN v_count;
EXCEPTION

    WHEN OTHERS
    THEN
        RETURN 0;

END BUSQUEDA_DICCIONARIO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Cambia_Telefono(
  pCliente INTEGER,
  pOldTelefono NUMBER,
  pOldCarrier NUMBER,
  pNewTelefono NUMBER,
  pNewCarrier NUMBER,
  pClave INTEGER
  )

  RETURN INTEGER IS

  vTelefono NUMBER;
  vMensajeID NUMBER;
  vMensaje NUMBER;
  verdadero INTEGER:= 1;
  falso INTEGER:= 0;

  BEGIN
	BEGIN
	  -- Si no existe cliente en la base de datos regresar ERROR
	  SELECT telefono_id INTO vTelefono FROM TELEFONO
	  		 WHERE telefono_id = pOldTelefono AND cliente_id = pCliente AND carrier_id = pOldCarrier;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    RETURN falso;
	END;

  DELETE MENSAJE WHERE telefono_id = pOldTelefono AND carrier_id = pOldCarrier;

  UPDATE TELEFONO SET telefono_id = pNewTelefono, carrier_id = pNewCarrier, status = 0
  WHERE telefono_id = pOldTelefono AND cliente_id = pCliente AND carrier_id = pOldCarrier;

  BEGIN
    -- Se inserta el mensaje en la tabla de Mensajes
	-- Ocurre si el cliente existe y el telefono existe
    SELECT SEQ_MENSAJE_ID.NEXTVAL INTO vMensajeID FROM dual;
    SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO MENSAJE VALUES (pNewTelefono, pNewCarrier, SYSDATE, 'Su clave de confirmacion para el sistema de alertas de Banco Azteca es: ' || pClave, 1, vMensajeID);
      SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
  END;
  /*
  DBMS_OUTPUT.PUT_LINE ('TELEFONO MODIFICADO ');
  DBMS_OUTPUT.PUT_LINE ('  Status: Desactivado ');
  DBMS_OUTPUT.PUT_LINE ('  Telefono Anterior:  ' || pOldTelefono);
  DBMS_OUTPUT.PUT_LINE ('  Telefono Actual:  ' || pNewTelefono);
  DBMS_OUTPUT.PUT_LINE ('  Carrier Anterior:  ' || pOldCarrier);
  DBMS_OUTPUT.PUT_LINE ('  Carrier Actual:  ' || pNewCarrier);
  DBMS_OUTPUT.PUT_LINE ('<*> Mensaje Enviado... ' || vMensaje );
  */
  COMMIT;
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Cambia_Telefono;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "CAMBIA_TELEFONOSINCLAVE"(
  pCliente INTEGER,
  pOldTelefono NUMBER,
  pOldCarrier NUMBER,
  pNewTelefono NUMBER,
  pNewCarrier NUMBER
  )

  RETURN INTEGER IS

  vTelefono NUMBER;
  vMensajeID NUMBER;
  vMensaje NUMBER;
  vCLAVE NUMBER;
  verdadero INTEGER:= 1;
  falso INTEGER:= 0;

  BEGIN
	BEGIN
	  -- Si no existe cliente en la base de datos regresar ERROR
        SELECT CLAVE INTO vCLAVE FROM TELEFONO
        WHERE telefono_id = pOldTelefono AND cliente_id = pCliente AND carrier_id = pOldCarrier;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    RETURN falso;
	END;
	BEGIN
	  -- Si no existe cliente en la base de datos regresar ERROR
	  SELECT telefono_id INTO vTelefono FROM TELEFONO
	  		 WHERE telefono_id = pOldTelefono AND cliente_id = pCliente AND carrier_id = pOldCarrier;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    RETURN falso;
	END;

  DELETE MENSAJE WHERE telefono_id = pOldTelefono AND carrier_id = pOldCarrier;

  UPDATE TELEFONO SET telefono_id = pNewTelefono, carrier_id = pNewCarrier, status = 0
  WHERE telefono_id = pOldTelefono AND cliente_id = pCliente AND carrier_id = pOldCarrier;

  BEGIN
    -- Se inserta el mensaje en la tabla de Mensajes
	-- Ocurre si el cliente existe y el telefono existe
    SELECT SEQ_MENSAJE_ID.NEXTVAL INTO vMensajeID FROM dual;
    SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO MENSAJE VALUES (pNewTelefono, pNewCarrier, SYSDATE, 'Su clave de confirmacion para el sistema de alertas de Banco Azteca es: ' || vCLAVE, 1, vMensajeID);
      SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
  END;
  /*
  DBMS_OUTPUT.PUT_LINE ('TELEFONO MODIFICADO ');
  DBMS_OUTPUT.PUT_LINE ('  Status: Desactivado ');
  DBMS_OUTPUT.PUT_LINE ('  Telefono Anterior:  ' || pOldTelefono);
  DBMS_OUTPUT.PUT_LINE ('  Telefono Actual:  ' || pNewTelefono);
  DBMS_OUTPUT.PUT_LINE ('  Carrier Anterior:  ' || pOldCarrier);
  DBMS_OUTPUT.PUT_LINE ('  Carrier Actual:  ' || pNewCarrier);
  DBMS_OUTPUT.PUT_LINE ('<*> Mensaje Enviado... ' || vMensaje );
  */
  COMMIT;
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Cambia_Telefonosinclave;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION CargaBeneficiario (numCteAlnova VARCHAR2,
nombre1New VARCHAR2, 
nombre2New VARCHAR2, 
paternoNew VARCHAR2, 
maternoNew VARCHAR2, 
parentescoNew VARCHAR2, 
edadNew VARCHAR2, 
porcentajeNew VARCHAR2)

 RETURN VARCHAR2

IS
  RESULT VARCHAR2(10);

  BEGIN

	INSERT INTO EBANKING.FI_BENEFICIARIOS_ACTUALES (FBA_CTE_ALNOVA,FBA_NOMBRE1_BENEFICIARIO,FBA_NOMBRE2_BENEFICIARIO,FBA_APELLIDOP_BENEFICIARIO,FBA_APELLIDOM_BENEFICIARIO,FBA_PARENTESCO,FBA_EDAD,FBA_PORCENTAJE,FBA_FIDE_IDE)
		VALUES (numCteAlnova, nombre1New, nombre2New, paternoNew, maternoNew, parentescoNew, edadNew, porcentajeNew,'FR100');
  COMMIT;
  
  RESULT:= 'S';
  
  RETURN RESULT;  

EXCEPTION

WHEN OTHERS
    THEN
        RETURN 'N';

END CargaBeneficiario ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          CLIENTECONOCIDO_SP (fechaInicio IN VARCHAR2)
return ;
IS
IDUSER number(20):=0;
cursor users_to_update (p_continente IN VARCHAR2) is
      select id from ebanking.EBANKING_USER_CERT_VIP where FECHA_FIN= to_date('28/02/2009','dd/mm/yyyy');

BEGIN

 OPEN users_to_update FOR
     FOR reg IN cursor_x LOOP
       DBMS_OUTPUT.PUT_LINE
           (users_to_update.id);
      END LOOP;


EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_OPERACIONES;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          CLIENTE_CONOCIDO_UPD (fechaInicio IN VARCHAR2)
 RETURN varchar2
IS
total_regs number(6);
numUser number(10);
cursor users_to_update is
        select id from ebanking.EBANKING_USER_CERT_VIP
        where FECHA_FIN= to_date('28/02/2009','dd/mm/yyyy');
BEGIN
total_regs:=0;
     FOR reg IN users_to_update LOOP
     numUser:=reg.id;
     update ebanking.ebanking_user set user_status=3 where id=numUser;
      END LOOP;
      RETURN total_regs;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END CLIENTE_CONOCIDO_UPD;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Confirma_Clave(
	   pCliente INTEGER,
	   pTelefono NUMBER
	   )

  RETURN INTEGER
  IS
  vCliente NUMBER(10);
  vTelefono NUMBER(10);
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

	BEGIN
	  -- Si no existe el telefono especificado para ese cliente regresar falso
	  SELECT telefono_id INTO vTelefono FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    RETURN falso;
	END;

  UPDATE TELEFONO SET status = 1 WHERE telefono_id = pTelefono AND cliente_id = pCliente;
  --DBMS_OUTPUT.PUT_LINE ('Cliente:  ' || vCliente );
  COMMIT;
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20007, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Confirma_Clave;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION consulta2
(
P_USUARIO VARCHAR2
)
RETURN EBANKING.TYPES.REFCURSOR
IS
CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
BEGIN
OPEN CURSOR_OUTPUT 
FOR SELECT ID_USUARIO, NOMBRE, USUARIO, CONTRASENA, TELEFONO FROM EBANKING.USUARIO
where LTRIM(RTRIM(USUARIO))= LTRIM(RTRIM(P_USUARIO));

RETURN CURSOR_OUTPUT;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          CONSULTA_OPERACIONES (fechaInicio IN VARCHAR2, fechaFin
IN VARCHAR2)
 RETURN Types.REFCURSOR
IS
numClientesMovs number(25):=0;
numClientesPagos number(25):=0;
numClientesTransf number(25):=0;
numClientesInv number(25):=0;
numClientesOtrosMovs number(25):=0;
numClientesOtros number(25):=0;
numContratos varchar(25):=0;
numContratosMovs varchar(25):=0;
numConMovs number(25):=0;
numConCli number(25):=0;
tConsultas number(25):=0;
tConsultasS number(25):=0;
tOtrasConsultas number(25):=0;
cursor_salida Types.REFCURSOR;
BEGIN

--CLIENTES PAGOS
          select  count(distinct (NUM_CLIENTE)) into numClientesPagos
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(10,25,9,43);
          --Pago de Tarjeta de Crédito otros Bancos,Pago de Servicios
          --Crédito Inmobiliario,Pago de Tarjeta de Crédito de Banco Azteca
          --Pago Tarjeta de Crédito Corporativa
--CLIENTES TRANSFERENCIAS
          select count(distinct (NUM_CLIENTE)) into numClientesTransf
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(29,2,3,4,1);
          --Transferencias Cuentas Propias,Transferencias Interbancarias
          --TEF (día siguiente),Transferencias Interbancarias SPEI (mismo día)
          --Transferencias Internacionales,Transferencias Mismo Banco
--CLIENTES INVERSIONES
          select count(distinct (NUM_CLIENTE)) into numClientesInv
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(36,33,37,34);
          --Apertura de Cuenta Socio Plus,Apertura de Cuenta
          --Socio,Apertura de Cuenta Mi Plata en Bóveda
          --Apertura de Inversión Azteca
--CLIENTES OTROS MOVIMIENTOS
          select count(distinct (NUM_CLIENTE)) into numClientesOtrosMovs
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(24,19,12,13,15,14,16,17,18,11,5,8);
          --Pago de Servicios AZTECA WEB,Pago de Servicios Ediciones
          --Culturales,Pago de Servicios IUSACELL,Pago de Servicios MOVISTAR
          --Pago de Servicios SKY,Pago de Servicios TELMEX,Pago de
          --Servicios LUZ y FUERZA del CENTRO,Pago de Servicios MaxiGas
          --Natural
          --Pago de Servicios Todito Card Max,Compra de Tiempo
          --Aire,Aportaciones Voluntarias Afore Azteca,Donativos
--CLIENTES OTROS
select count(distinct (NUM_CLIENTE)) into numClientesOtros
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(42);
 -- NUMERO DE CONTRATOS
 SELECT count (*) into numContratos
          FROM EBANKING.ebanking_user
          where activation BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy') and
TO_DATE(fechaFin,'dd/mm/yyyy') and active=1 ;
 -- NUMERO DE CONTRATOS MOVS
     select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numContratosMovs
          from dual;

--CLIENTES TOTAL MOVIMIENTOS
          select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numClientesMovs
          from dual;

-- numero de consultas y clientes
 SELECT count(*) into numConCli FROM EBANKING.EBANKING_USER USWER
WHERE USWER.ACTIVE = 1
AND USWER.ULT_ACCESO <= TO_DATE(fechaFin,'dd/mm/yyyy');
 SELECT  count(*) as NUM_OPER into numConMovs
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
SELECT  count(*) as NUM_OPER into tConsultas
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
 SELECT  count(*) as NUM_OPER into tConsultasS
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
SELECT   count(*) as NUM_OPER into tOtrasConsultas
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
 OPEN cursor_salida FOR
    -- TOTAL DE CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1000' as Concepto,'CONSULTAS' as Descripcion, numConMovs
+ tConsultas as NUM_OPER, 0 as MONTO_OPER ,numConCli as
NUM_CLIENTES , numContratos as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE CONSULTAS DE SALDOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1100' as Concepto,'CONSULTAS_DE_SALDOS' as Descripcion,
tConsultasS as NUM_OPER, 0 as
MONTO_OPER,ROUND(TO_NUMBER(tConsultasS/(tConsultasS+tOtrasConsultas)*numConCli))
as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE OTRAS CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1200' as Concepto,'OTRAS_CONSULTAS' as Descripcion,
tOtrasConsultas as NUM_OPER, 0 as MONTO_OPER,
ROUND(TO_NUMBER(tOtrasConsultas/(tConsultasS+tOtrasConsultas)*numConCli))
as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
      -- TOTAL DE MOVIMIENTOS
          SELECT  substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2000' as Concepto,'MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0) as NUM_OPER, NVL(SUM(IMPORTE),0) as MONTO_OPER,
numClientesMovs as NUM_CLIENTES, numContratosMovs as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO','PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL',
          'APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT','SERV_LUZ_FUERZA_CEN',
          'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX',
          'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS',
          'SOLICITUD token','SOLICITUD lector')
            union
     -- TOTAL DE PAGOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2100' as Concepto,'PAGOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER , NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesPagos as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO') union
     -- TOTAL DE TRANSFERENCIAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2200' as Concepto,'TRANSFERENCIAS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesTransf as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL') union
     -- TOTAL DE INVERSIONES
         SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2) as
MES, '2300' as Concepto,'INVERSIONES' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesInv as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
         WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND OPERACION
IN('APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT')union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2400' as Concepto,'OTROS MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtrosMovs as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
            'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX','SERV_LUZ_FUERZA_CEN',
            'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS')
union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '3000' as Concepto,'OTROS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtros as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
             'SOLICITUD token','SOLICITUD lector');
    RETURN cursor_salida;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||
SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||
SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_OPERACIONES;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          CONSULTA_OPERACIONES_PROD (fechaInicio IN VARCHAR2, fechaFin
IN VARCHAR2)
 RETURN Types.REFCURSOR
IS
numClientesMovs number(25):=0;
numClientesPagos number(25):=0;
numClientesTransf number(25):=0;
numClientesInv number(25):=0;
numClientesOtrosMovs number(25):=0;
numClientesOtros number(25):=0;
numContratos varchar(25):=0;
numContratosMovs varchar(25):=0;
numConMovs number(25):=0;
numConCli number(25):=0;
tConsultas number(25):=0;
tConsultasS number(25):=0;
tOtrasConsultas number(25):=0;
cursor_salida Types.REFCURSOR;
BEGIN

--CLIENTES PAGOS
          select  count(distinct (NUM_CLIENTE)) into numClientesPagos
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(10,25,9,43);
          --Pago de Tarjeta de Crédito otros Bancos,Pago de Servicios
          --Crédito Inmobiliario,Pago de Tarjeta de Crédito de Banco Azteca
          --Pago Tarjeta de Crédito Corporativa
--CLIENTES TRANSFERENCIAS
          select count(distinct (NUM_CLIENTE)) into numClientesTransf
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(29,2,3,4,1);
          --Transferencias Cuentas Propias,Transferencias Interbancarias
          --TEF (día siguiente),Transferencias Interbancarias SPEI (mismo día)
          --Transferencias Internacionales,Transferencias Mismo Banco
--CLIENTES INVERSIONES
          select count(distinct (NUM_CLIENTE)) into numClientesInv
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(36,33,37,34);
          --Apertura de Cuenta Socio Plus,Apertura de Cuenta
          --Socio,Apertura de Cuenta Mi Plata en Bóveda
          --Apertura de Inversión Azteca
--CLIENTES OTROS MOVIMIENTOS
          select count(distinct (NUM_CLIENTE)) into numClientesOtrosMovs
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(24,19,12,13,15,14,16,17,18,11,5,8);
          --Pago de Servicios AZTECA WEB,Pago de Servicios Ediciones
          --Culturales,Pago de Servicios IUSACELL,Pago de Servicios MOVISTAR
          --Pago de Servicios SKY,Pago de Servicios TELMEX,Pago de
          --Servicios LUZ y FUERZA del CENTRO,Pago de Servicios MaxiGas
          --Natural
          --Pago de Servicios Todito Card Max,Compra de Tiempo
          --Aire,Aportaciones Voluntarias Afore Azteca,Donativos
--CLIENTES OTROS
select count(distinct (NUM_CLIENTE)) into numClientesOtros
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(42);
 -- NUMERO DE CONTRATOS
 SELECT count (*) into numContratos
          FROM EBANKING.ebanking_user
          where activation BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy') and
TO_DATE(fechaFin,'dd/mm/yyyy') and active=1 ;
 -- NUMERO DE CONTRATOS MOVS
     select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numContratosMovs
          from dual;

--CLIENTES TOTAL MOVIMIENTOS
          select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numClientesMovs
          from dual;

-- numero de consultas y clientes
 SELECT count(*) into numConCli FROM EBANKING.EBANKING_USER USWER
WHERE USWER.ACTIVE = 1
AND USWER.ULT_ACCESO <= TO_DATE(fechaFin,'dd/mm/yyyy');
 SELECT  count(*) as NUM_OPER into numConMovs
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
SELECT  count(*) as NUM_OPER into tConsultas
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
 SELECT  count(*) as NUM_OPER into tConsultasS
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
SELECT   count(*) as NUM_OPER into tOtrasConsultas
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy');
 OPEN cursor_salida FOR
    -- TOTAL DE CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1000' as Concepto,'CONSULTAS' as Descripcion, numConMovs
+ tConsultas as NUM_OPER, 0 as MONTO_OPER ,numConCli as
NUM_CLIENTES , numContratos as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE CONSULTAS DE SALDOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1100' as Concepto,'CONSULTAS_DE_SALDOS' as Descripcion,
tConsultasS as NUM_OPER, 0 as
MONTO_OPER,ROUND(TO_NUMBER(tConsultasS/(tConsultasS+tOtrasConsultas)*numConCli))
as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE OTRAS CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1200' as Concepto,'OTRAS_CONSULTAS' as Descripcion,
tOtrasConsultas as NUM_OPER, 0 as MONTO_OPER,
ROUND(TO_NUMBER(tOtrasConsultas/(tConsultasS+tOtrasConsultas)*numConCli))
as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
      -- TOTAL DE MOVIMIENTOS
          SELECT  substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2000' as Concepto,'MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0) as NUM_OPER, NVL(SUM(IMPORTE),0) as MONTO_OPER,
numClientesMovs as NUM_CLIENTES, numContratosMovs as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO','PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL',
          'APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT','SERV_LUZ_FUERZA_CEN',
          'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX',
          'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS',
          'SOLICITUD token','SOLICITUD lector')
            union
     -- TOTAL DE PAGOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2100' as Concepto,'PAGOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER , NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesPagos as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO') union
     -- TOTAL DE TRANSFERENCIAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2200' as Concepto,'TRANSFERENCIAS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesTransf as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL') union
     -- TOTAL DE INVERSIONES
         SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2) as
MES, '2300' as Concepto,'INVERSIONES' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesInv as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
         WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND OPERACION
IN('APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT')union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2400' as Concepto,'OTROS MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtrosMovs as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
            'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX','SERV_LUZ_FUERZA_CEN',
            'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS')
union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '3000' as Concepto,'OTROS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtros as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
             'SOLICITUD token','SOLICITUD lector');
    RETURN cursor_salida;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||
SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||
SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_OPERACIONES_PROD;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION CONSULTA_OPERACIONES_PROD_NW (fechaInicio IN VARCHAR2, fechaFin
IN VARCHAR2)
 RETURN Types.REFCURSOR
IS
numClientesMovs number(25):=0;
numClientesPagos number(25):=0;
numClientesTransf number(25):=0;
numClientesInv number(25):=0;
numClientesOtrosMovs number(25):=0;
numClientesOtros number(25):=0;
numContratos varchar(25):=0;
numContratosMovs varchar(25):=0;
numConMovs number(25):=0;
tConsultas number(25):=0;
tConsultasS number(25):=0;
CTE_CONSULTAS number(25):=0;
CTE_OTRS_CONSULTAS number(25):=0;

cursor_salida Types.REFCURSOR;
BEGIN

--CLIENTES PAGOS
          select  count(distinct (NUM_CLIENTE)) into numClientesPagos
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(10,25,9,43);
          --Pago de Tarjeta de Crédito otros Bancos,Pago de Servicios
          --Crédito Inmobiliario,Pago de Tarjeta de Crédito de Banco Azteca
          --Pago Tarjeta de Crédito Corporativa
--CLIENTES TRANSFERENCIAS
          select count(distinct (NUM_CLIENTE)) into numClientesTransf
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(29,2,3,4,1);
          --Transferencias Cuentas Propias,Transferencias Interbancarias
          --TEF (día siguiente),Transferencias Interbancarias SPEI (mismo día)
          --Transferencias Internacionales,Transferencias Mismo Banco
--CLIENTES INVERSIONES
          select count(distinct (NUM_CLIENTE)) into numClientesInv
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(36,33,37,34);
          --Apertura de Cuenta Socio Plus,Apertura de Cuenta
          --Socio,Apertura de Cuenta Mi Plata en Bóveda
          --Apertura de Inversión Azteca
--CLIENTES OTROS MOVIMIENTOS
          select count(distinct (NUM_CLIENTE)) into numClientesOtrosMovs
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(24,19,12,13,15,14,16,17,18,11,5,8);
          --Pago de Servicios AZTECA WEB,Pago de Servicios Ediciones
          --Culturales,Pago de Servicios IUSACELL,Pago de Servicios MOVISTAR
          --Pago de Servicios SKY,Pago de Servicios TELMEX,Pago de
          --Servicios LUZ y FUERZA del CENTRO,Pago de Servicios MaxiGas
          --Natural
          --Pago de Servicios Todito Card Max,Compra de Tiempo
          --Aire,Aportaciones Voluntarias Afore Azteca,Donativos
--CLIENTES OTROS
select count(distinct (NUM_CLIENTE)) into numClientesOtros
          from EBANKING.EBANKING_BITACORA_TRAN
          WHERE FECHA_OPER BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND ID_CAT_OPERACION IN(42);
 -- NUMERO DE CONTRATOS
 SELECT count (*) into numContratos
          FROM EBANKING.ebanking_user
          where activation BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy') and
TO_DATE(fechaFin,'dd/mm/yyyy') and active=1 ;
 -- NUMERO DE CONTRATOS MOVS
     select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numContratosMovs
          from dual;

--CLIENTES TOTAL MOVIMIENTOS
          select numClientesPagos+numClientesTransf+numClientesInv+numClientesOtrosMovs+numClientesOtros into numClientesMovs
          from dual;


/* **NUEBVOS CAMIBIO  **/
-- NUMERO DE CONSULTAS
SELECT SUM(MOVIMIENTO)  AS NUM_OPER  INTO numConMovs
FROM EBANKING.ACCIONES
where  FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND TO_DATE(fechaFin,'dd/mm/yyyy')
AND operacion IN ('CONSULTAS');

/* **NUEBVOS CAMIBIO  **/
-- NUMERO DE OTRAS COPNSULTAS
SELECT  count(*) as NUM_OPER into tConsultas
FROM EBANKING.ACCIONES
where  FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND TO_DATE(fechaFin,'dd/mm/yyyy')
AND operacion IN ('MCONSULTAS','ESTADO_CUENTA' , 'MOVIMIENTOS','CONSULTA_TDC_ALNOVA','MISFINANZAS');

/* **NUEBVOS CAMIBIO  **/
--- NUMERO DE CLIENTES QUE CONSULTARON
SELECT COUNT(DISTINCT oc.CLIENTE) into CTE_CONSULTAS
FROM ebanking.operaciones_cli oc
WHERE  FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND TO_DATE(fechaFin,'dd/mm/yyyy')
AND operacion IN ('CONSULTAS');

/* **NUEBVOS CAMIBIO  **/
--- NUMERO DE CLIENTES DE OTRAS CONSULTAS

SELECT COUNT(DISTINCT oc.CLIENTE) into CTE_OTRS_CONSULTAS
FROM ebanking.operaciones_cli oc
WHERE  FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND TO_DATE(fechaFin,'dd/mm/yyyy')
AND operacion IN ('MCONSULTAS','ESTADO_CUENTA' , 'MOVIMIENTOS','CONSULTA_TDC_ALNOVA','MISFINANZAS');


/* ***** MUESTRA DETALLE DEL REPORTE DE R15****/
OPEN cursor_salida FOR
    -- TOTAL DE CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1000' as Concepto,'CONSULTAS' as Descripcion, numConMovs
+ tConsultas as NUM_OPER, 0 as MONTO_OPER ,CTE_CONSULTAS+CTE_OTRS_CONSULTAS as
NUM_CLIENTES , numContratos as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE CONSULTAS DE SALDOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1100' as Concepto,'CONSULTAS_DE_SALDOS' as Descripcion,
numConMovs as NUM_OPER, 0 as MONTO_OPER,
CTE_CONSULTAS as NUM_CLIENTES ,
'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion in('CONSULTAS')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
   -- TOTAL DE OTRAS CONSULTAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '1200' as Concepto,'OTRAS_CONSULTAS' as Descripcion,
tConsultas as NUM_OPER, 0 as MONTO_OPER,
CTE_OTRS_CONSULTAS as NUM_CLIENTES ,
'0' as NUM_CONTRATOS
          from EBANKING.OPERACIONES_CLI where operacion
in('CONSULTA_TDC_ALNOVA')
          and FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy') union
      -- TOTAL DE MOVIMIENTOS
          SELECT  substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2000' as Concepto,'MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0) as NUM_OPER, NVL(SUM(IMPORTE),0) as MONTO_OPER,
numClientesMovs as NUM_CLIENTES, numContratosMovs as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO','PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL',
          'APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT','SERV_LUZ_FUERZA_CEN',
          'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX',
          'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS',
          'SOLICITUD token','SOLICITUD lector')
            union
     -- TOTAL DE PAGOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2100' as Concepto,'PAGOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER , NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesPagos as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'CRED OTROS BANCOS','CRED_INMOBILIARIO','PAGOTDCAZTECA','TTCREDITO') union
     -- TOTAL DE TRANSFERENCIAS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2200' as Concepto,'TRANSFERENCIAS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesTransf as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
          'PROPIAS','SPEI','TEF','TERCEROS','TRANSFINTERNAL') union
     -- TOTAL DE INVERSIONES
         SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2) as
MES, '2300' as Concepto,'INVERSIONES' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesInv as NUM_CLIENTES ,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
         WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')
          AND OPERACION
IN('APECTASOCIOP','APERTCTASOC','APERTPLATABOVEDA','APERTURA_INV_AZT')union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '2400' as Concepto,'OTROS MOVIMIENTOS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtrosMovs as NUM_CLIENTES,'0' as
NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
            'SERVICIOS_AZTECAWEB','SERVICIOS_EDCULTUR','SERVICIOS_IUSACELL','SERVICIOS_MOVISTAR','SERVICIOS_SKY','SERVICIOS_TELMEX','SERV_LUZ_FUERZA_CEN',
            'SERV_MAXIGASNAT','SERV_TODITOCARDMAX','TIEMPOAIRE_IUSACELL','TIEMPOAIRE_MOVISTAR','TIEMPOAIRE_UNEFON','TSUNAMI','APORVOLUNTARIAS')
union
     -- TOTAL DE OTROS MOVIMIENTOS
          SELECT substr(fechaInicio,7,4) as ANIO,substr(fechaInicio,4,2)
as MES, '3000' as Concepto,'OTROS' as Descripcion,
NVL(SUM(MOVIMIENTO),0)as NUM_OPER, NVL(SUM(IMPORTE),0)as
MONTO_OPER,numClientesOtros as NUM_CLIENTES,'0' as NUM_CONTRATOS
          FROM EBANKING.MOVIMIENTOS
          WHERE FECHA BETWEEN TO_DATE(fechaInicio,'dd/mm/yyyy')  AND
TO_DATE(fechaFin,'dd/mm/yyyy')  AND OPERACION IN(
             'SOLICITUD token','SOLICITUD lector');
    RETURN cursor_salida;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||
SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||
SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_OPERACIONES_PROD_NW;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION CONSULTA_TOKEN_SOLICITUD (fechaInicio IN VARCHAR2, fechaFin
IN VARCHAR2)
 RETURN Types.REFCURSOR
IS
cursor_salida Types.REFCURSOR;
BEGIN

SELECT S.NUM_CTE,S.NOM_CTE, S.APE_PAT_CTE,S.APE_MAT_CTE, S.TEL_ENT AS "TELEFONO SOLICITUD",S.TEL_ADI_ENT AS "TELEFONO SOL ADICIONAL", S.EMAIL, S.SKU1
, E.CELLULAR AS "CELULAR REGISTRO", E.TELEFONO_OFICINA AS "OFICINA REGISTRO"
FROM EBANKING.EBANKING_TOKEN_SOLICITUD S , EBANKING.EBANKING_USER E
WHERE (TRUNC(S.FECHA_SOL_INTERNET)>='09/06/2009' AND TRUNC(S.FECHA_SOL_INTERNET)<='16/06/2009')
AND E.ID = S.NUM_CTE AND SKU1>0;

RETURN cursor_salida;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_TOKEN_SOLICITUD;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION "CONSULTA_TRANSFERENCIAS" (fechaInicio IN VARCHAR2, fechaFin IN VARCHAR2)

 RETURN Types.REFCURSOR
IS
montoTransProg float (30):=0;
numTransProg number (30):=0;

numMov number (30):=0;
numImp float (30):=0;

cursor_out Types.REFCURSOR;
BEGIN
       SELECT TO_Number(sum(substr(REQUEST, instr(REQUEST,'~OPEAMT/')+8,16))/100) into montoTransProg
       FROM EBANKING.SCHEDULED_PAYMENT WHERE APPLY_DATE BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') and TO_DATE(fechaFin,'yyyy-mm-dd')
AND
      (TX_NAME = 'SPEI' or TX_NAME = 'TEF');

      SELECT count(*) into numTransProg
      FROM EBANKING.SCHEDULED_PAYMENT WHERE APPLY_DATE BETWEEN
	  TO_DATE(fechaInicio,'yyyy-mm-dd') and TO_DATE(fechaFin,'yyyy-mm-dd')

AND
      (TX_NAME = 'SPEI' or TX_NAME = 'TEF');

	  select  SUM(MOVIMIENTO) as CANTIDAD into numMov
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN('SPEI');


	  select  SUM(IMPORTE) as MONTO into numImp
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN('SPEI');

 OPEN cursor_out FOR
      SELECT fechaInicio as Fecha, fechaFin as periodo,'4.1.1' as SECCI,'1806' as CLAV,'0000' as CONCEPTO,
	  count(*) as CANTIDAD, TO_Number(sum(substr(REQUEST, instr(REQUEST,'~OPEAMT/')+8, 16))/100) as MONTO, '5' as Id_Interfaz
	  FROM EBANKING.SCHEDULED_PAYMENT
	  WHERE APPLY_DATE BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') and TO_DATE(fechaFin,'yyyy-mm-dd')
 AND
      TX_NAME = 'SPEI'
      union
      select fechaInicio as Fecha, fechaFin as periodo,'4.1.1' as SECCI,'1802' as CLAV,'0000' as CONCEPTO, SUM(MOVIMIENTO) as CANTIDAD,
	  SUM(IMPORTE) as MONTO, '5' as Id_Interfaz
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd')  AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN(
      'TERCEROS')
      union
      select fechaInicio as Fecha, fechaFin as periodo,'4.1.1' as SECCI,'1803' as CLAV,'0000' as CONCEPTO, SUM(MOVIMIENTO) as CANTIDAD,
	  SUM(IMPORTE) as MONTO, '5' as Id_Interfaz
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd')  AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN('PROPIAS')
      union
      select fechaInicio as Fecha, fechaFin as periodo,'4.1.1' as SECCI,'1805' as CLAV,'0000' as CONCEPTO, SUM(MOVIMIENTO) as CANTIDAD,
	  SUM(IMPORTE) as MONTO, '5' as Id_Interfaz
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN('SPEI')
      union
      SELECT fechaInicio as Fecha, fechaFin as periodo,'4.1.2' as SECCI,'1808' as CLAV,'0000' as CONCEPTO, SUM(MOVIMIENTO) as CANTIDAD,
	  SUM(IMPORTE) as MONTO, '5' as Id_Interfaz
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd')  AND TO_DATE(fechaFin,'yyyy-mm-dd')  AND OPERACION IN('TRANSFINTERNAL')
	  GROUP BY OPERACION
      union
      select fechaInicio as Fecha, fechaFin as periodo,'4.1.3' as SECCI,'1816' as CLAV,'0000' as CONCEPTO, count(*) as  CANTIDAD,
	  0 as MONTO,'5' as Id_Interfaz
      from EBANKING.EBANKING_USER
      WHERE activation between TO_DATE(fechaInicio,'yyyy-mm-dd')  AND TO_DATE(fechaFin,'yyyy-mm-dd') and active=1
	  union
      select fechaInicio as Fecha, fechaFin as periodo,'4.2.1' as SECCI,'1801' as CLAV,'1510' as CONCEPTO, SUM(MOVIMIENTO) as CANTIDAD,
	  SUM(IMPORTE) as MONTO, '5' as Id_Interfaz
      FROM EBANKING.MOVIMIENTOS
      WHERE FECHA BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd')  AND TO_DATE(fechaFin,'yyyy-mm-dd')
	  AND (OPERACION IN('TERCEROS') OR OPERACION IN('PROPIAS'))
	  union
	  SELECT fechaInicio as Fecha, fechaFin as periodo,'4.2.1' as SECCI,'1804' as CLAV,'1510' as CONCEPTO,
	  count(*) + numMov as CANTIDAD, TO_Number(sum(substr(REQUEST, instr(REQUEST,'~OPEAMT/')+8, 16))/100)+ numImp as MONTO, '5' as Id_Interfaz
	  FROM EBANKING.SCHEDULED_PAYMENT
	  WHERE SCHEDULED_PAYMENT.APPLY_DATE BETWEEN TO_DATE(fechaInicio,'yyyy-mm-dd') and TO_DATE(fechaFin,'yyyy-mm-dd')

	   ;
 RETURN cursor_out;
EXCEPTION

        WHEN NO_DATA_FOUND THEN
                 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||
SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
                 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||
SQLCODE || '  ' || SQLERRM ||  '  *)');
END CONSULTA_TRANSFERENCIAS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION CREATE_ALBUM(nombreAlbum in varchar2) RETURN INTEGER IS
idAlbum INTEGER;
BEGIN
	 idAlbum := 0;
	 select album_seq.nextval into idAlbum from dual;

	 INSERT INTO ALBUM(ID,NOMBRE,ENVIADO) VALUES(idAlbum, nombreAlbum,'N');
	 RETURN idAlbum;
   EXCEPTION
     WHEN OTHERS THEN
       return 0;
END CREATE_ALBUM;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION CUENTA_EXISTE (pCuenta number)
RETURN INTEGER IS
  vCuenta number(14);
  BEGIN
	BEGIN
	  -- Si no existe cuenta en la base de datos regresar ERROR
	  select cuenta_id into vCuenta from cliente where cuenta_id = pCuenta;
	  EXCEPTION
	  when no_data_found then
        DBMS_OUTPUT.PUT_LINE ('ERROR: Cuenta ['||pCuenta||'] no existe');
	    return 0;
	END;
  return 1;
  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    return 0;
  END CUENTA_EXISTE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          deleteFixFoto (
    pid         NUMBER,
    pidalbum    NUMBER)
   RETURN VARCHAR2
IS
   vFixPhoto   VARCHAR2(50);
BEGIN
   SELECT PH.FIX_NAME
     INTO vFixPhoto
     FROM PHOTOS PH
    WHERE PH.ID = pid AND PH.IDALBUM = pidalbum;

   UPDATE   PHOTOS ph
      SET   PH.FIX_NAME = NULL, PH.FIXFOTOUPDATE = NULL
    WHERE   ID = pid AND IDALBUM = pidalbum;

   COMMIT;

   RETURN vFixPhoto;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END deleteFixFoto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          DESACTIVACION_PAGMOV(
   CLIENTE_AL NUMBER,
   USUARIO VARCHAR2
)
RETURN INTEGER IS

var_Client NUMBER(10);

c_BuscStatus CONSTANT NUMBER(1):=1;
c_UpdateStatus CONSTANT NUMBER(1):=0;
c_SinActivar CONSTANT NUMBER(1):=2;
c_Desactivado CONSTANT NUMBER(1):=1;
c_Error CONSTANT NUMBER(1):=0;

BEGIN

 BEGIN
      --Primero tengo que verificarque el registro no exista
    --Si NO existe entonces lo agrego como nuevo
     select CTEALNOVA into var_Client from EBANKING.PAGO_MOVIL_ACT
    where CTEALNOVA = CLIENTE_AL AND STATUS=c_BuscStatus;

    EXCEPTION
      when no_data_found then
        RETURN c_SinActivar;
  END;

    

   UPDATE EBANKING.PAGO_MOVIL_ACT SET STATUS=c_UpdateStatus, ULTIMA_MODIFICACION = SYSDATE, USUARIO_MODIFICO = USUARIO
            WHERE CTEALNOVA=CLIENTE_AL AND STATUS=c_BuscStatus;
            COMMIT;
    RETURN c_Desactivado;
  
  EXCEPTION 
      WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR (-20102, 'Error al grabar la transaccion en NEBDPROD ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
          ROLLBACK;
          RETURN c_Error;
END DESACTIVACION_PAGMOV;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_CREDEXTFRECUENT(
    pCliente number,
	pBanco number,
	pTipoCredito number,
	pCuentaCredito varchar,
	pIpOrigen varchar
  )
  RETURN INTEGER IS

  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  update CREDITOSOTROSBANCOSFRECUENT set status = 0, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where cliente = pCliente
  and cuentaCredito = pCuentaCredito
  and tipoCredito = pTipoCredito
  and banco = pBanco;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END DESACTIVA_CREDEXTFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Desactiva_Internalfrecuent(
    pClient NUMBER,
	pDestino VARCHAR,
	pClave_swift VARCHAR,
	pIpOrigen VARCHAR
  )
  RETURN INTEGER IS

  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  UPDATE TRANSFINTERNALFRECUENT SET status = 0, fecha_modificacion = SYSDATE, ip_origen = pIPOrigen
  WHERE client = pClient AND clave_swift=pClave_swift AND destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
    RETURN 0;
  END Desactiva_Internalfrecuent;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_SPEIFRECUENT(
    pClient number,
	pDestino number,
	pIpOrigen varchar
  )
  RETURN INTEGER IS

  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  update TEFSPEUAFRECUENT set status = 0, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where client = pClient and state = -2 and plaza = -2 and destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END DESACTIVA_SPEIFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_SPEUAFRECUENT(
    PCLIENT NUMBER,
	PDESTINO NUMBER,
	PIPORIGEN VARCHAR
  )
  RETURN INTEGER IS

  BEGIN
  --SI EL REGISTRO EXISTE. MODIFICAR STATUS A INACTIVO, FECHA DE MODIFICACION, IPORIGEN
  UPDATE TEFSPEUAFRECUENT SET STATUS = 0, FECHA_MODIFICACION = SYSDATE, IP_ORIGEN = PIPORIGEN
  WHERE CLIENT = PCLIENT AND STATE >= 0 AND DESTINO = PDESTINO;
  COMMIT;
  RETURN 1;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
    RETURN 0;
  END DESACTIVA_SPEUAFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_TDCFRECUENT(
    pClient number,
	pDestino number,
	pIpOrigen varchar
  )
  RETURN INTEGER IS
  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  update TDCFRECUENT set status = 0, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where client = pClient and destino = pDestino;
  COMMIT;
  RETURN 1;
  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END DESACTIVA_TDCFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_TEFFRECUENT(
    pClient number,
	pDestino number,
	pIpOrigen varchar
  )
  RETURN INTEGER IS

  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  update TEFSPEUAFRECUENT set status = 0, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where client = pClient and state = -1 and plaza = -1 and destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END DESACTIVA_TEFFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION DESACTIVA_TERCEROSFRECUENT(
    pClient number,
	pDestino number,
	pIpOrigen varchar
  )
  RETURN INTEGER IS

  BEGIN
  --Si el registro existe. Modificar status a INACTIVO, fecha de modificacion, IpOrigen
  update TERCEROSFRECUENT set status = 0, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where client = pClient and destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END DESACTIVA_TERCEROSFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          DESCRYPTREQUEST (CADENA in VARCHAR2, LLAVE in VARCHAR2, ORIGEN INTEGER)
RETURN Varchar2 IS 
CADENA_DESENCRIPTADA VARCHAR2(3000);
STATUS_ENCRIPTADO BOOLEAN;
VALIDACION_ORIGEN CONSTANT VARCHAR2(48):='Error en Parametros';
CLAVE CONSTANT VARCHAR2(12):='|Encriptado';
ERROR_DESENCRIPTACION CONSTANT VARCHAR2(6):='ERROR';
BEGIN 
  IF(ORIGEN IS NULL )THEN
     return VALIDACION_ORIGEN;
  END IF;
  IF (instr( CADENA,CLAVE ) > 0) 
     THEN
        CADENA_DESENCRIPTADA:= substr(CADENA, 0, instr(CADENA,CLAVE)-1);
        CADENA_DESENCRIPTADA:= dbms_obfuscation_toolkit.des3decrypt( input_string =>UTL_RAW.cast_to_varchar2(HEXTORAW (CADENA_DESENCRIPTADA)), key_string =>LLAVE );  
        CADENA_DESENCRIPTADA:=RTRIM(CADENA_DESENCRIPTADA); 
        STATUS_ENCRIPTADO:=TRUE; 
     ELSE
        CADENA_DESENCRIPTADA:=CADENA;
        STATUS_ENCRIPTADO:=FALSE;         
  END IF;
  IF(ORIGEN=1)
   THEN
      RETURN CADENA_DESENCRIPTADA;    
    ELSE
     
       IF (NOT STATUS_ENCRIPTADO) 
        THEN
            CADENA_DESENCRIPTADA:=ERROR_DESENCRIPTACION;    
       END IF;         
       
    RETURN CADENA_DESENCRIPTADA;
        
   END IF;   
EXCEPTION
 WHEN OTHERS THEN
     CADENA_DESENCRIPTADA:=ERROR_DESENCRIPTACION|| SQLERRM ;
     return CADENA_DESENCRIPTADA;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION EliminaBeneficiarios (fide VARCHAR2, cte_alnova VARCHAR2)
 RETURN VARCHAR2

IS
  RESULT VARCHAR2(10);

  BEGIN

  DELETE FROM EBANKING.FI_BENEFICIARIOS_ACTUALES WHERE  FBA_CTE_ALNOVA = cte_alnova AND FBA_FIDE_IDE = fide;
  COMMIT;
  
  RESULT:= 'S';
  
  RETURN RESULT;  

EXCEPTION

WHEN OTHERS
    THEN
        RETURN 'N';

END EliminaBeneficiarios ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Eliminar_Telefono (
pCliente INTEGER,
pTelefono NUMBER
)

RETURN INTEGER
IS
  vCliente NUMBER(10);
  vTelefono NUMBER(10);
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN
	BEGIN
	  -- Si no existe telefono en la base de datos regresar ERROR
	  SELECT telefono_id INTO vTelefono FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
        --DBMS_OUTPUT.PUT_LINE ('ERROR: Telefono ['||pTelefono||'] no existe');
	    RETURN falso;
	END;

  DELETE MENSAJE WHERE telefono_id = pTelefono;
  COMMIT;
  DELETE TELEFONO WHERE telefono_id = pTelefono AND cliente_id = pCliente;
  --DBMS_OUTPUT.PUT_LINE ('Telefono ['||vTelefono||'] eliminado');
  COMMIT;
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
    RETURN verdadero;
  END Eliminar_Telefono;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION ENCRYPTREQUEST (CADENA IN VARCHAR2,  LLAVE IN VARCHAR2 )
RETURN VARCHAR2 IS 
CADENA_ENCRIPTADA VARCHAR2(3000);
CADENA_ENCRIPTAR VARCHAR2(3000);
BEGIN 
     CADENA_ENCRIPTAR:=RPAD (CADENA, (8 * ROUND (LENGTH (CADENA) / 8, 0) + 8)); 
     CADENA_ENCRIPTADA := dbms_obfuscation_toolkit.des3encrypt (input_string => CADENA_ENCRIPTAR, key_string => LLAVE);
     CADENA_ENCRIPTADA := RAWTOHEX (UTL_RAW.cast_to_raw (CADENA_ENCRIPTADA))||'|Encriptado';
     RETURN CADENA_ENCRIPTADA; 

EXCEPTION
 WHEN OTHERS THEN
     CADENA_ENCRIPTAR:=CADENA;
     RETURN CADENA_ENCRIPTAR;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Enviar_Clave(
	   pTelefono NUMBER,
	   pCarrier NUMBER,
	   pClave NUMBER
  )

 RETURN INTEGER
 IS
  vTelefono NUMBER(10);
  vClave NUMBER(10);
  vMensajeID INTEGER;
  vMensaje INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

	  BEGIN
	    -- Se inserta el mensaje en la tabla de Mensajes
		-- Ocurre si el cliente existe y el telefono existe
	    SELECT SEQ_MENSAJE_ID.NEXTVAL INTO vMensajeID FROM dual;
	    SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
	    EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	      INSERT INTO MENSAJE VALUES (pTelefono, pCarrier, SYSDATE, 'Su clave de confirmacion para el sistema de alertas de Banco Azteca es: ' || pClave, 1, vMensajeID);
	      SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
	      --DBMS_OUTPUT.PUT_LINE ('Mensaje:  ' || vMensaje );
	  END;

  COMMIT;
  -- Si regresa cero el proceso fue exitoso
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
  RETURN falso;
  END Enviar_Clave;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Enviar_Cuenta_Alerta(
	   pCuenta NUMBER,
	   pMensaje MENSAJE.DESCRIPCION%TYPE
       )

 RETURN INTEGER
 IS
  vCliente NUMBER;
  vTelefono NUMBER;

  BEGIN
    BEGIN
  	  -- Existe cliente en la base de datos?
      -- Si NO existe devolver ERROR
      SELECT cliente_id INTO vCliente FROM CLIENTE WHERE cuenta_id = pCuenta;
    EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	  RETURN 0;
  END;

    BEGIN
  	  -- Existe telefono asociado con el cliente en la base de datos?
      -- Si NO existe devolver ERROR
      SELECT max(telefono_id) INTO vTelefono FROM TELEFONO f WHERE f.cliente_id = vCliente AND f.status = 1;
    EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	  RETURN 0;
  END;

    BEGIN
  -- Se inserta el mensaje en la tabla de Mensajes
  -- Ocurre si el cliente existe y el telefono existe
     INSERT INTO MENSAJE
	 SELECT p.telefono_id, p.carrier_id, SYSDATE, pMensaje, 0 AS STATUS, SEQ_MENSAJE_ID.NEXTVAL
	 FROM TELEFONO p
	 WHERE p.cliente_id = vCliente AND p.status = 1;
  COMMIT;
  RETURN 1;
  END;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20001, 'Error'||SQLERRM(SQLCODE));
  RETURN 0;
END Enviar_Cuenta_Alerta;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Enviar_Mensaje(
	   pTelefono NUMBER,
	   pCarrier NUMBER,
	   pMensaje VARCHAR2
  )

 RETURN INTEGER
 IS
  vMensajeID INTEGER;
  vMensaje INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

	  BEGIN
	    -- Se inserta el mensaje en la tabla de Mensajes
		-- Ocurre si el cliente existe y el telefono existe
	    SELECT SEQ_MENSAJE_ID.NEXTVAL INTO vMensajeID FROM dual;
	    SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
	    EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	      INSERT INTO MENSAJE VALUES (pTelefono, pCarrier, SYSDATE, pMensaje, 1, vMensajeID);
	      SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
	      --DBMS_OUTPUT.PUT_LINE ('Mensaje:  ' || vMensaje );
	  END;

  COMMIT;
  -- Si regresa cero el proceso fue exitoso
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
  RETURN falso;
  END Enviar_Mensaje;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "FIAR_CONSULTAXSTATUS"(fecha DATE)
    RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
BEGIN
  OPEN cursor_salida FOR
		SELECT
		    CASE STATUS
			WHEN  '0' THEN 'SIN AFILIAR'
			WHEN '1' THEN 'FIRMA DE CONTRATO DE AFILIACION A FIAR'
			WHEN '2' THEN 'FIRMA DE CARTA DE ADHESION AL FIDEICOMISO'
			WHEN '3' THEN 'CAPTURA DE BENEFICIARIOS'
			WHEN '4' THEN 'FIRMA DE CARTA DE ADHESION'
			WHEN '6' THEN 'SOLICITUD DE CONSULTA EN BURO DE CREDITO'
			WHEN '6' THEN 'CONSULTA CON CIRCULO DE CREDITO'
			WHEN '7' THEN 'REGISTRO CON MESA DE CONTROL'
			WHEN '8' THEN 'DIGITALIZACION'
			WHEN '9' THEN 'CONSULTA DE CUENTAS DE ALNOVA'
			WHEN '10' THEN 'REGISTRO CON FIDUCIARIO'
			WHEN '11' THEN 'REGISTRO DE BENEFICIARIOS CON FIDUCIARIO'
			WHEN '12' THEN 'REGISTRO CON EBANKING'
			ELSE 'AFILIACION COMPLETADA'
			END AS STATUS,
			COUNT(CTE_ALNOVA) AS TOTAL_CLIENTES
		FROM EBANKING.FIAR_STATUS_CLIENTES
		WHERE TO_DATE(FECHA_AFILIACION,'DD/MM/YY') = TO_DATE(FECHA,'DD/MM/YY')
		GROUP BY STATUS;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FIAR_CONSULTAXSTATUS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION                     FIAR_CONSULTA_AFILIADOS_XDIA(fecha DATE)
RETURN Types.REFCURSOR IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
    
SELECT C.CTE_ALNOVA  , MONTO_CREDITO , R.ULTIMA_MODIFICACION as FECHA_AFILIACION FROM EBANKING.FIAR_CLIENTES C, EBANKING.FIAR_REGISTRO R
WHERE  R.NUM_EMPLEADO= C.NO_EMPLEADO
AND to_date(R.ULTIMA_MODIFICACION,'dd/mm/yy') = to_date(fecha,'dd/mm/yy');

	RETURN cursor_salida;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END FIAR_CONSULTA_AFILIADOS_XDIA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION           FIAR_CONSULTA_TOTALES
    RETURN Types.REFCURSOR
IS
	 NUM_TOTAL number(25):=0;
	 MONTO_TOTAL number(25):= 0;
	 AFILIADOS number(25):=0;
	 MONTO_AFIL number(25):=0;
	 SIN_AFILIAR number(25):=0;
	 MONTO_SIN_AFIL number(25):=0;
   mod_fiar2  number(2):=2;
   status_reg char(4):='true';
	 cursor_salida Types.REFCURSOR;
   
BEGIN

  SELECT COUNT(1) INTO NUM_TOTAL 
    FROM EBANKING.FIAR_CLIENTES
    WHERE MODULO_FIAR = mod_fiar2;
    
	SELECT SUM(CTE_ALNOVA) INTO MONTO_TOTAL
  	FROM EBANKING.FIAR_CLIENTES
    WHERE MODULO_FIAR = mod_fiar2;

    	SELECT COUNT(NUM_EMPLEADO) INTO AFILIADOS
	FROM EBANKING.FIAR_REGISTRO
	WHERE ESTATUS_REGISTRO=status_reg;

      	SELECT SUM(MONTO_CREDITO) INTO MONTO_AFIL
	FROM  EBANKING.FIAR_CLIENTES
  	WHERE NO_EMPLEADO  IN (SELECT NUM_EMPLEADO FROM EBANKING.FIAR_REGISTRO);

    SIN_AFILIAR := NUM_TOTAL - AFILIADOS;
    MONTO_SIN_AFIL := MONTO_TOTAL - MONTO_AFIL;  
 
    OPEN cursor_salida FOR
      SELECT NUM_TOTAL AS NUM_TOTAL, MONTO_TOTAL AS MONTO_TOTAL, AFILIADOS AS AFILIADOS,
        MONTO_AFIL AS MONTO_AFIL, SIN_AFILIAR AS SIN_AFILIAR, MONTO_SIN_AFIL AS MONTO_SIN_AFIL
		  FROM DUAL;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FIAR_CONSULTA_TOTALES;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          findalbumbyinteresado (
   pnum   VARCHAR2
)
RETURN TYPES.refcursor
IS
   interesadoref   TYPES.refcursor;
BEGIN
   OPEN interesadoref FOR
        SELECT A.ID, A.NOMBRE
        FROM ALBUM A, INTERESADOS i
        WHERE   A.ID = I.IDALBUM
          AND   I.NUM_EMPLEADO = pnum
        GROUP BY A.ID, A.NOMBRE;
   RETURN interesadoref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END findalbumbyinteresado;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION findalbumbypk (pid NUMBER)
   RETURN TYPES.refcursor
IS
   albumpkref   TYPES.refcursor;
BEGIN
   OPEN albumpkref FOR
      SELECT nombre, comentarios, idacuerdo,enviado,fecha_visita
        FROM album
       WHERE ID = pid;

   RETURN albumpkref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END findalbumbypk;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION findfotosbyalbum (pidalbum NUMBER)
   RETURN TYPES.refcursor
IS
   fotosref   TYPES.refcursor;
BEGIN
   OPEN fotosref FOR
      SELECT f.comentario, f.descripcion, f.fix_name, f.ID, f.NAME, f.ruta,
             f.visita, f.fixfotoupdate
        FROM photos f
       WHERE f.idalbum = pidalbum;

   RETURN fotosref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END findfotosbyalbum;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          findinteresado (
   pid   NUMBER
)
RETURN TYPES.refcursor
IS
   interesadoref   TYPES.refcursor;
BEGIN
   OPEN interesadoref FOR
      SELECT i.id, i.nombre, i.email, i.num_empleado, i.ou
        FROM interesados i
       WHERE i.id = pid;

   RETURN interesadoref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END findinteresado;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          findtipointeresadosbyalbum (
   pidalbum   NUMBER,
   ptipo      VARCHAR2
)
   RETURN TYPES.refcursor
IS
   interesadoref   TYPES.refcursor;
BEGIN
   OPEN interesadoref FOR
      SELECT i.email, i.ID, i.nombre, i.num_empleado, i.ou
        FROM interesados i
       WHERE i.idalbum = pidalbum AND tipo = ptipo;

   RETURN interesadoref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END findtipointeresadosbyalbum;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION FIND_BANK_BY_SWIFT
(V_CLAVE IN EBANKING.SWIFTABA.CLAVE%TYPE ) 
RETURN EBANKING.TYPES.REFCURSOR
 IS
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   
 BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT DISTINCT TIPO_CLAVE,CLAVE,DESCRIPCION,PAIS,CVE_PAIS,CIUDAD 
          FROM EBANKING.SWIFTABA 
          WHERE CLAVE LIKE V_CLAVE;
    RETURN CURSOR_OUTPUT;
 EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FIND_BANK_BY_SWIFT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNADD_BENEFICIARY_NAME(
V_ID_BENEFICIARIO_DEX   IN  EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE,
V_ALIAS_BENEFICIARIO    IN  EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE,
V_CTEDEX                IN  EBANKING.BENEFI_DEX.CTEDEX%TYPE,
V_USUARIO_MODIFICO      IN  EBANKING.BENEFI_DEX.USUARIO_MODIFICO%TYPE,
V_NOMBRE_COMPLETO       IN  EBANKING.BENEFI_DEX.NOMBRE_COMPLETO%TYPE,
V_NUM_CELULAR           IN  EBANKING.BENEFI_DEX.NUM_CELULAR%TYPE,
V_CEL_COMPANY           IN  EBANKING.BENEFI_DEX.CEL_COMPANY%TYPE,
V_TIP_BENEFI            IN  EBANKING.BENEFI_DEX.TIP_BENEFI%TYPE,
V_ESTATUS               IN  EBANKING.BENEFI_DEX.ESTATUS%TYPE  

) RETURN NUMBER IS
SALIDA NUMBER := 0;
BEGIN
   INSERT INTO EBANKING.BENEFI_DEX (
                                    ID_BENEFICIARIO_DEX,
                                    ALIAS_BENEFICIARIO,
                                    CTEDEX,
                                    FECHAACTIVACION,
                                    ULTIMA_MODIFICACION,
                                    USUARIO_MODIFICO,
                                    NOMBRE_COMPLETO,
                                    NUM_CELULAR,
                                    CEL_COMPANY,
                                    TIP_BENEFI,
                                    ESTATUS)
                            VALUES(
                                   V_ID_BENEFICIARIO_DEX,
                                   V_ALIAS_BENEFICIARIO,
                                   V_CTEDEX,
                                   SYSDATE,
                                   SYSDATE,
                                   V_USUARIO_MODIFICO,
                                   V_NOMBRE_COMPLETO,
                                   V_NUM_CELULAR,
                                   V_CEL_COMPANY,
                                   V_TIP_BENEFI,
                                   V_ESTATUS);
   IF SQL%FOUND THEN
      SALIDA:=1; 
   ELSE
      SALIDA:=0;
   END IF;
   
   COMMIT;    
                 
   RETURN SALIDA;
   
   EXCEPTION
     
     WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNADD_BENEFICIARY_NAME;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULTOKENDISP(PAFCID_ALNOVA IN EBANKING.TOKEN_DISP.ID_ALNOVA%TYPE,PAFCBANDERA   IN EBANKING.TOKEN_DISP.ESTADO%TYPE  )
 RETURN TYPES.REFCURSOR 
 IS  CURSOR_SALIDA TYPES.REFCURSOR;
  cslNumeroUno NUMBER := 1;
  cslNumeroCero NUMBER := 0;
  cslNumeroDos NUMBER := 2;
    BEGIN
       OPEN CURSOR_SALIDA FOR
         SELECT  ID_ACT_DISPOSITIVO
                      ,ID_ALNOVA
                      ,SEMILLA
                      ,ESTADO 
                      ,DESFASE
                      ,SINCRONIZACIONES
                      ,FECHA_SOLICITUD
                      ,FECHA_ACTIVACION
                      ,SISTEMA
                      ,PAIS
                      ,ULTIMA_MODIFICACION
                      ,USUARIO_MODIFICO
            FROM EBANKING.TOKEN_DISP 
          WHERE ID_ALNOVA = PAFCID_ALNOVA
               AND 1 = CASE WHEN PAFCBANDERA = cslNumeroDos THEN cslNumeroUno
                                     WHEN PAFCBANDERA = cslNumeroUno AND CONTRATO_FIRMADO = cslNumeroUno THEN cslNumeroUno
                                       ELSE cslNumeroCero END
               AND 1 = CASE WHEN PAFCBANDERA = cslNumeroUno THEN cslNumeroUno
                                     WHEN PAFCBANDERA = cslNumeroDos AND ESTADO = cslNumeroUno THEN cslNumeroUno
                                       ELSE cslNumeroCero END;
 RETURN cursor_salida;     
      EXCEPTION
   WHEN NO_DATA_FOUND THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar1 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
   WHEN OTHERS THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar2 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END FNCONSULTOKENDISP;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULTPEDIEKT( PAFCNUM_CTE EBANKING.EBANKING_TOKEN_SOLICITUD.NUM_CTE%TYPE,PAFNFOLIO_SOLICITUD EBANKING.EBANKING_TOKEN_SOLICITUD.NUM_CTE%TYPE)
RETURN TYPES.REFCURSOR 
IS  CURSOR_SALIDA TYPES.REFCURSOR;
    BEGIN
       OPEN CURSOR_SALIDA FOR
          SELECT NUM_PEDIDO_EKT
                     ,CANT_SKU1
                     ,CANT_SKU2
                     ,DIR_ENT
                     ,COL_ENT
                     ,CP_ENT
                     ,CIUDAD_ENT
                     ,EDO_ENT
                     ,PER_AUT1
                     ,PER_AUT2
                     ,FECHA_SOL_INTERNET
                     ,ESTATUS_SOL  
           FROM EBANKING.EBANKING_TOKEN_SOLICITUD 
         WHERE NUM_CTE = PAFCNUM_CTE
              AND FOLIO_SOLICITUD = PAFNFOLIO_SOLICITUD;
              
           RETURN cursor_salida;     
      EXCEPTION
   WHEN NO_DATA_FOUND THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar1 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
   WHEN OTHERS THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar2 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END FNCONSULTPEDIEKT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULT_BENEFIALIAS
(
CLIENTEDEX IN  EBANKING.BENEFI_DEX.CTEDEX%TYPE,
TIPOBEN      IN  EBANKING.BENEFI_DEX.TIP_BENEFI%TYPE
)
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion para consultar los alias de un beneficiario
   Parametros de entrada:  paFnCteDexId        - Identificador dex del cliente
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  07/05/2013
****************************************************************************/
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   CSLSTATUS NUMBER := 1;
   BEGIN
    IF TIPOBEN = 1 THEN
        OPEN CURSOR_OUTPUT 
         FOR
            SELECT ID_BENEFICIARIO_DEX
                  ,ALIAS_BENEFICIARIO
                  ,TO_DATE(ULTIMA_MODIFICACION , 'dd-mm-yyyy hh24:mi:ss') AS UM 
            FROM BENEFI_DEX   
             WHERE CTEDEX     = CLIENTEDEX
               AND TIP_BENEFI = TIPOBEN
               AND ESTATUS    = CSLSTATUS
               ORDER BY FECHAACTIVACION DESC;
               
     ELSIF TIPOBEN = 2 THEN
        OPEN CURSOR_OUTPUT 
         FOR
            SELECT ID_BENEFICIARIO_DEX
                  ,ALIAS_BENEFICIARIO
                  ,NUM_CELULAR
                  ,CEL_COMPANY
                  ,TO_DATE(ULTIMA_MODIFICACION , 'dd-mm-yyyy hh24:mi:ss') AS UM 
            FROM BENEFI_DEX   
             WHERE CTEDEX     = CLIENTEDEX
               AND TIP_BENEFI = TIPOBEN
               AND ESTATUS    = CSLSTATUS
               ORDER BY FECHAACTIVACION DESC;
               
     END IF;
     
    RETURN CURSOR_OUTPUT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCONSULT_BENEFIALIAS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULT_CELLCARRIERDEX(paFcAlnovaUser IN EBANKING.EBANKING_USER.ID%TYPE)
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion para consultar los celulares con carrier por numero de cliente para envios a celular dex
   Parametros de entrada:  paFcAlnovaUser        - Identificador del cliente
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  06/05/2013
****************************************************************************/
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT CELLULAR
                ,USER2CELLCOMPANY 
            FROM EBANKING.EBANKING_USER 
           WHERE ID = paFcAlnovaUser;
    RETURN CURSOR_OUTPUT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCONSULT_CELLCARRIERDEX;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULT_CUFREC(paFcAlnovaUser IN EBANKING.CU_FRECUENTES.ID_ALNOVA%TYPE)
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion parea consultar las frecuentes de credimadx
   Parametros de entrada:  paFcAlnovaUser        - Identificador del cliente
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  16/04/2013
****************************************************************************/
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   CSLACTIVO NUMBER := 1;
   CSLINACTIVO NUMBER := 0;
   CSLCERO NUMBER := 0;
   BEGIN
          UPDATE EBANKING.CU_FRECUENTES
             SET STATUS = CSLACTIVO   
           WHERE ID > CSLCERO
             AND ID_ALNOVA = paFcAlnovaUser
             AND STATUS = CSLINACTIVO
             AND ULTIMA_MODIFICACION <= SYSDATE -30/1440;
             COMMIT;
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT ID
                ,ID_ALNOVA
                ,CLIENTE_UNICO 
                ,ALIAS 
                ,NOMBRE 
                ,TO_CHAR(FECHA_MODIFICACION,'DD/MM/YYYY hh24:mi:ss') FECHA_MODIFICACION
                ,TO_CHAR(ULTIMA_MODIFICACION,'DD/MM/YYYY hh24:mi:ss') ULTIMA_MODIFICACION
                ,STATUS
                ,SISTEMA
                ,PAIS
                ,USUARIO_MODIFICO
            FROM EBANKING.CU_FRECUENTES
           WHERE ID > CSLCERO
             AND ID_ALNOVA = paFcAlnovaUser
             AND STATUS IN( CSLACTIVO,CSLINACTIVO );
    RETURN CURSOR_OUTPUT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCONSULT_CUFREC;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONSULT_EXTCREDFREC(pAFcCliente IN EBANKING.CREDITOSOTROSBANCOSFRECUENT.CLIENTE%TYPE)
/******************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion parea consultar las frecuentes de creditos externos
   Parametros de entrada:  pAFcCliente        - Identificador del cliente
   Creador:                Juan Antonio Ortiz Guillén
   Fecha:                  06/08/2013

******************************************************************************/
RETURN EBANKING.TYPES.REFCURSOR
IS 
CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
CSLSTATUS NUMBER:= 1;
BEGIN
      OPEN CURSOR_OUTPUT 
           FOR
               SELECT CLIENTE
                       ,BANCO
                       ,TIPOCREDITO
                       ,CUENTACREDITO
                       ,BENEFICIARIO
                       ,FECHA_MODIFICACION   
                     FROM EBANKING.CREDITOSOTROSBANCOSFRECUENT
                        ,EBANKING.EBANKING_BANKS 
                     WHERE CLIENTE = pAFcCliente
                     AND STATUS = CSLSTATUS 
                     AND CODE = BANCO;
           RETURN CURSOR_OUTPUT;       
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
      WHEN OTHERS THEN
         ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END FNCONSULT_EXTCREDFREC;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION                   FNCONTOKENDISPCANCEL(PAFCID_ALNOVA IN EBANKING.TOKEN_DISP.ID_ALNOVA%TYPE)
 RETURN TYPES.REFCURSOR 
 IS  CURSOR_SALIDA TYPES.REFCURSOR;
  cslNumeroUno NUMBER := 1;
    BEGIN
       OPEN CURSOR_SALIDA FOR
         SELECT  ID_ACT_DISPOSITIVO
                      ,ID_ALNOVA
                      ,SEMILLA
                      ,ESTADO 
                      ,DESFASE
                      ,SINCRONIZACIONES
                      ,FECHA_SOLICITUD
                      ,FECHA_ACTIVACION
                      ,SISTEMA
                      ,PAIS
                      ,ULTIMA_MODIFICACION
                      ,USUARIO_MODIFICO
            FROM EBANKING.TOKEN_DISP 
          WHERE ID_ALNOVA = PAFCID_ALNOVA
            AND ESTADO = cslNumeroUno ;
 RETURN cursor_salida;     
      EXCEPTION
   WHEN NO_DATA_FOUND THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar1 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
   WHEN OTHERS THEN         
          RAISE_APPLICATION_ERROR (-20100, 'Error al consultar2 ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END FNCONTOKENDISPCANCEL;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCONTOP15PS(PAFNSUCURSALID IN EBANKING.TATOP15_PS.FNSUCRSALID%TYPE)
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion parea consultar el top 15 de pago de servicios
   Parametros de entrada:  PASUCURSALID                          --Identificador de la sucrusal
   Parametros de entrada:  Cursor
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  23/05/2013
****************************************************************************/
 RETURN EBANKING.TYPES.REFCURSOR
 IS 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT  FNEMISORID
                      ,FNSUCRSALID
                      ,FCNOMBRECOMERCIAL
                      ,FCNOMBRECORTO
                      ,FNESTATUS
                      ,FNREFERENCIAMIN
                      ,FNREFERENCIAMAX
                      ,FNFORMASPAGO
                      ,FNPERMITECANCELAR
                      ,FNREFERENCIAVARIABLE
                      ,FNCATEGORIAID
                      ,FCCATEGORIA
                      ,FNORDENTOP
                      ,TO_CHAR(FECHA_MODIFICO)AS FDFECHAULTMODI
                      ,USUARIO_MODIFICO
            FROM EBANKING.TATOP15_PS
            WHERE FNSUCRSALID = PAFNSUCURSALID;
    RETURN CURSOR_OUTPUT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCONTOP15PS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCON_OPEPROGRA_30MIN
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion para consultar las operaciones programadas por 30 minutos
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  04/04/2014
****************************************************************************/
 RETURN TYPES.REFCURSOR
IS
 type T_CURSOR IS REF CURSOR RETURN TAOPPROG30MIN%ROWTYPE;
 CURSOR_SALIDA T_CURSOR;
 V_REG EBANKING.TAOPPROG30MIN%ROWTYPE;
 VLFECHA_INI DATE;
 VLFECHA_FIN DATE;
BEGIN
VLFECHA_INI := SYSDATE -1/144;
VLFECHA_FIN := SYSDATE;
   OPEN CURSOR_SALIDA 
    FOR
       SELECT FIID
                  ,FCNUM_TRANSACCION
                  ,FCPETICION
                  ,FCRESPUESTA
                  ,FCESTADO 
                  ,FDHORA_APLICACION
                  ,FDFECHA_PROGRAMACION
                  ,FCTEXTO_ADJUNTO
                  ,FCFOLIO
                  ,FIID_USUARIO
                  ,FCID_EMAIL
                  ,FDULTIMA_MODIFICACION
                  ,FCUSUARIO_MODIFICO
                  ,FCNOMBRE_TRANSACCION 
         FROM EBANKING.TAOPPROG30MIN
       WHERE FDHORA_APLICACION BETWEEN VLFECHA_INI  AND VLFECHA_FIN 
           AND FCESTADO = 1;--POR ENVIAR
           
           UPDATE EBANKING.TAOPPROG30MIN
             SET FCESTADO = 2
             WHERE FDHORA_APLICACION BETWEEN VLFECHA_INI  AND VLFECHA_FIN 
           AND FCESTADO = 1;--POR ENVIAR
             COMMIT;

RETURN CURSOR_SALIDA;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCON_OPEPROGRA_30MIN;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNCON_SUBPROINVAZT
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion para consultar el catalogo de inversion azteca
   Parametros de entrada:  ALNOVAUSER        - Identificador del cliente
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  16/04/2013
****************************************************************************/
 RETURN Types.REFCURSOR
IS
cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida 
    FOR
       SELECT CODIGO_PRODUCTO
             ,ENTIDAD
             ,OPCION_INVERSION
             ,SUBPRODUCTO 
         FROM EBANKING.INVERSION_AZTECA;
RETURN cursor_salida;
EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNCON_SUBPROINVAZT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FNGET_MORAL_PERSON(
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE
)
RETURN TYPES.REFCURSOR
IS
type T_CURSOR IS REF CURSOR; --RETURN TRANSFINTERNALFRECUENT%ROWTYPE;
CURSOR_SALIDA T_CURSOR;
V_REG EBANKING.TRANSFINTERNALFRECUENT%ROWTYPE;
PERSONA NUMBER := 2;
BEGIN
   OPEN CURSOR_SALIDA 
    FOR
       SELECT 
          CLIENT,
          DESTINO,
          NAME,
          STATUS,
          FECHA_MODIFICACION,
          /*IP_ORIGEN,*/
          CLAVE_SWIFT,
          /*CANAL,*/
          APELLIDO_PATERNO,
          APELLIDO_MATERNO,
          LUGAR_NACIMIENTO,
          /*DOMICILIO,*/
          STATUS_BLOQUEO,
         /* FECHA_NACIMIENTO,*/
          FECHA_ACTIVACION,
          TIPO_PERSONA,
          RFC
      FROM EBANKING.TRANSFINTERNALFRECUENT
      WHERE CLIENT = P_CLIENT AND  TIPO_PERSONA = PERSONA;
      
    RETURN CURSOR_SALIDA;

EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||SQLCODE || '  ' || SQLERRM ||  '  *)');
END FNGET_MORAL_PERSON ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FN_ACRTUMUSER
(
P_TELEFONO IN EBANKING.ACTIVAR_ACRTUM.TELEFONO %TYPE
)
RETURN VARCHAR2
AS
C_USUARIO_INACTIVO VARCHAR2(15):='USUARIOINACTIVO';
C_USUARIO_ACTIVO VARCHAR2(13):='USUARIOACTIVO';
C_SIN_REGISTROS VARCHAR2(12):='SINREGISTROS';
V_EXISTE_USUARIO NUMBER:=0;
V_PRIMER_LOGEO NUMBER:=0;
V_RESPUESTA VARCHAR2(15):='';
BEGIN
SELECT COUNT(TELEFONO) INTO V_EXISTE_USUARIO FROM EBANKING.ACTIVAR_ACRTUM
WHERE TELEFONO=P_TELEFONO;
IF(V_EXISTE_USUARIO>0) THEN
  SELECT PRIMER_LOGEO INTO V_PRIMER_LOGEO  FROM EBANKING.ACTIVAR_ACRTUM
  WHERE TELEFONO=P_TELEFONO;
  IF(V_PRIMER_LOGEO=0) THEN
    V_RESPUESTA:=C_USUARIO_INACTIVO;
  ELSE
    V_RESPUESTA:=C_USUARIO_ACTIVO;
  END IF;
ELSE  
   V_RESPUESTA:=C_SIN_REGISTROS;
END IF;
RETURN V_RESPUESTA;
EXCEPTION
  WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR
      (
        -20100, 'Error ocurrido en la funcion EBANKING.FN_ACRTUMUSER  ( * ' || SQLCODE || '  ' || SQLERRM || '  *)'
      );
 END FN_ACRTUMUSER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION FN_DELETE_DEXBEN(
V_ID_BENEFICIARIO_DEX   IN  EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE 

) RETURN NUMBER IS
SALIDA NUMBER := 0;
INACTIVO INTEGER:=0;
BEGIN
   UPDATE EBANKING.BENEFI_DEX SET ESTATUS=INACTIVO 
                WHERE ID_BENEFICIARIO_DEX=V_ID_BENEFICIARIO_DEX;
   IF SQL%FOUND THEN
      SALIDA:=1; 
   ELSE
      SALIDA:=0;
   END IF;
   
   COMMIT;    
                 
   RETURN SALIDA;
   
   EXCEPTION
     
     WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FN_DELETE_DEXBEN;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          FN_TEST(PI_LETTER_ID IN NUMBER) RETURN SYS_REFCURSOR IS 
 PO_CUR_RESULT    SYS_REFCURSOR;

--CADENA        CONSTANT VARCHAR2(10):= 'ACTIVO';
CADENA  VARCHAR2(10):= 'ACTIVO';

BEGIN
 OPEN PO_CUR_RESULT FOR
 SELECT EU.ID,
    EU.ACTIVE,
    EU.EMAIL,
    EU.CELLULAR,
    CADENA CADENA
    FROM
    EBANKING_USER EU
    WHERE EU.ID = 3556295;
    RETURN PO_CUR_RESULT;
    END FN_TEST;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION FN_UPDATE_DEXBEN(
V_ID_BENEFICIARIO_DEX   IN  EBANKING.BENEFI_DEX.ID_BENEFICIARIO_DEX%TYPE,
V_ALIAS_BENEFICIARIO    IN  EBANKING.BENEFI_DEX.ALIAS_BENEFICIARIO%TYPE 

) RETURN NUMBER IS
SALIDA NUMBER := 0;
BEGIN
   UPDATE EBANKING.BENEFI_DEX SET ALIAS_BENEFICIARIO=V_ALIAS_BENEFICIARIO 
                           WHERE ID_BENEFICIARIO_DEX=V_ID_BENEFICIARIO_DEX;
   IF SQL%FOUND THEN
      SALIDA:=1; 
   ELSE
      SALIDA:=0;
   END IF;
   
   COMMIT;    
                 
   RETURN SALIDA;
   
   EXCEPTION
     
     WHEN OTHERS THEN
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FN_UPDATE_DEXBEN;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAllAppUser
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
        select aplicacion,count(user_name) as total
        from EBANKING.m_usuarios
        group by aplicacion;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAllAppUser;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAllLoginUser
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
        select u.aplicacion,u.nombrecompleto, u.empleado, count(u.user_name) as total
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario 
        and op.operacion='login'
        group by u.aplicacion, u.nombrecompleto, u.empleado;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAllLoginUser;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAllOpeMonto
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
         select u.aplicacion,u.nombrecompleto,op.operacion, td.valor as monto, op.FECHA_OPERACION
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op, EBANKING.m_tracking t, EBANKING.m_tracking_detalle td
        where  u.idusuario= op.idusuario 
        and  t.id_usuario_operacion = op.id_usuario_operacion
        and td.idtracking = t.idtracking
        and (td.campo='importe' or  td.campo='monto')
        and op.operacion !='login';

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAllOpeMonto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAllTotalOper
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

        select aplicacion,nombrecompleto,count(user_name) as total
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario 
        and op.operacion !='login'
        group by aplicacion, nombrecompleto;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAllTotalOper;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAllTrackUser
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

       select aplicacion,nombrecompleto,operacion,op.fecha_operacion
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario 
        and op.operacion !='login';

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAllTrackUser;

-------------------------------
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getAppUser(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
        select aplicacion,count(user_name) as total
        from EBANKING.m_usuarios 
        where trunc(fecha_operacion) between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy') 
        group by aplicacion;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getAppUser;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GETCELLPHONE(id_user NUMBER)

 RETURN VARCHAR2
 IS
  cellPhone VARCHAR2(10);

  BEGIN

      BEGIN
        -- Se inserta el mensaje en la tabla de Mensajes
        -- Ocurre si el cliente existe y el telefono existe
        SELECT CELLULAR INTO cellPhone FROM EBANKING.ebanking_user
        WHERE id_cliente = id;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
          cellPhone :='0';
      END;

  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
    cellPhone :='0';
  RETURN cellPhone;
  END GETCELLPHONE;
/

SHOW ERRORS;


CREATE OR REPLACE function          getEbakingCore(PEcadena in varchar2)
return sys_refcursor is
TYPE CUR_TYP IS REF CURSOR;
c_cursor   CUR_TYP;
BEGIN
  OPEN c_cursor FOR PEcadena;
  return c_cursor;
exception
 WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20121, 'Error ocurrido al getIupiCard(' || SQLCODE || '  ' || SQLERRM || ')');
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GETHUELLA (idCliente VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorHuellas Types.REFCURSOR;

  BEGIN
    OPEN cursorHuellas FOR

  SELECT * FROM EBANKING.TMP_HUELLA HD WHERE HD.cliente=idCliente;
   RETURN cursorHuellas;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GETHUELLA ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          gethuellacte

  RETURN Types.REFCURSOR

IS

  cursorHuellas Types.REFCURSOR;

  BEGIN
    OPEN cursorHuellas FOR

    SELECT * FROM ebanking.temporalhuellas WHERE status = 1;

   RETURN cursorHuellas;


  END gethuellacte;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GETHUELLAMONTOS (idCliente VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorHuellas Types.REFCURSOR;

  BEGIN
    OPEN cursorHuellas FOR

  SELECT  FCHUELLA_DIGITAL FROM EBANKING.TMP_HUELLA_MONTOS HD WHERE HD.cliente=idCliente;
   RETURN cursorHuellas;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GETHUELLAMONTOS ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getLoginUser(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

        select u.aplicacion,u.nombrecompleto, u.empleado, count(u.user_name) as total
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario 
        and op.operacion='login' 
        and trunc(op.fecha_operacion) between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy')
        group by u.aplicacion, u.nombrecompleto, u.empleado;


    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getLoginUser;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION           getOpeMonto(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
         select u.aplicacion,u.nombrecompleto,op.operacion, td.valor as monto, op.FECHA_OPERACION
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op, EBANKING.m_tracking t, EBANKING.m_tracking_detalle td
        where  u.idusuario= op.idusuario 
        and  t.id_usuario_operacion = op.id_usuario_operacion
        and td.idtracking = t.idtracking
        and (td.campo='importe' or  td.campo='monto')
        and op.operacion !='login'
        and trunc(op.fecha_operacion)between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy');

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getOpeMonto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getOperMonto(fechaInicio varchar, fechaFin varchar)RETURN Types.REFCURSOR IS  

cursor_salida Types.REFCURSOR;
min_idtracking_detalle EBANKING.m_tracking_detalle.id_tracking_detalle%TYPE;
max_idtracking_detalle EBANKING.m_tracking_detalle.id_tracking_detalle%TYPE;

BEGIN

    select min(id_tracking_detalle) , max(id_tracking_detalle) INTO min_idtracking_detalle, max_idtracking_detalle
    from EBANKING.m_tracking_detalle 
    where (campo='importe' or  campo='monto')
    and fecha_operacion between to_date(fechaInicio,'dd/mm/yyyy') and to_date(fechaFin,'dd/mm/yyyy')+1;

   
   OPEN cursor_salida FOR

         select u.usralnova,u.aplicacion,u.nombrecompleto,op.operacion, td.valor as monto, op.FECHA_OPERACION
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op, EBANKING.m_tracking t, EBANKING.m_tracking_detalle td
        where  u.idusuario= op.idusuario 
        and  t.id_usuario_operacion = op.id_usuario_operacion
        and td.idtracking = t.idtracking
        and td.id_tracking_detalle between min_idtracking_detalle and max_idtracking_detalle
        and (td.campo='importe' or  td.campo='monto')
        and op.operacion !='login'
        and op.fecha_operacion between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy')+1;

    RETURN cursor_salida;
    CLOSE cursor_salida;
    

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getOperMonto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION getterminalfree (idterminal NUMBER
/*ADVICE(2): Mode of parameter is not specified with IN parameter [521] */
                                                             )
   RETURN TYPES.refcursor
AS
   terminalcursor   TYPES.refcursor;
   codigoterminal   VARCHAR2 (10);
BEGIN
   SELECT     code
         INTO codigoterminal
         FROM alnova_terminal
        WHERE busy = 0 AND ID = idterminal
   FOR UPDATE;

   IF codigoterminal IS NOT NULL
   THEN
      UPDATE alnova_terminal
         SET busy = 1
       WHERE ID = idterminal;

      COMMIT;

      OPEN terminalcursor
       FOR
          SELECT *
            FROM alnova_terminal
           WHERE ID = idterminal;
   ELSE
      OPEN terminalcursor
       FOR
          SELECT *
            FROM alnova_terminal
           WHERE busy = 0 AND ID = idterminal AND CODE IS NOT NULL;
   END IF;
   RETURN terminalcursor;
EXCEPTION
WHEN NO_DATA_FOUND THEN
	 OPEN terminalcursor
       FOR
          SELECT *
            FROM alnova_terminal
           WHERE busy = 0 AND ID = idterminal;
   RETURN terminalcursor;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getTotalOper(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

        select aplicacion,nombrecompleto,count(user_name) as total
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario 
        and op.operacion !='login' 
        and trunc(op.fecha_operacion) between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy')
        group by aplicacion, nombrecompleto;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getTotalOper;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getTracking(IDUSUARIOOPERACION IN NUMBER)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
        SELECT  idTRACKING  
       FROM EBANKING.M_TRACKING 
       WHERE ID_USUARIO_OPERACION = IDUSUARIOOPERACION;

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
               RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getTracking;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getTrackUser(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

        select aplicacion,nombrecompleto,operacion,op.fecha_operacion
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario and op.operacion !='login' 
        and trunc(op.fecha_operacion) between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy');

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getTrackUser;

-----------------------------------
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          getTrackUser_TMP(fechaInicio varchar, fechaFin varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

        select aplicacion,nombrecompleto,operacion,TO_CHAR(op.fecha_operacion,'DD/MM/YYYY')
        from EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
        where  u.idusuario= op.idusuario and op.operacion !='login' 
        and trunc(op.fecha_operacion) between TO_DATE(fechaInicio,'dd/MM/yyyy') and TO_DATE(fechaFin,'dd/MM/yyyy');

    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar   ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END getTrackUser_TMP;

-----------------------------------
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          get_bal (FECHAINI IN VARCHAR,FECHAFIN IN VARCHAR)
RETURN VARCHAR,NUMBER
IS
APLICA VARCHAR
TOTAL NUMBER; /* declaración de una variable */
BEGIN
SELECT APLICACION INTO APLICA,count(user_name) INTO TOTAL
FROM M_USUARIOS
where fecha_operacion >= FECHAINI and fecha_operacion <= FECHAFIN 
group by aplicacion;
RETURN(APLICA,TOTAL);
END
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_BANKS_INTER
(V_CVE_PAIS IN EBANKING.SWIFTABA.CVE_PAIS%TYPE,
V_CIUDAD    IN EBANKING.SWIFTABA.CIUDAD%TYPE) 
RETURN EBANKING.TYPES.REFCURSOR
 IS
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   
 BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT TIPO_CLAVE,CLAVE,DESCRIPCION 
          FROM EBANKING.SWIFTABA 
          WHERE CVE_PAIS = V_CVE_PAIS AND CIUDAD = V_CIUDAD;
          
    RETURN CURSOR_OUTPUT;
 EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_BANKS_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_BENEFICIARIO (cte_alnova VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorBeneficiario Types.REFCURSOR;

  BEGIN
    OPEN cursorBeneficiario FOR

  SELECT FD.FI_NOMBRE1, FD.FI_NOMBRE2, FD.FI_APATERNO, FD.FI_AMATERNO, FD.FI_PARENTESCO, FD.FI_EDAD, FD.FI_PORC_PART FROM EBANKING.FI_BENEFICIARIO FD WHERE FD.FI_CTE_ALNOVA=cte_alnova;
   RETURN cursorBeneficiario;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener beneficiario (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener beneficiario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_BENEFICIARIO ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_BENEFICIARIOT (cte_alnova VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorBeneficiario Types.REFCURSOR;

  BEGIN
    OPEN cursorBeneficiario FOR

  SELECT FD.FI_NOMBRE1, FD.FI_NOMBRE2, FD.FI_APATERNO, FD.FI_AMATERNO, FD.FI_PARENTESCO, FD.FI_EDAD, FD.FI_PORC_PART FROM EBANKING.FI_BENEFICIARIO FD;
   RETURN cursorBeneficiario;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener beneficiario (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener beneficiario ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_BENEFICIARIOT ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_CITIES_INTER 
(V_CVE_PAIS IN EBANKING.SWIFTABA.CVE_PAIS%TYPE ) 
RETURN EBANKING.TYPES.REFCURSOR
 IS
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   
 BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT DISTINCT CIUDAD 
          FROM EBANKING.SWIFTABA 
          WHERE CVE_PAIS = V_CVE_PAIS ORDER BY CIUDAD;
    RETURN CURSOR_OUTPUT;
 EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_CITIES_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_CLIENTE (cl_cliente_alnova VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorCliente Types.REFCURSOR;

  BEGIN
    OPEN cursorCliente FOR

  SELECT CLI.CLIENTE_ALNOVA, CLI.CLIENTE_ID, CLI.NOMBRE, CLI.APELLIDO_PATERNO, CLI.APELLIDO_MATERNO,
  		 CLI.FECHA_NACIMIENTO
		 FROM EBANKING.DINERO_EXPRESS_CLIENTE CLI 
		 WHERE CLI.CLIENTE_ALNOVA = cl_cliente_alnova;
   RETURN cursorCliente;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener cliente (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener cliente ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_CLIENTE ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_CLIENTE_CONOCIDO
RETURN Types.refCursor IS
  companiasCursor Types.refCursor;
BEGIN
  OPEN companiasCursor FOR
    SELECT c.descripcion, c.carrier_id AS id
    FROM CARRIER c
    WHERE c.STATUS=1
    ORDER BY c.descripcion;
  RETURN companiasCursor;

EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20002, 'Error'||SQLERRM(SQLCODE));

END GET_CLIENTE_CONOCIDO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_CLIENT_DEX(ID_ALNOVA IN EBANKING.ACTIVACION_DEX.CTEALNOVA%TYPE)
RETURN INTEGER
 IS 
 CLIENT_DEX INTEGER;
   BEGIN
    SELECT CTEDEX INTO CLIENT_DEX FROM ACTIVACION_DEX 
    WHERE  CTEALNOVA = ID_ALNOVA;
    
    IF SQL%FOUND THEN
      RETURN CLIENT_DEX; 
   ELSE
      RETURN -1;
   END IF;
EXCEPTION
  
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_CLIENT_DEX;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_COMISIONES (tr_folio_transferencia VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorComisiones Types.REFCURSOR;

  BEGIN
    OPEN cursorComisiones FOR

  SELECT COM.FOLIO_TRANSFERENCIA, COM.DESCRIPCION, COM.MONTO, COM.TIPO
  		 FROM EBANKING.DINERO_EXPRESS_COMISIONES COM 
		 WHERE COM.FOLIO_TRANSFERENCIA = tr_folio_transferencia;		 
   RETURN cursorComisiones;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener comisiones (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener comisiones ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_COMISIONES ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_COMPANIAS"
RETURN Types.refCursor IS
  companiasCursor Types.refCursor;
BEGIN
  OPEN companiasCursor FOR
    SELECT c.descripcion, c.carrier_id AS id
    FROM CARRIER c
    WHERE c.STATUS=1
    ORDER BY c.descripcion;
  RETURN companiasCursor;

EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20002, 'Error'||SQLERRM(SQLCODE));

END GET_COMPANIAS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_COUNTRIES_INTER

 RETURN EBANKING.TYPES.REFCURSOR
 IS
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   
 BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT DISTINCT  CVE_PAIS, PAIS FROM EBANKING.SWIFTABA ORDER BY PAIS;
    RETURN CURSOR_OUTPUT;
 EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_COUNTRIES_INTER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION  GET_DATA_EBANKING_USER(id_alnova IN EBANKING.EBANKING_USER.ID%TYPE)

RETURN EBANKING.TYPES.REFCURSOR
IS 
CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;

CLSTATUS number:= 1;
BEGIN

    OPEN CURSOR_OUTPUT

    FOR
    
    select activation,
           active,
           advancedservice,
           tracking,
           ult_acceso,token
           
    from EBANKING_USER
    
    where ID = id_alnova;
    
    RETURN CURSOR_OUTPUT;
    
     EXCEPTION
      WHEN NO_DATA_FOUND THEN
         ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
      WHEN OTHERS THEN
         ROLLBACK;
         RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
         
   END GET_DATA_EBANKING_USER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_DATOS_PAGOS(idAlnova IN EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE, ctaOrigen IN EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE, idOper IN EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE, fechaIni VARCHAR2, fechaFin VARCHAR2) 
RETURN EBANKING.TYPES.REFCURSOR
 IS cursorPago EBANKING.TYPES.REFCURSOR;
BEGIN
      OPEN cursorPago FOR
      SELECT CTA_DESTINO, MONTO, FOLIO, IP, METODO_CONFIR 
      FROM EBANKING.EBANKING_BITACORA_TRAN
      WHERE NUM_CLIENTE = idAlnova AND CTA_ORIGEN = ctaOrigen AND ID_CAT_OPERACION = idOper 
      AND to_date(to_char(FECHA_OPER, 'dd/MM/yyyy'),'dd/MM/yyyy') BETWEEN to_date( fechaIni, 'dd/MM/yyyy') AND to_date( fechaFin,'dd/MM/yyyy')
      ORDER BY FECHA_OPER DESC;
      RETURN cursorPago;  
EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al obtener informacion de Pago  (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al obtener informacion de Pago ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END GET_DATOS_PAGOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_DESCUENTO (des_mtcn VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorDescuento Types.REFCURSOR;

  BEGIN
    OPEN cursorDescuento FOR

  SELECT DES.MTCN, DES.DESCRIPCION, DES.MONTO
		 FROM EBANKING.DINERO_EXPRESS_DESCUENTO DES 
		 WHERE DES.MTCN = des_mtcn;
   RETURN cursorDescuento;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener descuento (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener descuento ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_DESCUENTO ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_ESTADOS_REPUBLICA
RETURN Types.REFCURSOR  IS  CURSORSALIDA Types.REFCURSOR;
BEGIN
  
  OPEN CURSORSALIDA FOR
       SELECT ES.ID_ESTADO,ES.DESC_EDO FROM AFOREUSER.SEG_ESTADOS ES;
    RETURN CURSORSALIDA;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_ESTADOS_REPUBLICA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_FIRMA (folio_alnova VARCHAR2, contrato VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorFirma Types.REFCURSOR;

  BEGIN
    OPEN cursorFirma FOR

  SELECT FI.FIRMA FROM EBANKING_FIRMA FI WHERE FI.FOLIO_ALNOVA=folio_alnova AND FI.CONTRATO=contrato;
   RETURN cursorFirma;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener firma (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener firma ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_FIRMA ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_FRECUENTES_TA_IDCLIENTE" (idCliente NUMBER)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.COMPRATA_TELEFONOSFRECUENTES
  WHERE CLIENT=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de tiempo aire  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de tiempo aire  ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_FRECUENTES_TA_IDCLIENTE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_FRECUENTES_TA_IDSTATUS" (idCliente NUMBER)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.COMPRATA_TELEFONOSFRECUENTES
  WHERE (STATUS='1' OR STATUS IS NULL) AND CLIENT=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de tiempo aire  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de tiempo aire  ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_FRECUENTES_TA_IDSTATUS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_FREC_INTERN_MORAL_PERSON(
P_CLIENT                IN      EBANKING.TRANSFINTERNALFRECUENT.CLIENT%TYPE
)
RETURN TYPES.REFCURSOR
IS
type T_CURSOR IS REF CURSOR; --RETURN TRANSFINTERNALFRECUENT%ROWTYPE;
CURSOR_SALIDA T_CURSOR;
V_REG EBANKING.TRANSFINTERNALFRECUENT%ROWTYPE;
PERSONA NUMBER := 2;
BEGIN
   OPEN CURSOR_SALIDA 
    FOR
       SELECT 
          CLIENT,
          DESTINO,
          NAME,
          STATUS,
          FECHA_MODIFICACION,
          /*IP_ORIGEN,*/
          CLAVE_SWIFT,
          /*CANAL,*/
          APELLIDO_PATERNO,
          APELLIDO_MATERNO,
          LUGAR_NACIMIENTO,
          /*DOMICILIO,*/
          STATUS_BLOQUEO,
         /* FECHA_NACIMIENTO,*/
          FECHA_ACTIVACION,
          TIPO_PERSONA,
          RFC
      FROM EBANKING.TRANSFINTERNALFRECUENT
      WHERE CLIENT = P_CLIENT AND  TIPO_PERSONA = PERSONA;
      
    RETURN CURSOR_SALIDA;

EXCEPTION
         WHEN NO_DATA_FOUND THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' ||SQLCODE || '  ' || SQLERRM || ')');
         WHEN OTHERS THEN
                   RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' ||SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_FREC_INTERN_MORAL_PERSON ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_FREC_TELMEX_IDSTATUS" (idCliente NUMBER)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.TELMEX
  WHERE (STATUS='1' OR STATUS IS NULL) AND USER_ID=idCliente;
  DBMS_OUTPUT.PUT_LINE('hola');
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END GET_FREC_TELMEX_IDSTATUS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_FREC_TELMEX_IDTEL" (idCliente NUMBER, tel VARCHAR2)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.TELMEX
  WHERE TELEFONO=tel AND USER_ID=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END GET_FREC_TELMEX_IDTEL;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION "GET_FREC_TRAS_IDCUENTA" (idCliente NUMBER, pCuenta VARCHAR2)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
  WHERE CUENTA_DESTINO=pCuenta AND ID_CLIENTE=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de traspasos  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de traspasos  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END GET_FREC_TRAS_IDCUENTA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_FREC_TRAS_IDSTATUS" (idCliente NUMBER)

RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.DESTINOS_TEF_SPEI_TERCEROS
  WHERE (STATUS='1' OR STATUS IS NULL) AND ID_CLIENTE=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de traspasos  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de traspasos  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END GET_FREC_TRAS_IDSTATUS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Get_Historico_Pendientes (NUM_CTA VARCHAR2)
   RETURN TYPES.refcursor
IS
   datos   TYPES.refcursor;
BEGIN
   OPEN datos
    FOR
       SELECT   AN.FOLIO_ALNOVA,
                   AN.FOLIO_OPERACION,
                AN.NUMERO_REGISTRO,
                AN.CUENTA_ABONO,
                AN.IMPORTE,
                AN.BENEFICIARIO,
                AN.CONCEPTO,
                AN.LLAVE,
                AN.FECHA_INICIO_PERIODO,
                AN.FECHA_FIN_PERIODO,
                AN.CONCEPTO_COMPROBANTE,
                AN.NUM_PERIODO,
                AN.RFC_EMPLEADO,
                AN.NUM_SEG_SOC_EMPLEADO,
                AN.DESCRIPCION_PUESTO,
                AN.COMPANIA,
                AN.PERCEPCIONES,
                AN.DEDUCCIONES,
                AN.STATUS_PAGO,
                AN.BANDERA_RETENCION,
                AN.BANDERA_SUMATORIA,
                AN.CONTRATO
                
           FROM PAPERLESS.ARCHIVO_NOMINA_H AN
          WHERE AN.CUENTA_ABONO = '00'--NUM_CTA    Se omite la cuenta que llega desde la WS de liberacion de recibos, ya que no se van a regresar los recibos historicos y se le pone una cuenta ficticia
            AND AN.BANDERA_SUMATORIA NOT IN ('02','99')   --02 son las llaves principales y las 99 las otras.. buscar dentro de las
            AND AN.LLAVE IN (                                --relaciones de llaves para obtener los historicos.        
                                SELECT FR.LLAVE
                                  FROM PAPERLESS.FIRMA_RECIBO FR
                                 WHERE FR.NUM_CUENTA_EMPLEADO = NUM_CTA) /*NUM_CTA Se omite la cuenta que llega desde la WS de liberacion de recibos, ya que no se van a regresar los recibos historicos y se le pone una cuenta ficticia*/
                                 
                            
       ORDER BY AN.LLAVE;

   RETURN datos;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      RETURN datos;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_HUELLA_NOMI_EXP (
    v_sucursal VARCHAR2,
    v_cuenta VARCHAR2
    )
 RETURN Types.REFCURSOR

IS

  cursorHuellas Types.REFCURSOR;

  BEGIN
    OPEN cursorHuellas FOR

  SELECT * FROM EBANKING.TMP_HUELLA HD WHERE HD.sucursal=v_sucursal and  HD.cuenta=v_cuenta;
   RETURN cursorHuellas;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener huella ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_HUELLA_NOMI_EXP ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_IMPUESTO (imp_mtcn VARCHAR2)
 RETURN Types.REFCURSOR

IS

  cursorImpuesto Types.REFCURSOR;

  BEGIN
    OPEN cursorImpuesto FOR

  SELECT IMP.MTCN, IMP.DESCRIPCION, IMP.MONTO
		 FROM EBANKING.DINERO_EXPRESS_IMPUESTO IMP 
		 WHERE IMP.MTCN = imp_mtcn;
   RETURN cursorImpuesto;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener impuesto (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener impuesto ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_IMPUESTO ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_IP_METODOAUTENTIFICACION (
    p_accion              VARCHAR2,
    p_numCliente          EBANKING.EBANKING_BITACORA_TRAN.NUM_CLIENTE%TYPE,
    p_cuenta              EBANKING.EBANKING_BITACORA_TRAN.CTA_ORIGEN%TYPE, 
    p_ID_Cat_Operacion    EBANKING.EBANKING_BITACORA_TRAN.ID_CAT_OPERACION%TYPE
) RETURN types.REFCURSOR
IS
  cursorIPMetodoAutentificacion types.REFCURSOR;
BEGIN
  IF p_accion='1' THEN
      OPEN cursoripmetodoautentificacion FOR
      SELECT CTA_DESTINO, IP, METODO_CONFIR, CTA_ORIGEN, MONTO 
      FROM EBANKING.EBANKING_BITACORA_TRAN
      WHERE NUM_CLIENTE = P_NUMCLIENTE AND CTA_ORIGEN = p_cuenta AND ID_CAT_OPERACION = P_ID_CAT_OPERACION ORDER BY ID, FECHA_OPER DESC;
      RETURN cursoripmetodoautentificacion;
  END IF;  
EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener IP y Metodo de autentificacion (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, ' IP y Metodo de autentificacion ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
END GET_IP_METODOAUTENTIFICACION;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_LISTA_USERS_TEMP(
    ENTRADA VARCHAR2
    )
RETURN INTEGER IS

var_Client NUMBER;
 
 BEGIN

          SELECT CLIENTE  INTO var_Client  FROM EBANKING.EBANKING_ACTIVATION WHERE CLIENTE=03218887;
          
          RETURN(var_Client);
              

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_LISTA_USERS_TEMP;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION "GET_MAX_AMOUNT" (idCliente NUMBER) RETURN Types.refCursor
IS
  frecuentesCursor Types.refCursor;
BEGIN
  OPEN frecuentesCursor FOR
  SELECT *
  FROM EBANKING.EBANKING_SECURITY_MAX_AMOUNT
  WHERE IDUSER=idCliente;
  RETURN frecuentesCursor;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los montos maximos  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de tiempo aire  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');

END GET_MAX_AMOUNT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_MODIFICATION_DATE(
CLIENTEDEX  IN  EBANKING.BENEFI_DEX.CTEDEX%TYPE,
TIPOBEN     IN  EBANKING.BENEFI_DEX.TIP_BENEFI%TYPE
)
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
            SELECT ID_BENEFICIARIO_DEX,ALIAS_BENEFICIARIO, CTEDEX,  
            TO_CHAR(ULTIMA_MODIFICACION , 'dd-mm-yyyy hh24:mi:ss') AS UM 
            FROM BENEFI_DEX 
            WHERE CTEDEX= CLIENTEDEX AND TIP_BENEFI= TIPOBEN ORDER BY FECHAACTIVACION DESC;
            
    RETURN CURSOR_OUTPUT;
    
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_MODIFICATION_DATE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_MODIFICATION_DATE_DEX(
CLIENTEDEX  IN  EBANKING.BENEFI_DEX.CTEDEX%TYPE,
TIPOBEN     IN  EBANKING.BENEFI_DEX.TIP_BENEFI%TYPE
)
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
            SELECT ID_BENEFICIARIO_DEX,ALIAS_BENEFICIARIO,  
            TO_CHAR(ULTIMA_MODIFICACION , 'dd-mm-yyyy hh24:mi:ss') AS UM 
            FROM BENEFI_DEX 
            WHERE CTEDEX= CLIENTEDEX AND TIP_BENEFI= TIPOBEN ORDER BY FECHAACTIVACION DESC;
            
    RETURN CURSOR_OUTPUT;
    
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_MODIFICATION_DATE_DEX;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_MONTOS_PERMITIDOS
   RETURN Types.REFCURSOR
IS

 montosPermitidos Types.REFCURSOR;

BEGIN
  OPEN montosPermitidos FOR

SELECT MONTO_MX,MONTO_COM FROM EBANKING.MONTOS_USER WHERE ID_MONTO_USER=(SELECT MAX(ID_MONTO_USER) FROM EBANKING.MONTOS_USER);
   RETURN montosPermitidos;

  EXCEPTION
    WHEN OTHERS THEN
   raise_application_error(-20001,'Ocurrio un error al intentar obtener Montos - '||SQLCODE||' -ERROR- '||SQLERRM);

END GET_MONTOS_PERMITIDOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_MTCN_transactions(
V_CLIENTE_ID   IN  EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE
)RETURN EBANKING.TYPES.REFCURSOR
 IS
 CURSOR_OUTPUT EBANKING.TYPES.REFCURSOR;
   BEGIN
      OPEN CURSOR_OUTPUT 
       FOR
          SELECT TRANSFER_DEX.CLIENTE_ID, TRANSFER_DEX.MTCN,PAIS_ID_DESTINO,
            ESTADO_ID_DESTINO,
            CIUDAD_ID_DESTINO,
            IMPUESTO_DEX.MONTO,
            FECHA_ENVIO,
            TARIFA
            FROM EBANKING.TRANSFER_DEX
            JOIN EBANKING.IMPUESTO_DEX ON TRANSFER_DEX.MTCN=IMPUESTO_DEX.MTCN
            WHERE
            TRANSFER_DEX.CLIENTE_ID=V_CLIENTE_ID
            ORDER BY TRANSFER_DEX.ULTIMA_MODIFICACION,TO_NUMBER(TRANSFER_DEX.MTCN);
    RETURN CURSOR_OUTPUT;
   
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR (-20100, 'No hay resultados (' || SQLCODE || '  ' || SQLERRM || ')');
     WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END GET_MTCN_transactions;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_NSS RETURN
Types.refCursor IS
  nssCursor Types.refCursor;
BEGIN
  OPEN nssCursor FOR
    SELECT A.NSS, A.RFC
    FROM AFOREUSER.AFOREUSER_USER A;
  RETURN nssCursor;

EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20002, 'Error'||SQLERRM(SQLCODE));

END GET_NSS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_PAGO_GOB_PDF_FIN(
    v_linea_captura VARCHAR2,
    v_num_autorizacion VARCHAR2
    )
 RETURN Types.REFCURSOR

IS
  cursorPagos Types.REFCURSOR;

  BEGIN
    OPEN cursorPagos FOR
    SELECT ID_CLIENTE, TITULO_PAGO, NOMBRE_CLIENTE, DIRECCION, CODIGO_POSTAL, MUNICIPIO, ESTADO, CONCEPTO,
 BANCO, NUM_AUTORIZACION, FECHA_PAGO, LINEA_CAPTURA, CERT_DIGITAL, TOTAL, ID_SERVICIO, COLONIA, CONCEPTO1,
 CONCEPTO2, CONCEPTO3, CONCEPTO4, CONCEPTO5, CONCEPTO6, CONCEPTO7,RFC,CUENTACARGO,IVACOMISION,IVA,IMPORTE
 FROM ebanking.DATOS_GOBIERNOS_PDF
   WHERE LINEA_CAPTURA LIKE v_linea_captura
   AND NUM_AUTORIZACION LIKE v_num_autorizacion;

  RETURN cursorPagos;

EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_PAGO_GOB_PDF_FIN ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          Get_Pago_Imss_Pdf(  
 V_CLIENTE IN EBANKING.DATOS_IMSS_PDF.ID_CLIENTE%TYPE
   ,V_FECINI  VARCHAR2
   ,V_FECFIN  VARCHAR2
)
RETURN EBANKING.TYPES.REFCURSOR
IS
  cursorPagos EBANKING.TYPES.REFCURSOR;
  BEGIN
    OPEN cursorPagos FOR
    SELECT LINEA_CAPTURA
          ,NUM_AUTORIZACION
          ,OPCION
          ,FOLIOSUA
          ,PERIODOPAGO
          ,IMPORTETOTAL
          ,IMPORTERCV
          ,IMPORTEIMSS
          ,IMPORTEACV
          ,IMPORTEVIVIENDA
          ,IMPORTEINFONAVIT
          ,IMPORTESEGUROSIMSS
          ,IMPORTEACTUALIZACIONIMSS
          ,IMPORTERECARGOSIMSS
          ,IMPORTERETIROCESAFORE
          ,IMPORTEACTUALIZACIONAFORE
          ,IMPORTERECARGOSAFORE
          ,IMPORTEAPORTACIONVOLAFORE
          ,IMPORTEAPORTACIONCOMAFORE
          ,IMPORTECUENTAINDINFONAVIT
          ,IMPORTEAPORPATRONALINFONAVIT
          ,IMPORTEAMORTIZACIONINFONAVIT
          ,IMPORTEACTUALIZACIONINFONAVIT
          ,IMPORTERECARGOSINFONAVIT
          ,IMPORTEMULTASINFONAVIT
          ,IMPORTEFUNDEMEXINFONAVIT
          ,ORIGENARCHIVO
          ,REGPATRONAL
          ,VERSIONSUA
          ,TO_CHAR(FECHA_VENCIMIENTO,'YYYYMMDD') FECHA_VENCIMIENTO
          ,TO_CHAR(FECHA_CARGO,'DD/MM/YYYY HH24:MI:SS') FECHA_CARGO
          ,TO_CHAR(FECHA_PAGO,'DD/MM/YYYY HH24:MI:SS') FECHA_PAGO
          ,NUM_TRABAJADORES
          ,RAZONSOCIAL
          ,DOMICILIO
          ,RFCPATRONAL
          ,ID_CLIENTE
          ,CUENTACARGO
          ,SELLO_DIGITAL
          ,COMISION
     FROM EBANKING.DATOS_IMSS_PDF
    WHERE ID_CLIENTE = V_CLIENTE
      AND TRUNC(FECHA_PAGO) BETWEEN TO_DATE(V_FECINI, 'dd/MM/yyyy')  AND TO_DATE(V_FECFIN, 'dd/MM/yyyy');    

   RETURN cursorPagos;
EXCEPTION
   WHEN NO_DATA_FOUND THEN  
      RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio IMSS (' || SQLCODE || '  ' || SQLERRM || ')');
   WHEN OTHERS THEN  
      RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio IMSS (' || SQLCODE || '  ' || SQLERRM || ')');

END Get_Pago_Imss_Pdf;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_PAGO_SERV_PDF(
    v_cliente VARCHAR2,
    v_servicio VARCHAR2,
    v_fecini VARCHAR2,
    v_fecfin VARCHAR2
    )
 RETURN Types.REFCURSOR

IS
  cursorPagos Types.REFCURSOR;
 BEGIN
IF v_servicio='*'
    THEN
       OPEN cursorPagos FOR
       SELECT ID_SERVICIO, LINEA_CAPTURA REFERENCIA,  FECHA_PAGO, NUM_AUTORIZACION NUMERO_OPERACION, FECHA_PAGO FECHA_APLICACION, TOTAL, CERT_DIGITAL AS SELLO_DIGITAL, CUENTACARGO
        FROM ebanking.DATOS_GOBIERNOS_PDF
        WHERE ID_CLIENTE = v_cliente
        AND FECHA_PAGO BETWEEN to_date( v_fecini, 'dd/MM/yyyy') and to_date( v_fecfin,'dd/MM/yyyy')
       UNION ALL
       SELECT ID_SERVICIO,  REFERENCIA, FECHA_PAGO, NUMERO_OPERACION, FECHA_APLICACION, TOTAL, SELLO_DIGITAL, CUENTA_CARGO 
       FROM ebanking.DATOS_SERVICIO_PDF
        WHERE NUMERO_CLIENTE = v_cliente
        AND to_date(to_char( FECHA_PAGO, 'dd/MM/yyyy'),'dd/MM/yyyy') BETWEEN to_date( v_fecini, 'dd/MM/yyyy') and to_date(v_fecfin, 'dd/MM/yyyy');
        RETURN cursorPagos;
    ELSE
       OPEN cursorPagos FOR
       SELECT ID_SERVICIO, LINEA_CAPTURA REFERENCIA,  FECHA_PAGO, NUM_AUTORIZACION NUMERO_OPERACION, FECHA_PAGO FECHA_APLICACION, TOTAL, CERT_DIGITAL AS SELLO_DIGITAL, CUENTACARGO
       FROM ebanking.DATOS_GOBIERNOS_PDF
        WHERE ID_CLIENTE = v_cliente
        AND to_date(to_char( FECHA_PAGO, 'dd/MM/yyyy'),'dd/MM/yyyy') BETWEEN to_date( v_fecini, 'dd/MM/yyyy') and to_date( v_fecfin,'dd/MM/yyyy')
        AND ID_SERVICIO = v_servicio
       UNION ALL
       SELECT ID_SERVICIO,  REFERENCIA, FECHA_PAGO, NUMERO_OPERACION, FECHA_APLICACION, TOTAL, SELLO_DIGITAL, CUENTA_CARGO
       FROM ebanking.DATOS_SERVICIO_PDF
        WHERE NUMERO_CLIENTE = v_cliente
        AND to_date(to_char( FECHA_PAGO, 'dd/MM/yyyy'),'dd/MM/yyyy') BETWEEN to_date( v_fecini, 'dd/MM/yyyy') and to_date( v_fecfin, 'dd/MM/yyyy')
        AND ID_SERVICIO = v_servicio;
        RETURN cursorPagos;
    END IF;
EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_PAGO_SERV_PDF;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_PAGO_SERV_PDF_FIN(
	v_referencia VARCHAR2,
    v_numero_operacion VARCHAR2
    )
 RETURN Types.REFCURSOR

IS

  cursorPagos Types.REFCURSOR;

  BEGIN
    OPEN cursorPagos FOR

  SELECT REFERENCIA, NUMERO_OPERACION, FECHA_APLICACION, FECHA_PAGO, ID_SERVICIO, CUENTA_CARGO, IMPORTE, COMISION,
  IVA, TOTAL, SELLO_DIGITAL, NOMBRE_COMPLETO, ACTIVIDAD, NUMERO_CLIENTE, ADICIONAL FROM ebanking.DATOS_SERVICIO_PDF
   WHERE NUMERO_OPERACION = v_numero_operacion
   AND REFERENCIA = v_referencia;

  RETURN cursorPagos;


EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener pago de servicio ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_PAGO_SERV_PDF_FIN ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_RFC( V_NUMERO_CLIENTE VARCHAR2 )
RETURN VARCHAR2 IS
tmpVar VARCHAR2(256);
/******************************************************************************
   NAME:       GET_RFC
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        16/06/2009          1. Created this function.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     GET_RFC
      Sysdate:         16/06/2009
      Date and Time:   16/06/2009, 05:43:35 p.m., and 16/06/2009 05:43:35 p.m.
      Username:         (set in TOAD Options, Procedure Editor)
      Table Name:       (set in the "New PL/SQL Object" dialog)

******************************************************************************/
BEGIN
  SELECT AUX.RFC INTO tmpVar
  		 from EBANKING.EBANKING_RFC AUX WHERE AUX.USER_ID=V_NUMERO_CLIENTE ;


   RETURN tmpVar;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END GET_RFC;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "GET_SERVICIO_DP_RT_NS"(
vSECUENCIA          TELEFONO.SECUENCIA%TYPE)
RETURN NUMERIC IS
    vDEPOSITO NUMERIC;
    vRETIRO   NUMERIC;
    vDPRT     NUMERIC;
BEGIN
    SELECT COUNT(T.TELEFONO_ID) INTO vDEPOSITO
    FROM EBANKING_ALERTAS_DEPOSITO X, TELEFONO T, CARRIER C
    WHERE X.SECUENCIA_TELEFONO=vSECUENCIA AND X.SECUENCIA_TELEFONO= T.SECUENCIA AND T.CARRIER_ID=C.CARRIER_ID;

    SELECT COUNT(T.TELEFONO_ID) INTO vRETIRO
    FROM EBANKING_ALERTAS_RETIRO X, TELEFONO T, CARRIER C
    WHERE X.SECUENCIA_TELEFONO=vSECUENCIA AND X.SECUENCIA_TELEFONO= T.SECUENCIA AND T.CARRIER_ID=C.CARRIER_ID;

    IF vDEPOSITO=1 AND  vRETIRO=1 THEN
        SELECT COUNT(EAD.CLIENTE_ID) INTO vDPRT
        FROM EBANKING_ALERTAS_DEPOSITO EAD, EBANKING_ALERTAS_RETIRO EAR
        WHERE EAD.CLIENTE_ID=EAR.CLIENTE_ID AND EAD.CUENTA_HASH=EAR.CUENTA_HASH AND EAD.SECUENCIA_TELEFONO=EAR.SECUENCIA_TELEFONO
        AND EAD.SECUENCIA_TELEFONO=vSECUENCIA;
        IF vDPRT=0 THEN
            RETURN vDEPOSITO+vRETIRO;
        ELSE
            RETURN 1;
        END IF;
    ELSE
        RETURN vDEPOSITO+vRETIRO;
    END IF;

END GET_SERVICIO_DP_RT_NS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_STATUS_CAT  
RETURN TYPES.refCursor

IS
cat_id NUMBER;
datos   TYPES.refcursor;
BEGIN

	OPEN datos
 	FOR	   
	   SELECT PC.STATUS, PC.ID FROM EBANKING.PORTAL_CAT PC WHERE PC.ID = (SELECT MAX(PC2.ID) FROM EBANKING.PORTAL_CAT PC2);
	   RETURN datos;	 
	 	 		 		   
EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en GET_STATUS_CAT (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error al insertar en GET_STATUS_CAT ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_STATUS_CAT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_TERM_NO_CONVER(ID VARCHAR)
 
RETURN TYPES.refCursor IS
terminalesCursor types.refCursor;

BEGIN
 OPEN terminalesCursor FOR 
 	   SELECT MIN(id), MAX(id) FROM EBANKING.ALNOVA_TERMINAL WHERE CODE<>'NKRL' AND BUSY = 0; 
 RETURN terminalesCursor;
 
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  (' || SQLCODE || '  ' || SQLERRM || ')');

	WHEN OTHERS THEN
		 RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los frecuentes de telmex  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
      
END GET_TERM_NO_CONVER;
/

SHOW ERRORS;


CREATE OR REPLACE function get_token (
    the_list varchar2,
    the_index number,
    delim varchar2 :=';'
)
    return varchar2
is
    start_pos number;
    end_pos number;

begin
    if the_index = 1 then
        start_pos := 1;

    elsif the_index < 0 then
        start_pos := instr(the_list, delim, -1, abs(the_index)) + 1;

    else
        start_pos := instr(the_list, delim, 1, the_index - 1);

        if start_pos = 0 then
            return null;
        else
            start_pos := start_pos + length(delim);
        end if;

    end if;

    if the_index < 0 then
        end_pos := instr(the_list, delim, start_pos+1, 1);
    else
        end_pos := instr(the_list, delim, start_pos, 1);
    end if;

    if end_pos = 0 then
        return substr(the_list, start_pos);
    else
        return substr(the_list, start_pos, end_pos - start_pos);
    end if;

end get_token;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          Get_TokenSolicitud
RETURN Types.refCursor
IS
  MonTransaccionCursor Types.refCursor;
BEGIN
  OPEN MonTransaccionCursor FOR
  
        
  Select   
    /*+ INDEX (etp IDX_TOKEN_PREV_CTE)*/
        etp.ID      AS id ,                                                             
        TO_CHAR(etp.FEC_HORA_OPERACION,'dd/mm/yyyy hh24:mm:ss ') AS fechasolicitud     ,
        etp.ESTATUS                                                                 AS estatus            , 
        ea.Cuenta             AS cuenta      

    FROM ebanking_token_prevencion etp, EBANKING_CELLCOMPANY ec , ebanking_user eu,     ebanking_cellCompany ec2 ,
         EBANKING_ACTIVATION ea
    WHERE                                                                                                                   
               etp.CARRIER_CEL=ec.id                                                                                           
           AND eu.USER2CELLCOMPANY=ec2.id                                                                                           
           AND eu.ID =etp.NUM_CLIENTE     
           AND etp.TIPO_OPERACION = 0          
           AND etp.ESTATUS =1                                         
           AND ea.cliente (+)  =  etp.NUM_CLIENTE  
           AND LENGTH(etp.NUM_CLIENTE) = 8           
       
UNION         

    SELECT   

     /*+ INDEX (etp IDX_TOKEN_PREV_CTE)*/
        etp.ID                 AS ID,                                                        
        TO_CHAR (etp.fec_hora_operacion,'dd/mm/yyyy hh24:mm:ss ')         AS fechasolicitud,  
        etp.estatus                 AS estatus,                   
        ''            AS cuenta             

    FROM ebanking_token_prevencion etp, ebanking_cellcompany ec
               
    WHERE 
          etp.tipo_operacion = 0 
          AND etp.estatus = 1 AND LENGTH(etp.NUM_CLIENTE) = 12
          AND (ec.ID = etp.CARRIER_CEL OR etp.CARRIER_CEL = -1) ;
      
  RETURN MonTransaccionCursor;

EXCEPTION
WHEN OTHERS THEN
 RAISE_APPLICATION_ERROR (-20003, 'Error'||SQLERRM(SQLCODE));

END Get_TokenSolicitud;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_TRANSFERENCIA (tr_num_cuenta VARCHAR2, tr_fecha_inicio DATE, tr_fecha_fin DATE)
 RETURN Types.REFCURSOR

IS

  cursorTransferencia Types.REFCURSOR;

  BEGIN
	IF(tr_fecha_fin IS NOT NULL AND tr_fecha_inicio IS NOT NULL)
		THEN
		    OPEN cursorTransferencia FOR		
			SELECT TRAN.CLIENTE_ID, TRAN.MTCN, TRAN.MONTO_ENVIADO, TRAN.BENEFICIARIO_ID, TRAN.TARIFA,
				   TRAN.NUM_CUENTA, TRAN.FECHA_ENVIO, NVL(IMP.MONTO,0) IMPUESTOS, NVL(DES.MONTO,0) DESCUENTOS
				   FROM EBANKING.DINERO_EXPRESS_TRANSFERENCIA TRAN
				   		LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_IMPUESTO GROUP BY MTCN) IMP
						ON IMP.MTCN = TRAN.MTCN
						LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_DESCUENTO GROUP BY MTCN) DES
						ON DES.MTCN = TRAN.MTCN 
				   WHERE TRAN.NUM_CUENTA = tr_num_cuenta AND TRAN.FECHA_ENVIO BETWEEN tr_fecha_inicio AND tr_fecha_fin;
		    RETURN cursorTransferencia;		
		ELSE
			IF(tr_fecha_inicio IS NOT NULL)
				THEN
				    OPEN cursorTransferencia FOR				
					SELECT TRAN.CLIENTE_ID, TRAN.MTCN, TRAN.MONTO_ENVIADO, TRAN.BENEFICIARIO_ID, TRAN.TARIFA,
						   TRAN.NUM_CUENTA, TRAN.FECHA_ENVIO, NVL(IMP.MONTO,0) IMPUESTOS, NVL(DES.MONTO,0) DESCUENTOS
						   FROM EBANKING.DINERO_EXPRESS_TRANSFERENCIA TRAN
						   		LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_IMPUESTO GROUP BY MTCN) IMP
								ON IMP.MTCN = TRAN.MTCN
								LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_DESCUENTO GROUP BY MTCN) DES
								ON DES.MTCN = TRAN.MTCN						    
						   WHERE TRAN.NUM_CUENTA = tr_num_cuenta AND TRAN.FECHA_ENVIO >= tr_fecha_inicio;	 
				    RETURN cursorTransferencia;				
				ELSE
					IF(tr_fecha_fin IS NOT NULL)
						THEN
						    OPEN cursorTransferencia FOR						
							SELECT TRAN.CLIENTE_ID, TRAN.MTCN, TRAN.MONTO_ENVIADO, TRAN.BENEFICIARIO_ID, 
								   TRAN.TARIFA, TRAN.NUM_CUENTA, TRAN.FECHA_ENVIO,
								   NVL(IMP.MONTO,0) IMPUESTOS, NVL(DES.MONTO,0) DESCUENTOS
								   FROM EBANKING.DINERO_EXPRESS_TRANSFERENCIA TRAN
								   		LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_IMPUESTO GROUP BY MTCN) IMP
										ON IMP.MTCN = TRAN.MTCN
										LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_DESCUENTO GROUP BY MTCN) DES
										ON DES.MTCN = TRAN.MTCN								    
								   WHERE TRAN.NUM_CUENTA = tr_num_cuenta AND TRAN.FECHA_ENVIO <= tr_fecha_fin;
						    RETURN cursorTransferencia;						
						ELSE
						    OPEN cursorTransferencia FOR						
							SELECT TRAN.CLIENTE_ID, TRAN.MTCN, TRAN.MONTO_ENVIADO, TRAN.BENEFICIARIO_ID, 
								   TRAN.TARIFA, TRAN.NUM_CUENTA, TRAN.FECHA_ENVIO,
								   NVL(IMP.MONTO,0) IMPUESTOS, NVL(DES.MONTO,0) DESCUENTOS
								   FROM EBANKING.DINERO_EXPRESS_TRANSFERENCIA TRAN
								   		LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_IMPUESTO GROUP BY MTCN) IMP
										ON IMP.MTCN = TRAN.MTCN
										LEFT JOIN (SELECT MTCN, SUM(MONTO) MONTO FROM EBANKING.DINERO_EXPRESS_DESCUENTO GROUP BY MTCN) DES
										ON DES.MTCN = TRAN.MTCN								    
								   WHERE TRAN.NUM_CUENTA = tr_num_cuenta;
						    RETURN cursorTransferencia;						
					END IF;
			END IF;	
	END IF;	


EXCEPTION
WHEN NO_DATA_FOUND THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener transferencia (' || SQLCODE || '  ' || SQLERRM || ')');
WHEN OTHERS THEN  RAISE_APPLICATION_ERROR (-20100, 'Error obtener transferencia ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');

END GET_TRANSFERENCIA ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          GET_USR_CTA_OCULTA 
    (P_CUENTA IN EBANKING.CTAS_OCULTAS.CUENTA%TYPE,
    P_IDALNOVA IN EBANKING.CTAS_OCULTAS.ID_CLI_ALNOVA%TYPE)
RETURN EBANKING.CTAS_OCULTAS.CUENTA%TYPE IS
P_CUENTA_EXISTE EBANKING.CTAS_OCULTAS.CUENTA%TYPE;
BEGIN
   SELECT CUENTA INTO P_CUENTA_EXISTE
     FROM EBANKING.CTAS_OCULTAS
     WHERE ID_CLI_ALNOVA=P_IDALNOVA AND CUENTA=P_CUENTA;
   RETURN P_CUENTA_EXISTE;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
        RETURN -1;
     WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR (-20000, 'Error al obtener usuario en  EBANKING.GET_USUARIO_CUENTA_OCULTA  (' || SQLCODE || '  ' || SQLERRM || ')');
END GET_USR_CTA_OCULTA ;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_CREDEXTFRECUENT(
    pCliente number,
	pBanco number,
	pTipoCredito number,
	pCuentaCredito varchar,
	pBeneficiario varchar,
	pIPOrigen varchar
  )
  RETURN INTEGER IS

  vClient number;
  vStatus integer;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENTE,STATUS into vClient, vStatus from CREDITOSOTROSBANCOSFRECUENT
	where cliente = pCliente and banco = pBanco  and beneficiario = pBeneficiario and cuentaCredito=pCuentaCredito;

    EXCEPTION
      when no_data_found then
		insert into CREDITOSOTROSBANCOSFRECUENT
        ( cliente,banco,tipoCredito,cuentaCredito,beneficiario,status,fecha_modificacion,ip_origen )
		values (pCliente, pBanco, pTipoCredito, pCuentaCredito, pBeneficiario, 1, sysdate, pIPOrigen);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  update CREDITOSOTROSBANCOSFRECUENT set
  	beneficiario = pBeneficiario,
	status = 1,
	fecha_modificacion = sysdate,
	ip_origen = pIPOrigen
  where
   cliente = pCliente
   and banco = pBanco
   and Beneficiario = pBeneficiario
   and cuentaCredito =pCuentaCredito  ;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_CREDEXTFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_MAIL(
    pSubject number,
	pMail_to varchar,
	pMail_cc varchar,
	pMail_bcc varchar,
	pContenido varchar,
	pStatus varchar
  )
  BEGIN
		INSERT INTO EBANKING_MAIL (SUBJECT, MAIL_TO, MAIL_CC, MAIL_BCC, CONTENIDO, STATUS)
		VALUES (pSubject, pMail_to, pMail_cc, pMail_bcc, pContenido, pStatus);
  END;

  END INSERTA_MAIL;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Noreferencia_Tef(
    pCliente NUMBER,
	pNoReferencia VARCHAR
  )
  RETURN INTEGER
  IS
  BEGIN
  	--Insertamos el cliente, numero de referencia, fecha de operacion y status
	INSERT INTO EBANKING_REF_TEF (CLIENTE_ID, NOREFERENCIA, FECHAOPERACION,STATUS)
	VALUES (pCliente,pNoReferencia, SYSDATE, 1);
	RETURN 1;
  EXCEPTION
  WHEN OTHERS THEN
     RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN 0;
  END Inserta_Noreferencia_Tef;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Servicio_Deposito(
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vCliente_Id INTEGER;
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

    BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  RETURN falso;
  END;

	BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
	SELECT cliente_id INTO vCliente_Id FROM EBANKING_ALERTAS_DEPOSITO WHERE cliente_id = pCliente AND cuenta_hash=pCuentaHash AND secuencia_telefono=vSecuencia;
	RETURN verdadero;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  INSERT INTO EBANKING_ALERTAS_DEPOSITO VALUES (pCliente, pCuentaHash, VSecuencia);
	  COMMIT;
	  RETURN verdadero;
  END;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Inserta_Servicio_Deposito;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Servicio_Retiro(
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vCliente_Id INTEGER;
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

    BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  RETURN falso;
  END;

	BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
	SELECT cliente_id INTO vCliente_Id FROM EBANKING_ALERTAS_RETIRO WHERE cliente_id = pCliente AND cuenta_hash=pCuentaHash AND secuencia_telefono=vSecuencia;
	RETURN verdadero;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  INSERT INTO EBANKING_ALERTAS_RETIRO VALUES (pCliente, pCuentaHash, VSecuencia);
	  COMMIT;
	  RETURN verdadero;
  END;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Inserta_Servicio_Retiro;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Servicio_Tefdev(
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vCliente_Id INTEGER;
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

    BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  RETURN falso;
  END;

	BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
	SELECT cliente_id INTO vCliente_Id FROM EBANKING_ALERTAS_TEFDEV WHERE cliente_id = pCliente AND cuenta_hash=pCuentaHash AND secuencia_telefono=vSecuencia;
	RETURN verdadero;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
	  INSERT INTO EBANKING_ALERTAS_TEFDEV VALUES (pCliente, pCuentaHash, VSecuencia);
	  COMMIT;
	  RETURN verdadero;
  END;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Inserta_Servicio_Tefdev;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_SPEIFRECUENT(
    pClient number,
	pBank number,
	pState number,
	pPlaza number,
	pDestino varchar,
	pName varchar,
	pIpOrigen varchar,
	pEmail varchar,
	pCelular varchar,
	pTelCasa varchar,
	pTelOficina varchar,
	pExtension varchar
  )
  RETURN INTEGER IS

  vClient number;
  vStatus integer;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENT,STATUS into vClient, vStatus from TEFSPEUAFRECUENT
	where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;

    EXCEPTION
      when no_data_found then
		insert into TEFSPEUAFRECUENT
                   (client,  bank,  state,  plaza,  destino,  name,  status, fecha_modificacion, ip_origen, email,  celular,  telcasa,  teloficina,  extension)
            values (pClient, pBank, pState, pPlaza, pDestino, pName, 1,       sysdate,           pIpOrigen, pEmail,	pCelular, pTelCasa,	pTelOficina, pExtension);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  update TEFSPEUAFRECUENT
  set    name = pName
        ,status = 1
		,fecha_modificacion = sysdate
		,ip_origen = pIPOrigen
        ,email = pEmail
        ,celular = pCelular
        ,telcasa = pTelCasa
        ,teloficina = pTelOficina
        ,extension = pExtension
  where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_SPEIFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_SPEUAFRECUENT(
    pClient number,
	pBank number,
	pState number,
	pPlaza number,
	pDestino varchar,
	pName varchar,
	pIpOrigen varchar
  )
  RETURN INTEGER IS

  vClient number;
  vStatus integer;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENT,STATUS into vClient, vStatus from TEFSPEUAFRECUENT
	where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;

    EXCEPTION
      when no_data_found then
		insert into TEFSPEUAFRECUENT
                   (client,  bank,  state,  plaza,  destino,  name,  status, fecha_modificacion, ip_origen)
            values (pClient, pBank, pState, pPlaza, pDestino, pName, 1,       sysdate,           pIpOrigen);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  update TEFSPEUAFRECUENT set name = pName, status = 1, fecha_modificacion = sysdate, ip_origen = pIPOrigen
  where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_SPEUAFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          INSERTA_TDCFRECUENT(
    pClient number,
	pDestino varchar,
	pBanco varchar,
	pNombre varchar,
	pIpOrigen varchar,
	pAlias varchar
  )
  RETURN INTEGER IS
  vClient number;
  vStatus integer;
  BEGIN
  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENT,STATUS into vClient, vStatus from TDCFRECUENT
	where client = pClient and destino = pDestino;
    EXCEPTION
      when no_data_found then
		insert into TDCFRECUENT (CLIENT, DESTINO, BANCO, NOMBRE, STATUS, FECHA_MODIFICACION, IP_ORIGEN,ALIAS)
		values (pClient, pDestino, pBanco, pNombre, 1, sysdate, pIpOrigen, pAlias);
	  RETURN 1;
  END;
  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el status, fecha y la IP
  update TDCFRECUENT set status = 1, fecha_modificacion = sysdate, ip_origen = pIPOrigen, banco =pBanco, nombre = pNombre, alias = pAlias
  where client = pClient and destino = pDestino;
  COMMIT;
  RETURN 1;
  END IF;
  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_TDCFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_TEFFRECUENT(
    pClient number,
	pBank number,
	pState number,
	pPlaza number,
	pDestino varchar,
	pName varchar,
	pIpOrigen varchar,
	pEmail varchar,
	pCelular varchar,
	pTelCasa varchar,
	pTelOficina varchar,
	pExtension varchar
  )

  RETURN INTEGER IS

  vClient number;
  vStatus integer;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENT,STATUS into vClient, vStatus from TEFSPEUAFRECUENT
	where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;

    EXCEPTION
      when no_data_found then
		insert into TEFSPEUAFRECUENT
--                   (client,  bank,  state,  plaza,  destino,  name,  status, fecha_modificacion, ip_origen)
            values (pClient, pBank, pState, pPlaza, pDestino, pName, 1,       sysdate,           pIpOrigen,
			pEmail, pCelular, pTelCasa, pTelOficina, pExtension);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  update TEFSPEUAFRECUENT
  set name = pName
     ,status = 1
     ,fecha_modificacion = sysdate
     ,ip_origen = pIPOrigen
     ,email = pEmail
     ,celular = pCelular
     ,telcasa = pTelCasa
     ,teloficina = pTelOficina
     ,extension = pExtension
  where client = pClient and bank = pBank and state = pState and plaza = pPlaza and destino = pDestino;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_TEFFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Telefono(
	   pCliente INTEGER,
	   pTelefono NUMBER,
	   pCarrier NUMBER,
	   pClave NUMBER
  )

 RETURN INTEGER
 IS
  vCliente NUMBER(10);
  vTelefono NUMBER(10);
  vTelefonoID INTEGER;
  vClave NUMBER(10);
  vMensajeID INTEGER;
  vMensaje INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN

  BEGIN
	-- Si el telefono esta repetido devuelve error
    SELECT telefono_id INTO vTelefono FROM TELEFONO WHERE telefono_id = pTelefono AND cliente_id = pCliente;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      SELECT SEQ_TELEFONO_ID.NEXTVAL INTO vTelefonoID FROM dual;
      INSERT INTO TELEFONO VALUES (pCliente, pTelefono, pCarrier, SYSDATE, 0, pClave,vTelefonoID);
      SELECT telefono_id INTO vTelefono FROM TELEFONO WHERE telefono_id = pTelefono AND cliente_id = pCliente;
      --DBMS_OUTPUT.PUT_LINE ('Telefono:  ' || vTelefono );
  END;

  BEGIN
    -- Se inserta el mensaje en la tabla de Mensajes
	-- Ocurre si el cliente existe y el telefono existe
    SELECT SEQ_MENSAJE_ID.NEXTVAL INTO vMensajeID FROM dual;
    SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
      INSERT INTO MENSAJE VALUES (pTelefono, pCarrier, SYSDATE, 'Su clave de confirmacion para el sistema de alertas de Banco Azteca es: ' || pClave, 0, vMensajeID);
      SELECT mensaje_id INTO vMensaje FROM MENSAJE WHERE mensaje_id = vMensajeID;
      --DBMS_OUTPUT.PUT_LINE ('Mensaje:  ' || vMensaje );
  END;

  COMMIT;
  -- Si regresa cero el proceso fue exitoso
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20007, 'Error'||SQLERRM(SQLCODE));
  -- Si regresa distinto de cero el proceso fue exitoso
 RETURN falso;
END Inserta_Telefono;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION INSERTA_TERCEROSFRECUENT(
    pClient number,
	pDestino varchar,
	pName varchar,
	pIpOrigen varchar,
	pEmail varchar,
	pCelular varchar,
	pTelCasa varchar,
	pTelOficina varchar,
	pExtension varchar
  )

  RETURN INTEGER IS

  vClient number;
  vStatus integer;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	select CLIENT,STATUS into vClient, vStatus from TERCEROSFRECUENT
	where client = pClient and destino = pDestino;

    EXCEPTION
      when no_data_found then
		insert into TERCEROSFRECUENT
                   (client,  destino,  name,  status, fecha_modificacion, ip_origen, email,  celular,  telcasa,  teloficina,  extension)
            values (pClient, pDestino, pName, 1,      sysdate,            pIpOrigen, pEmail, pCelular, pTelCasa, pTelOficina, pExtension);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  update TERCEROSFRECUENT
  set name = pName
     ,status = 1
	 ,fecha_modificacion = sysdate
	 ,ip_origen = pIPOrigen
     ,email = pEmail
     ,celular = pCelular
     ,telcasa = pTelCasa
     ,teloficina = pTelOficina
     ,extension = pExtension
  where client = pClient and destino = pDestino;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error'||sqlerrm(sqlcode));
    RETURN 0;
  END INSERTA_TERCEROSFRECUENT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Inserta_Transfinternalfrecuent(
    pClient NUMBER,
	pDestino VARCHAR,
	pName VARCHAR,
	pIpOrigen VARCHAR,
	pClave_Swift VARCHAR
  )
  RETURN INTEGER IS

  vClient NUMBER;
  vStatus INTEGER;
  BEGIN

  BEGIN
  	--Primero tengo que verificarque el registro no exista
	--Si NO existe entonces lo agrego como nuevo
 	SELECT CLIENT,STATUS INTO vClient, vStatus FROM TRANSFINTERNALFRECUENT
	WHERE clave_swift=pClave_swift AND client = pClient AND destino = pDestino;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
		INSERT INTO TRANSFINTERNALFRECUENT (CLIENT, DESTINO, NAME, STATUS, FECHA_MODIFICACION, IP_ORIGEN, CLAVE_SWIFT)
		VALUES (pClient, pDestino, pName, 1, SYSDATE, pIpOrigen, pClave_swift);
	  RETURN 1;
  END;

  --Si el registro existe y el Status es ACTIVO, entonces no se realiza nada...
  IF vStatus = 1 THEN
  	 RETURN 1;
  ELSE
  --Si el registro existe y el status es INACTIVO entonces tengo que cambiar el nombre, status, fecha y la IP
  UPDATE TRANSFINTERNALFRECUENT SET name = pName, status = 1, fecha_modificacion = SYSDATE, ip_origen = pIPOrigen
  WHERE client = pClient AND destino = pDestino AND clave_swift=pClave_swift;
  COMMIT;
  RETURN 1;
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
    RETURN 0;
  END Inserta_Transfinternalfrecuent;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          INSERTDATATRANSDEX(
V_CLIENTE_ID            IN EBANKING.TRANSFER_DEX.CLIENTE_ID%TYPE,
V_MTCN                  IN EBANKING.TRANSFER_DEX.MTCN%TYPE,
V_MONTO_ENVIADO         IN EBANKING.TRANSFER_DEX.MONTO_ENVIADO%TYPE,
V_BENEFICIARIO_ID       IN EBANKING.TRANSFER_DEX.BENEFICIARIO_ID%TYPE,
V_TARIFA                IN EBANKING.TRANSFER_DEX.TARIFA%TYPE,
V_NUM_CUENTA            IN EBANKING.TRANSFER_DEX.NUM_CUENTA%TYPE,
V_FOLIO_RETENCION       IN EBANKING.TRANSFER_DEX.FOLIO_RETENCION%TYPE,
V_PAIS_ID_DESTINO       IN EBANKING.TRANSFER_DEX.PAIS_ID_DESTINO%TYPE,
V_ESTADO_ID_DESTINO     IN EBANKING.TRANSFER_DEX.ESTADO_ID_DESTINO%TYPE,
V_CIUDAD_ID_DESTINO     IN EBANKING.TRANSFER_DEX.CIUDAD_ID_DESTINO%TYPE,
V_ID_MONEDA_ENVIO       IN EBANKING.TRANSFER_DEX.ID_MONEDA_ENVIO%TYPE,
V_ID_MONEDA_DESTINO     IN EBANKING.TRANSFER_DEX.ID_MONEDA_DESTINO%TYPE,
V_USUARIO_MODIFICO      IN EBANKING.TRANSFER_DEX.USUARIO_MODIFICO%TYPE,
V_NOMBRE_IMPUESTO       IN EBANKING.IMPUESTO_DEX.NOMBRE_IMPUESTO%TYPE,
V_MONTO                 IN EBANKING.IMPUESTO_DEX.MONTO%TYPE,
V_NOMBRE_CORTO_IMPUESTO IN EBANKING.IMPUESTO_DEX.NOMBRE_CORTO_IMPUESTO%TYPE
)
RETURN NUMBER IS
SALIDA NUMBER := 0;
V_ID_IMPUESTO INTEGER:= 1;
V_ID_IMPORTE  INTEGER:= 1;
BEGIN
   INSERT INTO EBANKING.TRANSFER_DEX
                    (CLIENTE_ID,
                    MTCN,
                    MONTO_ENVIADO,
                    BENEFICIARIO_ID,
                    TARIFA,
                    NUM_CUENTA,
                    FECHA_ENVIO,
                    FOLIO_RETENCION,
                    PAIS_ID_DESTINO,
                    ESTADO_ID_DESTINO,
                    CIUDAD_ID_DESTINO,
                    ID_MONEDA_ENVIO,
                    ID_MONEDA_DESTINO,
                    ULTIMA_MODIFICACION,
                    USUARIO_MODIFICO)
               VALUES(V_CLIENTE_ID,
                    V_MTCN,
                    V_MONTO_ENVIADO,
                    V_BENEFICIARIO_ID,
                    V_TARIFA,
                    V_NUM_CUENTA,
                    SYSDATE,
                    V_FOLIO_RETENCION,
                    V_PAIS_ID_DESTINO,
                    V_ESTADO_ID_DESTINO,
                    V_CIUDAD_ID_DESTINO,
                    V_ID_MONEDA_ENVIO,
                    V_ID_MONEDA_DESTINO,
                    SYSDATE,
                    V_USUARIO_MODIFICO);
                    
      IF SQL%FOUND THEN   
        INSERT INTO EBANKING.IMPUESTO_DEX
                    (MTCN,
                    NOMBRE_IMPUESTO,
                    MONTO,
                    ID_IMPUESTO,
                    ID_IMPORTE,
                    NOMBRE_CORTO_IMPUESTO,
                    ULTIMA_MODIFICACION,
                    USUARIO_MODIFICO) 
                    VALUES(
                    V_MTCN,
                    V_NOMBRE_IMPUESTO,
                    V_MONTO,
                    V_ID_IMPUESTO,
                    V_ID_IMPORTE,
                    V_NOMBRE_CORTO_IMPUESTO,
                    SYSDATE,
                    V_USUARIO_MODIFICO);
          IF SQL%FOUND THEN
            COMMIT;
            SALIDA:=1;              
          ELSE
            ROLLBACK;
            SALIDA:=0;
          END IF;
      ELSE
          ROLLBACK;
          SALIDA:=0;
      END IF;
                
   RETURN SALIDA;
   
   EXCEPTION
     WHEN OTHERS THEN
       ROLLBACK;
       RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
       RAISE;
END INSERTDATATRANSDEX;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Insert_Monitor_Services(
    pId NUMBER,
	pNameService VARCHAR
  )
  RETURN INTEGER IS

  BEGIN
  	--Insertamos el id, nombre del servicio y fecha de ultima vez ejecutado
	UPDATE EBANKING_MONITOR_SERVICES SET status = 'I' WHERE status = 'A' AND id=pId;
	INSERT INTO EBANKING_MONITOR_SERVICES VALUES (pId, SYSDATE,'A');
	COMMIT;
	RETURN 1;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN 0;
  END Insert_Monitor_Services;
/

SHOW ERRORS;


CREATE OR REPLACE function join
(
    p_cursor sys_refcursor,
    p_del varchar2 := ','
) return varchar2
is
    l_value   varchar2(32767);
    l_result  varchar2(32767);
begin
    loop
        fetch p_cursor into l_value;
        exit when p_cursor%notfound;
        if l_result is not null then
            l_result := l_result || p_del;
        end if;
        l_result := l_result || l_value;
    end loop;
    return l_result;
end join;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          LOCKTERMINAL(  NID NUMBER  )    RETURN VARCHAR2
  IS
  NUM NUMBER;
  TERM VARCHAR2(10);

   CURSOR terminal_cur
   IS
   	   SELECT CODE INTO TERM FROM ALNOVA_TERMINAL WHERE BUSY = 0 AND ID = NID FOR UPDATE;
	   /* For each terminal fetched by the cursor... */
   BEGIN
	   FOR terminal_rec IN terminal_cur
   	   LOOP
	   	   IF terminal_rec.CODE IS NOT NULL THEN
		   	   /* Bloquear de terminal   */
		   	   TERM := terminal_rec.CODE;
	       	   UPDATE ALNOVA_TERMINAL SET BUSY = 1 WHERE CODE =  TERM;
			   COMMIT;
		  	   RETURN TERM;
		   END IF;
	   END LOOP;
	   COMMIT;
	   RETURN TERM;
	   EXCEPTION
	     when others then
		 COMMIT;
		 RETURN NULL;
   END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION MODIFICA_SPEIFRECUENT(
    pClient number,
	pDestino number,
    pName varchar,
	pIpOrigen varchar,
    pEmail varchar,
    pCelular varchar,
    pTelcasa varchar,
    pTeloficina varchar,
    pExtension varchar
  )

  RETURN INTEGER IS

  BEGIN
  --Se Modifican los datos de beneficiario
  update TEFSPEUAFRECUENT
     set name               = pName
        ,fecha_modificacion = sysdate
		,ip_origen          = pIPOrigen
        ,email              = pEmail
        ,celular            = PCelular
        ,telcasa            = pTelcasa
        ,teloficina         = pTeloficina
        ,extension          = pExtension
  where client = pClient and state = -2 and plaza = -2 and destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error: Actualizacion Beneficiario '||sqlerrm(sqlcode));
    RETURN 0;
  END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION MODIFICA_TEFFRECUENT(
    pClient number,
	pDestino number,
    pName varchar,
	pIpOrigen varchar,
    pEmail varchar,
    pCelular varchar,
    pTelcasa varchar,
    pTeloficina varchar,
    pExtension varchar
  )

  RETURN INTEGER IS

  BEGIN
  --Se Modifican los datos de beneficiario
  update TEFSPEUAFRECUENT
     set name               = pName
        ,fecha_modificacion = sysdate
		,ip_origen          = pIPOrigen
        ,email              = pEmail
        ,celular            = PCelular
        ,telcasa            = pTelcasa
        ,teloficina         = pTeloficina
        ,extension          = pExtension
  where client = pClient and state = -1 and plaza = -1 and destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error: Actualizacion Beneficiario '||sqlerrm(sqlcode));
    RETURN 0;
  END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION MODIFICA_TERCEROSFRECUENT(
    pClient number,
    pDestino varchar,
    pName varchar,
    pIpOrigen varchar,
    pEmail varchar,
    pCelular varchar,
    pTelCasa varchar,
    pTelOficina varchar,
    pExtension varchar
  )
  RETURN INTEGER IS
  BEGIN
  update TERCEROSFRECUENT
  set status = 1
     ,fecha_modificacion = sysdate
     ,ip_origen = pIPOrigen
     ,email = pEmail
     ,celular = pCelular
     ,telcasa = pTelCasa
     ,teloficina = pTelOficina
     ,extension = pExtension
  where client = pClient
  and   destino = pDestino;
  COMMIT;
  RETURN 1;

  EXCEPTION
  when others then
    RAISE_APPLICATION_ERROR (sqlcode, 'Error en actualizar Beneficiario, terceros'||sqlerrm(sqlcode));
    RETURN 0;
  END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION OBTENCELULAR(id_cliente IN NUMBER)

    RETURN VARCHAR2
 IS
    cellPhone VARCHAR2(10);

  BEGIN

        -- Se obtiene el numero celular en base al cliente alnova 
        -- de la tabla eBanking_user.
        BEGIN
        SELECT o.cellular INTO cellPhone FROM EBANKING.ebanking_user o
        WHERE  o.id = id_cliente;
        END;
        
  RETURN cellPhone; 
       
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
            cellPhone :='0';
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (SQLCODE, 'Error'||SQLERRM(SQLCODE));
            cellPhone :='0';
            
  RETURN cellPhone;
  
END OBTENCELULAR;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          OBTENCELULAR11(id_cliente IN NUMBER)

    RETURN VARCHAR2
 IS
    cellPhone VARCHAR2(16);

  BEGIN

        -- Se obtiene el numero celular en base al cliente alnova 
        -- de la tabla eBanking_user.
        BEGIN
        SELECT o.cellular INTO cellPhone FROM EBANKING.ebanking_user o
        WHERE  o.id = id_cliente;
        END;
        
  RETURN cellPhone; 
       
       

END OBTENCELULAR11;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          obtener_estadis (
   tipo_operacion   IN   VARCHAR,
   anio             IN   VARCHAR
)
   RETURN TYPES.refcursor
IS
   startdate         VARCHAR (20)    := CONCAT ('01/01/', anio);
   fecha_inicio      DATE            := TO_DATE (startdate, 'dd/mm/yyyy');
   fecha_fin         DATE;
   tot_consul        VARCHAR (20);
   estadistica_sem   TYPES.refcursor;
BEGIN
   DBMS_OUTPUT.put_line ('num_oper' || '--' || 'inicio_sem');

   LOOP
      fecha_fin := NEXT_DAY (fecha_inicio, 'DOM');

      OPEN estadistica_sem FOR
         SELECT NVL (SUM (contador), 0) total_consultas
           FROM movsadmin
          WHERE operacion = tipo_operacion
            AND fecha BETWEEN (fecha_inicio) AND (fecha_fin);

      FETCH estadistica_sem
       INTO tot_consul;

      DBMS_OUTPUT.put_line (tot_consul || '--' || fecha_inicio);
      fecha_inicio := fecha_fin + 1;
      EXIT WHEN fecha_inicio >= ADD_MONTHS (TO_DATE (startdate), 12);
   END LOOP;

   RETURN estadistica_sem;
END obtener_estadis;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION            "OBTENER_ESTADIS_PRUEBA" (
   tipo_operacion   IN   VARCHAR,
   anio             IN   VARCHAR
)
   RETURN TYPES.refcursor
IS
   startdate         VARCHAR (20)    := CONCAT ('01/01/', anio);
   fecha_inicio      DATE            := TO_DATE (startdate, 'dd/mm/yyyy');
   fecha_fin         DATE;
   tot_consul        VARCHAR (20);
   monto_consul      VARCHAR (20);
   estadistica_sem_comp TYPES.refcursor;

BEGIN
   LOOP
      fecha_fin := NEXT_DAY (fecha_inicio, 'DOM');
         SELECT NVL (SUM (contador), 0) total_consultas,
                NVL (SUM (monto), 0) monto_semanal
         INTO tot_consul, monto_consul 
         FROM MONETXCTA
          WHERE operacion = tipo_operacion
            AND fecha BETWEEN (fecha_inicio) AND (fecha_fin);
         
         INSERT INTO TMP_PRUEBA values(tot_consul, monto_consul);
      fecha_inicio := fecha_fin + 1;
      EXIT WHEN fecha_inicio >= ADD_MONTHS (TO_DATE (startdate), 12);
   END LOOP;
    OPEN estadistica_sem_comp FOR
        SELECT *
        FROM TMP_PRUEBA;
    DELETE TMP_PRUEBA;
    RETURN estadistica_sem_comp;
END OBTENER_ESTADIS_PRUEBA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          OBTEN_DIAS(p_userId IN INTEGER)
  RETURN INTEGER IS
    v_dias INTEGER;
BEGIN
    SELECT FLOOR(SYSDATE-login_date)
        INTO v_dias
        FROM ebanking.ebanking_login
        WHERE user_id=p_userId;
    RETURN v_dias;

EXCEPTION

    WHEN NO_DATA_FOUND
    THEN
        RETURN NULL;
END OBTEN_DIAS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          OBTEN_ESTADO (p_userId IN INTEGER, p_sessionId IN VARCHAR)
  RETURN INTEGER IS
    v_fecha DATE;
    v_sesion VARCHAR(100);
    v_estado INTEGER;
BEGIN

    SELECT session_start, session_activa
        INTO v_fecha, v_sesion
        FROM ebanking.ebanking_user_session
        WHERE id=p_userId;

    IF (v_fecha + NUMTODSINTERVAL(1, 'HOUR')) > SYSDATE
        AND v_sesion = p_sessionId
    THEN
        v_estado := 1;
    ELSE
        v_estado := 2;
    END IF;

    RETURN v_estado;

EXCEPTION

    WHEN NO_DATA_FOUND
    THEN
        RETURN NULL;
END OBTEN_ESTADO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          OBTEN_INTENTOS (p_userId IN INTEGER)
  RETURN INTEGER IS
    v_attemps INTEGER;
BEGIN
    SELECT attempts
        INTO v_attemps
        FROM ebanking.ebanking_login
        WHERE user_id=p_userId
            AND FLOOR(SYSDATE-login_date) = 0;
    RETURN v_attemps;

EXCEPTION

    WHEN NO_DATA_FOUND
    THEN
        RETURN 0;
END OBTEN_INTENTOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          OBTEN_SESIONACTUAL (p_userId IN INTEGER)
RETURN VARCHAR2 IS
    SACTUAL VARCHAR2(50);
BEGIN
  SELECT SESSION_ACTIVA INTO SACTUAL FROM ebanking.ebanking_user_session WHERE ID = p_userId;
  RETURN SACTUAL;

EXCEPTION

    WHEN NO_DATA_FOUND
    THEN
        RETURN ' ';
END OBTEN_SESIONACTUAL;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION postitbyfoto (pidalbum NUMBER, pidfoto NUMBER)
   RETURN TYPES.refcursor
IS
   postitref   TYPES.refcursor;
BEGIN
   OPEN postitref FOR
      SELECT   ID, comentario, x, y
          FROM postit
         WHERE idalbum = pidalbum AND idfoto = pidfoto
      ORDER BY ID;

   RETURN postitref;
EXCEPTION
   WHEN OTHERS
   THEN
      raise_application_error (-20002, 'Error' || SQLERRM (SQLCODE));
END postitbyfoto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION                    Pruebas_FIAR_CONSULTA_TOTALES
    RETURN Types.REFCURSOR
IS
	 NUM_TOTAL number(25):=0;
	 MONTO_TOTAL number(25):=0;
	 AFILIADOS number(25):=0;
	 MONTO_AFIL number(25):=0;
	 SIN_AFILIAR number(25):=0;
	 MONTO_SIN_AFIL number(25):=0;
	 cursor_salida Types.REFCURSOR;
BEGIN

  	SELECT COUNT(1) INTO NUM_TOTAL
    FROM EBANKING.FIAR_CLIENTES
	WHERE TO_DATE(FECHA_INGRESO, 'dd/mm/yy') = TO_DATE('15/02/12', 'dd/mm/yy');

	SELECT COUNT(CTE_ALNOVA) INTO MONTO_TOTAL
  	FROM EBANKING.FIAR_CLIENTES
  	WHERE TO_DATE(FECHA_INGRESO, 'dd/mm/yy') = TO_DATE('15/02/12', 'dd/mm/yy');

    	SELECT COUNT(NUM_EMPLEADO) INTO AFILIADOS
	FROM EBANKING.FIAR_REGISTRO
	WHERE ESTATUS_REGISTRO='true';

  SELECT SUM(MONTO_CREDITO) INTO MONTO_AFIL
	FROM  EBANKING.FIAR_CLIENTES
  WHERE NO_EMPLEADO  IN (SELECT NUM_EMPLEADO FROM EBANKING.FIAR_REGISTRO);

  	SELECT SUM(C.MONTO_CREDITO) INTO MONTO_SIN_AFIL
    	FROM EBANKING.FIAR_CLIENTES C
    	WHERE C.NO_EMPLEADO NOT IN (
        SELECT DISTINCT NUM_EMPLEADO
        FROM EBANKING.FIAR_REGISTRO)
    	AND to_char(to_date(C.ULTIMA_MODIFICACION, 'dd/mm/yy'),'yy') = '12';

    	SELECT COUNT (CTE_ALNOVA) INTO SIN_AFILIAR
	FROM EBANKING.FIAR_CLIENTES
	WHERE NO_EMPLEADO NOT IN (SELECT NUM_EMPLEADO FROM EBANKING.FIAR_REGISTRO) 
	AND to_char(to_date(ULTIMA_MODIFICACION, 'dd/mm/yy'),'yy') = '12';

    OPEN cursor_salida FOR
		SELECT NUM_TOTAL AS NUM_TOTAL, MONTO_TOTAL AS MONTO_TOTAL, AFILIADOS AS AFILIADOS,
		   MONTO_AFIL AS MONTO_AFIL, SIN_AFILIAR AS SIN_AFILIAR, MONTO_SIN_AFIL AS MONTO_SIN_AFIL
		FROM DUAL;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los clientes del FIAR  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END FIAR_CONSULTA_TOTALES;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REGISTRA_FINSESION (p_userId IN INTEGER, p_sessionId IN VARCHAR, p_sessionIp IN VARCHAR)
 RETURN INTEGER IS
BEGIN

	DELETE FROM ebanking.ebanking_user_session WHERE id=p_userId;
    COMMIT;
    RETURN 0;

EXCEPTION

    WHEN OTHERS  THEN
        RETURN 0;

END REGISTRA_FINSESION;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REGISTRA_INTENTO(p_userId IN INTEGER, p_alias IN VARCHAR, p_ip IN VARCHAR)
  RETURN INTEGER IS
    v_attemps INTEGER;
    v_days INTEGER;
    v_fecha DATE;
    v_registra_login INTEGER;
    v_registra_login_hist INTEGER;
BEGIN
    v_days := obten_dias( p_userId );
    v_fecha := SYSDATE;

    IF v_days IS NULL
    THEN
        v_attemps:=1;
        v_registra_login := EBANKING.REGISTRA_INTENTO_LOGIN(p_userId, v_attemps, v_fecha);
    ELSE
        v_attemps:=obten_intentos( p_userId )+1;
        UPDATE ebanking.ebanking_login SET attempts=v_attemps, login_date=v_fecha WHERE user_id=p_userId;
    END IF;

    v_registra_login_hist := EBANKING.REGISTRA_LOGIN_HISTORICO(p_userId, v_attemps, v_fecha, p_alias, p_ip);

    COMMIT;

    RETURN v_attemps;

EXCEPTION

    WHEN OTHERS  THEN
         RETURN 0;


END REGISTRA_INTENTO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REGISTRA_INTENTO_LOGIN (p_userId IN INTEGER, p_attemps IN INTEGER, p_fecha IN DATE)
RETURN INTEGER IS
BEGIN

    INSERT INTO ebanking.ebanking_login( user_id, attempts, login_date ) VALUES( p_userId, p_attemps, p_fecha);
    COMMIT;
	RETURN 0;

EXCEPTION

    WHEN OTHERS  THEN
         RETURN 0;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REGISTRA_LOGIN_HISTORICO  (p_userId IN INTEGER, v_attemps IN INTEGER, p_fecha IN DATE, p_alias IN VARCHAR2, p_ip IN VARCHAR2)
RETURN INTEGER IS
BEGIN

    INSERT INTO ebanking.ebanking_login_hist( id, user_id, login_date, alias, attempt, ip, validacion )
        VALUES( id_login_history_seq.nextval, p_userId, p_fecha, p_alias, v_attemps, p_ip, null );
    COMMIT;
	RETURN 0;

EXCEPTION

    WHEN OTHERS  THEN
         RETURN 0;
        COMMIT;
END REGISTRA_LOGIN_HISTORICO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Registra_Sesion(p_userId IN INTEGER, p_sessionId IN VARCHAR, p_sessionIp IN VARCHAR, p_forceUpdate IN INTEGER)
  RETURN INTEGER IS
    v_estado INTEGER;
BEGIN

    v_estado := ebanking.Obten_Estado( p_userId, p_sessionId );
    IF v_estado IS NULL
    THEN
        INSERT INTO ebanking.EBANKING_USER_SESSION( ID, session_activa, session_start, ip ) VALUES( p_userId, p_sessionId, SYSDATE, NULL );
        v_estado := 0;
    ELSE
        IF v_estado = 1
        THEN
            UPDATE ebanking.EBANKING_USER_SESSION SET session_start=SYSDATE WHERE ID=p_userId;
        ELSE
            IF p_forceUpdate = 1
            THEN
                UPDATE ebanking.EBANKING_USER_SESSION SET session_start=SYSDATE, session_activa=p_sessionId WHERE ID=p_userId;
                v_estado := 1;
            END IF;
        END IF;
    END IF;
    COMMIT;
    RETURN v_estado;

EXCEPTION

    WHEN OTHERS  THEN
         RETURN 0;

END Registra_Sesion;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REG_MONMAX_PAGMOV(
   CLIENTE_AL NUMBER,
   MONTO_PAGO NUMBER,
   USUARIO VARCHAR2 
)
RETURN INTEGER IS
 var_Client number;
 var_Monto  number;
 var_Fecha  date;
 
 
c_OK CONSTANT NUMBER(1):=1;
c_Error CONSTANT NUMBER(1):=0;
BEGIN


  BEGIN
      --Primero tengo que verificarque el registro no exista
    --Si NO existe entonces lo agrego como nuevo
     select CTEALNOVA,MONTO,FECHA_MOV into var_Client, var_Monto,var_Fecha from EBANKING.PAGO_MOVIL_MAXD
    where CTEALNOVA = CLIENTE_AL ;

    EXCEPTION
      when no_data_found then
       INSERT INTO EBANKING.PAGO_MOVIL_MAXD (CTEALNOVA, MONTO, FECHA_MOV, 
                                            ULTIMA_MODIFICACION, USUARIO_MODIFICO) 
            VALUES (CLIENTE_AL ,MONTO_PAGO ,SYSDATE ,SYSDATE , USUARIO);
            COMMIT;
        RETURN c_OK;
  END;

  IF TO_CHAR(SYSDATE, 'MMDDYYYY')=TO_CHAR(var_Fecha, 'MMDDYYYY') THEN
        UPDATE EBANKING.PAGO_MOVIL_MAXD SET MONTO =  var_Monto+MONTO_PAGO,ULTIMA_MODIFICACION = SYSDATE, USUARIO_MODIFICO = USUARIO 
            WHERE CTEALNOVA=CLIENTE_AL;
            COMMIT;
        RETURN c_OK;
  ELSE
        UPDATE EBANKING.PAGO_MOVIL_MAXD SET MONTO = MONTO_PAGO,FECHA_MOV=SYSDATE,ULTIMA_MODIFICACION = SYSDATE, USUARIO_MODIFICO = USUARIO
        WHERE CTEALNOVA=CLIENTE_AL;
            COMMIT;
          RETURN  c_OK;
   END IF;
  EXCEPTION 
      WHEN OTHERS THEN
          RAISE_APPLICATION_ERROR (-20102, 'Error al grabar la transaccion en NEBDPROD ( * ' || SQLCODE || '  ' || SQLERRM ||  '   *)');
          ROLLBACK;
          RETURN c_Error;
END REG_MONMAX_PAGMOV;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION releaseterminal (IDTERMINAL INTEGER)
   RETURN INTEGER
IS
   verdadero INTEGER := 1;
   falso INTEGER := 0;

BEGIN
   UPDATE ALNOVA_TERMINAL SET BUSY = 0 WHERE ID = IDTERMINAL;
   RETURN verdadero;
   EXCEPTION
   WHEN  OTHERS THEN
   RETURN falso;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REPO_BUSQ_TASA_PLAZO
    RETURN TYPES.refCursor
  IS
    cursorTasaPlazo TYPES.refCursor;
  BEGIN
    OPEN cursorTasaPlazo FOR SELECT ID_TASA_PLAZO, TASA, PLAZO FROM EBANKING.REPO_TASA_PLAZO ORDER BY ID_TASA_PLAZO;
    RETURN cursorTasaPlazo;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar las tasas y plazos (' || SQLCODE || '  ' || SQLERRM || ')');
  END REPO_BUSQ_TASA_PLAZO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          REPO_CUENTA(
      idAlnova IN VARCHAR2)
    RETURN TYPES.refCursor
  IS
    cursorCuenta TYPES.refCursor;
  BEGIN
    OPEN cursorCuenta FOR SELECT CUENTA,CONTRATO_TAS,ULTIMA_MODIFICACION FROM EBANKING.REPO_CLIENTES WHERE ID_ALNOVA=idAlnova;
    RETURN cursorCuenta;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar el monto (' || SQLCODE || '  ' || SQLERRM || ')');
  END REPO_CUENTA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_ACTIVACION_USUARIO (fechaInicio IN VARCHAR2, fechaFin IN VARCHAR2)
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
    	OPEN cursor_salida FOR
		SELECT A.CLIENTE, H.CUENTA, H.TITULAR, H.EMAIL, H.IPHONE, H.FACTIVACION, H.INTENTOS, H.FCONFIRMACION, H.RESULTADO, H.STATUS
		FROM EBANKING.EBANKING_ACTIVATION_H H, EBANKING_ACTIVATION A
		WHERE H.FCONFIRMACION BETWEEN TO_DATE(fechaInicio,'DD/MM/YY') AND TO_DATE(fechaFin,'DD/MM/YY') + 1 AND A.CUENTA = H.CUENTA
		AND H.STATUS < 4
		union
		SELECT E.CLIENTE,E.CUENTA,E.NAME, E.EMAIL, E.CEL_PHONE, E.ACTIVACION, E.INTENTOS_LOCALIZAR,null,null,E.STATUS
		FROM EBANKING.EBANKING_ACTIVATION E
		WHERE (E.STATUS = 0 OR E.STATUS = 1) AND E.ACTIVACION BETWEEN TO_DATE(fechaInicio,'DD/MM/YY') AND TO_DATE(fechaFin,'DD/MM/YY') + 1 ORDER BY 6;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los usuarios activos en el portal (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los usuarios activos en el portal ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_ACTIVACION_USUARIO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_CLIENTE_BY_ID(IDUSUARIO IN varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
 OPEN cursor_salida FOR
  SELECT EMAIL,CELLULAR,TELEFONO_OFICINA,ADVANCEDSERVICE,TRACKING,ACTIVATION,ID,ACTIVE,SECURITY_LEVEL,ULT_ACCESO FROM EBANKING.EBANKING_USER eu
 WHERE eu.ID = IDUSUARIO;  
   RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_CLIENTE_BY_ID;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_CLIENTE_BY_NOMBRE(NOMBRE IN varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
 OPEN cursor_salida FOR
  SELECT CLIENTE
  FROM EBANKING.EBANKING_ACTIVATION 
  WHERE NAME = NOMBRE;   
   RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_CLIENTE_BY_NOMBRE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_DATOS_PERSONALES(IDUSUARIO varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
SELECT email, 
       cellular, 
       telefono_oficina,
       advancedservice, 
       tracking, 
       activation
  FROM ebanking_user usuario
 WHERE ID = IDUSUARIO;
    RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_DATOS_PERSONALES;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_MAXD_PAGMOV(CLIENTE_AL IN NUMBER)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
 OPEN cursor_salida FOR
  SELECT CTEALNOVA,MONTO,FECHA_MOV
  FROM EBANKING.PAGO_MOVIL_MAXD 
  WHERE CTEALNOVA = CLIENTE_AL;   
   RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_MAXD_PAGMOV;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_MOVIL_ACT(CLIENTE_AL IN NUMBER)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;

c_BuscStatus CONSTANT NUMBER(1):=1;

BEGIN
 OPEN cursor_salida FOR
  SELECT CTEALNOVA,TELEFONO,CUENTA,FECHA_ALTA,UID_TEL,STATUS,USUARIO_MODIFICO
  FROM EBANKING.PAGO_MOVIL_ACT  
  WHERE CTEALNOVA = CLIENTE_AL AND STATUS=c_BuscStatus;   
   RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_MOVIL_ACT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_NIVELES_SEGURIDAD(IDUSUARIO varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR


SELECT nivelfrecuentes, 
        nivelmovimientos,       
       niveltransferencias
  FROM ebanking_nivelesseguridad
 WHERE iduser = IDUSUARIO;
    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_NIVELES_SEGURIDAD;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_NOMBRE_BY_ID(IDCLIENTE IN varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
 OPEN cursor_salida FOR
    SELECT NAME nombre FROM EBANKING_ACTIVATION WHERE cliente = IDCLIENTE;
   RETURN cursor_salida;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_NOMBRE_BY_ID;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_ACTIVACION
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
		OPEN cursor_salida FOR
		Select etp.ID as id , etp.TITULAR as titular , decode(etp.EMAIL,null,'Sin datos a listar',etp.EMAIL) as emailnew , etp.IP as ip ,
			etp.NUM_SERIE_TOKEN as num_serie_token , etp.TEL_PARTICULAR as tel_particular , decode(etp.TEL_CELULAR,null,'Sin datos a listar',etp.TEL_CELULAR )
			as celnew , decode(etp.CARRIER_CEL,null,'Sin datos a listar', etp.CARRIER_CEL) as celcarriernew ,
			to_char(etp.FEC_HORA_OPERACION,'dd/mm/yyyy hh24:mm:ss ') as fechasolicitud , etp.NUM_CLIENTE as num_cliente , etp.ESTATUS as estatus ,
			decode(etp.MOTIVO_PREV_FRAUDE,0,'No cuenta con Servicios Avanzados', 1,'Actualizacion de datos',2,'Confirmacion con NIP ' ) as motivo ,
			etp.ALIAS as alias , to_char(etp.FEC_PREV_FRAU,'dd/mm/yyyy' ) as fechaliberacion , etp.ID_USER_PREV_FRAU as iduser_prev_f ,
			etp.NUM_INTENTOS as num_intentos, etp.OBSERVACION as observacion, to_char(etp.FEC_PRI_INTENTO,'dd/mm/yyyy' ) as fecpintento,
			to_char(etp.FEC_ULT_INTENTO,'dd/mm/yyyy') as fecuintento , etp.TIPO_OPERACION as tipooperacion , ec.code as newcelcode ,
			ec.description as newcelcom , decode(eu.CELLULAR,null,'Sin datos a listar',eu.CELLULAR ) as celold , decode(eu.TELEFONO_OFICINA,null,
			'Sin datos a listar',eu.TELEFONO_OFICINA )  as telold , decode(eu.EMAIL,null,'Sin datos a listar',eu.EMAIL ) as emailold ,
			ec2.code as oldcelcode , ec2.description as oldcelcom,  ea.Cuenta as cuenta , ea.tipoprod as tipoProducto ,
			to_char(ea.activacion ,'dd/mm/yyyy') as fechaActivacion , etp.sistema as sistema , etp.idpais as pais , etp.FEC_HORA_OPERACION as fo
		from EBANKING.ebanking_token_prevencion etp, EBANKING.EBANKING_CELLCOMPANY ec , EBANKING.ebanking_user eu, EBANKING.ebanking_cellCompany ec2 ,
		EBANKING.EBANKING_ACTIVATION ea
		where etp.CARRIER_CEL=ec.id and eu.USER2CELLCOMPANY=ec2.id  and eu.ID =etp.NUM_CLIENTE   and  etp.TIPO_OPERACION = 0
			and  etp.ESTATUS =1 and  ea.cliente (+)  =  etp.NUM_CLIENTE and length(etp.NUM_CLIENTE) = 8
		union
		SELECT etp.ID as ID, etp.titular as titular, DECODE (etp.email,NULL, 'Sin datos a listar',etp.email) as emailnew, etp.ip  ip,
			etp.num_serie_token AS num_serie_token, etp.tel_particular AS tel_particular,
			DECODE (etp.tel_celular,NULL, 'Sin datos a listar',etp.tel_celular) AS celnew, DECODE (etp.carrier_cel,NULL, 'Sin datos a listar',etp.carrier_cel)
			AS celcarriernew, TO_CHAR (etp.fec_hora_operacion,'dd/mm/yyyy hh24:mm:ss ') AS fechasolicitud, etp.num_cliente AS num_cliente,
			etp.estatus AS estatus, DECODE (etp.motivo_prev_fraude,0, 'No cuenta con Servicios Avanzados',1, 'Actualizacion de datos',2,'Confirmacion con NIP')
			AS motivo, etp.alias AS alias, TO_CHAR (etp.fec_prev_frau, 'dd/mm/yyyy') AS fechaliberacion, etp.id_user_prev_frau AS iduser_prev_f,
			etp.num_intentos AS num_intentos,  etp.observacion AS observacion, TO_CHAR (etp.fec_pri_intento, 'dd/mm/yyyy') AS fecpintento,
			TO_CHAR (etp.fec_ult_intento, 'dd/mm/yyyy') AS fecuintento, etp.tipo_operacion AS tipooperacion,
			DECODE(etp.CARRIER_CEL,-1,'Sin datos a listar',EC.CODE) as newcelcode ,
			DECODE(etp.CARRIER_CEL,-1,'Sin datos a listar',EC.DESCRIPTION) as newcelcom, 'Sin datos a listar' as celold,
			'Sin datos a listar' as telold, 'Sin datos a listar' as emailold, 'Sin datos a listar' as oldcelcode,
			'Sin datos a listar' as oldcelcom, '' as cuenta , '' as tipoProducto , '' as fechaActivacion , etp.sistema as sistema , etp.idpais as pais,
			etp.FEC_HORA_OPERACION as fo
		FROM EBANKING.ebanking_token_prevencion etp, EBANKING.ebanking_cellcompany ec
		WHERE etp.tipo_operacion = 0 AND etp.estatus = 1 and length(etp.NUM_CLIENTE) = 12 and (ec.ID = etp.CARRIER_CEL or etp.CARRIER_CEL = -1)
		order by fo asc;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los tokens a activar (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar laos tokens a activar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_ACTIVACION;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_ATRASADOS
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
    	OPEN cursor_salida FOR
		SELECT COUNT(FOLIO_SOLICITUD)
		FROM EBANKING.EBANKING_TOKEN_SOLICITUD T
		WHERE TO_DATE(T.FECHA_SOL_INTERNET,'DD/MM/YYYY') < TO_DATE(SYSDATE,'DD/MM/YYYY') and T.ESTATUS_SOL = 1;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los tokens pendientes atrasados (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar laos tokens pendientes atrasados  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_ATRASADOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_CLIENTE(NUMEROCLIENTE varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
       SELECT fecha_activacion,fecha_modificacion,id,idpais,num_cliente,num_serie_token,sistema,status
           FROM EBANKING.ebanking_token_status ets
          WHERE ets.num_cliente = NUMEROCLIENTE;
    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_CLIENTE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_DESBLOQUEO
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
    	OPEN cursor_salida FOR
		Select etp.ID as id, etp.TITULAR as titular , decode(etp.EMAIL,null,'Sin datos a listar',etp.EMAIL) as emailnew,etp.IP as ip,
			etp.NUM_SERIE_TOKEN as num_serie_token ,etp.TEL_PARTICULAR as tel_particular, decode(etp.TEL_CELULAR,null,'Sin datos a listar',
			etp.TEL_CELULAR ) as celnew ,decode(etp.CARRIER_CEL,null,'Sin datos a listar', etp.CARRIER_CEL)as celcarriernew,
			to_char(etp.FEC_HORA_OPERACION,'dd/mm/yyyy hh24:mm:ss') as fechasolicitud,etp.NUM_CLIENTE  as num_cliente ,etp.ESTATUS as estatus,
			decode(etp.MOTIVO_PREV_FRAUDE,0,'No cuenta con Servicios Avanzados',1,'Actualizacion de datos',2,'Confirmacion con NIP',3,'Reactivacion en el Portal')
			as motivo, etp.ALIAS as alias, to_char(etp.FEC_PREV_FRAU,'dd/mm/yyyy') as fechaliberacion,etp.ID_USER_PREV_FRAU as iduser_prev_f,
			etp.NUM_INTENTOS as num_intentos,etp.OBSERVACION as observacion , to_char(etp.FEC_PRI_INTENTO,'dd/mm/yyyy') as fecpintento ,
			to_char(etp.FEC_ULT_INTENTO,'dd/mm/yyyy') as fecuintento , etp.TIPO_OPERACION as tipooperacion , ec.code as newcelcode ,
			ec.description as newcelcom , decode(eu.CELLULAR,null,'Sin datos a listar',eu.CELLULAR ) as celold , decode(eu.TELEFONO_OFICINA,null,
			'Sin datos a listar',eu.TELEFONO_OFICINA )  as telold ,  decode(eu.EMAIL,null,'Sin datos a listar',eu.EMAIL ) as emailold ,
			ec2.code as oldcelcode , ec2.description as oldcelcom, ea.Cuenta as cuenta , ea.tipoprod as tipoProducto ,
			to_char(ea.activacion ,'dd/mm/yyyy') as fechaActivacion , etp.sistema as sistema ,  etp.idpais as pais
		FROM ebanking.ebanking_token_prevencion etp, ebanking.EBANKING_CELLCOMPANY ec , ebanking.ebanking_user eu, ebanking.ebanking_cellCompany ec2 ,
		EBANKING_ACTIVATION ea where  etp.CARRIER_CEL=ec.id and  eu.USER2CELLCOMPANY=ec2.id  and eu.ID =etp.NUM_CLIENTE
			and  etp.TIPO_OPERACION = 1  and etp.ESTATUS =1   and  ea.cliente  (+) =  etp.NUM_CLIENTE
		union
		SELECT DISTINCT  etp.ID as ID,  etp.titular as titular,  DECODE (etp.email,NULL, 'Sin datos a listar',etp.email) as emailnew,
			etp.ip as ip, etp.num_serie_token AS num_serie_token, etp.tel_particular AS tel_particular,  DECODE (etp.tel_celular,NULL,
			'Sin datos a listar',etp.tel_celular) AS celnew, DECODE (etp.carrier_cel,NULL, 'Sin datos a listar',etp.carrier_cel) AS celcarriernew,
			TO_CHAR (etp.fec_hora_operacion,'dd/mm/yyyy hh24:mm:ss ') AS fechasolicitud, etp.num_cliente AS num_cliente, etp.estatus AS estatus,
			DECODE (etp.motivo_prev_fraude,0, 'No cuenta con Servicios Avanzados',1, 'Actualizacion de datos',2,'Confirmacion con NIP') AS motivo,
			etp.alias AS alias,  TO_CHAR (etp.fec_prev_frau, 'dd/mm/yyyy') AS fechaliberacion, etp.id_user_prev_frau AS iduser_prev_f,
			etp.num_intentos AS num_intentos, etp.observacion AS observacion, TO_CHAR (etp.fec_pri_intento, 'dd/mm/yyyy') AS fecpintento,
			TO_CHAR (etp.fec_ult_intento, 'dd/mm/yyyy') AS fecuintento, etp.tipo_operacion AS tipooperacion,   DECODE(etp.CARRIER_CEL,-1,
			'Sin datos a listar',EC.CODE) as newcelcode , DECODE(etp.CARRIER_CEL,-1,'Sin datos a listar',EC.DESCRIPTION) as newcelcom,
			'Sin datos a listar' as celold	, 'Sin datos a listar' as telold,  'Sin datos a listar' as emailold,'Sin datos a listar' as oldcelcode,
			'Sin datos a listar' as oldcelcom, '' as cuenta , '' as tipoProducto , '' as fechaActivacion , etp.sistema as sistema ,
			etp.idpais as pais
		FROM ebanking.ebanking_token_prevencion etp, ebanking.ebanking_cellcompany ec
		WHERE etp.tipo_operacion = 1 AND etp.estatus = 1 and length(etp.NUM_CLIENTE) = 12 and (ec.ID = etp.CARRIER_CEL or etp.CARRIER_CEL = -1)
		order by fechasolicitud asc;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los tokens a desbloquear (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar laos tokens a desbloquear ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_DESBLOQUEO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_PENDIENTES_HOY
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
    	OPEN cursor_salida FOR
		SELECT COUNT(FOLIO_SOLICITUD)
		FROM EBANKING.EBANKING_TOKEN_SOLICITUD T
		WHERE TO_DATE(T.FECHA_SOL_INTERNET,'DD/MM/YYYY') = TO_DATE(SYSDATE,'DD/MM/YYYY') and T.ESTATUS_SOL = 1;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar los tokens pendientes del dia (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar laos tokens pendientes del dia  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_PENDIENTES_HOY;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_SERIE(NUMEROSERIE varchar)
RETURN Types.REFCURSOR 
IS  cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR
      SELECT fecha_activacion,fecha_modificacion,id,idpais,num_cliente,num_serie_token,sistema,status  FROM EBANKING.EBANKING_TOKEN_STATUS ets
	WHERE ets.NUM_SERIE_TOKEN =  NUMEROSERIE;
    RETURN cursor_salida;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar  ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_SERIE;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SELECT_TOKEN_SOLICITADOS
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
	BEGIN
    	OPEN cursor_salida FOR
		SELECT T.NUM_CTE, T.FOLIO_SOLICITUD, T.DIR_ENT, T.EDO_ENT, T.CIUDAD_ENT, T.COL_ENT, T.CP_ENT, T.TEL_ENT, T.NOM_CTE,
			T.APE_PAT_CTE, T.APE_MAT_CTE, T.EMAIL, T.DIR_IP, T.CTA_CARGO,T.TIPO_CTA_CARGO, T.TEL_ADI_ENT, T.FECHA_SOL_INTERNET,
			T.NO_INTENTOS, T.NUM_PEDIDO_EKT, T.PER_AUT1, T.PER_AUT2, T.PER_AUT3, T.ALIAS, T.CANT_SKU1, T.CANT_SKU2, T.COSTO_ENVIO,
			T.DES_MENSAJERIA, T.ID_MENSAJERIA, T.RFC_CTE, T.SKU1, T.SKU2,
			CASE T.SKU1
				WHEN  '0' THEN 'HUELLA AZTECA'
			ELSE
				 CASE T.SKU2
				 WHEN '0' THEN 'FIRMA AZTECA'
			     ELSE 'FIRMA Y HUELLA AZTECA'
				 END
			END AS TIPO_PRODUCTO,
			CASE T.SKU1
				WHEN  '0' THEN 1
			ELSE
				 CASE T.SKU2
				 WHEN '0' THEN 2
			     ELSE 3
				 END
			END AS ID_PRODUCTO,
			T.PRIMER_INTENTO, T.IMPORTE, T.RETENCION_SOLICITUD,
			T.IDPAIS, T.SISTEMA
		FROM EBANKING.EBANKING_TOKEN_SOLICITUD T
		WHERE T.ESTATUS_SOL = 1 ORDER BY T.FECHA_SOL_INTERNET asc;
	RETURN cursor_salida;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar las solicitudes de tokens (' || SQLCODE || '  ' || SQLERRM || ')');
        WHEN OTHERS THEN
			RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar las solicitudes de tokens ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END SELECT_TOKEN_SOLICITADOS;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION spalbum_findfotobypk (pid NUMBER, pidalbum NUMBER)
   RETURN TYPES.refcursor
IS
   fotoref   TYPES.refcursor;
BEGIN
   OPEN fotoref FOR
      SELECT   comentario, descripcion, NAME, ruta, fix_name,visita, fixfotoupdate
          FROM photos
         WHERE ID = pid AND idalbum = pidalbum
      ORDER BY ID, idalbum;

   RETURN fotoref;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_findfotobypk;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION spalbum_findlastphotoid (pidalbum NUMBER)
   RETURN NUMBER
IS
   lastfoto   NUMBER;
BEGIN
   lastfoto := 0;

   SELECT   ID
       INTO lastfoto
       FROM photos
      WHERE idalbum = pidalbum AND ROWNUM < 2
   ORDER BY ID DESC;

   RETURN lastfoto;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      return 1;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_findlastphotoid;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION spalbum_findpostitbyfoto (
   pidalbum   NUMBER,
   pidfoto    NUMBER
)
   RETURN TYPES.refcursor
IS
   postitref   TYPES.refcursor;
BEGIN
   OPEN postitref FOR
      SELECT   ID, comentario, x, y
          FROM postit
         WHERE idalbum = pidalbum AND idfoto = pidfoto
      ORDER BY ID;

   RETURN postitref;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_findpostitbyfoto;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION spalbum_findpostitbypk (
   pidalbum   NUMBER,
   pidfoto    NUMBER,
   pid        NUMBER
)
   RETURN TYPES.refcursor
IS
   postitref   TYPES.refcursor;
BEGIN
   OPEN postitref FOR
      SELECT   ID, comentario, x, y
          FROM postit
         WHERE idalbum = pidalbum AND idfoto = pidfoto AND ID = pid
      ORDER BY ID;

   RETURN postitref;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_findpostitbypk;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION spalbum_insertpostit (
   pcomentario   VARCHAR2,
   px            FLOAT,
   py            FLOAT,
   pid           NUMBER,
   pidalbum      NUMBER,
   pidfoto       NUMBER,
   puser		 VARCHAR2
)
   RETURN NUMBER
IS
   postitid   NUMBER;
BEGIN
   postitid := 0;

   SELECT ID
     INTO postitid
     FROM postit
    WHERE idalbum = pidalbum AND idfoto = pidfoto AND ID = pid;

   UPDATE postit
      SET comentario = pcomentario,
          x = px,
          y = py
    WHERE ID = pid AND idalbum = pidalbum AND idfoto = pidfoto;

   COMMIT;
   RETURN pid;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      SELECT photos_seq.NEXTVAL
        INTO postitid
        FROM DUAL;

      INSERT INTO postit
                  (ID, idalbum, idfoto, comentario, x, y,usuario
                  )
           VALUES (postitid, pidalbum, pidfoto, pcomentario, px, py,puser
                  );

      COMMIT;
      RETURN postitid;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END spalbum_insertpostit;
/

SHOW ERRORS;


CREATE OR REPLACE function split
(
    p_list varchar2,
    p_del varchar2 := ','
) return split_tbl pipelined
is
    l_idx    pls_integer;
    l_list    varchar2(32767) := p_list;

    l_value    varchar2(32767);
begin
    loop
        l_idx := instr(l_list,p_del);
        if l_idx > 0 then
            pipe row(substr(l_list,1,l_idx-1));
            l_list := substr(l_list,l_idx+length(p_del));

        else
            pipe row(l_list);
            exit;
        end if;
    end loop;
    return;
end split;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          sp_album_list
   RETURN TYPES.refcursor
IS
   listaref   TYPES.refcursor;
BEGIN
   OPEN listaref FOR
      SELECT   nombre, ID
          FROM album
      ORDER BY ID DESC;

   RETURN listaref;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      NULL;
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END sp_album_list;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          SP_NOMBRES_BLOCK_TEMP (
        ENTRADA           IN      VARCHAR2
        ,PASMSG_ERROR   OUT     VARCHAR2
        ,REGRESA       OUT SYS_REFCURSOR
)

IS
NOM     VARCHAR2(50 BYTE);
IDEN    VARCHAR2(8 BYTE);
JUNTACION VARCHAR2(58 BYTE);
STR_SQL VARCHAR2(1048 BYTE);


BEGIN
            STR_SQL := 'SELECT * FROM EBANKING.EBANKING_ACTIVATION WHERE CLIENTE IN ('||ENTRADA||')';
            EXECUTE IMMEDIATE STR_SQL;   
RETURN SQL%ROWCOUNT;
  
              PASMSG_ERROR := 'EXITOSO';       
              

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       NULL;
     WHEN OTHERS THEN
       RAISE;
END SP_NOMBRES_BLOCK_TEMP;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION sp_update_foto (
   pcomentario    VARCHAR2,
   pdescripcion   VARCHAR2,
   pid            NUMBER,
   pidalbum       NUMBER
)
   RETURN NUMBER
IS
   tmpvar   NUMBER;
BEGIN
   tmpvar := 0;

   UPDATE photos p
      SET p.comentario = pcomentario,
          p.descripcion = pdescripcion
    WHERE p.ID = pid AND p.idalbum = pidalbum;

   SELECT COUNT (ID)
     INTO tmpvar
     FROM photos
    WHERE ID = pid AND idalbum = pidalbum;

   COMMIT;
   RETURN tmpvar;
EXCEPTION
   WHEN NO_DATA_FOUND
   THEN
      RETURN -1;
   WHEN OTHERS
   THEN
      RETURN -1;
END sp_update_foto;
/

SHOW ERRORS;


CREATE OR REPLACE function SQUIRREL_GET_ERROR_OFFSET (query IN varchar2) return number authid current_user is      l_theCursor     integer default dbms_sql.open_cursor;      l_status        integer; begin          begin          dbms_sql.parse(  l_theCursor, query, dbms_sql.native );          exception                  when others then l_status := dbms_sql.last_error_position;          end;          dbms_sql.close_cursor( l_theCursor );          return l_status; end;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Suspender_Servicio_Deposito (
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN
	BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
  	--Insertamos el id, nombre del servicio y fecha de ultima vez ejecutado
	DELETE EBANKING_ALERTAS_DEPOSITO WHERE Cliente_id = pCliente AND cuenta_hash = pCuentaHash AND secuencia_telefono = vSecuencia;
	COMMIT;
	EXCEPTION
	      WHEN NO_DATA_FOUND THEN
		  RETURN verdadero;
	  END;
	RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Suspender_Servicio_Deposito;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Suspender_Servicio_Retiro (
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN
	BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
  	--Insertamos el id, nombre del servicio y fecha de ultima vez ejecutado
	DELETE EBANKING_ALERTAS_RETIRO WHERE Cliente_id = pCliente AND cuenta_hash = pCuentaHash AND secuencia_telefono = vSecuencia;
	COMMIT;
	EXCEPTION
	      WHEN NO_DATA_FOUND THEN
		  RETURN verdadero;
	  END;
	RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Suspender_Servicio_Retiro;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Suspender_Servicio_Tefdev (
    pCliente NUMBER,
	pCuentaHash VARCHAR,
	pTelefono NUMBER
  )
  RETURN INTEGER
  IS
  vSecuencia INTEGER;
  verdadero INTEGER := 1;
  falso INTEGER := 0;

  BEGIN
	BEGIN
    --Buscamos el Id de ese telefono
	SELECT secuencia INTO vSecuencia FROM TELEFONO WHERE cliente_id = pCliente AND telefono_id = pTelefono;
  	--Insertamos el id, nombre del servicio y fecha de ultima vez ejecutado
	DELETE EBANKING_ALERTAS_TEFDEV WHERE Cliente_id = pCliente AND cuenta_hash = pCuentaHash AND secuencia_telefono = vSecuencia;
	COMMIT;
	EXCEPTION
	      WHEN NO_DATA_FOUND THEN
		  RETURN verdadero;
	  END;
	RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Suspender_Servicio_Tefdev;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION TERMINAL_CONVER (
   TABLA             VARCHAR2,
   GETTERMINALDEFAULT VARCHAR2,
   NUMALE1           NUMBER,
   NUMALE2           NUMBER,
   NUMALE3           NUMBER
)
   RETURN TYPES.REFCURSOR
IS
   RECTERMINAL   TYPES.REFCURSOR;
   SQL_STR       VARCHAR2(2000);
BEGIN
	 SQL_STR:= 'SELECT BUSY, CODE FROM ' ||TABLA|| ' WHERE CODE<>'||''''||GETTERMINALDEFAULT||''''||' (ID =' || NUMALE1|| ' OR  ID =' || NUMALE2 ||' OR ID =' || NUMALE3||')';  
   	 		   		   
   OPEN RECTERMINAL FOR SQL_STR;     
   RETURN RECTERMINAL;
END TERMINAL_CONVER;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION TEST_GET_CURSO (
   id IN EBANKING.TESTCURSO.ID%TYPE)
RETURN Types.REFCURSOR
IS
   curCursorSalida Types.REFCURSOR;
   vlMsg VARCHAR2(150);
   cont  NUMBER(2);
   
   CURSOR curTabla IS
      SELECT tc.ID, tc.NOMBRE, tc.APELLIDOP, tc.APELLIDOM
        FROM EBANKING.TESTCURSO tc
    ORDER BY ID;
     
BEGIN

	 FOR registro IN curTabla LOOP
	 	 DBMS_OUTPUT.PUT_LINE('Id: ' || registro.id || ' Nombre: ' || registro.NOMBRE || ' ' || registro.APELLIDOP || ' ' || registro.APELLIDOM);
	 END LOOP;
    
	 cont:=0;
	
	 WHILE (cont < 5) LOOP
	      DBMS_OUTPUT.PUT_LINE('cont: ' || cont);
	      cont:= cont + 1;
	 END LOOP;

    OPEN curCursorSalida FOR
  SELECT tc.ID, tc.NOMBRE, tc.APELLIDOP, tc.APELLIDOM
    FROM EBANKING.TESTCURSO tc
   WHERE tc.ID = id;

   
RETURN curCursorSalida;

EXCEPTION
WHEN NO_DATA_FOUND THEN
      OPEN
         curCursorSalida
      FOR
         SELECT 0 AS ID
		        ,'No se encontraron datos' AS NOMBRE
				,'' AS APELLIDOP
				,'' AS APELLIDOM
           FROM DUAL;
      RETURN curCursorSalida;
WHEN OTHERS THEN
	  vlMsg := SQLCODE || ' ' ||
               SUBSTR(SQLERRM, 1, 135); 
      OPEN
         curCursorSalida
      FOR
         SELECT 0 AS ID
		        ,'Error: Descripción.- ' || vlMsg AS NOMBRE		        
				,'' AS APELLIDOP
				,'' AS APELLIDOM
           FROM DUAL;
      RETURN curCursorSalida;

END TEST_GET_CURSO;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION TEST_GET_CURSO2 (
   id IN EBANKING.TESTCURSO.ID%TYPE)
RETURN EBANKING.TESTCURSO.NOMBRE%TYPE
IS
   nombre EBANKING.TESTCURSO.NOMBRE%TYPE;        
BEGIN

  SELECT tc.NOMBRE
    INTO nombre
    FROM EBANKING.TESTCURSO tc
   WHERE tc.ID = id;
   
RETURN nombre;

EXCEPTION
WHEN NO_DATA_FOUND THEN
      RETURN 'No se encontro';
WHEN OTHERS THEN
      RETURN 'Hubo error';

END TEST_GET_CURSO2;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION TOKEN_CONSULTA_ACTIVACION(cliente VARCHAR2)
RETURN Types.REFCURSOR IS cursor_salida Types.REFCURSOR;
BEGIN
   OPEN cursor_salida FOR

    SELECT NUM_SERIE_TOKEN,STATUS, FECHA_ACTIVACION
	FROM EBANKING_TOKEN_STATUS WHERE NUM_CLIENTE = cliente;

	RETURN cursor_salida;

END TOKEN_CONSULTA_ACTIVACION;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          UPDATEOPPROGRA(CURSOR IN IS REF CURSOR%TYPE)
 /****************************************************************************
   Proyecto:               Ebanking
   Descripcion:            Funcion parea consultar las frecuentes de credimadx
   Parametros de entrada:  paFcAlnovaUser        - Identificador del cliente
   Creador:                Oscar Tzompantzi Astivia
   Fecha:                  16/04/2013
****************************************************************************/
 RETURN EBANKING.TYPES.REFCURSOR
 IS
 
   BEGIN
 SELECT * FROM DUAL;
             COMMIT;
    
    RETURN CURSOR_OUTPUT;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar (' || SQLCODE || '  ' || SQLERRM || ')');
  WHEN OTHERS THEN
     ROLLBACK;
     RAISE_APPLICATION_ERROR (-20100, 'Error ocurrido al consultar ( * ' || SQLCODE || '  ' || SQLERRM ||  '  *)');
END UPDATEOPPROGRA;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION Update_Mensajes (
  pMensaje_Id NUMBER
  )
  RETURN INTEGER IS

  vMensaje_Id NUMBER(10);
  verdadero INTEGER := 1;
  falso INTEGER := 0;
  BEGIN
	BEGIN
	  -- Si no existe el mensaje en la base de datos regresar ERROR
	  SELECT mensaje_id INTO vMensaje_Id FROM MENSAJE WHERE mensaje_id = pMensaje_Id;
	  EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    RETURN 0;
	END;

--  LOCK TABLE mensaje IN ROW SHARE MODE NOWAIT;
--  LOCK TABLE mensaje IN ROW SHARE MODE;
  UPDATE MENSAJE SET status = 1 WHERE mensaje_id = pMensaje_Id;

  COMMIT;
  RETURN verdadero;

  EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR (-20006, 'Error'||SQLERRM(SQLCODE));
    RETURN falso;
  END Update_Mensajes;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          USER_DATA_ACT
RETURN EBANKING.TYPES.REFCURSOR

 IS 
 
 cursorActiv EBANKING.TYPES.REFCURSOR;
 
BEGIN
      OPEN cursorActiv FOR
        SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
        FROM EBANKING.EBANKING_USER;
      
      RETURN cursorActiv;  

END USER_DATA_ACT;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          USER_DATA_ACT2
RETURN EBANKING.TYPES.REFCURSOR
 IS cursorActiv EBANKING.TYPES.REFCURSOR;
BEGIN
      OPEN cursorActiv FOR
        SELECT ID, TO_CHAR(ACTIVATION,'DD/MM/YYYY HH24:MI:SS') AS ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, TO_CHAR(ULT_ACCESO,'DD/MM/YYYY HH24:MI:SS') AS ULT_ACCESO, TOKEN
        FROM (
            (SELECT ID, ACTIVATION, ACTIVE, ADVANCEDSERVICE, TRACKING, ULT_ACCESO, TOKEN
            FROM EBANKING.EBANKING_USER)
                UNION
            (SELECT TO_NUMBER(CLIENTE) AS ID, ACTIVACION AS ACTIVATION, 8 AS ACTIVE, 8 AS ADVANCEDSERVICE, 8 AS TRACKING, SYSDATE AS ULT_ACCESO, 8 AS TOKEN 
            FROM EBANKING.EBANKING_ACTIVATION WHERE EBANKING.EBANKING_ACTIVATION.CLIENTE NOT IN (
            SELECT EBANKING.EBANKING_USER.ID  FROM EBANKING.EBANKING_USER))
);
      
      RETURN cursorActiv;  

END USER_DATA_ACT2;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION          USER_DATA_CLIENTSPF_SINGLE(IDENTIFICADOR IN NUMBER)
RETURN TYPES.REFCURSOR  
IS
                         ESNULLO NUMBER;
                         PC_CURSOR EBANKING.TYPES.REFCURSOR;                         
                       IDENTIF_STR  VARCHAR2(8);
                         
                      BEGIN
                      
                        IF IDENTIFICADOR < 99 THEN
                                IDENTIF_STR := '000000' || IDENTIFICADOR;
                       END IF;
                       
                        IF IDENTIFICADOR < 999 THEN
                            IDENTIF_STR := '00000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 9999 THEN
                            IDENTIF_STR := '0000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 99999 THEN
                            IDENTIF_STR := '000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 999999 THEN
                            IDENTIF_STR := '00' || IDENTIFICADOR;
                        END IF;
                        
                       IF IDENTIFICADOR < 9999999 THEN
                            IDENTIF_STR := '0' || IDENTIFICADOR;
                       END IF;
                       
                       IF IDENTIFICADOR > 9999999 THEN
                                IDENTIF_STR := '' || IDENTIFICADOR;  

                       END IF;

                         SELECT  COUNT (EBANKING_USER.ID) INTO ESNULLO FROM EBANKING.EBANKING_USER
                           WHERE EBANKING_USER.ID=IDENTIFICADOR;
                           
                           IF ESNULLO != 0 THEN
                           OPEN PC_CURSOR FOR
                           
                            SELECT EBANKING_USER.ID, EBANKING_USER.ACTIVE, EBANKING_USER.ADVANCEDSERVICE,
                            EBANKING_USER.TRACKING,  EBANKING_USER.ULT_ACCESO,  EBANKING_USER.TOKEN FROM EBANKING.EBANKING_USER
                            WHERE EBANKING_USER.ID=IDENTIFICADOR;
                            
                            RETURN PC_CURSOR;

                           ELSE
                           OPEN PC_CURSOR FOR
                            SELECT TO_NUMBER(CLIENTE) AS ID, ACTIVACION AS ACTIVATION, ' ' AS ACTIVE, ' ' AS ADVANCEDSERVICE, ' ' AS TRACKING, SYSDATE AS ULT_ACCESO, ' ' AS TOKEN 
                            FROM EBANKING.EBANKING_ACTIVATION  WHERE EBANKING_ACTIVATION.CLIENTE = IDENTIF_STR;
                            RETURN PC_CURSOR;
                            
                           
                           END IF;
                         
                         
                      END;    

   /*
CREATE OR REPLACE FUNCTION EBANKING.USER_DATA_CLIENTSPF_SINGLE(IDENTIFICADOR IN NUMBER)
RETURN TYPES.REFCURSOR  
IS
                         ESNULLO NUMBER;
                         PC_CURSOR EBANKING.TYPES.REFCURSOR;                         
                       IDENTIF_STR  VARCHAR2(8);
                         
                      BEGIN
                      
                        IF IDENTIFICADOR < 99 THEN
                                IDENTIF_STR := '000000' || IDENTIFICADOR;
                       END IF;
                       
                        IF IDENTIFICADOR < 999 THEN
                            IDENTIF_STR := '00000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 9999 THEN
                            IDENTIF_STR := '0000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 99999 THEN
                            IDENTIF_STR := '000' || IDENTIFICADOR;
                        END IF;
                        
                        IF IDENTIFICADOR < 999999 THEN
                            IDENTIF_STR := '00' || IDENTIFICADOR;
                        END IF;
                        
                       IF IDENTIFICADOR < 9999999 THEN
                            IDENTIF_STR := '0' || IDENTIFICADOR;
                       END IF;
                       
                       IF IDENTIFICADOR > 9999999 THEN
                                IDENTIF_STR := '' || IDENTIFICADOR;  

                       END IF;

                         SELECT  COUNT (EBANKING_USER.ID) INTO ESNULLO FROM EBANKING.EBANKING_USER
                           WHERE EBANKING_USER.ID=IDENTIFICADOR;
                           
                           IF ESNULLO != 0 THEN
                           OPEN PC_CURSOR FOR
                           
                            SELECT EBANKING_USER.ID, EBANKING_USER.ACTIVE, EBANKING_USER.ADVANCEDSERVICE,
                            EBANKING_USER.TRACKING,  EBANKING_USER.ULT_ACCESO,  EBANKING_USER.TOKEN FROM EBANKING.EBANKING_USER
                            WHERE EBANKING_USER.ID=IDENTIFICADOR;
                            
                            RETURN PC_CURSOR;

                           ELSE
                           OPEN PC_CURSOR FOR
                            SELECT TO_NUMBER(CLIENTE) AS ID, ACTIVACION AS ACTIVATION, ' ' AS ACTIVE, ' ' AS ADVANCEDSERVICE, ' ' AS TRACKING, SYSDATE AS ULT_ACCESO, ' ' AS TOKEN 
                            FROM EBANKING.EBANKING_ACTIVATION  WHERE EBANKING_ACTIVATION.CLIENTE = IDENTIF_STR;
                            RETURN PC_CURSOR;
                            
                           
                           END IF;
                         
                         
                      END;
                      
 END USER_DATA_CLIENTSPF_SINGLE;
 
 /*
 SELECT EBANKING_USER.ID, EBANKING_USER.ACTIVE, EBANKING_USER.ADVANCEDSERVICE,
                            EBANKING_USER.TRACKING,  EBANKING_USER.ULT_ACCESO,  EBANKING_USER.TOKEN FROM EBANKING.EBANKING_USER
                            WHERE EBANKING_USER.ID=3693444;
                        
*/
/*
 select USER_DATA_CLIENTSPF_SINGLE(:n) from dual;

/*
5369370

3693444

SELECT ID, TOKEN from EBANKING_USER;*/
/*
IDENTIF_STR  VARCHAR2;

IF IDENTIFICADOR < 99 THEN
    IDENTIF_STR = '000000' || IDENTIFICADOR;
ELSE IF IDENTIFICADOR < 999 THEN
    IDENTIF_STR = '00000' || IDENTIFICADOR;
ELSE IF IDENTIFICADOR < 9999 THEN
    IDENTIF_STR = '0000' || IDENTIFICADOR;
ELSE IF IDENTIFICADOR < 99999 THEN
    IDENTIF_STR = '000' || IDENTIFICADOR;
ELSE IF IDENTIFICADOR < 999999 THEN
    IDENTIF_STR = '00' || IDENTIFICADOR;
ELSE IF IDENTIFICADOR < 9999999 THEN
    IDENTIF_STR = '0' || IDENTIFICADOR;
ELSE
    IDENTIF_STR = '' || IDENTIFICADOR;
    
    */
/*
SELECT TO_NUMBER(CLIENTE)  AS ID, ACTIVACION AS ACTIVATION, 8 AS ACTIVE, 8 AS ADVANCEDSERVICE, 8 AS TRACKING, SYSDATE AS ULT_ACCESO, 8 AS TOKEN 
                            FROM EBANKING.EBANKING_ACTIVATION WHERE EBANKING_ACTIVATION.CLIENTE ='05369370';
                            */
/

SHOW ERRORS;


CREATE OR REPLACE function VALIDA_ARCHIVO_PMASIVOS(Name in type, Name in type, ...) return  is


CREATE OR REPLACE FUNCTION BELEKTRA.VALIDA_ARCHIVO
(
  NOMBRE_ARCHIVO ARCHIVO.NOMBRE%TYPE,
  NOMBRE_EMPRESA EMPRESA.NOMBRE%TYPE
)
RETURN INT
IS
  INDICADOR	  	 INT := -1;
  ID_EMPRESA	 EMPRESA.ID_EMPRESA%TYPE;
BEGIN

	 BEGIN

	 	 ID_EMPRESA := GETIDEMPRESA( NOMBRE_EMPRESA );

		 SELECT COUNT( ARCHIVO.NOMBRE ) INTO INDICADOR
	 	 FROM ARCHIVO_PMASIVOS ARCHIVO, PEND_TRASPASOS_MASIVOS PENDIENTE
		 WHERE ARCHIVO.ID_ARCHIVO = PENDIENTE.ID_ARCHIVO
		 	   AND UPPER( ARCHIVO.NOMBRE ) = UPPER ( NOMBRE_ARCHIVO )
		 	   AND PENDIENTE.EMPRESA_ID = ID_EMPRESA;

		RETURN INDICADOR;

	 EXCEPTION
	     WHEN NO_DATA_FOUND THEN
		   INDICADOR := 0;
		 WHEN OTHERS THEN
		   INDICADOR := -1;
	END;

	RETURN INDICADOR;

END VALIDA_ARCHIVO_PMASIVOS;
/

SHOW ERRORS;


CREATE OR REPLACE VIEW MGV_ALL_CAPTURED_SQL
AS 
SELECT d.*, p.native_sql,p.linecount 
FROM md_stored_programs p , mgv_all_programs_details d
WHERE p.id = d.objid
AND d.capturedorconverted = 'CAPTURED'
UNION ALL
SELECT d.*,v.native_sql,v.linecount
FROM md_views v , mgv_all_view_details d
WHERE v.id = d.objid
AND d.capturedorconverted = 'CAPTURED'
UNION ALL
SELECT d.* ,t.native_sql,t.linecount
FROM md_triggers t , mgv_all_trigger_details d
WHERE t.id = d.objid
AND d.capturedorconverted = 'CAPTURED';


CREATE OR REPLACE VIEW MGV_ALL_CATALOGS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name
  FROM md_projects ,
    md_connections,
    md_catalogs
  WHERE md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk   = md_projects.id
WITH READ ONLY;


CREATE OR REPLACE VIEW MGV_ALL_CATALOG_DETAILS
AS 
SELECT 'MD_CATALOGS' objtype, cat.catalog_name objname, cat.id objid,  'MD_CATALOGS' MainObjType,cat.catalog_name MAINOBJNAME, cat.id MAINOBJID,null SchemaName,null schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name ELSE NULL END QualifiedName
FROM  MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE  cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_COLUMNDT_DETAILS
AS 
SELECT 'MD_COLUMNS' objtype, c.COLUMN_NAME objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname ,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.COLUMN_NAME QualifiedName,
c.column_type datatype,
CASE WHEN p.PROP_KEY='SEEDVALUE' THEN 'Y' ELSE 'N' END IsIdentity
FROM MD_COLUMNS c LEFT OUTER JOIN MD_ADDITIONAL_PROPERTIES p ON c.id =p.ref_id_fk
, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn,MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_COLUMN_DETAILS
AS 
SELECT 'MD_COLUMNS' objtype, c.COLUMN_NAME objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.COLUMN_NAME QualifiedName
FROM MD_COLUMNS c, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_CONNECTIONS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    MD_CONNECTIONS.ID CONNECTION_ID ,
    MD_CONNECTIONS.NAME CONNECTION_NAME,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl
  FROM md_projects,
    md_connections
  WHERE MD_CONNECTIONS.PROJECT_ID_FK = MD_PROJECTS.ID
WITH READ ONLY;


CREATE OR REPLACE VIEW MGV_ALL_CONSTRAINTS_DETAILS
AS 
SELECT 'MD_CONSTRAINTS' objtype, c.name objname, c.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||t.table_name ||'.'||c.name QualifiedName
FROM MD_CONSTRAINTS c, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE c.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_DETAILS
AS 
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_CATALOG_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_SCHEMA_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_TABLES_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_COLUMN_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_CONSTRAINTS_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_INDEX_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_TRIGGER_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_VIEW_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_PROGRAMS_DETAILS
UNION
SELECT "OBJTYPE","OBJNAME","OBJID","MAINOBJTYPE","MAINOBJNAME","MAINOBJID","SCHEMANAME","SCHEMAID","CATALOGNAME","CATALOGID","CONNNAME","CONNID","PROJECTNAME","PROJECTID","CAPTUREDORCONVERTED","QUALIFIEDNAME" FROM MGV_ALL_PARTITIONS_DETAILS;


CREATE OR REPLACE VIEW MGV_ALL_INDEX_DETAILS
AS 
SELECT 'MD_INDEXES' objtype,i.index_name objname, i.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME,t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid, proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||i.index_name  QualifiedName
FROM MD_INDEXES i, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn,MD_PROJECTS proj
WHERE i.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_PARTITIONS_DETAILS
AS 
SELECT 'MD_PARTITIONS' objtype, 'PARTTITION_EXP' objname, t.id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN   md_meta.quote(cat.catalog_name,s.name,t.table_name,conn.id)
                            ELSE   s.name || '.' || t.table_name END QualifiedName
FROM MD_PARTITIONS p, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE p.table_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_PROGRAMS_DETAILS
AS 
SELECT 'MD_STORED_PROGRAMS' objtype,p.name objname, p.Id objid,  'MD_STORED_PROGRAMS' MainObjType,p.name MAINOBJNAME,p.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||p.name  QualifiedName
FROM MD_STORED_PROGRAMS p,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE p.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_SCHEMA
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_projects
  WHERE md_schemas.catalog_id_fk   = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id
WITH READ ONLY;


CREATE OR REPLACE VIEW MGV_ALL_SCHEMA_DETAILS
AS 
SELECT 'MD_SCHEMAS' objtype, s.name objname, s.id objid,  'MD_SCHEMAS' MainObjType,s.name MAINOBJNAME, s.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name QualifiedName
FROM MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_STORED_PROGRAMS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name ,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_stored_programs.id stored_program_id ,
    md_stored_programs.programtype programtype ,
    md_stored_programs.name stored_program_name,
    md_stored_programs.package_id_fk package_id_fk
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_stored_programs
  WHERE md_stored_programs.schema_id_fk = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;


CREATE OR REPLACE VIEW MGV_ALL_TABLES
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_connections.dburl dburl ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_tables.id table_id ,
    md_tables.TABLE_NAME TABLE_NAME
  FROM md_connections,
    md_catalogs ,
    md_schemas ,
    md_tables ,
    md_projects
  WHERE md_tables.schema_id_fk     = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id
WITH READ ONLY;


CREATE OR REPLACE VIEW MGV_ALL_TABLES_DETAILS
AS 
SELECT 'MD_TABLES' objtype, t.table_name objname, t.id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME, t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN   md_meta.quote(cat.catalog_name,s.name,t.table_name,conn.id)
                            ELSE   s.name || '.' || t.table_name END QualifiedName
FROM MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_TABLE_TRIGGERS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_tables.id table_id ,
    md_tables.TABLE_NAME TABLE_NAME ,
    md_triggers.id trigger_id ,
    md_triggers.trigger_name trigger_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_tables ,
    md_triggers
  WHERE md_triggers.table_or_view_id_fk = md_tables.id
  AND md_tables.schema_id_fk            = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;


CREATE OR REPLACE VIEW MGV_ALL_TRIGGER_DETAILS
AS 
SELECT 'MD_TRIGGERS' objtype,trig.trigger_name objname, trig.Id objid,  'MD_TABLES' MainObjType,t.table_name MAINOBJNAME,t.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||trig.trigger_name  QualifiedName
FROM MD_TRIGGERS trig, MD_TABLES t,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE trig.table_or_view_id_fk = t.id
AND t.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id 
UNION
SELECT 'MD_TRIGGERS' objtype,trig.trigger_name objname, trig.Id objid,  'MD_VIEWS' MainObjType,v.view_name MAINOBJNAME,v.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||trig.trigger_name  QualifiedName
FROM MD_TRIGGERS trig, MD_VIEWS v,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE trig.table_or_view_id_fk = v.id
AND v.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id 
ORDER BY objid;


CREATE OR REPLACE VIEW MGV_ALL_VIEWS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_views.id view_id ,
    md_views.view_name view_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_views
  WHERE md_views.schema_id_fk      = md_schemas.id
  AND md_schemas.catalog_id_fk     = md_catalogs.id
  AND md_catalogs.connection_id_fk = md_connections.id
  AND md_connections.project_id_fk = md_projects.id
WITH READ ONLY;


CREATE OR REPLACE VIEW MGV_ALL_VIEW_DETAILS
AS 
SELECT 'MD_VIEWS' objtype, v.view_name objname, v.Id objid,  'MD_VIEWS' MainObjType,v.view_name MAINOBJNAME,v.id MAINOBJID, s.name SchemaName, s.id schemaid, cat.catalog_name catalogname,cat.id catalogid, conn.name connname,conn.id  connid,proj.project_name projectname,proj.id projectid,
NVL(conn.type,'CAPTURED') CapturedOrConverted, 
CASE WHEN conn.type IS NULL THEN cat.catalog_name||'.' ELSE '' END || s.name||'.'||v.view_name  QualifiedName
FROM MD_VIEWS v,MD_SCHEMAS s, MD_CATALOGS cat,MD_CONNECTIONS conn, MD_PROJECTS proj
WHERE v.schema_id_fk = s.id
AND s.catalog_id_fk = cat.id
AND cat.connection_id_fk = conn.id
AND conn.PROJECT_ID_FK = proj.id;


CREATE OR REPLACE VIEW MGV_ALL_VIEW_TRIGGERS
AS 
SELECT md_projects.id project_id ,
    md_projects.project_name project_name,
    md_connections.id connection_id ,
    md_connections.host host ,
    md_connections.port port ,
    md_connections.username username ,
    md_catalogs.id catalog_id ,
    md_catalogs.catalog_name catalog_name,
    md_catalogs.dummy_flag dummy_flag ,
    md_schemas.id schema_id ,
    md_schemas.name schema_name ,
    md_views.id view_id ,
    md_views.view_name view_name ,
    md_triggers.id trigger_id ,
    md_triggers.trigger_name trigger_name
  FROM md_projects ,
    md_connections,
    md_catalogs ,
    md_schemas ,
    md_views ,
    md_triggers
  WHERE md_triggers.table_or_view_id_fk = md_views.id
  AND md_views.schema_id_fk             = md_schemas.id
  AND md_schemas.catalog_id_fk          = md_catalogs.id
  AND md_catalogs.connection_id_fk      = md_connections.id
  AND md_connections.project_id_fk      = md_projects.id;


CREATE OR REPLACE VIEW MGV_DERIVATIVES
AS 
SELECT "ID","SRC_ID","SRC_TYPE","DERIVED_ID","DERIVED_TYPE","DERIVED_CONNECTION_ID_FK","TRANSFORMED","ORIGINAL_IDENTIFIER","NEW_IDENTIFIER","DERIVED_OBJECT_NAMESPACE","DERIVATIVE_REASON","SECURITY_GROUP_ID","CREATED_ON","CREATED_BY","LAST_UPDATED_ON","LAST_UPDATED_BY" FROM MD_DERIVATIVES WHERE (Derivative_Reason <> 'SCRATCH' OR DERIVative_Reason IS NULL);


CREATE OR REPLACE VIEW MGV_DERIVED_DETAILS
AS 
select d1.catalogid capcatalogid,
   d1.catalogname capcatalogname,
   d1.connid capconnid,
   d1.connname capconnname,
   d1.mainobjid capmainobjid,
   d1.mainobjname capmainobjname,
   d1.mainobjtype capmainobjtype ,
   d1.objid capobjid,
   d1.objname capobjname,
   d1.objtype capobjtype,
   d1.projectid capprojectid,
   d1.projectname capprojectname,
   d1.qualifiedname capqualifiedname,
   d1.schemaid capschemaid,
   d1.schemaname capschemaname,
   d2.catalogid concatalogid,
   d2.catalogname concatalogname,
   d2.connid conconnid,
   d2.connname conconnname,
   d2.mainobjid conmainobjid,
   d2.mainobjname conmainobjname,
   d2.mainobjtype conmainobjtype ,
   d2.objid conobjid,
   d2.objname conobjname,
   d2.objtype conobjtype,
   d2.projectid conprojectid,
   d2.projectname conprojectname,
   d2.qualifiedname conqualifiedname,
   d2.schemaid conschemaid,
   d2.schemaname conschemaname,
    der.derivative_reason,
    der.transformed
  FROM mgv_all_details d1
  LEFT OUTER JOIN md_derivatives der
  ON der.src_id              = d1.objid
  AND der.derivative_reason IS NULL
  LEFT OUTER JOIN mgv_all_details d2
  ON der.derived_id            = d2.objid
  WHERE d1.capturedorconverted = 'CAPTURED'
  AND der.derivative_reason   IS NULL;


CREATE OR REPLACE VIEW MGV_SCRATCH_DERIVATIVES
AS 
SELECT "ID","SRC_ID","SRC_TYPE","DERIVED_ID","DERIVED_TYPE","DERIVED_CONNECTION_ID_FK","TRANSFORMED","ORIGINAL_IDENTIFIER","NEW_IDENTIFIER","DERIVED_OBJECT_NAMESPACE","DERIVATIVE_REASON","SECURITY_GROUP_ID","CREATED_ON","CREATED_BY","LAST_UPDATED_ON","LAST_UPDATED_BY" FROM MD_DERIVATIVES WHERE Derivative_Reason = 'SCRATCH';


CREATE OR REPLACE VIEW PREACTI
AS 
Select "ID_ALNOVA","ACCOUNT_NUMBER","STATUS","MAIL","ALIAS","ULTIMA_MODIFICACION","FECHA_EJECUCION","SUCURSAL","USUARIO_MODIFICO","NUM_EMPLEADO" from EBANKING.PREACTIVE_USER;


CREATE OR REPLACE VIEW USUARIOSINTERNET
AS 
select id, activation, active from ebanking.ebanking_user;


CREATE OR REPLACE VIEW VWALLOPERMONTO
AS 
SELECT u.usralnova, u.aplicacion, u.nombrecompleto, op.operacion,
          td.valor AS monto, op.fecha_operacion
     FROM EBANKING.m_usuarios u,
          EBANKING.m_usuarios_operaciones op,
          EBANKING.m_tracking t,
          EBANKING.m_tracking_detalle td
    WHERE u.idusuario = op.idusuario
      AND t.id_usuario_operacion = op.id_usuario_operacion
      AND td.idtracking = t.idtracking
      AND td.id_tracking_detalle BETWEEN (SELECT MIN (id_tracking_detalle)
                                            FROM EBANKING.m_tracking_detalle
                                           WHERE (   campo = 'importe'
                                                  OR campo = 'monto'
                                                 ))
                                     AND (SELECT MAX (id_tracking_detalle)
                                            FROM EBANKING.m_tracking_detalle
                                           WHERE (   campo = 'importe'
                                                  OR campo = 'monto'
                                                 ))
      AND (td.campo = 'importe' OR td.campo = 'monto')
      AND op.operacion != 'login';


CREATE OR REPLACE VIEW VWALLREGISTROUSUARIO
AS 
SELECT   aplicacion, COUNT (user_name) AS total
       FROM EBANKING.m_usuarios
   GROUP BY aplicacion;


CREATE OR REPLACE VIEW VWALLREGISUSERNAME
AS 
SELECT   u.aplicacion, u.nombrecompleto, COUNT (u.user_name) AS total
       FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
      WHERE u.idusuario = op.idusuario AND op.operacion = 'login'
   GROUP BY u.aplicacion, u.nombrecompleto;


CREATE OR REPLACE VIEW VWALLTOTOPERBYUSER
AS 
SELECT   u.aplicacion, u.nombrecompleto, COUNT (u.user_name) AS total
       FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
      WHERE u.idusuario = op.idusuario AND op.operacion != 'login'
   GROUP BY u.aplicacion, u.nombrecompleto;


CREATE OR REPLACE VIEW VWALLTRACKUSERAPP
AS 
SELECT aplicacion, nombrecompleto, operacion
     FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
    WHERE u.idusuario = op.idusuario AND op.operacion != 'login';


CREATE OR REPLACE VIEW VWOPERMONTO
AS 
SELECT u.usralnova, u.aplicacion, u.nombrecompleto, op.operacion,
          td.valor AS monto, op.fecha_operacion
     FROM EBANKING.m_usuarios u,
          EBANKING.m_usuarios_operaciones op,
          EBANKING.m_tracking t,
          EBANKING.m_tracking_detalle td
    WHERE u.idusuario = op.idusuario
      AND t.id_usuario_operacion = op.id_usuario_operacion
      AND td.idtracking = t.idtracking
      AND td.id_tracking_detalle
             BETWEEN (SELECT MIN (id_tracking_detalle)
                        FROM EBANKING.m_tracking_detalle
                       WHERE (campo = 'importe' OR campo = 'monto')
                         AND fecha_operacion BETWEEN SYSDATE - 7 AND SYSDATE)
                 AND (SELECT MAX (id_tracking_detalle)
                        FROM EBANKING.m_tracking_detalle
                       WHERE (campo = 'importe' OR campo = 'monto')
                         AND fecha_operacion BETWEEN SYSDATE - 7 AND SYSDATE)
      AND (td.campo = 'importe' OR td.campo = 'monto')
      AND op.operacion != 'login';


CREATE OR REPLACE VIEW VWREGISTROUSUARIO
AS 
SELECT   aplicacion, COUNT (user_name) AS total
       FROM EBANKING.m_usuarios
      WHERE TRUNC (fecha_operacion) BETWEEN SYSDATE - 7 AND SYSDATE
   GROUP BY aplicacion;


CREATE OR REPLACE VIEW VWREGISTROUSUARIONOMBRE
AS 
SELECT   u.aplicacion, u.nombrecompleto, COUNT (u.user_name) AS total
       FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
      WHERE u.idusuario = op.idusuario
        AND op.operacion = 'login'
        AND TRUNC (op.fecha_operacion) BETWEEN SYSDATE - 7 AND SYSDATE
   GROUP BY u.aplicacion, u.nombrecompleto;


CREATE OR REPLACE VIEW VWTOTOPERBYUSER
AS 
SELECT   aplicacion, nombrecompleto, COUNT (user_name) AS total
       FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
      WHERE u.idusuario = op.idusuario
        AND op.operacion != 'login'
        AND TRUNC (op.fecha_operacion) BETWEEN SYSDATE - 7 AND SYSDATE
   GROUP BY aplicacion, nombrecompleto;


CREATE OR REPLACE VIEW VWTRACKUSERAPP
AS 
SELECT aplicacion, nombrecompleto, operacion
     FROM EBANKING.m_usuarios u, EBANKING.m_usuarios_operaciones op
    WHERE u.idusuario = op.idusuario
      AND op.operacion != 'login'
      AND TRUNC (op.fecha_operacion) BETWEEN SYSDATE - 7 AND SYSDATE;


CREATE OR REPLACE VIEW V_PREACT
AS 
SELECT ID, CLIENTE_ALNOVA, EMAIL, NOMBRE, APELLIDO_PATERNO, APELLIDO_MATERNO, SUCURSAL, NUMERO_EMPLEADO, ULTIMA_MODIFICACION, USUARIO_MODIFICO, SISTEMA, PAIS, ESTATUS, APLICACION, FECHA_INSERCION, FECHA_ACTIVACION FROM EBANKING.PREACTIVACION ORDER BY ID;


CREATE OR REPLACE VIEW V_PREACT_USER
AS 
((SELECT ID, ULT_ACCESO, 'SI' AS TIENE_BANCA FROM EBANKING.EBANKING_USER)
UNION
(SELECT ID, NULL AS ULT_ACCESO, 'NO' AS TIENE_BANCA FROM PREACTIVACION WHERE ID NOT IN (select ID from EBANKING.EBANKING_USER)));


CREATE OR REPLACE VIEW V_USER
AS 
SELECT ID, ACTIVATION, ACTIVE, CELLULAR, EMAIL,USER2CELLCOMPANY, ADVANCEDSERVICE, SECUREDATA, ACTIVATIONTYPE, SECURITY_LEVEL, STATUS_CONT_TRAN, MAIL_RECEIVE, TRACKING, PWD_CHANGE_DATE, PWD_STATUS, PWD_CONFIRM_CHANGE_DATE, BIOMETRICO, TELEFONO_OFICINA, OLD_ADVANCEDSERVICE, ULT_ACCESO, FECHA_CAMBIO_STATUS_BAJA, STATUS_BAJA, TOKEN FROM EBANKING.EBANKING_USER ORDER BY ID ASC;


CREATE OR REPLACE TRIGGER ALLFRE_TRIGER BEFORE INSERT ON EBANKING."ALL_FRECUENTES" FOR 
EACH ROW
BEGIN 
SELECT ALLFREC_SEQUENCE.NEXTVAL INTO :NEW.ID_FRECUENTES FROM DUAL; 
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "DEL_MD_TRIGGERS_T_TRG" AFTER DELETE ON MD_TABLES 
FOR EACH ROW
BEGIN
  DELETE FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = :OLD.ID AND MD_TRIGGERS.TRIGGER_ON_FLAG = 'T';
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "DEL_MD_TRIGGERS_V_TRG" AFTER DELETE ON MD_VIEWS
FOR EACH ROW
BEGIN
  DELETE FROM MD_TRIGGERS WHERE MD_TRIGGERS.TABLE_OR_VIEW_ID_FK = :OLD.ID AND MD_TRIGGERS.TRIGGER_ON_FLAG = 'V';
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER FIAR_SORTEO_TRG
    BEFORE INSERT
        ON FIAR_SORTEO         REFERENCING NEW AS New OLD AS Old
        FOR EACH ROW
BEGIN
        SELECT EBANKING.FIAR_SORTEO_SEQ.NEXTVAL
        INTO :NEW.ID_SORTEO
        FROM DUAL;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR('-20000','TRIGGERNAME');
    END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "INS_APPLICATIONFILE_TRG" BEFORE INSERT OR UPDATE ON MD_APPLICATIONFILES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "INS_APPLICATION_TRG" BEFORE INSERT OR UPDATE ON MD_APPLICATIONS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "INS_FILE_ARTIFACT_TRG" BEFORE INSERT OR UPDATE ON MD_FILE_ARTIFACTS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_ADDITIONAL_PROPERTY_TRG" BEFORE INSERT OR UPDATE ON MD_ADDITIONAL_PROPERTIES 
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_CATALOGS_TRG" BEFORE INSERT OR UPDATE ON MD_CATALOGS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_COLUMNS_TRG" BEFORE INSERT OR UPDATE ON MD_COLUMNS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_CONNECTIONS_TRG" BEFORE INSERT OR UPDATE ON MD_CONNECTIONS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_CONSTRAINTS_TRG" BEFORE INSERT OR UPDATE ON MD_CONSTRAINTS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_CONSTRAINT_DETAILS_TRG" BEFORE INSERT OR UPDATE ON MD_CONSTRAINT_DETAILS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_DERIVATIVES_TRG" BEFORE INSERT OR UPDATE ON MD_DERIVATIVES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_GROUPS_TRG" BEFORE INSERT OR UPDATE ON MD_GROUPS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_GROUP_MEMBERS_TRG" BEFORE INSERT OR UPDATE ON MD_GROUP_MEMBERS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_GROUP_PRIVILEGES_TRG" BEFORE INSERT OR UPDATE ON MD_GROUP_PRIVILEGES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_INDEXES_TRG" BEFORE INSERT OR UPDATE ON MD_INDEXES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_INDEX_DETAILS_TRG" BEFORE INSERT OR UPDATE ON MD_INDEX_DETAILS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_MIGR_DEPENDENCY_TRG" BEFORE INSERT OR UPDATE ON MD_MIGR_DEPENDENCY
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_MIGR_PARAMETER_TRG" BEFORE INSERT OR UPDATE ON MD_MIGR_PARAMETER
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_MIGR_WEAKDEP_TRG" BEFORE INSERT OR UPDATE ON MD_MIGR_WEAKDEP
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_OTHER_OBJECTS_TRG" BEFORE INSERT OR UPDATE ON MD_OTHER_OBJECTS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_PACKAGES_TRG" BEFORE INSERT OR UPDATE ON MD_PACKAGES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_PARTITIONS_TRG" BEFORE INSERT OR UPDATE ON MD_PARTITIONS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_PRIVILEGES_TRG" BEFORE INSERT OR UPDATE ON MD_PRIVILEGES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_PROJECTS_TRG" BEFORE INSERT OR UPDATE ON MD_PROJECTS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_SCHEMAS_TRG" BEFORE INSERT OR UPDATE ON MD_SCHEMAS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_SEQUENCES_TRG" BEFORE INSERT OR UPDATE ON MD_SEQUENCES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_STORED_PROGRAMS_TRG" BEFORE INSERT OR UPDATE ON MD_STORED_PROGRAMS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_SYNONYMS_TRG" BEFORE INSERT OR UPDATE ON MD_SYNONYMS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_TABLESPACES_TRG" BEFORE INSERT OR UPDATE ON MD_TABLESPACES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_TABLES_TRG" BEFORE INSERT OR UPDATE ON MD_TABLES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_TRIGGERS_TRG" BEFORE INSERT OR UPDATE ON MD_TRIGGERS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_USERS_TRG" BEFORE INSERT OR UPDATE ON MD_USERS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_USER_DEFINED_DATA_TYPES_TRG" BEFORE INSERT OR UPDATE ON MD_USER_DEFINED_DATA_TYPES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_USER_PRIVILEGES_TRG" BEFORE INSERT OR UPDATE ON MD_USER_PRIVILEGES
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MD_VIEWS_TRG" BEFORE INSERT OR UPDATE ON MD_VIEWS
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MIGRLOG_TRG" BEFORE INSERT OR UPDATE ON MIGRLOG
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MIGR_DATATYPE_MAP_TRG" BEFORE INSERT OR UPDATE ON MIGR_DATATYPE_TRANSFORM_MAP
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MIGR_DATATYPE_RULE_TRG" BEFORE INSERT OR UPDATE ON MIGR_DATATYPE_TRANSFORM_RULE
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "MIGR_GENERATION_ORDER_TRG" BEFORE INSERT OR UPDATE ON MIGR_GENERATION_ORDER
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER RMASMS_TRIGGER BEFORE INSERT ON EBANKING."EBANKING_RMASMS" FOR 
EACH ROW
BEGIN 
SELECT RMASMS_SEQUENCE.NEXTVAL INTO :NEW.SMSKEY FROM DUAL; 
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "STAGE_MIGRLOG_ID_TRG" BEFORE INSERT OR UPDATE ON STAGE_MIGRLOG
FOR EACH ROW
BEGIN
  if inserting and :new.id is null then
        :new.id := MD_META.get_next_id;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "STAGE_MIGRLOG_LOG_DATE_TRG" BEFORE INSERT OR UPDATE ON STAGE_MIGRLOG
FOR EACH ROW
BEGIN
  if inserting and :new.log_date is null then
        :new.log_date := systimestamp;
    end if;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIGGER_M_TRACKING
before insert ON M_TRACKING for each row
begin
select EBANKING.SEQUENCE_M_TRACKING.nextval into :new.IDTRACKING 
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIGGER_M_TRACKING_DETALLE
before insert ON M_TRACKING_DETALLE for each row
begin
select EBANKING.SEQUENCE_M_TRACKING_DETALLE.nextval into :new.ID_TRACKING_DETALLE from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIGGER_M_USUARIOS
before insert ON M_USUARIOS for each row
begin
  select EBANKING.SEQUENCE_M_USUARIOS.nextval into :new.IDUSUARIO 
  from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIGGER_M_USUARIOS_OPERACIONES
before insert ON M_USUARIOS_OPERACIONES for each row
begin
   select EBANKING.SEQUENCE_M_USUARIOS_OPERA.nextval into :new.ID_USUARIO_OPERACION 
   from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_ACT_PAGMOV
before insert ON PAGO_MOVIL_ACT for each row
begin
select EBANKING.SEQ_ACT_PAGMOV.nextval into :new.ID_ACT_PAGMOV
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_FAKE_TOKEN_DISP
before insert ON FAKE_TOKEN_DISP for each row
begin
select EBANKING.SEQ_FAKE_DISP.nextval into :new.ID_ACT_DISPOSITIVO 
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_ID
BEFORE INSERT
ON EBANKING_TOKEN_PREVENCION REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
tmpVar NUMBER;
/******************************************************************************
   NAME:       trig_id
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        2/19/2007    Juan Luis URiel         1. Created this trigger.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     trig_id
      Sysdate:         2/19/2007
      Date and Time:   2/19/2007, 11:26:30 AM, and 2/19/2007 11:26:30 AM
      Username:         (set in TOAD Options, Proc Templates)
      Table Name:      EBANKING_TOKEN_PREVENCION (set in the "New PL/SQL Object" dialog)
      Trigger Options:  (set in the "New PL/SQL Object" dialog)
******************************************************************************/
BEGIN
   tmpVar := 0;

   SELECT SEQ_TOKEN_PREVENCION_ID.NEXTVAL INTO tmpVar FROM dual;
   :NEW.id := tmpVar;

END trig_id;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_ID_TARJETA
before insert ON EBANKING_TOKEN_TARJETA_AG12 for each row
begin
select EBANKING.SEQUENCE_TOKEN_TARJETA.nextval into :new.ID_TARJETA 
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_IUPIFRECUENT
before insert ON IUPIFRECUENT for each row
begin
select EBANKING.SEQUENCE_IUPIFRECUENT.nextval into :new.ID 
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER trig_sucursal_act_desbl
BEFORE INSERT
ON EBANKING_TOKEN_HIST REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
tmpVar NUMBER;
/******************************************************************************
   NAME:       trig_tiendas_act_desbl
   PURPOSE:    se encarga de eliminar los registros con estaus 1 en la tabla token_prevencion y pasarlos a 0

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        3/1/2007    jlrdgz          1. Created this trigger.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     trig_tiendas_act_desbl
      Sysdate:         3/1/2007
      Date and Time:   3/1/2007, 4:22:04 PM, and 3/1/2007 4:22:04 PM
      Username:         (set in TOAD Options, Proc Templates)
      Table Name:      EBANKING_TOKEN_HIST (set in the "New PL/SQL Object" dialog)
      Trigger Options:  (set in the "New PL/SQL Object" dialog)
******************************************************************************/
BEGIN
   tmpVar := 0;

	   if (:new.ACCION=1  and :new.OPERADOR<>'NETNET') then
	   	 update EBANKING_TOKEN_PREVENCION etp
		 		set etp.ESTATUS=0,  etp.OBSERVACION = 'Actualización por Sucursal'
				where etp.NUM_CLIENTE = :new.NUM_CLIENTE  and etp.NUM_SERIE_TOKEN =:new.NUM_SERIE_TOKEN and etp.ESTATUS=1 and etp.TIPO_OPERACION=0;
   		elsif ( :new.ACCION=3 and :new.OPERADOR<>'NETNET') then
			   	 update EBANKING_TOKEN_PREVENCION etp
				 		set etp.ESTATUS=0,  etp.OBSERVACION = 'Actualización por Sucursal'
						where etp.NUM_CLIENTE = :new.NUM_CLIENTE  and etp.NUM_SERIE_TOKEN =:new.NUM_SERIE_TOKEN and etp.ESTATUS=1 and etp.TIPO_OPERACION=1;
   		end if;



   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END trig_tiendas_act_desbl;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_TOKEN_DISP
before insert ON TOKEN_DISP for each row
begin
select EBANKING.SEQ_TOKEN_DISP.nextval into :new.ID_ACT_DISPOSITIVO 
from dual;
end;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRIG_UPDATE_ESTATUS
AFTER UPDATE
OF ESTATUS
ON EBANKING_TOKEN_PREVENCION REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW

/******************************************************************************
   NAME:       trig_update_estatus
   PURPOSE:

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        2/19/2007             1. Created this trigger.

   NOTES:

   Automatically available Auto Replace Keywords:
      Object Name:     trig_update_estatus
      Sysdate:         2/19/2007
      Date and Time:   2/19/2007, 11:45:07 PM, and 2/19/2007 11:45:07  PM
      Username:         (set in TOAD Options, Proc Templates)
      Table Name:      EBANKING_TOKEN_PREVENCION (set in the "New PL/SQL Object" dialog)
      Trigger Options:  (set in the "New PL/SQL Object" dialog)
******************************************************************************/
BEGIN

   if((:old.SISTEMA = 'NETNET' and :old.IDPAIS = 'MX') or (:old.SISTEMA is null and :old.IDPAIS is null) ) then
      if (:old.ESTATUS=1 and :new.estatus=0) then
   	  update ebanking_user  eu
	     set eu.TELEFONO_OFICINA=:new.TEL_PARTICULAR,
	     eu.CELLULAR=:new.TEL_CELULAR,
		 eu.USER2CELLCOMPANY=:new.CARRIER_CEL,
		 eu.EMAIL=:new.EMAIL
		 where eu.id= :new.NUM_CLIENTE;
   	  else if (:old.ESTATUS=1 and :new.estatus=3) then
		 update ebanking_user  eu2
		 set eu2.TRACKING =2
		 where eu2.id= :new.NUM_CLIENTE;
   	  end if;
      end if;
   end if;

   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END trig_update_estatus;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TRI_TOK_DISP_PC
before insert ON TOKEN_DISP_PC for each row
begin
select EBANKING.SEQ_TOKEN_PC.nextval into :new.ID_ACT_DISPOSITIVO 
from dual;
end;
/
SHOW ERRORS;


ALTER TABLE ACERTUM_USER ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE ACTIVACION_DEX ADD (
  CHECK ("CTEDEX" IS NOT NULL),
  CHECK ("U_ID" IS NOT NULL),
  CHECK ("FECHAACTIVACION" IS NOT NULL),
  CHECK ("ULTIMA_MODIFICACION" IS NOT NULL),
  CHECK ("USUARIO_MODIFICO" IS NOT NULL),
  CONSTRAINT CNT_ADEX_CTEALNOVA
 PRIMARY KEY
 (CTEALNOVA));

ALTER TABLE ACTIVACION_SMS ADD (
  CONSTRAINT EBANKING_ID_PK
 PRIMARY KEY
 (ID_CLIENTE));

ALTER TABLE ACTIVACION_WU ADD (
  CONSTRAINT ACTIVACION_WU_PK
 PRIMARY KEY
 (CU));

ALTER TABLE ACTIVAR_ACRTUM ADD (
  CONSTRAINT PK_TELACRTUM
 PRIMARY KEY
 (TELEFONO));

ALTER TABLE ALERTAS_BAZ ADD (
  CONSTRAINT ALERTAS_BAZ_PK
 PRIMARY KEY
 (ID_ALERTA));

ALTER TABLE ALERTAS_TEST ADD (
  CONSTRAINT ALERTAS_TEST_PK
 PRIMARY KEY
 (ID));

ALTER TABLE ALL_FRECUENTES ADD (
  CONSTRAINT ID_FRECPK
 PRIMARY KEY
 (ID_FRECUENTES));

ALTER TABLE ALNOVA_BRANCH ADD (
  CONSTRAINT PK_ALNOVA_BRANCH
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_CHANNEL ADD (
  CONSTRAINT PK_ALNOVA_CHANNEL
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_STATUS ADD (
  CONSTRAINT PK_ALNOVA_STATUS
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TERMINAL ADD (
  CONSTRAINT PK_ALNOVA_TERMINAL
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TERMINAL_ACERTUM ADD (
  CONSTRAINT PK_ALNOVA_TERMINAL_ACERTUM
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TERM_ES ADD (
  CONSTRAINT PK_AL_TERM_ES
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TERM_SEL ADD (
  CONSTRAINT PK_AL_TERM_SEL_1
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TERM_SEL_RESPALD ADD (
  CONSTRAINT PK_AL_TERM_SEL
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_TRANSACTION ADD (
  CONSTRAINT PK_ALNOVA_TRANSACTION
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_USER ADD (
  CONSTRAINT PK_ALNOVA_USER
 PRIMARY KEY
 (ID));

ALTER TABLE BENEFICIARIOS_WU ADD (
  CONSTRAINT PK_BENEFWU_ID
 PRIMARY KEY
 (ID_BENEFICIARIO_WU));

ALTER TABLE BENEFICIARIOWU ADD (
  CONSTRAINT PK_BENEFWU_ID2
 PRIMARY KEY
 (ID_BENEFICIARIO_WU));

ALTER TABLE BENEFI_DEX ADD (
  CONSTRAINT PK_BDEX_ID
 PRIMARY KEY
 (ID_BENEFICIARIO_DEX));

ALTER TABLE BENEFI_WU ADD (
  CONSTRAINT PK_BWU_ID
 PRIMARY KEY
 (ID_BENEFICIARIO_WU));

ALTER TABLE BIT_CAN_FA ADD (
  CONSTRAINT BIT_CAN_FA_PK
 PRIMARY KEY
 (ID_FA));

ALTER TABLE BIT_CAN_FA_EBK ADD (
  CONSTRAINT BIT_CAN_FA_EBK_PK
 PRIMARY KEY
 (ID_FA));

ALTER TABLE BIT_MEX_TRANS ADD (
  CONSTRAINT BIT_MEX_TRANS_PK
 PRIMARY KEY
 (ID_TRANSACCION));

ALTER TABLE BIT_REF_FAM ADD (
  CONSTRAINT BIT_REF_FAM_PK
 PRIMARY KEY
 (ID_DISPOSITIVO));

ALTER TABLE BIT_REF_TOKEN ADD (
  CONSTRAINT BIT_REF_TOKEN_PK
 PRIMARY KEY
 (ID_DIS));

ALTER TABLE CALLCENTERLOG ADD (
  PRIMARY KEY
 (CONSECUTIVO));

ALTER TABLE CARRIER ADD (
  CONSTRAINT PK_CARRIER
 PRIMARY KEY
 (CARRIER_ID));

ALTER TABLE COMPRAMAX_ESTATUS ADD (
  PRIMARY KEY
 (IDESTATUS));

ALTER TABLE CONFIR ADD (
  CONSTRAINT PK_DESTINOS_TEF_SPEI_TERCEROS
 PRIMARY KEY
 (ID));

ALTER TABLE CORE_EJBS ADD (
  CONSTRAINT XPKRMA_EJBS
 PRIMARY KEY
 (IDEJB));

ALTER TABLE CORE_MACS ADD (
  PRIMARY KEY
 (MAC, NOMBRE_APLICACION));

ALTER TABLE CORE_METODS ADD (
  CONSTRAINT XPKRMA_METODOS
 PRIMARY KEY
 (IDMETODO));

ALTER TABLE CORE_ROL ADD (
  CONSTRAINT XPKRMA_ROL
 PRIMARY KEY
 (IDROL));

ALTER TABLE CORE_ROL_METODS ADD (
  CONSTRAINT XPKRMA_ROL_METODOS
 PRIMARY KEY
 (IDROL_METODO));

ALTER TABLE CREDITOSOTROSBANCOSFRECUENT ADD (
  CONSTRAINT PK_CREDITOSOTROSBANCOSFRECUENT
 PRIMARY KEY
 (BENEFICIARIO, CLIENTE, BANCO, CUENTACREDITO));

ALTER TABLE CTAS_OCULTAS ADD (
  CONSTRAINT CPK_ID_CONSECUTIVO
 PRIMARY KEY
 (ID_CONSECUTIVO));

ALTER TABLE CT_COUNTRY ADD (
  CONSTRAINT PK_CT_COUNTRY
 PRIMARY KEY
 (FI_COUNTRY_ID));

ALTER TABLE CT_HOV_LETTER ADD (
  CONSTRAINT PKCT_HOV_LETTER
 PRIMARY KEY
 (FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID));

ALTER TABLE CT_NOTIFICATION_TYPE ADD (
  CONSTRAINT PK_CT_NOTIFICATION_TYPE
 PRIMARY KEY
 (FI_NOTIFICATION_TYPE_ID));

ALTER TABLE CT_STATE ADD (
  CONSTRAINT PK_CT_STATE
 PRIMARY KEY
 (FI_STATE_ID));

ALTER TABLE DATOS_GOBIERNOS_PDF ADD (
  PRIMARY KEY
 (LINEA_CAPTURA, NUM_AUTORIZACION));

ALTER TABLE DATOS_IMSS_PDF ADD (
  CHECK (OPCION IN(1,2)),
  PRIMARY KEY
 (LINEA_CAPTURA, NUM_AUTORIZACION));

ALTER TABLE DATOS_SERVICIO_PDF ADD (
  PRIMARY KEY
 (REFERENCIA, NUMERO_OPERACION));

ALTER TABLE DEXCLIENTE ADD (
  CONSTRAINT PK_CLIENTE_ALNOVA
 PRIMARY KEY
 (CLIENTE_ALNOVA, CLIENTE_ID));

ALTER TABLE DEXIMPUESTO ADD (
  CONSTRAINT PK_IMPUESTO
 PRIMARY KEY
 (ID));

ALTER TABLE DEXTRANSFERENCIA ADD (
  CONSTRAINT PK_DEXTRANSFERENCIA
 PRIMARY KEY
 (MTCN));

ALTER TABLE EBANKINGPAN_USER ADD (
  CONSTRAINT PK_EBANKINGPAN_USER
 PRIMARY KEY
 (NSS));

ALTER TABLE EBANKING_ACTECONOMICA ADD (
  CONSTRAINT PK_ACTECONOMICA
 PRIMARY KEY
 (ID_PROFESION, ID));

ALTER TABLE EBANKING_ACTGIRO ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_ACTIVATION ADD (
  CHECK ("IP" IS NOT NULL),
  CONSTRAINT PK_EBANKING_ACTIVATION
 PRIMARY KEY
 (CLIENTE, CUENTAOTARJ));

ALTER TABLE EBANKING_ACTIVATION_FAILURE ADD (
  PRIMARY KEY
 (USER_ID));

ALTER TABLE EBANKING_ACTIVATION_FAILURE_H ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_ACTIVATION_H ADD (
  CONSTRAINT PK_EBANKING_ACTIVATION_H
 PRIMARY KEY
 (FOLIO));

ALTER TABLE EBANKING_ADYACENCIA ADD (
  PRIMARY KEY
 (ADYACENCIA));

ALTER TABLE EBANKING_BAJASLDAP ADD (
  CONSTRAINT PK_EBANKING_BAJASLDAP
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_BANKS ADD (
  CONSTRAINT PK_EBANKING_BANKS
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_BINES ADD (
  PRIMARY KEY
 (PREFIJO));

ALTER TABLE EBANKING_BITACORA_TRAN ADD (
  CONSTRAINT PK_EBANKING_BITACORA_TRAN
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CAMBIO_PWD ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CAT_OPERACION ADD (
  CONSTRAINT PK_EBANKING_CAT_OPERACION
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CELLCOMPANY ADD (
  CONSTRAINT PK_EBANKING_CELLCOMPANY
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CLIP ADD (
  CONSTRAINT PK_EBANKING_CLIP
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CLIP_EEC_OTRONOMBRE ADD (
  CONSTRAINT EBANKING_CLIP_EEC_PK
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_CONTROL_HILOS ADD (
  CONSTRAINT PK_EBANKING_CONTROL_HILOS
 PRIMARY KEY
 (NOMBRE));

ALTER TABLE EBANKING_DICCIONARIO ADD (
  PRIMARY KEY
 (PALABRA, IDIOMA));

ALTER TABLE EBANKING_EDOCIVIL ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_EMPRESAS ADD (
  CONSTRAINT PK_EBANKING_EMPRESAS
 PRIMARY KEY
 (EMPRESA_ID));

ALTER TABLE EBANKING_ESTADOS ADD (
  CONSTRAINT PK_EBANKING_ESTADOS
 PRIMARY KEY
 (ESTADO_ID));

ALTER TABLE EBANKING_HISTORICO_PAGOPEDIDOS ADD (
  CONSTRAINT PK_HISTORICO_PAGO_PEDIDOS
 PRIMARY KEY
 (IDPEDIDO, IDRETENCION));

ALTER TABLE EBANKING_ICEL ADD (
  PRIMARY KEY
 (FOLIO));

ALTER TABLE EBANKING_IDENTIFICACION ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_IMPUESTOS_GDF ADD (
  CONSTRAINT PK_EBANKING_IMPUESTO_GDF
 PRIMARY KEY
 (LINEA_PAGO));

ALTER TABLE EBANKING_LOGIN ADD (
  PRIMARY KEY
 (USER_ID));

ALTER TABLE EBANKING_LOGIN_HIST ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_LOGIN_HISTORY ADD (
  PRIMARY KEY
 (USER_ID, LOGIN_DATE));

ALTER TABLE EBANKING_LOGIN_TA_HIS ADD (
  CONSTRAINT PK_EBANKING_LOGIN_TA_HIS
 PRIMARY KEY
 (ID, NUM_TARJETA));

ALTER TABLE EBANKING_MUNICIPIOS ADD (
  CONSTRAINT PK_EBANKING_MUNICIPIOS
 PRIMARY KEY
 (CITY_CODE));

ALTER TABLE EBANKING_NACIONALIDAD ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_NIVELESSEGURIDAD ADD (
  CONSTRAINT PK_EBANKING_NIVELESSEGURIDAD
 PRIMARY KEY
 (IDUSER));

ALTER TABLE EBANKING_OPERACIONES ADD (
  CONSTRAINT PK_EBANKING_OPERACIONES
 PRIMARY KEY
 (CLIENTE, SEMANA, ANIO));

ALTER TABLE EBANKING_PAGO_TAZ ADD (
  CONSTRAINT PK_EBANKING_PAGO_TAZ
 PRIMARY KEY
 (NUM_CLIENTE, FECHA_PAGO, NUM_TAZ));

ALTER TABLE EBANKING_PARAMETROS ADD (
  CONSTRAINT PK_PARAMETROS
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_RECORDATORIOS ADD (
  CONSTRAINT PK_EBANKING_RECORDATORIOS
 PRIMARY KEY
 (ID, CLIENTE));

ALTER TABLE EBANKING_RFC ADD (
  CONSTRAINT PK_EBANKING_RFC
 PRIMARY KEY
 (ID_EBANKING_RFC));

ALTER TABLE EBANKING_RMASMS ADD (
  CHECK (STATUS IN('A','C')),
  CONSTRAINT PK_RMASMS
 PRIMARY KEY
 (SMSKEY));

ALTER TABLE EBANKING_SERVICE ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_SPEI_ALNOVA ADD (
  CONSTRAINT PK_BCALNOVA_CODBANC
 PRIMARY KEY
 (CODBANC));

ALTER TABLE EBANKING_SUCURSALES ADD (
  CONSTRAINT PK_EBANKING_SUCURSALES
 PRIMARY KEY
 (SUCURSAL));

ALTER TABLE EBANKING_TARJETASNIP ADD (
  CONSTRAINT PK_EBANKING_TARJETASNIP
 PRIMARY KEY
 (CUENTA));

ALTER TABLE EBANKING_TASAS_IA ADD (
  CONSTRAINT PK_SUBPRODUCTO
 PRIMARY KEY
 (SUBPRODUCTO));

ALTER TABLE EBANKING_TEF_ALNOVA ADD (
  CONSTRAINT PK_BCALNOVA_ID
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_TOKEN_COBRO ADD (
  CONSTRAINT PK
 PRIMARY KEY
 (NO_CTE, NO_SERIE_TOKEN));

ALTER TABLE EBANKING_TOKEN_PREVENCION ADD (
  CONSTRAINT IDX_TOKEN_PREV_ID
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_TOKEN_TARJETA_AG12 ADD (
  CONSTRAINT IDX_TOKEN_TARJ_ID
 PRIMARY KEY
 (ID_TARJETA));

ALTER TABLE EBANKING_TX_PLACES ADD (
  CONSTRAINT PK_EBANKING_TX_PLACES
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_TX_STATES ADD (
  CONSTRAINT PK_EBANKING_TX_STATES
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USER ADD (
  CHECK ("ACTIVATION" IS NOT NULL),
  CONSTRAINT EBANKING_USER_PK
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USERX ADD (
  CHECK ("ID" IS NOT NULL),
  CHECK ("ACTIVATION" IS NOT NULL),
  CHECK ("ACTIVE" IS NOT NULL),
  CHECK ("ANSWER" IS NOT NULL),
  CHECK ("QUESTION" IS NOT NULL),
  CHECK ("USER2CELLCOMPANY" IS NOT NULL),
  CHECK ("ID" IS NULL),
  CHECK ("ACTIVATION" IS NOT NULL),
  CHECK ("ACTIVE" IS NOT NULL),
  CHECK ("ANSWER" IS NOT NULL),
  CHECK ("QUESTION" IS NOT NULL),
  CHECK ("USER2CELLCOMPANY" IS NOT NULL));

ALTER TABLE EBANKING_USER_ACTIVATION ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USER_CERT_VIP ADD (
  CONSTRAINT EBANKING_USER_CERT_VIP_PK
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USER_SESSION ADD (
  PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USER_STATUS ADD (
  CONSTRAINT EBANKING_USER_STATUS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE EBANKING_USER_TRACKING ADD (
  CONSTRAINT PK_EBANKING_USER_TRACKING
 PRIMARY KEY
 (NUMERO_CLIENTE, FECHA));

ALTER TABLE EDCULTURALES ADD (
  PRIMARY KEY
 (USER_ID, REFERENCIA));

ALTER TABLE EDITORIALES ADD (
  PRIMARY KEY
 (CODIGO));

ALTER TABLE EJB_CORE ADD (
  PRIMARY KEY
 (EJB));

ALTER TABLE ENCUESTA_DESPACHO ADD (
  CONSTRAINT PK_ENCUESTA_DESPACHO
 PRIMARY KEY
 (ID_ENCUESTA));

ALTER TABLE ENCUESTA_EMPLEADO ADD (
  CONSTRAINT PK_ENCUESTA_EMPLEADO
 PRIMARY KEY
 (ID_ENCUESTA, NUM_EMPLEADO));

ALTER TABLE ENCUESTA_PBAZ ADD (
  CONSTRAINT IDX_ID_ENCUESTA
 PRIMARY KEY
 (ID_ENCUESTA));

ALTER TABLE FBLIKE ADD (
  CONSTRAINT FBLIKE_PK
 PRIMARY KEY
 (ID_ALNOVA, EMPRESA));

ALTER TABLE FIAR_BOLETOS ADD (
  CONSTRAINT CPK_FIAR_BOLETOS
 PRIMARY KEY
 (ID_PARTICIPANTE, ID_SORTEO));

ALTER TABLE FIAR_CANDIDATOS ADD (
  CONSTRAINT CPK_FIAR_CANDIDATOS
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_CLIENTES ADD (
  CONSTRAINT CPK_FIAR_CLIENTES
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_CLIENTES_RESP ADD (
  CONSTRAINT CPK_FIAR_CLIENTES_RESP
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_CONTRATOS ADD (
  CONSTRAINT CPK_FIAR_CONTRATOS
 PRIMARY KEY
 (CTE_ALNOVA, IDCONTRATO));

ALTER TABLE FIAR_DATOS_SOLICITUD ADD (
  CONSTRAINT CPK_FIAR_DATOS_SOLICITUD
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_PREGUNTAS ADD (
  CONSTRAINT FIAR_PREGUNTAS_PK
 PRIMARY KEY
 (ID_PREGUNTA));

ALTER TABLE FIAR_PREMIO ADD (
  CONSTRAINT CPK_FIAR_PREMIO
 PRIMARY KEY
 (ID_SORTEO, ID_PREMIO));

ALTER TABLE FIAR_REGISTRO ADD (
  CONSTRAINT PKFRREG_IDREG
 PRIMARY KEY
 (ID_REGISTRO));

ALTER TABLE FIAR_RESPUESTAS ADD (
  CONSTRAINT CPK_FIAR_RESPUESTAS
 PRIMARY KEY
 (ID_RESPUESTA, ID_PREGUNTA));

ALTER TABLE FIAR_SORTEO ADD (
  CONSTRAINT CPK_FIAR_SORTEO
 PRIMARY KEY
 (ID_SORTEO));

ALTER TABLE FIAR_STATUS_CLIENTES ADD (
  CONSTRAINT CPK_FIAR_STATUS_CLIENTES
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_STATUS_CLIENTES_RESP ADD (
  CONSTRAINT CPK_FIAR_STATUS_CLIENTES_RESP
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE FIAR_TRACE ADD (
  CONSTRAINT CPK_FIAR_TRACE
 PRIMARY KEY
 (ID));

ALTER TABLE FIAR_USR_ADMON ADD (
  CONSTRAINT CPK_FIAR_USR_ADMON
 PRIMARY KEY
 (ID_USUARIO));

ALTER TABLE FIRMA_EMISORES ADD (
  CONSTRAINT FIRMA_EMISORES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE FOLIOCMP ADD (
  CONSTRAINT PK_FOLIOCMP
 PRIMARY KEY
 (CONSECUTIVO));

ALTER TABLE FRECUENTES_SPEI ADD (
  CONSTRAINT PK_FRECUENTES_SPEI
 PRIMARY KEY
 (ID));

ALTER TABLE HISTORICO_TEF_SPEI_TERCEROS ADD (
  CONSTRAINT PK_HISTORICO_TEF_SPEI_TERCEROS
 PRIMARY KEY
 (ID));

ALTER TABLE HISTORICO_TEF_SPEI_TERCEROS_AX ADD (
  CONSTRAINT PK_ID_HTST
 PRIMARY KEY
 (ID));

ALTER TABLE HIST_CUENTA_SMS ADD (
  CONSTRAINT EBANKING_IDHIST_PK
 PRIMARY KEY
 (ID));

ALTER TABLE INTERESADOS ADD (
  CONSTRAINT PK_INTERESADOS
 PRIMARY KEY
 (ID, IDALBUM));

ALTER TABLE INTERFACTURA_SERVICIO ADD (
  CONSTRAINT PK_INTERFACTURA_SERVICIO
 PRIMARY KEY
 (ID));

ALTER TABLE INVERSION_AZTECA ADD (
  PRIMARY KEY
 (SUBPRODUCTO));

ALTER TABLE IP_CORE ADD (
  PRIMARY KEY
 (IP, NOMBRE_APLICACION));

ALTER TABLE IUPIFRECUENT ADD (
  CONSTRAINT PK_IUPIFRECUENT
 PRIMARY KEY
 (ID));

ALTER TABLE IUSACELL ADD (
  PRIMARY KEY
 (USER_ID, CUENTA));

ALTER TABLE LUZYFUERZA ADD (
  PRIMARY KEY
 (USER_ID, REFERENCIA));

ALTER TABLE MD_ADDITIONAL_PROPERTIES ADD (
  CONSTRAINT MD_ADDITIONAL_PROPERTIES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_APPLICATIONFILES ADD (
  CONSTRAINT MD_APPLICATIONFILES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_APPLICATIONS ADD (
  CONSTRAINT MD_APPLICATIONS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_CATALOGS ADD (
  CONSTRAINT MD_CATALOGS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_COLUMNS ADD (
  CONSTRAINT MD_COLUMNS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_CONNECTIONS ADD (
  CONSTRAINT MD_CONNECTIONS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_CONSTRAINTS ADD (
  CONSTRAINT MD_CONSTRAINTS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_CONSTRAINT_DETAILS ADD (
  CONSTRAINT MD_CONSTRAINT_DETAILS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_DERIVATIVES ADD (
  CONSTRAINT MIGRDREIVATIVES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_FILE_ARTIFACTS ADD (
  CONSTRAINT MD_FILE_ARTIFACTS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_GROUPS ADD (
  CONSTRAINT MD_GROUPS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_GROUP_MEMBERS ADD (
  CONSTRAINT MD_GROUP_MEMBERS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_GROUP_PRIVILEGES ADD (
  CONSTRAINT MD_GROUP_PRIVILEGES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_INDEXES ADD (
  CONSTRAINT MD_INDEXES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_INDEX_DETAILS ADD (
  CONSTRAINT MD_INDEX_DETAILS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_MIGR_DEPENDENCY ADD (
  CONSTRAINT MIGR_DEPENDENCY_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_MIGR_PARAMETER ADD (
  CONSTRAINT MIGR_PARAMETER_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_MIGR_WEAKDEP ADD (
  CONSTRAINT MIGR_WEAKDEP_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_OTHER_OBJECTS ADD (
  CONSTRAINT MD_OTHER_OBJECTS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_PACKAGES ADD (
  CONSTRAINT MD_PACKAGES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_PARTITIONS ADD (
  CONSTRAINT MD_PARTITIONS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_PRIVILEGES ADD (
  CONSTRAINT MD_PRIVILEGES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_PROJECTS ADD (
  CONSTRAINT MD_PROJECTS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_REGISTRY ADD (
  CONSTRAINT MD_REGISTRY_PK
 PRIMARY KEY
 (OBJECT_TYPE, OBJECT_NAME));

ALTER TABLE MD_SCHEMAS ADD (
  CONSTRAINT MD_SCHEMAS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_SEQUENCES ADD (
  CONSTRAINT MD_SEQUENCES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_STORED_PROGRAMS ADD (
  CONSTRAINT MD_STORED_PROGRAMS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_SYNONYMS ADD (
  CONSTRAINT MD_SYNONYMS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_TABLES ADD (
  CONSTRAINT MD_TABLES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_TABLESPACES ADD (
  CONSTRAINT MD_TABLESPACES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_TRIGGERS ADD (
  CONSTRAINT MD_TRIGGERS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_USERS ADD (
  CONSTRAINT MD_USERS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_USER_DEFINED_DATA_TYPES ADD (
  CONSTRAINT MD_USER_DEFINED_DATA_TYPES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_USER_PRIVILEGES ADD (
  CONSTRAINT MD_USER_PRIVILEGES_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MD_VIEWS ADD (
  CONSTRAINT MD_VIEWS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MENSAJE ADD (
  CONSTRAINT PK_MENSAJE_ID
 PRIMARY KEY
 (MENSAJE_ID));

ALTER TABLE METODOS_CORE ADD (
  CONSTRAINT XPKMETODOS_CORE
 PRIMARY KEY
 (METODO));

ALTER TABLE MIGRLOG ADD (
  CONSTRAINT MIGRLOG_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MIGR_DATATYPE_TRANSFORM_MAP ADD (
  CONSTRAINT MIGR_DATATYPE_TRANSFORM_M_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MIGR_DATATYPE_TRANSFORM_RULE ADD (
  CONSTRAINT MIGR_DATATYPE_TRANSFORM_R_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MIGR_GENERATION_ORDER ADD (
  CONSTRAINT MIGR_GENERATION_ORDER_PK
 PRIMARY KEY
 (ID));

ALTER TABLE MODAL_APP_ALNOVA ADD (
  CONSTRAINT MODAL_APP_ALNOVA_PK
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE MONTOS_USER ADD (
  CONSTRAINT PK_MONTOS_USER
 PRIMARY KEY
 (ID_MONTO_USER));

ALTER TABLE MOVIMIENTOS ADD (
  CHECK ("IMPORTE" IS NOT NULL) DISABLE,
  CHECK ("OPERACION" IS NOT NULL) DISABLE,
  CHECK ("MOVIMIENTO" IS NOT NULL) DISABLE,
  CHECK ("FECHA" IS NOT NULL) DISABLE);

ALTER TABLE MOVISTAR ADD (
  PRIMARY KEY
 (USER_ID, REFERENCIA));

ALTER TABLE M_TRACKING ADD (
  CONSTRAINT XPKM_IDTRACKING
 PRIMARY KEY
 (IDTRACKING));

ALTER TABLE M_TRACKING_DETALLE ADD (
  CONSTRAINT XPKM_ID_TRACKING_DETALLE
 PRIMARY KEY
 (ID_TRACKING_DETALLE));

ALTER TABLE M_USUARIOS ADD (
  CONSTRAINT XPKM_USUARIOS
 PRIMARY KEY
 (IDUSUARIO));

ALTER TABLE M_USUARIOS_OPERACIONES ADD (
  CONSTRAINT XPKM_USUARIOS_OPERACIONES
 PRIMARY KEY
 (ID_USUARIO_OPERACION));

ALTER TABLE OPERACIONES_FREC ADD (
  CONSTRAINT OPERACIONES_FRECUENTES_PK
 PRIMARY KEY
 (ID_OPERACION));

ALTER TABLE OPE_PROGRAMADAS ADD (
  CONSTRAINT TRANSF_PROGRAMADAS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE OTROS_SERVICIOS ADD (
  PRIMARY KEY
 (ID_OTRO_SERVICIO));

ALTER TABLE PAGO_MOVIL_ACT ADD (
  CONSTRAINT CNTPAGMOV_ID
 PRIMARY KEY
 (ID_ACT_PAGMOV));

ALTER TABLE PAGO_MOVIL_MAXD ADD (
  CONSTRAINT PK_MAXD_PM
 PRIMARY KEY
 (CTEALNOVA));

ALTER TABLE PHOTOS ADD (
  CONSTRAINT PKPHOTOS
 PRIMARY KEY
 (ID, IDALBUM));

ALTER TABLE PORTAFOLIO ADD (
  CONSTRAINT PORTAFOLIO_PK
 PRIMARY KEY
 (ID));

ALTER TABLE POSTIT ADD (
  CONSTRAINT PK_POSTIT
 PRIMARY KEY
 (ID, IDALBUM, IDFOTO));

ALTER TABLE PREACTIVE_USER ADD (
  CONSTRAINT PREACT_ID_PK
 PRIMARY KEY
 (ID_ALNOVA));

ALTER TABLE PROVEEDOR_URL ADD (
  CONSTRAINT PROVEEDOR_URL_PK11079987718530
 PRIMARY KEY
 (URL));

ALTER TABLE RECORDATORIOS_AGENDA ADD (
  CONSTRAINT PK_RECORDATORIOS_AGENDA
 PRIMARY KEY
 (ID));

ALTER TABLE RECORDATORIOS_EVENTOS ADD (
  CONSTRAINT PK_RECORDATORIOS_EVENTOS
 PRIMARY KEY
 (ID, ID_RECORDATORIO));

ALTER TABLE REPO_CLIENTES ADD (
  CONSTRAINT CPK_CLIENTES
 PRIMARY KEY
 (ID_ALNOVA));

ALTER TABLE REPO_REG_OPERAC ADD (
  CONSTRAINT CPK_REPO_REG_OPERAC
 PRIMARY KEY
 (FOLIO_ALNOVA, FOLIO_TAS, FOLIO_EBANKING));

ALTER TABLE REPO_TASA_PLAZO ADD (
  CONSTRAINT CPK_REPO_TASA_PLAZO
 PRIMARY KEY
 (ID_TASA_PLAZO));

ALTER TABLE RMA_NOTIFICA ADD (
  CONSTRAINT RMA_NOTIFICA_PK
 PRIMARY KEY
 (CTE_ALNOVA));

ALTER TABLE ROL_CORE ADD (
  CONSTRAINT XPKROL_CORE
 PRIMARY KEY
 (ROL));

ALTER TABLE ROL_METODO_CORE ADD (
  CONSTRAINT XPKROL_METODO_CORE
 PRIMARY KEY
 (IDROL_METODO));

ALTER TABLE SCHEDULED_EMAIL ADD (
  PRIMARY KEY
 (SCHEDULED_EMAIL_ID));

ALTER TABLE SCHEDULED_PAYMENT ADD (
  PRIMARY KEY
 (SCHEDULED_PAYMENT_ID));

ALTER TABLE SEGURIDAD_ACCESO ADD (
  CONSTRAINT PK_SEGURIDAD_ACCESO
 PRIMARY KEY
 (ID));

ALTER TABLE SEGUROS ADD (
  PRIMARY KEY
 (USER_ID, TIPO_SEG, POLIZA, NUM_OPERACION));

ALTER TABLE SERVICIOS ADD (
  PRIMARY KEY
 (ID_SERVICIO));

ALTER TABLE SERVICIOS_LOG ADD (
  CONSTRAINT PK_KEY
 PRIMARY KEY
 (NUM_OPERACION));

ALTER TABLE SOLICITUDCREDITO ADD (
  PRIMARY KEY
 (FOLIO));

ALTER TABLE SPEI_PROG_30_MIN ADD (
  CONSTRAINT SPEI_FREC_30_PK
 PRIMARY KEY
 (ID));

ALTER TABLE STAGE_MIGRLOG ADD (
  CONSTRAINT STAGE_MIGRLOG_PK
 PRIMARY KEY
 (ID));

ALTER TABLE TABLATEST ADD (
  PRIMARY KEY
 (CAMPO1));

ALTER TABLE TABLAX ADD (
  CONSTRAINT PK_TABLAX
 PRIMARY KEY
 (CLOMUN1));

ALTER TABLE TACONFIRMACION_WU ADD (
  CONSTRAINT TACONFIRMACION_WU_PK
 PRIMARY KEY
 (ID));

ALTER TABLE TAOPPROG30MIN ADD (
  CONSTRAINT PKTPROG30MIN
 PRIMARY KEY
 (FIID));

ALTER TABLE TASAS ADD (
  CONSTRAINT PK_TASAS
 PRIMARY KEY
 (ID));

ALTER TABLE TASPEICELULAR ADD (
  CONSTRAINT PK_TASPEICELULAR
 PRIMARY KEY
 (FIID));

ALTER TABLE TATOP15_PS ADD (
  CONSTRAINT IDX_TATOP15_PS
 PRIMARY KEY
 (FNEMISORID, FNSUCRSALID));

ALTER TABLE TA_ACERTUM_USER ADD (
  PRIMARY KEY
 (USER_ID));

ALTER TABLE TA_BENEFAFILIA ADD (
  CONSTRAINT CPK_IDBENEFAF
 PRIMARY KEY
 (IDBENEFICIARIO));

ALTER TABLE TA_BENEFICIARIO ADD (
  CONSTRAINT CPK_IDBENEF
 PRIMARY KEY
 (IDBENEFICIARIO));

ALTER TABLE TA_CATALOGOS ADD (
  CONSTRAINT CPK_IDCATALOGO
 PRIMARY KEY
 (IDCATALOGO));

ALTER TABLE TA_CLIENTE ADD (
  CONSTRAINT CPK_IDCLIENTE
 PRIMARY KEY
 (IDCLIENTE));

ALTER TABLE TA_CONTENIDOCAT ADD (
  CONSTRAINT CPK_IDCONTENIDO
 PRIMARY KEY
 (IDCONTENIDO));

ALTER TABLE TA_DIRBENEF ADD (
  CONSTRAINT CPK_IDDIRBENEF
 PRIMARY KEY
 (IDDIRBENEF));

ALTER TABLE TA_DIRECCION ADD (
  CONSTRAINT CPK_IDDIRECCION
 PRIMARY KEY
 (IDDIRECCION));

ALTER TABLE TA_DIRECCIONAFI ADD (
  CONSTRAINT CPK_IDDIRECAFI
 PRIMARY KEY
 (IDDIRECCION));

ALTER TABLE TA_DOCUMENTOS ADD (
  CONSTRAINT CPK_IDDOCUMENTO
 PRIMARY KEY
 (IDDOCUMENTO));

ALTER TABLE TA_FISCAL ADD (
  CONSTRAINT CPK_IDFISCAL
 PRIMARY KEY
 (IDFISCAL));

ALTER TABLE TA_HOV_LETTER ADD (
  CONSTRAINT PKTA_HOV_LETTER
 PRIMARY KEY
 (FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID, FI_LETTER_ID));

ALTER TABLE TA_INFOECOYFIN ADD (
  CONSTRAINT CPK_IDINFOEYF
 PRIMARY KEY
 (IDINFOECOYFIN));

ALTER TABLE TA_NEGOCIO ADD (
  CONSTRAINT CPK_IDNEGOCIO
 PRIMARY KEY
 (IDNEGOCIO));

ALTER TABLE TA_PERSONAPEXP ADD (
  CONSTRAINT CPK_IDPERSONAPE
 PRIMARY KEY
 (IDPERSONAPOLITEXP));

ALTER TABLE TA_PRODUCT_LETTER ADD (
  CONSTRAINT PKTA_PRODUCT_LETTER
 PRIMARY KEY
 (FI_PRODUCT_LETTER_ID, FI_STATE_ID));

ALTER TABLE TA_TITULAR ADD (
  CONSTRAINT CPK_IDTITULAR
 PRIMARY KEY
 (IDTITULAR));

ALTER TABLE TA_USOCUENTA ADD (
  CONSTRAINT CPK_IDUSOCUENTA
 PRIMARY KEY
 (IDUSOCUENTA));

ALTER TABLE TA_USUARIO ADD (
  CONSTRAINT CPK_IDUSUARIO
 PRIMARY KEY
 (IDUSUARIO));

ALTER TABLE TA_WU_CONFIRMACION ADD (
  CONSTRAINT PK_ID
 PRIMARY KEY
 (IDENVIO));

ALTER TABLE TA_WU_CONFIRMACION1 ADD (
  CONSTRAINT PK_ID1
 PRIMARY KEY
 (ID));

ALTER TABLE TDCFRECUENT ADD (
  PRIMARY KEY
 (DESTINO, CLIENT));

ALTER TABLE TEFSPEUAFRECUENT ADD (
  CONSTRAINT PK_TEFSPEUAFRECUENT
 PRIMARY KEY
 (STATE, PLAZA, DESTINO, CLIENT, BANK));

ALTER TABLE TELEFONO ADD (
  CONSTRAINT PK_TELEFONO
 PRIMARY KEY
 (TELEFONO_ID, CLIENTE_ID));

ALTER TABLE TELMEX ADD (
  PRIMARY KEY
 (USER_ID, TELEFONO));

ALTER TABLE TERCEROSFRECUENT ADD (
  CONSTRAINT PK_TERCEROSFRECUENT
 PRIMARY KEY
 (CLIENT, DESTINO));

ALTER TABLE TESTCURSO ADD (
  CONSTRAINT TESTCURSO_PK
 PRIMARY KEY
 (ID));

ALTER TABLE TEST_RMASMS ADD (
  CHECK (STATUS IN('Y','N')),
  CONSTRAINT TEST_RMASMS
 PRIMARY KEY
 (SMSKEY));

ALTER TABLE TEST_SPECIAL_CHARACTERS ADD (
  CONSTRAINT TEST_SPECIAL_CHARACTERS_PK
 PRIMARY KEY
 (ID));

ALTER TABLE TEST_USUARIO ADD (
  PRIMARY KEY
 (USERNAME));

ALTER TABLE TIEMPOAIRE_APLICACION ADD (
  CONSTRAINT PK_TIEMPOAIRE_APLICACION
 PRIMARY KEY
 (NOMBRE));

ALTER TABLE TIEMPOAIRE_STATUS ADD (
  CONSTRAINT PK_TIEMPOAIRE_STATUS
 PRIMARY KEY
 (STATUS));

ALTER TABLE TIEMPOAIRE_TYPE ADD (
  CONSTRAINT PK_TIEMPOAIRE_TYPE
 PRIMARY KEY
 (TYPE));

ALTER TABLE TIEMPO_AIRE_LOG ADD (
  CONSTRAINT PRIMARY_KEY
 PRIMARY KEY
 (CARRIER, ABONO_SOCK));

ALTER TABLE TIPO_TRANSFERENCIAS ADD (
  CONSTRAINT PK_TRANSFERENCIAS
 PRIMARY KEY
 (ID));

ALTER TABLE TIP_BENEFI_DEX ADD (
  CONSTRAINT TIP_BENEFI_DEX_PK
 PRIMARY KEY
 (ID_TIPO));

ALTER TABLE TMP_HUELLA_MONTOS ADD (
  CONSTRAINT PK_TMP_HUELLA_MONTOS
 PRIMARY KEY
 (CLIENTE));

ALTER TABLE TOKEN_DISP ADD (
  CONSTRAINT IDX_DISP_ID
 PRIMARY KEY
 (ID_ACT_DISPOSITIVO));

ALTER TABLE TOKEN_DISP_PC ADD (
  CONSTRAINT IDX_DISP_ID_PC
 PRIMARY KEY
 (ID_ACT_DISPOSITIVO));

ALTER TABLE TOKEN_ENV_SMS ADD (
  CONSTRAINT TOKEN_ENV_SMS_PK
 PRIMARY KEY
 (ID_SMS));

ALTER TABLE TOKEN_HIST ADD (
  CONSTRAINT TOKEN_HIST_PK
 PRIMARY KEY
 (ID_ALNOVA, TOKEN));

ALTER TABLE TOKEN_HIST_PC ADD (
  CONSTRAINT TOKEN_HIST_PC_PK
 PRIMARY KEY
 (ID_ALNOVA, TOKEN));

ALTER TABLE TRANSCOPE_BITA ADD (
  CONSTRAINT TBA_PK
 PRIMARY KEY
 (CUENTA));

ALTER TABLE TRANSFER_DEX ADD (
  CONSTRAINT PK_TRANSFE_DEX
 PRIMARY KEY
 (MTCN));

ALTER TABLE TRANSFER_DEX2 ADD (
  CONSTRAINT PK_TRANSFE_DEX2
 PRIMARY KEY
 (MTCN));

ALTER TABLE TRANSFER_WU ADD (
  CONSTRAINT TRANSFER_WU_PK
 PRIMARY KEY
 (MTCN));

ALTER TABLE TRANSFINTERNALFRECUENT ADD (
  CONSTRAINT PK_TRANSFINTERNALFRECUENT
 PRIMARY KEY
 (CLIENT, DESTINO, CLAVE_SWIFT));

ALTER TABLE TRANS_CAT_ESTADOS ADD (
  CONSTRAINT TRANS_CAT_ESTADOS_PK
 PRIMARY KEY
 (IDESTADO));

ALTER TABLE TRANS_HISTORIAL_PROCESO ADD (
  CONSTRAINT TABLE1_PK
 PRIMARY KEY
 (ID_HIST_PROCESO));

ALTER TABLE TRANS_PROGRAMADAS ADD (
  CONSTRAINT TRANS_PROGRAMADAS_PK
 PRIMARY KEY
 (ID_TRANS_PROG));

ALTER TABLE TRANS_PROGRAMADAS_ADICIONALES ADD (
  CONSTRAINT TRANS_PROGRAMADAS_EXTRAS_PK
 PRIMARY KEY
 (ID_ADICIONALES));

ALTER TABLE TRANS_PROG_BITACORA ADD (
  CONSTRAINT TRANS_PROG_BITACORA_PK
 PRIMARY KEY
 (ID_BITACORA, ID_TRANS_PROG));

ALTER TABLE USUARIO ADD (
  CONSTRAINT PK_ID_USUARIO
 PRIMARY KEY
 (ID_USUARIO));

ALTER TABLE VENTA_ACCIONES_LOG ADD (
  CONSTRAINT PKV_KEY
 PRIMARY KEY
 (NUM_CLIENTE, FECHA));

ALTER TABLE WEBSERVICE_LOG ADD (
  CONSTRAINT PK_WEBSERVICE_LOG
 PRIMARY KEY
 (ID));

ALTER TABLE ALNOVA_CHANNEL ADD (
  CONSTRAINT FK_CHANNEL2BRANCH 
 FOREIGN KEY (CHANNEL2BRANCH) 
 REFERENCES ALNOVA_BRANCH (ID));

ALTER TABLE ALNOVA_TERMINAL ADD (
  CONSTRAINT FK_TERMINAL2CHANNEL 
 FOREIGN KEY (TERMINAL2CHANNEL) 
 REFERENCES ALNOVA_CHANNEL (ID));

ALTER TABLE ALNOVA_USER ADD (
  CONSTRAINT FK_USER2CHANNEL 
 FOREIGN KEY (USER2CHANNEL) 
 REFERENCES ALNOVA_CHANNEL (ID));

ALTER TABLE BENEFI_DEX ADD (
  CONSTRAINT FK_CEL_COMPANY 
 FOREIGN KEY (CEL_COMPANY) 
 REFERENCES EBANKING_CELLCOMPANY (ID),
  FOREIGN KEY (TIP_BENEFI) 
 REFERENCES TIP_BENEFI_DEX (ID_TIPO));

ALTER TABLE CONFIR ADD (
  CONSTRAINT PK_TRANSFERENCIASID 
 FOREIGN KEY (ID_TIPOTRANSFERENCIA) 
 REFERENCES TIPO_TRANSFERENCIAS (ID));

ALTER TABLE CORE_MACS ADD (
  CONSTRAINT CORE_MACS_R02 
 FOREIGN KEY (IDROL) 
 REFERENCES CORE_ROL (IDROL));

ALTER TABLE CORE_METODS ADD (
  FOREIGN KEY (IDEJB) 
 REFERENCES CORE_EJBS (IDEJB));

ALTER TABLE CORE_ROL_METODS ADD (
  FOREIGN KEY (IDMETODO) 
 REFERENCES CORE_METODS (IDMETODO),
  FOREIGN KEY (IDROL) 
 REFERENCES CORE_ROL (IDROL));

ALTER TABLE CT_STATE ADD (
  CONSTRAINT RN_STATE_COUNTRY 
 FOREIGN KEY (FI_COUNTRY_ID) 
 REFERENCES CT_COUNTRY (FI_COUNTRY_ID));

ALTER TABLE DEXIMPUESTO ADD (
  CONSTRAINT FK_IMPMTCN 
 FOREIGN KEY (MTCN) 
 REFERENCES DEXTRANSFERENCIA (MTCN));

ALTER TABLE EBANKING_ACTECONOMICA ADD (
  CONSTRAINT FK_ACTECONOMICA 
 FOREIGN KEY (ID_PROFESION) 
 REFERENCES EBANKING_ACTGIRO (ID));

ALTER TABLE EBANKING_CAMBIO_PWD ADD (
  CONSTRAINT FK_USERCAMBIO_PWD 
 FOREIGN KEY (USER_ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_LOGIN ADD (
  CONSTRAINT FK_USERLOGIN 
 FOREIGN KEY (USER_ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_LOGIN_HIST ADD (
  CONSTRAINT FK_USERLOGINHIST 
 FOREIGN KEY (USER_ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_LOGIN_HISTORY ADD (
  CONSTRAINT FK_USERLOGINHISTORY 
 FOREIGN KEY (USER_ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_SECURITY_CUENTAS ADD (
  FOREIGN KEY (IDUSER) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_SECURITY_CUENTAS_AUX ADD (
  CONSTRAINT FK_IDUSER 
 FOREIGN KEY (IDUSER) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_SECURITY_MAX_AMOUNT ADD (
  FOREIGN KEY (IDUSER) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE EBANKING_SECURITY_PWD ADD (
  FOREIGN KEY (IDUSER) 
 REFERENCES EBANKING_USER (ID)
    ON DELETE CASCADE);

ALTER TABLE EBANKING_SUCURSALES ADD (
  CONSTRAINT FK_MUNICIPIOS 
 FOREIGN KEY (CITY_CODE) 
 REFERENCES EBANKING_MUNICIPIOS (CITY_CODE));

ALTER TABLE EBANKING_TX_PLACES ADD (
  CONSTRAINT FK_PLACE2STATE 
 FOREIGN KEY (PLACE2STATE) 
 REFERENCES EBANKING_TX_STATES (ID));

ALTER TABLE EBANKING_USER ADD (
  CONSTRAINT FK_USER2CELLCOMPANY 
 FOREIGN KEY (USER2CELLCOMPANY) 
 REFERENCES EBANKING_CELLCOMPANY (ID),
  CONSTRAINT FK_USER_STATUS 
 FOREIGN KEY (USER_STATUS) 
 REFERENCES EBANKING_USER_STATUS (ID));

ALTER TABLE EBANKING_USER_SESSION ADD (
  FOREIGN KEY (ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE FIAR_BOLETOS ADD (
  CONSTRAINT CFK_FIAR_BOLETOS 
 FOREIGN KEY (ID_SORTEO) 
 REFERENCES FIAR_SORTEO (ID_SORTEO));

ALTER TABLE FIAR_PREMIO ADD (
  CONSTRAINT CFK_FIAR_PREMIO 
 FOREIGN KEY (ID_SORTEO) 
 REFERENCES FIAR_SORTEO (ID_SORTEO));

ALTER TABLE FIAR_RESPUESTAS ADD (
  CONSTRAINT CFK_FIAR_RESPUESTAS 
 FOREIGN KEY (ID_PREGUNTA) 
 REFERENCES FIAR_PREGUNTAS (ID_PREGUNTA));

ALTER TABLE HISTORICO_TEF_SPEI_TERCEROS ADD (
  CONSTRAINT PK_TRANSFERID 
 FOREIGN KEY (ID_TIPOTRANSFERENCIA) 
 REFERENCES TIPO_TRANSFERENCIAS (ID));

ALTER TABLE HISTORICO_TEF_SPEI_TERCEROS_AX ADD (
  CONSTRAINT FK_ID_TRANSFERENCIA 
 FOREIGN KEY (ID_TIPOTRANSFERENCIA) 
 REFERENCES TIPO_TRANSFERENCIAS (ID));

ALTER TABLE IMPUESTO_DEX ADD (
  CONSTRAINT FK_IMPMTCNDEX 
 FOREIGN KEY (MTCN) 
 REFERENCES TRANSFER_DEX (MTCN));

ALTER TABLE IMPUESTO_DEX1 ADD (
  CONSTRAINT FK_IMPMTCNDEX1 
 FOREIGN KEY (MTCN) 
 REFERENCES TRANSFER_DEX2 (MTCN));

ALTER TABLE IP_CORE ADD (
  CONSTRAINT IP_ROL_CORE 
 FOREIGN KEY (ROL) 
 REFERENCES ROL_CORE (ROL));

ALTER TABLE MD_ADDITIONAL_PROPERTIES ADD (
  CONSTRAINT MD_ADDITIONAL_PROPERTIES__FK1 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_APPLICATIONFILES ADD (
  CONSTRAINT MD_FILE_APP_FK 
 FOREIGN KEY (APPLICATIONS_ID_FK) 
 REFERENCES MD_APPLICATIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_APPLICATIONS ADD (
  CONSTRAINT MD_APP_CONN_FK 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_CATALOGS ADD (
  CONSTRAINT MD_CATALOGS_MD_CONNECTION_FK1 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_COLUMNS ADD (
  CONSTRAINT MD_COLUMNS_MD_TABLES_FK1 
 FOREIGN KEY (TABLE_ID_FK) 
 REFERENCES MD_TABLES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_CONNECTIONS ADD (
  CONSTRAINT MD_CONNECTIONS_MD_PROJECT_FK1 
 FOREIGN KEY (PROJECT_ID_FK) 
 REFERENCES MD_PROJECTS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_CONSTRAINTS ADD (
  CONSTRAINT MD_CONSTRAINTS_MD_TABLES_FK1 
 FOREIGN KEY (TABLE_ID_FK) 
 REFERENCES MD_TABLES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_CONSTRAINT_DETAILS ADD (
  CONSTRAINT MD_CONSTRAINT_DETAILS_MD__FK2 
 FOREIGN KEY (COLUMN_ID_FK) 
 REFERENCES MD_COLUMNS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_CONSTRAINT_DETAILS_MD__FK1 
 FOREIGN KEY (CONSTRAINT_ID_FK) 
 REFERENCES MD_CONSTRAINTS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_DERIVATIVES ADD (
  CONSTRAINT MD_DERIVATIVES_MD_CONNECT_FK1 
 FOREIGN KEY (DERIVED_CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_FILE_ARTIFACTS ADD (
  CONSTRAINT MD_ARTIFACT_FILE_FK 
 FOREIGN KEY (APPLICATIONFILES_ID) 
 REFERENCES MD_APPLICATIONFILES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_GROUPS ADD (
  CONSTRAINT MD_GROUPS_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_GROUP_MEMBERS ADD (
  CONSTRAINT MD_GROUPMEMBERS_MD_USERS_FK1 
 FOREIGN KEY (USER_ID_FK) 
 REFERENCES MD_USERS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_GROUPMEMBERS_MD_GROUPS_FK2 
 FOREIGN KEY (GROUP_MEMBER_ID_FK) 
 REFERENCES MD_GROUPS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_GROUPMEMBERS_MD_GROUPS_FK1 
 FOREIGN KEY (GROUP_ID_FK) 
 REFERENCES MD_GROUPS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_GROUP_PRIVILEGES ADD (
  CONSTRAINT MD_GROUP_PRIVILEGES_MD_GR_FK1 
 FOREIGN KEY (GROUP_ID_FK) 
 REFERENCES MD_GROUPS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_GROUP_PRIVILEGES_MD_PR_FK1 
 FOREIGN KEY (PRIVILEGE_ID_FK) 
 REFERENCES MD_PRIVILEGES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_INDEXES ADD (
  CONSTRAINT MD_INDEXES_MD_TABLES_FK1 
 FOREIGN KEY (TABLE_ID_FK) 
 REFERENCES MD_TABLES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_INDEX_DETAILS ADD (
  CONSTRAINT MD_INDEX_DETAILS_MD_COLUM_FK1 
 FOREIGN KEY (COLUMN_ID_FK) 
 REFERENCES MD_COLUMNS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_INDEX_DETAILS_MD_INDEX_FK1 
 FOREIGN KEY (INDEX_ID_FK) 
 REFERENCES MD_INDEXES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_MIGR_DEPENDENCY ADD (
  CONSTRAINT MIGR_DEPENDENCY_FK 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_MIGR_PARAMETER ADD (
  CONSTRAINT MIGR_PARAMETER_FK 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_MIGR_WEAKDEP ADD (
  CONSTRAINT MIGR_WEAKDEP_FK2 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MIGR_WEAKDEP_FK1 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_OTHER_OBJECTS ADD (
  CONSTRAINT MD_OTHER_OBJECTS_MD_SCHEM_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_PACKAGES ADD (
  CONSTRAINT MD_PACKAGES_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_PARTITIONS ADD (
  CONSTRAINT MD_PARTITIONS_MD_TABLES_FK1 
 FOREIGN KEY (TABLE_ID_FK) 
 REFERENCES MD_TABLES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_PRIVILEGES ADD (
  CONSTRAINT MD_PRIVILEGES_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_SCHEMAS ADD (
  CONSTRAINT MD_SCHEMAS_MD_CATALOGS_FK1 
 FOREIGN KEY (CATALOG_ID_FK) 
 REFERENCES MD_CATALOGS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_SEQUENCES ADD (
  CONSTRAINT MD_SEQUENCES_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_STORED_PROGRAMS ADD (
  CONSTRAINT MD_STORED_PROGRAMS_MD_SCH_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_STORED_PROGRAMS_MD_PAC_FK1 
 FOREIGN KEY (PACKAGE_ID_FK) 
 REFERENCES MD_PACKAGES (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_SYNONYMS ADD (
  CONSTRAINT MD_SYNONYMS_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_TABLES ADD (
  CONSTRAINT MD_TABLES_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_TABLESPACES ADD (
  CONSTRAINT MD_TABLESPACES_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_USERS ADD (
  CONSTRAINT MD_USERS_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_USER_DEFINED_DATA_TYPES ADD (
  CONSTRAINT MD_USER_DEFINED_DATA_TYPE_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_USER_PRIVILEGES ADD (
  CONSTRAINT MD_USER_PRIVILEGES_MD_PRI_FK1 
 FOREIGN KEY (PRIVILEGE_ID_FK) 
 REFERENCES MD_PRIVILEGES (ID)
    ON DELETE CASCADE,
  CONSTRAINT MD_USER_PRIVILEGES_MD_USE_FK1 
 FOREIGN KEY (USER_ID_FK) 
 REFERENCES MD_USERS (ID)
    ON DELETE CASCADE);

ALTER TABLE MD_VIEWS ADD (
  CONSTRAINT MD_VIEWS_MD_SCHEMAS_FK1 
 FOREIGN KEY (SCHEMA_ID_FK) 
 REFERENCES MD_SCHEMAS (ID)
    ON DELETE CASCADE);

ALTER TABLE MIGRLOG ADD (
  CONSTRAINT MIGR_MIGRLOG_FK 
 FOREIGN KEY (PARENT_LOG_ID) 
 REFERENCES MIGRLOG (ID));

ALTER TABLE MIGR_DATATYPE_TRANSFORM_MAP ADD (
  CONSTRAINT MIGR_DATATYPE_TRANSFORM_M_FK1 
 FOREIGN KEY (PROJECT_ID_FK) 
 REFERENCES MD_PROJECTS (ID)
    ON DELETE CASCADE);

ALTER TABLE MIGR_DATATYPE_TRANSFORM_RULE ADD (
  CONSTRAINT MIGR_DATATYPE_TRANSFORM_R_FK1 
 FOREIGN KEY (MAP_ID_FK) 
 REFERENCES MIGR_DATATYPE_TRANSFORM_MAP (ID)
    ON DELETE CASCADE);

ALTER TABLE MIGR_GENERATION_ORDER ADD (
  CONSTRAINT MIGR_GENERATION_ORDER_MD__FK1 
 FOREIGN KEY (CONNECTION_ID_FK) 
 REFERENCES MD_CONNECTIONS (ID)
    ON DELETE CASCADE);

ALTER TABLE M_TRACKING ADD (
  CONSTRAINT FK_M_USUARIOS_OPERACIONES 
 FOREIGN KEY (ID_USUARIO_OPERACION) 
 REFERENCES M_USUARIOS_OPERACIONES (ID_USUARIO_OPERACION));

ALTER TABLE M_TRACKING_DETALLE ADD (
  CONSTRAINT FK_M_TRACKING 
 FOREIGN KEY (IDTRACKING) 
 REFERENCES M_TRACKING (IDTRACKING));

ALTER TABLE M_USUARIOS_OPERACIONES ADD (
  CONSTRAINT FK_M_USUARIOS 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES M_USUARIOS (IDUSUARIO));

ALTER TABLE OTROS_SERVICIOS ADD (
  CONSTRAINT FK_ID_SERVICIO 
 FOREIGN KEY (ID_SERVICIO) 
 REFERENCES SERVICIOS (ID_SERVICIO));

ALTER TABLE RECORDATORIOS_EVENTOS ADD (
  CONSTRAINT FK_RECORDATORIOS_EVENTOS 
 FOREIGN KEY (ID) 
 REFERENCES RECORDATORIOS_AGENDA (ID)
    ON DELETE CASCADE);

ALTER TABLE ROL_METODO_CORE ADD (
  FOREIGN KEY (METODO) 
 REFERENCES METODOS_CORE (METODO),
  FOREIGN KEY (ROL) 
 REFERENCES ROL_CORE (ROL));

ALTER TABLE SCHEDULED_PAYMENT ADD (
  FOREIGN KEY (USER_ID) 
 REFERENCES EBANKING_USER (ID));

ALTER TABLE TABLAX ADD (
  CONSTRAINT ELCONSTREIN 
 FOREIGN KEY (CLOMUN1) 
 REFERENCES EBANKING_LOGIN (USER_ID));

ALTER TABLE TA_BENEFAFILIA ADD (
  CONSTRAINT CFK_USUABENEF 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES TA_USUARIO (IDUSUARIO));

ALTER TABLE TA_BENEFICIARIO ADD (
  CONSTRAINT CFK_TITULBENEF 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TA_CLIENTE ADD (
  CONSTRAINT CFK_USUARCLIE 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES TA_USUARIO (IDUSUARIO));

ALTER TABLE TA_CONTENIDOCAT ADD (
  CONSTRAINT CFK_CATCONTE 
 FOREIGN KEY (IDCATALOGO) 
 REFERENCES TA_CATALOGOS (IDCATALOGO));

ALTER TABLE TA_DIRBENEF ADD (
  CONSTRAINT CFK_BENEFDIREC 
 FOREIGN KEY (IDBENEFICIARIO) 
 REFERENCES TA_BENEFICIARIO (IDBENEFICIARIO));

ALTER TABLE TA_DIRECCION ADD (
  CONSTRAINT CFK_TITULDIREC 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TA_DIRECCIONAFI ADD (
  CONSTRAINT CFK_USUDIREC 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES TA_USUARIO (IDUSUARIO),
  CONSTRAINT CFK_BENDIRECAF 
 FOREIGN KEY (IDBENEFICIARIO) 
 REFERENCES TA_BENEFAFILIA (IDBENEFICIARIO));

ALTER TABLE TA_DOCUMENTOS ADD (
  CONSTRAINT CFK_TITULDOCU 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TA_FISCAL ADD (
  CONSTRAINT CFK_USUAFIS 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES TA_USUARIO (IDUSUARIO));

ALTER TABLE TA_HOV_LETTER ADD (
  CONSTRAINT RI_PROD_LETTER_LETTER 
 FOREIGN KEY (FI_PRODUCT_LETTER_ID, FI_STATE_ID) 
 REFERENCES TA_PRODUCT_LETTER (FI_PRODUCT_LETTER_ID,FI_STATE_ID),
  CONSTRAINT RN_HOV_LETTER_HOV_LETTER 
 FOREIGN KEY (FI_PRODUCT_LETTER_ID, FI_STATE_ID, FI_NOTIFICATION_TYPE_ID) 
 REFERENCES CT_HOV_LETTER (FI_PRODUCT_LETTER_ID,FI_STATE_ID,FI_NOTIFICATION_TYPE_ID),
  CONSTRAINT RN_NOT_HOV_LETTER 
 FOREIGN KEY (FI_NOTIFICATION_TYPE_ID) 
 REFERENCES CT_NOTIFICATION_TYPE (FI_NOTIFICATION_TYPE_ID));

ALTER TABLE TA_INFOECOYFIN ADD (
  CONSTRAINT CFK_TITINFOEYF 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TA_NEGOCIO ADD (
  CONSTRAINT CFK_USUANEGO 
 FOREIGN KEY (IDUSUARIO) 
 REFERENCES TA_USUARIO (IDUSUARIO));

ALTER TABLE TA_PERSONAPEXP ADD (
  CONSTRAINT CFK_TITPERSONPE 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TA_PRODUCT_LETTER ADD (
  CONSTRAINT RI_STATE_PROD_LETTER 
 FOREIGN KEY (FI_STATE_ID) 
 REFERENCES CT_STATE (FI_STATE_ID));

ALTER TABLE TA_USOCUENTA ADD (
  CONSTRAINT CFK_TITUSOCTA 
 FOREIGN KEY (IDTITULAR) 
 REFERENCES TA_TITULAR (IDTITULAR));

ALTER TABLE TELEFONO ADD (
  CONSTRAINT PK_CARRIER_ID 
 FOREIGN KEY (CARRIER_ID) 
 REFERENCES CARRIER (CARRIER_ID));

ALTER TABLE TEST_USUARIO_ROL ADD (
  CONSTRAINT TEST_USUARIO_ROL_R01 
 FOREIGN KEY (USERNAME) 
 REFERENCES TEST_USUARIO (USERNAME));

ALTER TABLE TRANS_PROGRAMADAS ADD (
  CONSTRAINT TRANS_PROGRAMADAS_TRANS_C_FK1 
 FOREIGN KEY (ESTADO) 
 REFERENCES TRANS_CAT_ESTADOS (IDESTADO));

GRANT ALTER ON FIAR_CONTRATOS TO EBANKINGGUA;

GRANT EXECUTE ON GETALLAPPUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETALLLOGINUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETALLTOTALOPER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETALLTRACKUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETAPPUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETIDTRACKING TO MONITOR_SERVICE;

GRANT EXECUTE ON GETLOGINUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETTOTALOPER TO MONITOR_SERVICE;

GRANT EXECUTE ON GETTRACKUSER TO MONITOR_SERVICE;

GRANT EXECUTE ON INSERTERROR TO MONITOR_SERVICE;

GRANT EXECUTE ON INSERTTRACKING TO MONITOR_SERVICE;

GRANT EXECUTE ON INSERTTRACKINGDE TO MONITOR_SERVICE;

GRANT EXECUTE ON INSERTUSUARIOS TO MONITOR_SERVICE;

GRANT EXECUTE ON INSERTUSUARIOSOP TO MONITOR_SERVICE;

GRANT DELETE, INSERT, SELECT, UPDATE ON TOAD_PLAN_SQL TO PUBLIC;

GRANT DELETE, INSERT, SELECT, UPDATE ON TOAD_PLAN_TABLE TO PUBLIC;

GRANT EXECUTE ON OBTENCELULAR TO PUNTOROJO;

GRANT EXECUTE ON SELECT_USUARIOSBLOQUEADOS TO USER_OPM;

GRANT SELECT ON EBANKING_ACTIVATION TO USRCLIENTEUNICO;

GRANT SELECT ON EBANKING_USER TO USRCLIENTEUNICO;

GRANT INSERT, SELECT, UPDATE ON FIAR_BOLETOS TO USRINFREPO;

GRANT SELECT ON EBANKING_ACTIVATION TO USRINFREPORTEBAZ;

GRANT SELECT ON EBANKING_USER TO USRINFREPORTEBAZ;

GRANT SELECT ON PREACTIVE_USER TO USRINFREPORTEBAZ;

GRANT INSERT, SELECT, UPDATE ON REPO_CLIENTES TO USRINFTESO;

GRANT DELETE, INSERT, SELECT, UPDATE ON REPO_TASA_PLAZO TO USRINFTESO;

GRANT EXECUTE ON CREA_VISTA_VWOPERMONTO TO USRINWAPEDES;

GRANT SELECT ON M_TRACKING TO USRINWAPEDES;

GRANT SELECT ON M_TRACKING_DETALLE TO USRINWAPEDES;

GRANT SELECT ON M_USUARIOS TO USRINWAPEDES;

GRANT SELECT ON M_USUARIOS_OPERACIONES TO USRINWAPEDES;

GRANT EXECUTE ON GETALLAPPUSER TO USRINWAPEDES2;

GRANT EXECUTE ON GETALLLOGINUSER TO USRINWAPEDES2;

GRANT EXECUTE ON GETALLTOTALOPER TO USRINWAPEDES2;

GRANT EXECUTE ON GETALLTRACKUSER TO USRINWAPEDES2;

GRANT EXECUTE ON GETAPPUSER TO USRINWAPEDES2;

GRANT EXECUTE ON GETEBAKINGCORE TO USRINWAPEDES2;

GRANT EXECUTE ON GETIDTRACKING TO USRINWAPEDES2;

GRANT EXECUTE ON GETIDUSUARIO TO USRINWAPEDES2;

GRANT EXECUTE ON GETIDUSUARIOOPER TO USRINWAPEDES2;

GRANT EXECUTE ON GETLOGINUSER TO USRINWAPEDES2;

GRANT EXECUTE ON GET_NOTIFICA TO USRINWAPEDES2;

GRANT EXECUTE ON GETOPERMONTO TO USRINWAPEDES2;

GRANT EXECUTE ON GETTOTALOPER TO USRINWAPEDES2;

GRANT EXECUTE ON GETTRACKUSER TO USRINWAPEDES2;

GRANT EXECUTE ON INSERTERROR TO USRINWAPEDES2;

GRANT EXECUTE ON INSERTTRACKING TO USRINWAPEDES2;

GRANT EXECUTE ON INSERTTRACKINGDE TO USRINWAPEDES2;

GRANT EXECUTE ON INSERTUSUARIOS TO USRINWAPEDES2;

GRANT EXECUTE ON INSERTUSUARIOSOP TO USRINWAPEDES2;

GRANT SELECT ON M_TRACKING TO USRINWAPEDES2;

GRANT SELECT ON M_TRACKING_DETALLE TO USRINWAPEDES2;

GRANT SELECT, UPDATE ON M_USUARIOS TO USRINWAPEDES2;

GRANT SELECT ON M_USUARIOS_OPERACIONES TO USRINWAPEDES2;

GRANT EXECUTE ON OBTENCELULAR TO USRINWAPEDES2;

GRANT EXECUTE ON FIAR_CONSULTA_AFILIADOS_XDIA TO USRMONITORFIAR;

GRANT EXECUTE ON FIAR_CONSULTA_TOTALES TO USRMONITORFIAR;

GRANT EXECUTE ON FIAR_CONSULTAXSTATUS TO USRMONITORFIAR;

GRANT INSERT, SELECT, UPDATE ON EBANKING_LOGIN TO USRPAGOAZTECA;

GRANT INSERT ON EBANKING_LOGIN_HIST TO USRPAGOAZTECA;

GRANT INSERT ON EBANKING_LOGIN_TIMES TO USRPAGOAZTECA;

GRANT SELECT ON EBANKING_USER TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_FEC_ACTI_USR TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_INSERT_HIST TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_INS_MAXATT TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_INSTIEME_USR TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_NUM_INTENTOS TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_UPDATE_ATTEMP TO USRPAGOAZTECA;

GRANT EXECUTE ON SP_VALIDA_ACT TO USRPAGOAZTECA;

GRANT SELECT ON TA_CLIENTE TO USRPAZ;

GRANT SELECT ON TA_USUARIO TO USRPAZ;

GRANT EXECUTE ON CONSULTA_OPERACIONES TO USR_PORTALUSER;

GRANT INSERT, SELECT, UPDATE ON PREACTIVACION_OLD TO USRPREACT;

GRANT EXECUTE ON REPO_BUSQ_TASA_PLAZO TO USRTESO;

GRANT EXECUTE ON REPO_CUENTA TO USRTESO;

GRANT EXECUTE ON REPO_INSERT_CLIENT TO USRTESO;

GRANT EXECUTE ON REPO_INSERT_OPERAC TO USRTESO;

GRANT EXECUTE ON SPREPO_BORRAR TO USRTESO;

GRANT EXECUTE ON SPREPO_INSERTAR TO USRTESO;

GRANT EXECUTE ON REPO_BUSQ_TASA_PLAZO TO USRTESO10;

GRANT EXECUTE ON REPO_CUENTA TO USRTESO10;

GRANT EXECUTE ON REPO_INSERT_CLIENT TO USRTESO10;

GRANT EXECUTE ON REPO_INSERT_OPERAC TO USRTESO10;

GRANT EXECUTE ON GET_SEM_AC_US TO USRTKNAPP;

GRANT EXECUTE ON SELECT_ACTIVACION_USUARIO TO USRVIDEOSPF;

GRANT EXECUTE ON SELECT_TOKEN_ACTIVACION TO USRVIDEOSPF;

GRANT EXECUTE ON SELECT_TOKEN_ATRASADOS TO USRVIDEOSPF;

GRANT EXECUTE ON SELECT_TOKEN_DESBLOQUEO TO USRVIDEOSPF;

GRANT EXECUTE ON SELECT_TOKEN_PENDIENTES_HOY TO USRVIDEOSPF;

GRANT EXECUTE ON SELECT_TOKEN_SOLICITADOS TO USRVIDEOSPF;
